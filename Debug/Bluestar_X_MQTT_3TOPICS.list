
Bluestar_X_MQTT_3TOPICS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08040000  08040000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00018314  080401b0  080401b0  000101b0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000022d8  080584c8  080584c8  000284c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0805a7a0  0805a7a0  0002a7a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000008  0805a7a8  0805a7a8  0002a7a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0805a7b0  0805a7b0  0002a7b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000427c  20000000  0805a7b4  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  0003427c  2**0
                  CONTENTS
  8 .bss          0000c0c4  2000427c  2000427c  0003427c  2**2
                  ALLOC
  9 ._user_heap_stack 00000600  20010340  20010340  0003427c  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  0003427c  2**0
                  CONTENTS, READONLY
 11 .debug_info   00082b54  00000000  00000000  000342ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 0000ca59  00000000  00000000  000b6e00  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_loc    00020497  00000000  00000000  000c3859  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00002330  00000000  00000000  000e3cf0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00002690  00000000  00000000  000e6020  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0003a718  00000000  00000000  000e86b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0005368a  00000000  00000000  00122dc8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0010f6dd  00000000  00000000  00176452  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  00285b2f  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00007a60  00000000  00000000  00285b84  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080401b0 <__do_global_dtors_aux>:
 80401b0:	b510      	push	{r4, lr}
 80401b2:	4c05      	ldr	r4, [pc, #20]	; (80401c8 <__do_global_dtors_aux+0x18>)
 80401b4:	7823      	ldrb	r3, [r4, #0]
 80401b6:	b933      	cbnz	r3, 80401c6 <__do_global_dtors_aux+0x16>
 80401b8:	4b04      	ldr	r3, [pc, #16]	; (80401cc <__do_global_dtors_aux+0x1c>)
 80401ba:	b113      	cbz	r3, 80401c2 <__do_global_dtors_aux+0x12>
 80401bc:	4804      	ldr	r0, [pc, #16]	; (80401d0 <__do_global_dtors_aux+0x20>)
 80401be:	f3af 8000 	nop.w
 80401c2:	2301      	movs	r3, #1
 80401c4:	7023      	strb	r3, [r4, #0]
 80401c6:	bd10      	pop	{r4, pc}
 80401c8:	2000427c 	.word	0x2000427c
 80401cc:	00000000 	.word	0x00000000
 80401d0:	080584ac 	.word	0x080584ac

080401d4 <frame_dummy>:
 80401d4:	b508      	push	{r3, lr}
 80401d6:	4b03      	ldr	r3, [pc, #12]	; (80401e4 <frame_dummy+0x10>)
 80401d8:	b11b      	cbz	r3, 80401e2 <frame_dummy+0xe>
 80401da:	4903      	ldr	r1, [pc, #12]	; (80401e8 <frame_dummy+0x14>)
 80401dc:	4803      	ldr	r0, [pc, #12]	; (80401ec <frame_dummy+0x18>)
 80401de:	f3af 8000 	nop.w
 80401e2:	bd08      	pop	{r3, pc}
 80401e4:	00000000 	.word	0x00000000
 80401e8:	20004280 	.word	0x20004280
 80401ec:	080584ac 	.word	0x080584ac

080401f0 <strlen>:
 80401f0:	4603      	mov	r3, r0
 80401f2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80401f6:	2a00      	cmp	r2, #0
 80401f8:	d1fb      	bne.n	80401f2 <strlen+0x2>
 80401fa:	1a18      	subs	r0, r3, r0
 80401fc:	3801      	subs	r0, #1
 80401fe:	4770      	bx	lr

08040200 <memchr>:
 8040200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8040204:	2a10      	cmp	r2, #16
 8040206:	db2b      	blt.n	8040260 <memchr+0x60>
 8040208:	f010 0f07 	tst.w	r0, #7
 804020c:	d008      	beq.n	8040220 <memchr+0x20>
 804020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8040212:	3a01      	subs	r2, #1
 8040214:	428b      	cmp	r3, r1
 8040216:	d02d      	beq.n	8040274 <memchr+0x74>
 8040218:	f010 0f07 	tst.w	r0, #7
 804021c:	b342      	cbz	r2, 8040270 <memchr+0x70>
 804021e:	d1f6      	bne.n	804020e <memchr+0xe>
 8040220:	b4f0      	push	{r4, r5, r6, r7}
 8040222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8040226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 804022a:	f022 0407 	bic.w	r4, r2, #7
 804022e:	f07f 0700 	mvns.w	r7, #0
 8040232:	2300      	movs	r3, #0
 8040234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8040238:	3c08      	subs	r4, #8
 804023a:	ea85 0501 	eor.w	r5, r5, r1
 804023e:	ea86 0601 	eor.w	r6, r6, r1
 8040242:	fa85 f547 	uadd8	r5, r5, r7
 8040246:	faa3 f587 	sel	r5, r3, r7
 804024a:	fa86 f647 	uadd8	r6, r6, r7
 804024e:	faa5 f687 	sel	r6, r5, r7
 8040252:	b98e      	cbnz	r6, 8040278 <memchr+0x78>
 8040254:	d1ee      	bne.n	8040234 <memchr+0x34>
 8040256:	bcf0      	pop	{r4, r5, r6, r7}
 8040258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 804025c:	f002 0207 	and.w	r2, r2, #7
 8040260:	b132      	cbz	r2, 8040270 <memchr+0x70>
 8040262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8040266:	3a01      	subs	r2, #1
 8040268:	ea83 0301 	eor.w	r3, r3, r1
 804026c:	b113      	cbz	r3, 8040274 <memchr+0x74>
 804026e:	d1f8      	bne.n	8040262 <memchr+0x62>
 8040270:	2000      	movs	r0, #0
 8040272:	4770      	bx	lr
 8040274:	3801      	subs	r0, #1
 8040276:	4770      	bx	lr
 8040278:	2d00      	cmp	r5, #0
 804027a:	bf06      	itte	eq
 804027c:	4635      	moveq	r5, r6
 804027e:	3803      	subeq	r0, #3
 8040280:	3807      	subne	r0, #7
 8040282:	f015 0f01 	tst.w	r5, #1
 8040286:	d107      	bne.n	8040298 <memchr+0x98>
 8040288:	3001      	adds	r0, #1
 804028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 804028e:	bf02      	ittt	eq
 8040290:	3001      	addeq	r0, #1
 8040292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8040296:	3001      	addeq	r0, #1
 8040298:	bcf0      	pop	{r4, r5, r6, r7}
 804029a:	3801      	subs	r0, #1
 804029c:	4770      	bx	lr
 804029e:	bf00      	nop

080402a0 <__aeabi_drsub>:
 80402a0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80402a4:	e002      	b.n	80402ac <__adddf3>
 80402a6:	bf00      	nop

080402a8 <__aeabi_dsub>:
 80402a8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080402ac <__adddf3>:
 80402ac:	b530      	push	{r4, r5, lr}
 80402ae:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80402b2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80402b6:	ea94 0f05 	teq	r4, r5
 80402ba:	bf08      	it	eq
 80402bc:	ea90 0f02 	teqeq	r0, r2
 80402c0:	bf1f      	itttt	ne
 80402c2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80402c6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80402ca:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80402ce:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80402d2:	f000 80e2 	beq.w	804049a <__adddf3+0x1ee>
 80402d6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80402da:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80402de:	bfb8      	it	lt
 80402e0:	426d      	neglt	r5, r5
 80402e2:	dd0c      	ble.n	80402fe <__adddf3+0x52>
 80402e4:	442c      	add	r4, r5
 80402e6:	ea80 0202 	eor.w	r2, r0, r2
 80402ea:	ea81 0303 	eor.w	r3, r1, r3
 80402ee:	ea82 0000 	eor.w	r0, r2, r0
 80402f2:	ea83 0101 	eor.w	r1, r3, r1
 80402f6:	ea80 0202 	eor.w	r2, r0, r2
 80402fa:	ea81 0303 	eor.w	r3, r1, r3
 80402fe:	2d36      	cmp	r5, #54	; 0x36
 8040300:	bf88      	it	hi
 8040302:	bd30      	pophi	{r4, r5, pc}
 8040304:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8040308:	ea4f 3101 	mov.w	r1, r1, lsl #12
 804030c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8040310:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8040314:	d002      	beq.n	804031c <__adddf3+0x70>
 8040316:	4240      	negs	r0, r0
 8040318:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 804031c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8040320:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8040324:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8040328:	d002      	beq.n	8040330 <__adddf3+0x84>
 804032a:	4252      	negs	r2, r2
 804032c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8040330:	ea94 0f05 	teq	r4, r5
 8040334:	f000 80a7 	beq.w	8040486 <__adddf3+0x1da>
 8040338:	f1a4 0401 	sub.w	r4, r4, #1
 804033c:	f1d5 0e20 	rsbs	lr, r5, #32
 8040340:	db0d      	blt.n	804035e <__adddf3+0xb2>
 8040342:	fa02 fc0e 	lsl.w	ip, r2, lr
 8040346:	fa22 f205 	lsr.w	r2, r2, r5
 804034a:	1880      	adds	r0, r0, r2
 804034c:	f141 0100 	adc.w	r1, r1, #0
 8040350:	fa03 f20e 	lsl.w	r2, r3, lr
 8040354:	1880      	adds	r0, r0, r2
 8040356:	fa43 f305 	asr.w	r3, r3, r5
 804035a:	4159      	adcs	r1, r3
 804035c:	e00e      	b.n	804037c <__adddf3+0xd0>
 804035e:	f1a5 0520 	sub.w	r5, r5, #32
 8040362:	f10e 0e20 	add.w	lr, lr, #32
 8040366:	2a01      	cmp	r2, #1
 8040368:	fa03 fc0e 	lsl.w	ip, r3, lr
 804036c:	bf28      	it	cs
 804036e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8040372:	fa43 f305 	asr.w	r3, r3, r5
 8040376:	18c0      	adds	r0, r0, r3
 8040378:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 804037c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8040380:	d507      	bpl.n	8040392 <__adddf3+0xe6>
 8040382:	f04f 0e00 	mov.w	lr, #0
 8040386:	f1dc 0c00 	rsbs	ip, ip, #0
 804038a:	eb7e 0000 	sbcs.w	r0, lr, r0
 804038e:	eb6e 0101 	sbc.w	r1, lr, r1
 8040392:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8040396:	d31b      	bcc.n	80403d0 <__adddf3+0x124>
 8040398:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 804039c:	d30c      	bcc.n	80403b8 <__adddf3+0x10c>
 804039e:	0849      	lsrs	r1, r1, #1
 80403a0:	ea5f 0030 	movs.w	r0, r0, rrx
 80403a4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80403a8:	f104 0401 	add.w	r4, r4, #1
 80403ac:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80403b0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80403b4:	f080 809a 	bcs.w	80404ec <__adddf3+0x240>
 80403b8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80403bc:	bf08      	it	eq
 80403be:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80403c2:	f150 0000 	adcs.w	r0, r0, #0
 80403c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80403ca:	ea41 0105 	orr.w	r1, r1, r5
 80403ce:	bd30      	pop	{r4, r5, pc}
 80403d0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80403d4:	4140      	adcs	r0, r0
 80403d6:	eb41 0101 	adc.w	r1, r1, r1
 80403da:	3c01      	subs	r4, #1
 80403dc:	bf28      	it	cs
 80403de:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80403e2:	d2e9      	bcs.n	80403b8 <__adddf3+0x10c>
 80403e4:	f091 0f00 	teq	r1, #0
 80403e8:	bf04      	itt	eq
 80403ea:	4601      	moveq	r1, r0
 80403ec:	2000      	moveq	r0, #0
 80403ee:	fab1 f381 	clz	r3, r1
 80403f2:	bf08      	it	eq
 80403f4:	3320      	addeq	r3, #32
 80403f6:	f1a3 030b 	sub.w	r3, r3, #11
 80403fa:	f1b3 0220 	subs.w	r2, r3, #32
 80403fe:	da0c      	bge.n	804041a <__adddf3+0x16e>
 8040400:	320c      	adds	r2, #12
 8040402:	dd08      	ble.n	8040416 <__adddf3+0x16a>
 8040404:	f102 0c14 	add.w	ip, r2, #20
 8040408:	f1c2 020c 	rsb	r2, r2, #12
 804040c:	fa01 f00c 	lsl.w	r0, r1, ip
 8040410:	fa21 f102 	lsr.w	r1, r1, r2
 8040414:	e00c      	b.n	8040430 <__adddf3+0x184>
 8040416:	f102 0214 	add.w	r2, r2, #20
 804041a:	bfd8      	it	le
 804041c:	f1c2 0c20 	rsble	ip, r2, #32
 8040420:	fa01 f102 	lsl.w	r1, r1, r2
 8040424:	fa20 fc0c 	lsr.w	ip, r0, ip
 8040428:	bfdc      	itt	le
 804042a:	ea41 010c 	orrle.w	r1, r1, ip
 804042e:	4090      	lslle	r0, r2
 8040430:	1ae4      	subs	r4, r4, r3
 8040432:	bfa2      	ittt	ge
 8040434:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8040438:	4329      	orrge	r1, r5
 804043a:	bd30      	popge	{r4, r5, pc}
 804043c:	ea6f 0404 	mvn.w	r4, r4
 8040440:	3c1f      	subs	r4, #31
 8040442:	da1c      	bge.n	804047e <__adddf3+0x1d2>
 8040444:	340c      	adds	r4, #12
 8040446:	dc0e      	bgt.n	8040466 <__adddf3+0x1ba>
 8040448:	f104 0414 	add.w	r4, r4, #20
 804044c:	f1c4 0220 	rsb	r2, r4, #32
 8040450:	fa20 f004 	lsr.w	r0, r0, r4
 8040454:	fa01 f302 	lsl.w	r3, r1, r2
 8040458:	ea40 0003 	orr.w	r0, r0, r3
 804045c:	fa21 f304 	lsr.w	r3, r1, r4
 8040460:	ea45 0103 	orr.w	r1, r5, r3
 8040464:	bd30      	pop	{r4, r5, pc}
 8040466:	f1c4 040c 	rsb	r4, r4, #12
 804046a:	f1c4 0220 	rsb	r2, r4, #32
 804046e:	fa20 f002 	lsr.w	r0, r0, r2
 8040472:	fa01 f304 	lsl.w	r3, r1, r4
 8040476:	ea40 0003 	orr.w	r0, r0, r3
 804047a:	4629      	mov	r1, r5
 804047c:	bd30      	pop	{r4, r5, pc}
 804047e:	fa21 f004 	lsr.w	r0, r1, r4
 8040482:	4629      	mov	r1, r5
 8040484:	bd30      	pop	{r4, r5, pc}
 8040486:	f094 0f00 	teq	r4, #0
 804048a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 804048e:	bf06      	itte	eq
 8040490:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8040494:	3401      	addeq	r4, #1
 8040496:	3d01      	subne	r5, #1
 8040498:	e74e      	b.n	8040338 <__adddf3+0x8c>
 804049a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 804049e:	bf18      	it	ne
 80404a0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80404a4:	d029      	beq.n	80404fa <__adddf3+0x24e>
 80404a6:	ea94 0f05 	teq	r4, r5
 80404aa:	bf08      	it	eq
 80404ac:	ea90 0f02 	teqeq	r0, r2
 80404b0:	d005      	beq.n	80404be <__adddf3+0x212>
 80404b2:	ea54 0c00 	orrs.w	ip, r4, r0
 80404b6:	bf04      	itt	eq
 80404b8:	4619      	moveq	r1, r3
 80404ba:	4610      	moveq	r0, r2
 80404bc:	bd30      	pop	{r4, r5, pc}
 80404be:	ea91 0f03 	teq	r1, r3
 80404c2:	bf1e      	ittt	ne
 80404c4:	2100      	movne	r1, #0
 80404c6:	2000      	movne	r0, #0
 80404c8:	bd30      	popne	{r4, r5, pc}
 80404ca:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80404ce:	d105      	bne.n	80404dc <__adddf3+0x230>
 80404d0:	0040      	lsls	r0, r0, #1
 80404d2:	4149      	adcs	r1, r1
 80404d4:	bf28      	it	cs
 80404d6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80404da:	bd30      	pop	{r4, r5, pc}
 80404dc:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80404e0:	bf3c      	itt	cc
 80404e2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80404e6:	bd30      	popcc	{r4, r5, pc}
 80404e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80404ec:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80404f0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80404f4:	f04f 0000 	mov.w	r0, #0
 80404f8:	bd30      	pop	{r4, r5, pc}
 80404fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80404fe:	bf1a      	itte	ne
 8040500:	4619      	movne	r1, r3
 8040502:	4610      	movne	r0, r2
 8040504:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8040508:	bf1c      	itt	ne
 804050a:	460b      	movne	r3, r1
 804050c:	4602      	movne	r2, r0
 804050e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8040512:	bf06      	itte	eq
 8040514:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8040518:	ea91 0f03 	teqeq	r1, r3
 804051c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8040520:	bd30      	pop	{r4, r5, pc}
 8040522:	bf00      	nop

08040524 <__aeabi_ui2d>:
 8040524:	f090 0f00 	teq	r0, #0
 8040528:	bf04      	itt	eq
 804052a:	2100      	moveq	r1, #0
 804052c:	4770      	bxeq	lr
 804052e:	b530      	push	{r4, r5, lr}
 8040530:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8040534:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8040538:	f04f 0500 	mov.w	r5, #0
 804053c:	f04f 0100 	mov.w	r1, #0
 8040540:	e750      	b.n	80403e4 <__adddf3+0x138>
 8040542:	bf00      	nop

08040544 <__aeabi_i2d>:
 8040544:	f090 0f00 	teq	r0, #0
 8040548:	bf04      	itt	eq
 804054a:	2100      	moveq	r1, #0
 804054c:	4770      	bxeq	lr
 804054e:	b530      	push	{r4, r5, lr}
 8040550:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8040554:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8040558:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 804055c:	bf48      	it	mi
 804055e:	4240      	negmi	r0, r0
 8040560:	f04f 0100 	mov.w	r1, #0
 8040564:	e73e      	b.n	80403e4 <__adddf3+0x138>
 8040566:	bf00      	nop

08040568 <__aeabi_f2d>:
 8040568:	0042      	lsls	r2, r0, #1
 804056a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 804056e:	ea4f 0131 	mov.w	r1, r1, rrx
 8040572:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8040576:	bf1f      	itttt	ne
 8040578:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 804057c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8040580:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8040584:	4770      	bxne	lr
 8040586:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 804058a:	bf08      	it	eq
 804058c:	4770      	bxeq	lr
 804058e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8040592:	bf04      	itt	eq
 8040594:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8040598:	4770      	bxeq	lr
 804059a:	b530      	push	{r4, r5, lr}
 804059c:	f44f 7460 	mov.w	r4, #896	; 0x380
 80405a0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80405a4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80405a8:	e71c      	b.n	80403e4 <__adddf3+0x138>
 80405aa:	bf00      	nop

080405ac <__aeabi_ul2d>:
 80405ac:	ea50 0201 	orrs.w	r2, r0, r1
 80405b0:	bf08      	it	eq
 80405b2:	4770      	bxeq	lr
 80405b4:	b530      	push	{r4, r5, lr}
 80405b6:	f04f 0500 	mov.w	r5, #0
 80405ba:	e00a      	b.n	80405d2 <__aeabi_l2d+0x16>

080405bc <__aeabi_l2d>:
 80405bc:	ea50 0201 	orrs.w	r2, r0, r1
 80405c0:	bf08      	it	eq
 80405c2:	4770      	bxeq	lr
 80405c4:	b530      	push	{r4, r5, lr}
 80405c6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80405ca:	d502      	bpl.n	80405d2 <__aeabi_l2d+0x16>
 80405cc:	4240      	negs	r0, r0
 80405ce:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80405d2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80405d6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80405da:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80405de:	f43f aed8 	beq.w	8040392 <__adddf3+0xe6>
 80405e2:	f04f 0203 	mov.w	r2, #3
 80405e6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80405ea:	bf18      	it	ne
 80405ec:	3203      	addne	r2, #3
 80405ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80405f2:	bf18      	it	ne
 80405f4:	3203      	addne	r2, #3
 80405f6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80405fa:	f1c2 0320 	rsb	r3, r2, #32
 80405fe:	fa00 fc03 	lsl.w	ip, r0, r3
 8040602:	fa20 f002 	lsr.w	r0, r0, r2
 8040606:	fa01 fe03 	lsl.w	lr, r1, r3
 804060a:	ea40 000e 	orr.w	r0, r0, lr
 804060e:	fa21 f102 	lsr.w	r1, r1, r2
 8040612:	4414      	add	r4, r2
 8040614:	e6bd      	b.n	8040392 <__adddf3+0xe6>
 8040616:	bf00      	nop

08040618 <__aeabi_dmul>:
 8040618:	b570      	push	{r4, r5, r6, lr}
 804061a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 804061e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8040622:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8040626:	bf1d      	ittte	ne
 8040628:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 804062c:	ea94 0f0c 	teqne	r4, ip
 8040630:	ea95 0f0c 	teqne	r5, ip
 8040634:	f000 f8de 	bleq	80407f4 <__aeabi_dmul+0x1dc>
 8040638:	442c      	add	r4, r5
 804063a:	ea81 0603 	eor.w	r6, r1, r3
 804063e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8040642:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8040646:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 804064a:	bf18      	it	ne
 804064c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8040650:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8040654:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8040658:	d038      	beq.n	80406cc <__aeabi_dmul+0xb4>
 804065a:	fba0 ce02 	umull	ip, lr, r0, r2
 804065e:	f04f 0500 	mov.w	r5, #0
 8040662:	fbe1 e502 	umlal	lr, r5, r1, r2
 8040666:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 804066a:	fbe0 e503 	umlal	lr, r5, r0, r3
 804066e:	f04f 0600 	mov.w	r6, #0
 8040672:	fbe1 5603 	umlal	r5, r6, r1, r3
 8040676:	f09c 0f00 	teq	ip, #0
 804067a:	bf18      	it	ne
 804067c:	f04e 0e01 	orrne.w	lr, lr, #1
 8040680:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8040684:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8040688:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 804068c:	d204      	bcs.n	8040698 <__aeabi_dmul+0x80>
 804068e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8040692:	416d      	adcs	r5, r5
 8040694:	eb46 0606 	adc.w	r6, r6, r6
 8040698:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 804069c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80406a0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80406a4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80406a8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80406ac:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80406b0:	bf88      	it	hi
 80406b2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80406b6:	d81e      	bhi.n	80406f6 <__aeabi_dmul+0xde>
 80406b8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80406bc:	bf08      	it	eq
 80406be:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80406c2:	f150 0000 	adcs.w	r0, r0, #0
 80406c6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80406ca:	bd70      	pop	{r4, r5, r6, pc}
 80406cc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80406d0:	ea46 0101 	orr.w	r1, r6, r1
 80406d4:	ea40 0002 	orr.w	r0, r0, r2
 80406d8:	ea81 0103 	eor.w	r1, r1, r3
 80406dc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80406e0:	bfc2      	ittt	gt
 80406e2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80406e6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80406ea:	bd70      	popgt	{r4, r5, r6, pc}
 80406ec:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80406f0:	f04f 0e00 	mov.w	lr, #0
 80406f4:	3c01      	subs	r4, #1
 80406f6:	f300 80ab 	bgt.w	8040850 <__aeabi_dmul+0x238>
 80406fa:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80406fe:	bfde      	ittt	le
 8040700:	2000      	movle	r0, #0
 8040702:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8040706:	bd70      	pople	{r4, r5, r6, pc}
 8040708:	f1c4 0400 	rsb	r4, r4, #0
 804070c:	3c20      	subs	r4, #32
 804070e:	da35      	bge.n	804077c <__aeabi_dmul+0x164>
 8040710:	340c      	adds	r4, #12
 8040712:	dc1b      	bgt.n	804074c <__aeabi_dmul+0x134>
 8040714:	f104 0414 	add.w	r4, r4, #20
 8040718:	f1c4 0520 	rsb	r5, r4, #32
 804071c:	fa00 f305 	lsl.w	r3, r0, r5
 8040720:	fa20 f004 	lsr.w	r0, r0, r4
 8040724:	fa01 f205 	lsl.w	r2, r1, r5
 8040728:	ea40 0002 	orr.w	r0, r0, r2
 804072c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8040730:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8040734:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8040738:	fa21 f604 	lsr.w	r6, r1, r4
 804073c:	eb42 0106 	adc.w	r1, r2, r6
 8040740:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040744:	bf08      	it	eq
 8040746:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804074a:	bd70      	pop	{r4, r5, r6, pc}
 804074c:	f1c4 040c 	rsb	r4, r4, #12
 8040750:	f1c4 0520 	rsb	r5, r4, #32
 8040754:	fa00 f304 	lsl.w	r3, r0, r4
 8040758:	fa20 f005 	lsr.w	r0, r0, r5
 804075c:	fa01 f204 	lsl.w	r2, r1, r4
 8040760:	ea40 0002 	orr.w	r0, r0, r2
 8040764:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040768:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 804076c:	f141 0100 	adc.w	r1, r1, #0
 8040770:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8040774:	bf08      	it	eq
 8040776:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 804077a:	bd70      	pop	{r4, r5, r6, pc}
 804077c:	f1c4 0520 	rsb	r5, r4, #32
 8040780:	fa00 f205 	lsl.w	r2, r0, r5
 8040784:	ea4e 0e02 	orr.w	lr, lr, r2
 8040788:	fa20 f304 	lsr.w	r3, r0, r4
 804078c:	fa01 f205 	lsl.w	r2, r1, r5
 8040790:	ea43 0302 	orr.w	r3, r3, r2
 8040794:	fa21 f004 	lsr.w	r0, r1, r4
 8040798:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 804079c:	fa21 f204 	lsr.w	r2, r1, r4
 80407a0:	ea20 0002 	bic.w	r0, r0, r2
 80407a4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80407a8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80407ac:	bf08      	it	eq
 80407ae:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80407b2:	bd70      	pop	{r4, r5, r6, pc}
 80407b4:	f094 0f00 	teq	r4, #0
 80407b8:	d10f      	bne.n	80407da <__aeabi_dmul+0x1c2>
 80407ba:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80407be:	0040      	lsls	r0, r0, #1
 80407c0:	eb41 0101 	adc.w	r1, r1, r1
 80407c4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80407c8:	bf08      	it	eq
 80407ca:	3c01      	subeq	r4, #1
 80407cc:	d0f7      	beq.n	80407be <__aeabi_dmul+0x1a6>
 80407ce:	ea41 0106 	orr.w	r1, r1, r6
 80407d2:	f095 0f00 	teq	r5, #0
 80407d6:	bf18      	it	ne
 80407d8:	4770      	bxne	lr
 80407da:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80407de:	0052      	lsls	r2, r2, #1
 80407e0:	eb43 0303 	adc.w	r3, r3, r3
 80407e4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80407e8:	bf08      	it	eq
 80407ea:	3d01      	subeq	r5, #1
 80407ec:	d0f7      	beq.n	80407de <__aeabi_dmul+0x1c6>
 80407ee:	ea43 0306 	orr.w	r3, r3, r6
 80407f2:	4770      	bx	lr
 80407f4:	ea94 0f0c 	teq	r4, ip
 80407f8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80407fc:	bf18      	it	ne
 80407fe:	ea95 0f0c 	teqne	r5, ip
 8040802:	d00c      	beq.n	804081e <__aeabi_dmul+0x206>
 8040804:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040808:	bf18      	it	ne
 804080a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 804080e:	d1d1      	bne.n	80407b4 <__aeabi_dmul+0x19c>
 8040810:	ea81 0103 	eor.w	r1, r1, r3
 8040814:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040818:	f04f 0000 	mov.w	r0, #0
 804081c:	bd70      	pop	{r4, r5, r6, pc}
 804081e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040822:	bf06      	itte	eq
 8040824:	4610      	moveq	r0, r2
 8040826:	4619      	moveq	r1, r3
 8040828:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 804082c:	d019      	beq.n	8040862 <__aeabi_dmul+0x24a>
 804082e:	ea94 0f0c 	teq	r4, ip
 8040832:	d102      	bne.n	804083a <__aeabi_dmul+0x222>
 8040834:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8040838:	d113      	bne.n	8040862 <__aeabi_dmul+0x24a>
 804083a:	ea95 0f0c 	teq	r5, ip
 804083e:	d105      	bne.n	804084c <__aeabi_dmul+0x234>
 8040840:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8040844:	bf1c      	itt	ne
 8040846:	4610      	movne	r0, r2
 8040848:	4619      	movne	r1, r3
 804084a:	d10a      	bne.n	8040862 <__aeabi_dmul+0x24a>
 804084c:	ea81 0103 	eor.w	r1, r1, r3
 8040850:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8040854:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8040858:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 804085c:	f04f 0000 	mov.w	r0, #0
 8040860:	bd70      	pop	{r4, r5, r6, pc}
 8040862:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8040866:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 804086a:	bd70      	pop	{r4, r5, r6, pc}

0804086c <__aeabi_ddiv>:
 804086c:	b570      	push	{r4, r5, r6, lr}
 804086e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8040872:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8040876:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 804087a:	bf1d      	ittte	ne
 804087c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8040880:	ea94 0f0c 	teqne	r4, ip
 8040884:	ea95 0f0c 	teqne	r5, ip
 8040888:	f000 f8a7 	bleq	80409da <__aeabi_ddiv+0x16e>
 804088c:	eba4 0405 	sub.w	r4, r4, r5
 8040890:	ea81 0e03 	eor.w	lr, r1, r3
 8040894:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8040898:	ea4f 3101 	mov.w	r1, r1, lsl #12
 804089c:	f000 8088 	beq.w	80409b0 <__aeabi_ddiv+0x144>
 80408a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80408a4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80408a8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80408ac:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80408b0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80408b4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80408b8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80408bc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80408c0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80408c4:	429d      	cmp	r5, r3
 80408c6:	bf08      	it	eq
 80408c8:	4296      	cmpeq	r6, r2
 80408ca:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80408ce:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80408d2:	d202      	bcs.n	80408da <__aeabi_ddiv+0x6e>
 80408d4:	085b      	lsrs	r3, r3, #1
 80408d6:	ea4f 0232 	mov.w	r2, r2, rrx
 80408da:	1ab6      	subs	r6, r6, r2
 80408dc:	eb65 0503 	sbc.w	r5, r5, r3
 80408e0:	085b      	lsrs	r3, r3, #1
 80408e2:	ea4f 0232 	mov.w	r2, r2, rrx
 80408e6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80408ea:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80408ee:	ebb6 0e02 	subs.w	lr, r6, r2
 80408f2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80408f6:	bf22      	ittt	cs
 80408f8:	1ab6      	subcs	r6, r6, r2
 80408fa:	4675      	movcs	r5, lr
 80408fc:	ea40 000c 	orrcs.w	r0, r0, ip
 8040900:	085b      	lsrs	r3, r3, #1
 8040902:	ea4f 0232 	mov.w	r2, r2, rrx
 8040906:	ebb6 0e02 	subs.w	lr, r6, r2
 804090a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804090e:	bf22      	ittt	cs
 8040910:	1ab6      	subcs	r6, r6, r2
 8040912:	4675      	movcs	r5, lr
 8040914:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8040918:	085b      	lsrs	r3, r3, #1
 804091a:	ea4f 0232 	mov.w	r2, r2, rrx
 804091e:	ebb6 0e02 	subs.w	lr, r6, r2
 8040922:	eb75 0e03 	sbcs.w	lr, r5, r3
 8040926:	bf22      	ittt	cs
 8040928:	1ab6      	subcs	r6, r6, r2
 804092a:	4675      	movcs	r5, lr
 804092c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8040930:	085b      	lsrs	r3, r3, #1
 8040932:	ea4f 0232 	mov.w	r2, r2, rrx
 8040936:	ebb6 0e02 	subs.w	lr, r6, r2
 804093a:	eb75 0e03 	sbcs.w	lr, r5, r3
 804093e:	bf22      	ittt	cs
 8040940:	1ab6      	subcs	r6, r6, r2
 8040942:	4675      	movcs	r5, lr
 8040944:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8040948:	ea55 0e06 	orrs.w	lr, r5, r6
 804094c:	d018      	beq.n	8040980 <__aeabi_ddiv+0x114>
 804094e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8040952:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8040956:	ea4f 1606 	mov.w	r6, r6, lsl #4
 804095a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 804095e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8040962:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8040966:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 804096a:	d1c0      	bne.n	80408ee <__aeabi_ddiv+0x82>
 804096c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8040970:	d10b      	bne.n	804098a <__aeabi_ddiv+0x11e>
 8040972:	ea41 0100 	orr.w	r1, r1, r0
 8040976:	f04f 0000 	mov.w	r0, #0
 804097a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 804097e:	e7b6      	b.n	80408ee <__aeabi_ddiv+0x82>
 8040980:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8040984:	bf04      	itt	eq
 8040986:	4301      	orreq	r1, r0
 8040988:	2000      	moveq	r0, #0
 804098a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 804098e:	bf88      	it	hi
 8040990:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8040994:	f63f aeaf 	bhi.w	80406f6 <__aeabi_dmul+0xde>
 8040998:	ebb5 0c03 	subs.w	ip, r5, r3
 804099c:	bf04      	itt	eq
 804099e:	ebb6 0c02 	subseq.w	ip, r6, r2
 80409a2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80409a6:	f150 0000 	adcs.w	r0, r0, #0
 80409aa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80409ae:	bd70      	pop	{r4, r5, r6, pc}
 80409b0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80409b4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80409b8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80409bc:	bfc2      	ittt	gt
 80409be:	ebd4 050c 	rsbsgt	r5, r4, ip
 80409c2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80409c6:	bd70      	popgt	{r4, r5, r6, pc}
 80409c8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80409cc:	f04f 0e00 	mov.w	lr, #0
 80409d0:	3c01      	subs	r4, #1
 80409d2:	e690      	b.n	80406f6 <__aeabi_dmul+0xde>
 80409d4:	ea45 0e06 	orr.w	lr, r5, r6
 80409d8:	e68d      	b.n	80406f6 <__aeabi_dmul+0xde>
 80409da:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80409de:	ea94 0f0c 	teq	r4, ip
 80409e2:	bf08      	it	eq
 80409e4:	ea95 0f0c 	teqeq	r5, ip
 80409e8:	f43f af3b 	beq.w	8040862 <__aeabi_dmul+0x24a>
 80409ec:	ea94 0f0c 	teq	r4, ip
 80409f0:	d10a      	bne.n	8040a08 <__aeabi_ddiv+0x19c>
 80409f2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80409f6:	f47f af34 	bne.w	8040862 <__aeabi_dmul+0x24a>
 80409fa:	ea95 0f0c 	teq	r5, ip
 80409fe:	f47f af25 	bne.w	804084c <__aeabi_dmul+0x234>
 8040a02:	4610      	mov	r0, r2
 8040a04:	4619      	mov	r1, r3
 8040a06:	e72c      	b.n	8040862 <__aeabi_dmul+0x24a>
 8040a08:	ea95 0f0c 	teq	r5, ip
 8040a0c:	d106      	bne.n	8040a1c <__aeabi_ddiv+0x1b0>
 8040a0e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8040a12:	f43f aefd 	beq.w	8040810 <__aeabi_dmul+0x1f8>
 8040a16:	4610      	mov	r0, r2
 8040a18:	4619      	mov	r1, r3
 8040a1a:	e722      	b.n	8040862 <__aeabi_dmul+0x24a>
 8040a1c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8040a20:	bf18      	it	ne
 8040a22:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8040a26:	f47f aec5 	bne.w	80407b4 <__aeabi_dmul+0x19c>
 8040a2a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8040a2e:	f47f af0d 	bne.w	804084c <__aeabi_dmul+0x234>
 8040a32:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8040a36:	f47f aeeb 	bne.w	8040810 <__aeabi_dmul+0x1f8>
 8040a3a:	e712      	b.n	8040862 <__aeabi_dmul+0x24a>

08040a3c <__gedf2>:
 8040a3c:	f04f 3cff 	mov.w	ip, #4294967295
 8040a40:	e006      	b.n	8040a50 <__cmpdf2+0x4>
 8040a42:	bf00      	nop

08040a44 <__ledf2>:
 8040a44:	f04f 0c01 	mov.w	ip, #1
 8040a48:	e002      	b.n	8040a50 <__cmpdf2+0x4>
 8040a4a:	bf00      	nop

08040a4c <__cmpdf2>:
 8040a4c:	f04f 0c01 	mov.w	ip, #1
 8040a50:	f84d cd04 	str.w	ip, [sp, #-4]!
 8040a54:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040a58:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040a5c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040a60:	bf18      	it	ne
 8040a62:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8040a66:	d01b      	beq.n	8040aa0 <__cmpdf2+0x54>
 8040a68:	b001      	add	sp, #4
 8040a6a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8040a6e:	bf0c      	ite	eq
 8040a70:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8040a74:	ea91 0f03 	teqne	r1, r3
 8040a78:	bf02      	ittt	eq
 8040a7a:	ea90 0f02 	teqeq	r0, r2
 8040a7e:	2000      	moveq	r0, #0
 8040a80:	4770      	bxeq	lr
 8040a82:	f110 0f00 	cmn.w	r0, #0
 8040a86:	ea91 0f03 	teq	r1, r3
 8040a8a:	bf58      	it	pl
 8040a8c:	4299      	cmppl	r1, r3
 8040a8e:	bf08      	it	eq
 8040a90:	4290      	cmpeq	r0, r2
 8040a92:	bf2c      	ite	cs
 8040a94:	17d8      	asrcs	r0, r3, #31
 8040a96:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8040a9a:	f040 0001 	orr.w	r0, r0, #1
 8040a9e:	4770      	bx	lr
 8040aa0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040aa4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040aa8:	d102      	bne.n	8040ab0 <__cmpdf2+0x64>
 8040aaa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040aae:	d107      	bne.n	8040ac0 <__cmpdf2+0x74>
 8040ab0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040ab4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040ab8:	d1d6      	bne.n	8040a68 <__cmpdf2+0x1c>
 8040aba:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040abe:	d0d3      	beq.n	8040a68 <__cmpdf2+0x1c>
 8040ac0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8040ac4:	4770      	bx	lr
 8040ac6:	bf00      	nop

08040ac8 <__aeabi_cdrcmple>:
 8040ac8:	4684      	mov	ip, r0
 8040aca:	4610      	mov	r0, r2
 8040acc:	4662      	mov	r2, ip
 8040ace:	468c      	mov	ip, r1
 8040ad0:	4619      	mov	r1, r3
 8040ad2:	4663      	mov	r3, ip
 8040ad4:	e000      	b.n	8040ad8 <__aeabi_cdcmpeq>
 8040ad6:	bf00      	nop

08040ad8 <__aeabi_cdcmpeq>:
 8040ad8:	b501      	push	{r0, lr}
 8040ada:	f7ff ffb7 	bl	8040a4c <__cmpdf2>
 8040ade:	2800      	cmp	r0, #0
 8040ae0:	bf48      	it	mi
 8040ae2:	f110 0f00 	cmnmi.w	r0, #0
 8040ae6:	bd01      	pop	{r0, pc}

08040ae8 <__aeabi_dcmpeq>:
 8040ae8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040aec:	f7ff fff4 	bl	8040ad8 <__aeabi_cdcmpeq>
 8040af0:	bf0c      	ite	eq
 8040af2:	2001      	moveq	r0, #1
 8040af4:	2000      	movne	r0, #0
 8040af6:	f85d fb08 	ldr.w	pc, [sp], #8
 8040afa:	bf00      	nop

08040afc <__aeabi_dcmplt>:
 8040afc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b00:	f7ff ffea 	bl	8040ad8 <__aeabi_cdcmpeq>
 8040b04:	bf34      	ite	cc
 8040b06:	2001      	movcc	r0, #1
 8040b08:	2000      	movcs	r0, #0
 8040b0a:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b0e:	bf00      	nop

08040b10 <__aeabi_dcmple>:
 8040b10:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b14:	f7ff ffe0 	bl	8040ad8 <__aeabi_cdcmpeq>
 8040b18:	bf94      	ite	ls
 8040b1a:	2001      	movls	r0, #1
 8040b1c:	2000      	movhi	r0, #0
 8040b1e:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b22:	bf00      	nop

08040b24 <__aeabi_dcmpge>:
 8040b24:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b28:	f7ff ffce 	bl	8040ac8 <__aeabi_cdrcmple>
 8040b2c:	bf94      	ite	ls
 8040b2e:	2001      	movls	r0, #1
 8040b30:	2000      	movhi	r0, #0
 8040b32:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b36:	bf00      	nop

08040b38 <__aeabi_dcmpgt>:
 8040b38:	f84d ed08 	str.w	lr, [sp, #-8]!
 8040b3c:	f7ff ffc4 	bl	8040ac8 <__aeabi_cdrcmple>
 8040b40:	bf34      	ite	cc
 8040b42:	2001      	movcc	r0, #1
 8040b44:	2000      	movcs	r0, #0
 8040b46:	f85d fb08 	ldr.w	pc, [sp], #8
 8040b4a:	bf00      	nop

08040b4c <__aeabi_dcmpun>:
 8040b4c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8040b50:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040b54:	d102      	bne.n	8040b5c <__aeabi_dcmpun+0x10>
 8040b56:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8040b5a:	d10a      	bne.n	8040b72 <__aeabi_dcmpun+0x26>
 8040b5c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8040b60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8040b64:	d102      	bne.n	8040b6c <__aeabi_dcmpun+0x20>
 8040b66:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8040b6a:	d102      	bne.n	8040b72 <__aeabi_dcmpun+0x26>
 8040b6c:	f04f 0000 	mov.w	r0, #0
 8040b70:	4770      	bx	lr
 8040b72:	f04f 0001 	mov.w	r0, #1
 8040b76:	4770      	bx	lr

08040b78 <__aeabi_d2iz>:
 8040b78:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040b7c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8040b80:	d215      	bcs.n	8040bae <__aeabi_d2iz+0x36>
 8040b82:	d511      	bpl.n	8040ba8 <__aeabi_d2iz+0x30>
 8040b84:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8040b88:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040b8c:	d912      	bls.n	8040bb4 <__aeabi_d2iz+0x3c>
 8040b8e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040b92:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8040b96:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040b9a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8040b9e:	fa23 f002 	lsr.w	r0, r3, r2
 8040ba2:	bf18      	it	ne
 8040ba4:	4240      	negne	r0, r0
 8040ba6:	4770      	bx	lr
 8040ba8:	f04f 0000 	mov.w	r0, #0
 8040bac:	4770      	bx	lr
 8040bae:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040bb2:	d105      	bne.n	8040bc0 <__aeabi_d2iz+0x48>
 8040bb4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8040bb8:	bf08      	it	eq
 8040bba:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8040bbe:	4770      	bx	lr
 8040bc0:	f04f 0000 	mov.w	r0, #0
 8040bc4:	4770      	bx	lr
 8040bc6:	bf00      	nop

08040bc8 <__aeabi_d2uiz>:
 8040bc8:	004a      	lsls	r2, r1, #1
 8040bca:	d211      	bcs.n	8040bf0 <__aeabi_d2uiz+0x28>
 8040bcc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8040bd0:	d211      	bcs.n	8040bf6 <__aeabi_d2uiz+0x2e>
 8040bd2:	d50d      	bpl.n	8040bf0 <__aeabi_d2uiz+0x28>
 8040bd4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8040bd8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8040bdc:	d40e      	bmi.n	8040bfc <__aeabi_d2uiz+0x34>
 8040bde:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040be2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8040be6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8040bea:	fa23 f002 	lsr.w	r0, r3, r2
 8040bee:	4770      	bx	lr
 8040bf0:	f04f 0000 	mov.w	r0, #0
 8040bf4:	4770      	bx	lr
 8040bf6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8040bfa:	d102      	bne.n	8040c02 <__aeabi_d2uiz+0x3a>
 8040bfc:	f04f 30ff 	mov.w	r0, #4294967295
 8040c00:	4770      	bx	lr
 8040c02:	f04f 0000 	mov.w	r0, #0
 8040c06:	4770      	bx	lr

08040c08 <__aeabi_d2f>:
 8040c08:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8040c0c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8040c10:	bf24      	itt	cs
 8040c12:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8040c16:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8040c1a:	d90d      	bls.n	8040c38 <__aeabi_d2f+0x30>
 8040c1c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8040c20:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8040c24:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8040c28:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8040c2c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8040c30:	bf08      	it	eq
 8040c32:	f020 0001 	biceq.w	r0, r0, #1
 8040c36:	4770      	bx	lr
 8040c38:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8040c3c:	d121      	bne.n	8040c82 <__aeabi_d2f+0x7a>
 8040c3e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8040c42:	bfbc      	itt	lt
 8040c44:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8040c48:	4770      	bxlt	lr
 8040c4a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8040c4e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8040c52:	f1c2 0218 	rsb	r2, r2, #24
 8040c56:	f1c2 0c20 	rsb	ip, r2, #32
 8040c5a:	fa10 f30c 	lsls.w	r3, r0, ip
 8040c5e:	fa20 f002 	lsr.w	r0, r0, r2
 8040c62:	bf18      	it	ne
 8040c64:	f040 0001 	orrne.w	r0, r0, #1
 8040c68:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8040c6c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8040c70:	fa03 fc0c 	lsl.w	ip, r3, ip
 8040c74:	ea40 000c 	orr.w	r0, r0, ip
 8040c78:	fa23 f302 	lsr.w	r3, r3, r2
 8040c7c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8040c80:	e7cc      	b.n	8040c1c <__aeabi_d2f+0x14>
 8040c82:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8040c86:	d107      	bne.n	8040c98 <__aeabi_d2f+0x90>
 8040c88:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8040c8c:	bf1e      	ittt	ne
 8040c8e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8040c92:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8040c96:	4770      	bxne	lr
 8040c98:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8040c9c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8040ca0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8040ca4:	4770      	bx	lr
 8040ca6:	bf00      	nop

08040ca8 <__aeabi_uldivmod>:
 8040ca8:	b953      	cbnz	r3, 8040cc0 <__aeabi_uldivmod+0x18>
 8040caa:	b94a      	cbnz	r2, 8040cc0 <__aeabi_uldivmod+0x18>
 8040cac:	2900      	cmp	r1, #0
 8040cae:	bf08      	it	eq
 8040cb0:	2800      	cmpeq	r0, #0
 8040cb2:	bf1c      	itt	ne
 8040cb4:	f04f 31ff 	movne.w	r1, #4294967295
 8040cb8:	f04f 30ff 	movne.w	r0, #4294967295
 8040cbc:	f000 b9a4 	b.w	8041008 <__aeabi_idiv0>
 8040cc0:	f1ad 0c08 	sub.w	ip, sp, #8
 8040cc4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8040cc8:	f000 f83c 	bl	8040d44 <__udivmoddi4>
 8040ccc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8040cd0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8040cd4:	b004      	add	sp, #16
 8040cd6:	4770      	bx	lr

08040cd8 <__aeabi_d2lz>:
 8040cd8:	b538      	push	{r3, r4, r5, lr}
 8040cda:	2200      	movs	r2, #0
 8040cdc:	2300      	movs	r3, #0
 8040cde:	4604      	mov	r4, r0
 8040ce0:	460d      	mov	r5, r1
 8040ce2:	f7ff ff0b 	bl	8040afc <__aeabi_dcmplt>
 8040ce6:	b928      	cbnz	r0, 8040cf4 <__aeabi_d2lz+0x1c>
 8040ce8:	4620      	mov	r0, r4
 8040cea:	4629      	mov	r1, r5
 8040cec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8040cf0:	f000 b80a 	b.w	8040d08 <__aeabi_d2ulz>
 8040cf4:	4620      	mov	r0, r4
 8040cf6:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
 8040cfa:	f000 f805 	bl	8040d08 <__aeabi_d2ulz>
 8040cfe:	4240      	negs	r0, r0
 8040d00:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8040d04:	bd38      	pop	{r3, r4, r5, pc}
 8040d06:	bf00      	nop

08040d08 <__aeabi_d2ulz>:
 8040d08:	b5d0      	push	{r4, r6, r7, lr}
 8040d0a:	4b0c      	ldr	r3, [pc, #48]	; (8040d3c <__aeabi_d2ulz+0x34>)
 8040d0c:	2200      	movs	r2, #0
 8040d0e:	4606      	mov	r6, r0
 8040d10:	460f      	mov	r7, r1
 8040d12:	f7ff fc81 	bl	8040618 <__aeabi_dmul>
 8040d16:	f7ff ff57 	bl	8040bc8 <__aeabi_d2uiz>
 8040d1a:	4604      	mov	r4, r0
 8040d1c:	f7ff fc02 	bl	8040524 <__aeabi_ui2d>
 8040d20:	4b07      	ldr	r3, [pc, #28]	; (8040d40 <__aeabi_d2ulz+0x38>)
 8040d22:	2200      	movs	r2, #0
 8040d24:	f7ff fc78 	bl	8040618 <__aeabi_dmul>
 8040d28:	4602      	mov	r2, r0
 8040d2a:	460b      	mov	r3, r1
 8040d2c:	4630      	mov	r0, r6
 8040d2e:	4639      	mov	r1, r7
 8040d30:	f7ff faba 	bl	80402a8 <__aeabi_dsub>
 8040d34:	f7ff ff48 	bl	8040bc8 <__aeabi_d2uiz>
 8040d38:	4621      	mov	r1, r4
 8040d3a:	bdd0      	pop	{r4, r6, r7, pc}
 8040d3c:	3df00000 	.word	0x3df00000
 8040d40:	41f00000 	.word	0x41f00000

08040d44 <__udivmoddi4>:
 8040d44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8040d48:	9d08      	ldr	r5, [sp, #32]
 8040d4a:	4604      	mov	r4, r0
 8040d4c:	468c      	mov	ip, r1
 8040d4e:	2b00      	cmp	r3, #0
 8040d50:	f040 8083 	bne.w	8040e5a <__udivmoddi4+0x116>
 8040d54:	428a      	cmp	r2, r1
 8040d56:	4617      	mov	r7, r2
 8040d58:	d947      	bls.n	8040dea <__udivmoddi4+0xa6>
 8040d5a:	fab2 f282 	clz	r2, r2
 8040d5e:	b142      	cbz	r2, 8040d72 <__udivmoddi4+0x2e>
 8040d60:	f1c2 0020 	rsb	r0, r2, #32
 8040d64:	fa24 f000 	lsr.w	r0, r4, r0
 8040d68:	4091      	lsls	r1, r2
 8040d6a:	4097      	lsls	r7, r2
 8040d6c:	ea40 0c01 	orr.w	ip, r0, r1
 8040d70:	4094      	lsls	r4, r2
 8040d72:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8040d76:	0c23      	lsrs	r3, r4, #16
 8040d78:	fbbc f6f8 	udiv	r6, ip, r8
 8040d7c:	fa1f fe87 	uxth.w	lr, r7
 8040d80:	fb08 c116 	mls	r1, r8, r6, ip
 8040d84:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8040d88:	fb06 f10e 	mul.w	r1, r6, lr
 8040d8c:	4299      	cmp	r1, r3
 8040d8e:	d909      	bls.n	8040da4 <__udivmoddi4+0x60>
 8040d90:	18fb      	adds	r3, r7, r3
 8040d92:	f106 30ff 	add.w	r0, r6, #4294967295
 8040d96:	f080 8119 	bcs.w	8040fcc <__udivmoddi4+0x288>
 8040d9a:	4299      	cmp	r1, r3
 8040d9c:	f240 8116 	bls.w	8040fcc <__udivmoddi4+0x288>
 8040da0:	3e02      	subs	r6, #2
 8040da2:	443b      	add	r3, r7
 8040da4:	1a5b      	subs	r3, r3, r1
 8040da6:	b2a4      	uxth	r4, r4
 8040da8:	fbb3 f0f8 	udiv	r0, r3, r8
 8040dac:	fb08 3310 	mls	r3, r8, r0, r3
 8040db0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8040db4:	fb00 fe0e 	mul.w	lr, r0, lr
 8040db8:	45a6      	cmp	lr, r4
 8040dba:	d909      	bls.n	8040dd0 <__udivmoddi4+0x8c>
 8040dbc:	193c      	adds	r4, r7, r4
 8040dbe:	f100 33ff 	add.w	r3, r0, #4294967295
 8040dc2:	f080 8105 	bcs.w	8040fd0 <__udivmoddi4+0x28c>
 8040dc6:	45a6      	cmp	lr, r4
 8040dc8:	f240 8102 	bls.w	8040fd0 <__udivmoddi4+0x28c>
 8040dcc:	3802      	subs	r0, #2
 8040dce:	443c      	add	r4, r7
 8040dd0:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8040dd4:	eba4 040e 	sub.w	r4, r4, lr
 8040dd8:	2600      	movs	r6, #0
 8040dda:	b11d      	cbz	r5, 8040de4 <__udivmoddi4+0xa0>
 8040ddc:	40d4      	lsrs	r4, r2
 8040dde:	2300      	movs	r3, #0
 8040de0:	e9c5 4300 	strd	r4, r3, [r5]
 8040de4:	4631      	mov	r1, r6
 8040de6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040dea:	b902      	cbnz	r2, 8040dee <__udivmoddi4+0xaa>
 8040dec:	deff      	udf	#255	; 0xff
 8040dee:	fab2 f282 	clz	r2, r2
 8040df2:	2a00      	cmp	r2, #0
 8040df4:	d150      	bne.n	8040e98 <__udivmoddi4+0x154>
 8040df6:	1bcb      	subs	r3, r1, r7
 8040df8:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8040dfc:	fa1f f887 	uxth.w	r8, r7
 8040e00:	2601      	movs	r6, #1
 8040e02:	fbb3 fcfe 	udiv	ip, r3, lr
 8040e06:	0c21      	lsrs	r1, r4, #16
 8040e08:	fb0e 331c 	mls	r3, lr, ip, r3
 8040e0c:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8040e10:	fb08 f30c 	mul.w	r3, r8, ip
 8040e14:	428b      	cmp	r3, r1
 8040e16:	d907      	bls.n	8040e28 <__udivmoddi4+0xe4>
 8040e18:	1879      	adds	r1, r7, r1
 8040e1a:	f10c 30ff 	add.w	r0, ip, #4294967295
 8040e1e:	d202      	bcs.n	8040e26 <__udivmoddi4+0xe2>
 8040e20:	428b      	cmp	r3, r1
 8040e22:	f200 80e9 	bhi.w	8040ff8 <__udivmoddi4+0x2b4>
 8040e26:	4684      	mov	ip, r0
 8040e28:	1ac9      	subs	r1, r1, r3
 8040e2a:	b2a3      	uxth	r3, r4
 8040e2c:	fbb1 f0fe 	udiv	r0, r1, lr
 8040e30:	fb0e 1110 	mls	r1, lr, r0, r1
 8040e34:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 8040e38:	fb08 f800 	mul.w	r8, r8, r0
 8040e3c:	45a0      	cmp	r8, r4
 8040e3e:	d907      	bls.n	8040e50 <__udivmoddi4+0x10c>
 8040e40:	193c      	adds	r4, r7, r4
 8040e42:	f100 33ff 	add.w	r3, r0, #4294967295
 8040e46:	d202      	bcs.n	8040e4e <__udivmoddi4+0x10a>
 8040e48:	45a0      	cmp	r8, r4
 8040e4a:	f200 80d9 	bhi.w	8041000 <__udivmoddi4+0x2bc>
 8040e4e:	4618      	mov	r0, r3
 8040e50:	eba4 0408 	sub.w	r4, r4, r8
 8040e54:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8040e58:	e7bf      	b.n	8040dda <__udivmoddi4+0x96>
 8040e5a:	428b      	cmp	r3, r1
 8040e5c:	d909      	bls.n	8040e72 <__udivmoddi4+0x12e>
 8040e5e:	2d00      	cmp	r5, #0
 8040e60:	f000 80b1 	beq.w	8040fc6 <__udivmoddi4+0x282>
 8040e64:	2600      	movs	r6, #0
 8040e66:	e9c5 0100 	strd	r0, r1, [r5]
 8040e6a:	4630      	mov	r0, r6
 8040e6c:	4631      	mov	r1, r6
 8040e6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040e72:	fab3 f683 	clz	r6, r3
 8040e76:	2e00      	cmp	r6, #0
 8040e78:	d14a      	bne.n	8040f10 <__udivmoddi4+0x1cc>
 8040e7a:	428b      	cmp	r3, r1
 8040e7c:	d302      	bcc.n	8040e84 <__udivmoddi4+0x140>
 8040e7e:	4282      	cmp	r2, r0
 8040e80:	f200 80b8 	bhi.w	8040ff4 <__udivmoddi4+0x2b0>
 8040e84:	1a84      	subs	r4, r0, r2
 8040e86:	eb61 0103 	sbc.w	r1, r1, r3
 8040e8a:	2001      	movs	r0, #1
 8040e8c:	468c      	mov	ip, r1
 8040e8e:	2d00      	cmp	r5, #0
 8040e90:	d0a8      	beq.n	8040de4 <__udivmoddi4+0xa0>
 8040e92:	e9c5 4c00 	strd	r4, ip, [r5]
 8040e96:	e7a5      	b.n	8040de4 <__udivmoddi4+0xa0>
 8040e98:	f1c2 0320 	rsb	r3, r2, #32
 8040e9c:	fa20 f603 	lsr.w	r6, r0, r3
 8040ea0:	4097      	lsls	r7, r2
 8040ea2:	fa01 f002 	lsl.w	r0, r1, r2
 8040ea6:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8040eaa:	40d9      	lsrs	r1, r3
 8040eac:	4330      	orrs	r0, r6
 8040eae:	0c03      	lsrs	r3, r0, #16
 8040eb0:	fbb1 f6fe 	udiv	r6, r1, lr
 8040eb4:	fa1f f887 	uxth.w	r8, r7
 8040eb8:	fb0e 1116 	mls	r1, lr, r6, r1
 8040ebc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8040ec0:	fb06 f108 	mul.w	r1, r6, r8
 8040ec4:	4299      	cmp	r1, r3
 8040ec6:	fa04 f402 	lsl.w	r4, r4, r2
 8040eca:	d909      	bls.n	8040ee0 <__udivmoddi4+0x19c>
 8040ecc:	18fb      	adds	r3, r7, r3
 8040ece:	f106 3cff 	add.w	ip, r6, #4294967295
 8040ed2:	f080 808d 	bcs.w	8040ff0 <__udivmoddi4+0x2ac>
 8040ed6:	4299      	cmp	r1, r3
 8040ed8:	f240 808a 	bls.w	8040ff0 <__udivmoddi4+0x2ac>
 8040edc:	3e02      	subs	r6, #2
 8040ede:	443b      	add	r3, r7
 8040ee0:	1a5b      	subs	r3, r3, r1
 8040ee2:	b281      	uxth	r1, r0
 8040ee4:	fbb3 f0fe 	udiv	r0, r3, lr
 8040ee8:	fb0e 3310 	mls	r3, lr, r0, r3
 8040eec:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8040ef0:	fb00 f308 	mul.w	r3, r0, r8
 8040ef4:	428b      	cmp	r3, r1
 8040ef6:	d907      	bls.n	8040f08 <__udivmoddi4+0x1c4>
 8040ef8:	1879      	adds	r1, r7, r1
 8040efa:	f100 3cff 	add.w	ip, r0, #4294967295
 8040efe:	d273      	bcs.n	8040fe8 <__udivmoddi4+0x2a4>
 8040f00:	428b      	cmp	r3, r1
 8040f02:	d971      	bls.n	8040fe8 <__udivmoddi4+0x2a4>
 8040f04:	3802      	subs	r0, #2
 8040f06:	4439      	add	r1, r7
 8040f08:	1acb      	subs	r3, r1, r3
 8040f0a:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 8040f0e:	e778      	b.n	8040e02 <__udivmoddi4+0xbe>
 8040f10:	f1c6 0c20 	rsb	ip, r6, #32
 8040f14:	fa03 f406 	lsl.w	r4, r3, r6
 8040f18:	fa22 f30c 	lsr.w	r3, r2, ip
 8040f1c:	431c      	orrs	r4, r3
 8040f1e:	fa20 f70c 	lsr.w	r7, r0, ip
 8040f22:	fa01 f306 	lsl.w	r3, r1, r6
 8040f26:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 8040f2a:	fa21 f10c 	lsr.w	r1, r1, ip
 8040f2e:	431f      	orrs	r7, r3
 8040f30:	0c3b      	lsrs	r3, r7, #16
 8040f32:	fbb1 f9fe 	udiv	r9, r1, lr
 8040f36:	fa1f f884 	uxth.w	r8, r4
 8040f3a:	fb0e 1119 	mls	r1, lr, r9, r1
 8040f3e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8040f42:	fb09 fa08 	mul.w	sl, r9, r8
 8040f46:	458a      	cmp	sl, r1
 8040f48:	fa02 f206 	lsl.w	r2, r2, r6
 8040f4c:	fa00 f306 	lsl.w	r3, r0, r6
 8040f50:	d908      	bls.n	8040f64 <__udivmoddi4+0x220>
 8040f52:	1861      	adds	r1, r4, r1
 8040f54:	f109 30ff 	add.w	r0, r9, #4294967295
 8040f58:	d248      	bcs.n	8040fec <__udivmoddi4+0x2a8>
 8040f5a:	458a      	cmp	sl, r1
 8040f5c:	d946      	bls.n	8040fec <__udivmoddi4+0x2a8>
 8040f5e:	f1a9 0902 	sub.w	r9, r9, #2
 8040f62:	4421      	add	r1, r4
 8040f64:	eba1 010a 	sub.w	r1, r1, sl
 8040f68:	b2bf      	uxth	r7, r7
 8040f6a:	fbb1 f0fe 	udiv	r0, r1, lr
 8040f6e:	fb0e 1110 	mls	r1, lr, r0, r1
 8040f72:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8040f76:	fb00 f808 	mul.w	r8, r0, r8
 8040f7a:	45b8      	cmp	r8, r7
 8040f7c:	d907      	bls.n	8040f8e <__udivmoddi4+0x24a>
 8040f7e:	19e7      	adds	r7, r4, r7
 8040f80:	f100 31ff 	add.w	r1, r0, #4294967295
 8040f84:	d22e      	bcs.n	8040fe4 <__udivmoddi4+0x2a0>
 8040f86:	45b8      	cmp	r8, r7
 8040f88:	d92c      	bls.n	8040fe4 <__udivmoddi4+0x2a0>
 8040f8a:	3802      	subs	r0, #2
 8040f8c:	4427      	add	r7, r4
 8040f8e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8040f92:	eba7 0708 	sub.w	r7, r7, r8
 8040f96:	fba0 8902 	umull	r8, r9, r0, r2
 8040f9a:	454f      	cmp	r7, r9
 8040f9c:	46c6      	mov	lr, r8
 8040f9e:	4649      	mov	r1, r9
 8040fa0:	d31a      	bcc.n	8040fd8 <__udivmoddi4+0x294>
 8040fa2:	d017      	beq.n	8040fd4 <__udivmoddi4+0x290>
 8040fa4:	b15d      	cbz	r5, 8040fbe <__udivmoddi4+0x27a>
 8040fa6:	ebb3 020e 	subs.w	r2, r3, lr
 8040faa:	eb67 0701 	sbc.w	r7, r7, r1
 8040fae:	fa07 fc0c 	lsl.w	ip, r7, ip
 8040fb2:	40f2      	lsrs	r2, r6
 8040fb4:	ea4c 0202 	orr.w	r2, ip, r2
 8040fb8:	40f7      	lsrs	r7, r6
 8040fba:	e9c5 2700 	strd	r2, r7, [r5]
 8040fbe:	2600      	movs	r6, #0
 8040fc0:	4631      	mov	r1, r6
 8040fc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8040fc6:	462e      	mov	r6, r5
 8040fc8:	4628      	mov	r0, r5
 8040fca:	e70b      	b.n	8040de4 <__udivmoddi4+0xa0>
 8040fcc:	4606      	mov	r6, r0
 8040fce:	e6e9      	b.n	8040da4 <__udivmoddi4+0x60>
 8040fd0:	4618      	mov	r0, r3
 8040fd2:	e6fd      	b.n	8040dd0 <__udivmoddi4+0x8c>
 8040fd4:	4543      	cmp	r3, r8
 8040fd6:	d2e5      	bcs.n	8040fa4 <__udivmoddi4+0x260>
 8040fd8:	ebb8 0e02 	subs.w	lr, r8, r2
 8040fdc:	eb69 0104 	sbc.w	r1, r9, r4
 8040fe0:	3801      	subs	r0, #1
 8040fe2:	e7df      	b.n	8040fa4 <__udivmoddi4+0x260>
 8040fe4:	4608      	mov	r0, r1
 8040fe6:	e7d2      	b.n	8040f8e <__udivmoddi4+0x24a>
 8040fe8:	4660      	mov	r0, ip
 8040fea:	e78d      	b.n	8040f08 <__udivmoddi4+0x1c4>
 8040fec:	4681      	mov	r9, r0
 8040fee:	e7b9      	b.n	8040f64 <__udivmoddi4+0x220>
 8040ff0:	4666      	mov	r6, ip
 8040ff2:	e775      	b.n	8040ee0 <__udivmoddi4+0x19c>
 8040ff4:	4630      	mov	r0, r6
 8040ff6:	e74a      	b.n	8040e8e <__udivmoddi4+0x14a>
 8040ff8:	f1ac 0c02 	sub.w	ip, ip, #2
 8040ffc:	4439      	add	r1, r7
 8040ffe:	e713      	b.n	8040e28 <__udivmoddi4+0xe4>
 8041000:	3802      	subs	r0, #2
 8041002:	443c      	add	r4, r7
 8041004:	e724      	b.n	8040e50 <__udivmoddi4+0x10c>
 8041006:	bf00      	nop

08041008 <__aeabi_idiv0>:
 8041008:	4770      	bx	lr
 804100a:	bf00      	nop

0804100c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 804100c:	b510      	push	{r4, lr}
 804100e:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8041010:	4b0e      	ldr	r3, [pc, #56]	; (804104c <HAL_InitTick+0x40>)
 8041012:	7818      	ldrb	r0, [r3, #0]
 8041014:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8041018:	fbb3 f3f0 	udiv	r3, r3, r0
 804101c:	4a0c      	ldr	r2, [pc, #48]	; (8041050 <HAL_InitTick+0x44>)
 804101e:	6810      	ldr	r0, [r2, #0]
 8041020:	fbb0 f0f3 	udiv	r0, r0, r3
 8041024:	f000 fc96 	bl	8041954 <HAL_SYSTICK_Config>
 8041028:	b968      	cbnz	r0, 8041046 <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 804102a:	2c0f      	cmp	r4, #15
 804102c:	d901      	bls.n	8041032 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 804102e:	2001      	movs	r0, #1
 8041030:	e00a      	b.n	8041048 <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8041032:	2200      	movs	r2, #0
 8041034:	4621      	mov	r1, r4
 8041036:	f04f 30ff 	mov.w	r0, #4294967295
 804103a:	f000 fc49 	bl	80418d0 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 804103e:	4b03      	ldr	r3, [pc, #12]	; (804104c <HAL_InitTick+0x40>)
 8041040:	605c      	str	r4, [r3, #4]
  }

  /* Return function status */
  return HAL_OK;
 8041042:	2000      	movs	r0, #0
 8041044:	e000      	b.n	8041048 <HAL_InitTick+0x3c>
    return HAL_ERROR;
 8041046:	2001      	movs	r0, #1
}
 8041048:	bd10      	pop	{r4, pc}
 804104a:	bf00      	nop
 804104c:	20000000 	.word	0x20000000
 8041050:	20003874 	.word	0x20003874

08041054 <HAL_Init>:
{
 8041054:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8041056:	4b0b      	ldr	r3, [pc, #44]	; (8041084 <HAL_Init+0x30>)
 8041058:	681a      	ldr	r2, [r3, #0]
 804105a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 804105e:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8041060:	681a      	ldr	r2, [r3, #0]
 8041062:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8041066:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8041068:	681a      	ldr	r2, [r3, #0]
 804106a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804106e:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8041070:	2003      	movs	r0, #3
 8041072:	f000 fc1b 	bl	80418ac <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8041076:	2000      	movs	r0, #0
 8041078:	f7ff ffc8 	bl	804100c <HAL_InitTick>
  HAL_MspInit();
 804107c:	f00e fd92 	bl	804fba4 <HAL_MspInit>
}
 8041080:	2000      	movs	r0, #0
 8041082:	bd08      	pop	{r3, pc}
 8041084:	40023c00 	.word	0x40023c00

08041088 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8041088:	4a03      	ldr	r2, [pc, #12]	; (8041098 <HAL_IncTick+0x10>)
 804108a:	6811      	ldr	r1, [r2, #0]
 804108c:	4b03      	ldr	r3, [pc, #12]	; (804109c <HAL_IncTick+0x14>)
 804108e:	781b      	ldrb	r3, [r3, #0]
 8041090:	440b      	add	r3, r1
 8041092:	6013      	str	r3, [r2, #0]
}
 8041094:	4770      	bx	lr
 8041096:	bf00      	nop
 8041098:	20005448 	.word	0x20005448
 804109c:	20000000 	.word	0x20000000

080410a0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80410a0:	4b01      	ldr	r3, [pc, #4]	; (80410a8 <HAL_GetTick+0x8>)
 80410a2:	6818      	ldr	r0, [r3, #0]
}
 80410a4:	4770      	bx	lr
 80410a6:	bf00      	nop
 80410a8:	20005448 	.word	0x20005448

080410ac <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80410ac:	b538      	push	{r3, r4, r5, lr}
 80410ae:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80410b0:	f7ff fff6 	bl	80410a0 <HAL_GetTick>
 80410b4:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 80410b6:	f1b4 3fff 	cmp.w	r4, #4294967295
 80410ba:	d002      	beq.n	80410c2 <HAL_Delay+0x16>
  {
    wait += (uint32_t)(uwTickFreq);
 80410bc:	4b04      	ldr	r3, [pc, #16]	; (80410d0 <HAL_Delay+0x24>)
 80410be:	781b      	ldrb	r3, [r3, #0]
 80410c0:	441c      	add	r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80410c2:	f7ff ffed 	bl	80410a0 <HAL_GetTick>
 80410c6:	1b40      	subs	r0, r0, r5
 80410c8:	42a0      	cmp	r0, r4
 80410ca:	d3fa      	bcc.n	80410c2 <HAL_Delay+0x16>
  {
  }
}
 80410cc:	bd38      	pop	{r3, r4, r5, pc}
 80410ce:	bf00      	nop
 80410d0:	20000000 	.word	0x20000000

080410d4 <ADC_Init>:
  /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
  /* control register)                                                    */
  tmpADC_Common = ADC_COMMON_REGISTER(hadc);
  
  /* Set the ADC clock prescaler */
  tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
 80410d4:	4b4a      	ldr	r3, [pc, #296]	; (8041200 <ADC_Init+0x12c>)
 80410d6:	685a      	ldr	r2, [r3, #4]
 80410d8:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80410dc:	605a      	str	r2, [r3, #4]
  tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
 80410de:	685a      	ldr	r2, [r3, #4]
 80410e0:	6841      	ldr	r1, [r0, #4]
 80410e2:	430a      	orrs	r2, r1
 80410e4:	605a      	str	r2, [r3, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 80410e6:	6802      	ldr	r2, [r0, #0]
 80410e8:	6853      	ldr	r3, [r2, #4]
 80410ea:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80410ee:	6053      	str	r3, [r2, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 80410f0:	6802      	ldr	r2, [r0, #0]
 80410f2:	6853      	ldr	r3, [r2, #4]
 80410f4:	6901      	ldr	r1, [r0, #16]
 80410f6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80410fa:	6053      	str	r3, [r2, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 80410fc:	6802      	ldr	r2, [r0, #0]
 80410fe:	6853      	ldr	r3, [r2, #4]
 8041100:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 8041104:	6053      	str	r3, [r2, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8041106:	6802      	ldr	r2, [r0, #0]
 8041108:	6853      	ldr	r3, [r2, #4]
 804110a:	6881      	ldr	r1, [r0, #8]
 804110c:	430b      	orrs	r3, r1
 804110e:	6053      	str	r3, [r2, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8041110:	6802      	ldr	r2, [r0, #0]
 8041112:	6893      	ldr	r3, [r2, #8]
 8041114:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8041118:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 804111a:	6802      	ldr	r2, [r0, #0]
 804111c:	6893      	ldr	r3, [r2, #8]
 804111e:	68c1      	ldr	r1, [r0, #12]
 8041120:	430b      	orrs	r3, r1
 8041122:	6093      	str	r3, [r2, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8041124:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8041126:	4b37      	ldr	r3, [pc, #220]	; (8041204 <ADC_Init+0x130>)
 8041128:	429a      	cmp	r2, r3
 804112a:	d057      	beq.n	80411dc <ADC_Init+0x108>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 804112c:	6802      	ldr	r2, [r0, #0]
 804112e:	6893      	ldr	r3, [r2, #8]
 8041130:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8041134:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8041136:	6802      	ldr	r2, [r0, #0]
 8041138:	6893      	ldr	r3, [r2, #8]
 804113a:	6a81      	ldr	r1, [r0, #40]	; 0x28
 804113c:	430b      	orrs	r3, r1
 804113e:	6093      	str	r3, [r2, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8041140:	6802      	ldr	r2, [r0, #0]
 8041142:	6893      	ldr	r3, [r2, #8]
 8041144:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8041148:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 804114a:	6802      	ldr	r2, [r0, #0]
 804114c:	6893      	ldr	r3, [r2, #8]
 804114e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8041150:	430b      	orrs	r3, r1
 8041152:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8041154:	6802      	ldr	r2, [r0, #0]
 8041156:	6893      	ldr	r3, [r2, #8]
 8041158:	f023 0302 	bic.w	r3, r3, #2
 804115c:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 804115e:	6802      	ldr	r2, [r0, #0]
 8041160:	6893      	ldr	r3, [r2, #8]
 8041162:	7e01      	ldrb	r1, [r0, #24]
 8041164:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
 8041168:	6093      	str	r3, [r2, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 804116a:	f890 3020 	ldrb.w	r3, [r0, #32]
 804116e:	2b00      	cmp	r3, #0
 8041170:	d03f      	beq.n	80411f2 <ADC_Init+0x11e>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8041172:	6802      	ldr	r2, [r0, #0]
 8041174:	6853      	ldr	r3, [r2, #4]
 8041176:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 804117a:	6053      	str	r3, [r2, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 804117c:	6802      	ldr	r2, [r0, #0]
 804117e:	6853      	ldr	r3, [r2, #4]
 8041180:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8041184:	6053      	str	r3, [r2, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8041186:	6801      	ldr	r1, [r0, #0]
 8041188:	684b      	ldr	r3, [r1, #4]
 804118a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 804118c:	3a01      	subs	r2, #1
 804118e:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
 8041192:	604b      	str	r3, [r1, #4]
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8041194:	6802      	ldr	r2, [r0, #0]
 8041196:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8041198:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 804119c:	62d3      	str	r3, [r2, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 804119e:	6801      	ldr	r1, [r0, #0]
 80411a0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80411a2:	69c2      	ldr	r2, [r0, #28]
 80411a4:	3a01      	subs	r2, #1
 80411a6:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 80411aa:	62cb      	str	r3, [r1, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 80411ac:	6802      	ldr	r2, [r0, #0]
 80411ae:	6893      	ldr	r3, [r2, #8]
 80411b0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80411b4:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 80411b6:	6802      	ldr	r2, [r0, #0]
 80411b8:	6893      	ldr	r3, [r2, #8]
 80411ba:	f890 1030 	ldrb.w	r1, [r0, #48]	; 0x30
 80411be:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
 80411c2:	6093      	str	r3, [r2, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80411c4:	6802      	ldr	r2, [r0, #0]
 80411c6:	6893      	ldr	r3, [r2, #8]
 80411c8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80411cc:	6093      	str	r3, [r2, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80411ce:	6802      	ldr	r2, [r0, #0]
 80411d0:	6893      	ldr	r3, [r2, #8]
 80411d2:	6941      	ldr	r1, [r0, #20]
 80411d4:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
 80411d8:	6093      	str	r3, [r2, #8]
}
 80411da:	4770      	bx	lr
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80411dc:	6802      	ldr	r2, [r0, #0]
 80411de:	6893      	ldr	r3, [r2, #8]
 80411e0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80411e4:	6093      	str	r3, [r2, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80411e6:	6802      	ldr	r2, [r0, #0]
 80411e8:	6893      	ldr	r3, [r2, #8]
 80411ea:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 80411ee:	6093      	str	r3, [r2, #8]
 80411f0:	e7b0      	b.n	8041154 <ADC_Init+0x80>
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 80411f2:	6802      	ldr	r2, [r0, #0]
 80411f4:	6853      	ldr	r3, [r2, #4]
 80411f6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80411fa:	6053      	str	r3, [r2, #4]
 80411fc:	e7ca      	b.n	8041194 <ADC_Init+0xc0>
 80411fe:	bf00      	nop
 8041200:	40012300 	.word	0x40012300
 8041204:	0f000001 	.word	0x0f000001

08041208 <HAL_ADC_Init>:
  if(hadc == NULL)
 8041208:	b338      	cbz	r0, 804125a <HAL_ADC_Init+0x52>
{
 804120a:	b510      	push	{r4, lr}
 804120c:	4604      	mov	r4, r0
  if(hadc->State == HAL_ADC_STATE_RESET)
 804120e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8041210:	b143      	cbz	r3, 8041224 <HAL_ADC_Init+0x1c>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8041212:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041214:	f013 0f10 	tst.w	r3, #16
 8041218:	d00b      	beq.n	8041232 <HAL_ADC_Init+0x2a>
    tmp_hal_status = HAL_ERROR;
 804121a:	2001      	movs	r0, #1
  __HAL_UNLOCK(hadc);
 804121c:	2300      	movs	r3, #0
 804121e:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 8041222:	bd10      	pop	{r4, pc}
    HAL_ADC_MspInit(hadc);
 8041224:	f00a f9b6 	bl	804b594 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8041228:	2300      	movs	r3, #0
 804122a:	6463      	str	r3, [r4, #68]	; 0x44
    hadc->Lock = HAL_UNLOCKED;
 804122c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
 8041230:	e7ef      	b.n	8041212 <HAL_ADC_Init+0xa>
    ADC_STATE_CLR_SET(hadc->State,
 8041232:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041234:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 8041238:	f023 0302 	bic.w	r3, r3, #2
 804123c:	f043 0302 	orr.w	r3, r3, #2
 8041240:	6423      	str	r3, [r4, #64]	; 0x40
    ADC_Init(hadc);
 8041242:	4620      	mov	r0, r4
 8041244:	f7ff ff46 	bl	80410d4 <ADC_Init>
    ADC_CLEAR_ERRORCODE(hadc);
 8041248:	2000      	movs	r0, #0
 804124a:	6460      	str	r0, [r4, #68]	; 0x44
    ADC_STATE_CLR_SET(hadc->State,
 804124c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 804124e:	f023 0303 	bic.w	r3, r3, #3
 8041252:	f043 0301 	orr.w	r3, r3, #1
 8041256:	6423      	str	r3, [r4, #64]	; 0x40
 8041258:	e7e0      	b.n	804121c <HAL_ADC_Init+0x14>
    return HAL_ERROR;
 804125a:	2001      	movs	r0, #1
}
 804125c:	4770      	bx	lr
	...

08041260 <HAL_ADC_Start_IT>:
{
 8041260:	b082      	sub	sp, #8
  __IO uint32_t counter = 0U;
 8041262:	2300      	movs	r3, #0
 8041264:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 8041266:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 804126a:	2b01      	cmp	r3, #1
 804126c:	f000 8085 	beq.w	804137a <HAL_ADC_Start_IT+0x11a>
 8041270:	2301      	movs	r3, #1
 8041272:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8041276:	6803      	ldr	r3, [r0, #0]
 8041278:	689a      	ldr	r2, [r3, #8]
 804127a:	f012 0f01 	tst.w	r2, #1
 804127e:	d113      	bne.n	80412a8 <HAL_ADC_Start_IT+0x48>
    __HAL_ADC_ENABLE(hadc);
 8041280:	689a      	ldr	r2, [r3, #8]
 8041282:	f042 0201 	orr.w	r2, r2, #1
 8041286:	609a      	str	r2, [r3, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 8041288:	4b40      	ldr	r3, [pc, #256]	; (804138c <HAL_ADC_Start_IT+0x12c>)
 804128a:	681b      	ldr	r3, [r3, #0]
 804128c:	4a40      	ldr	r2, [pc, #256]	; (8041390 <HAL_ADC_Start_IT+0x130>)
 804128e:	fba2 2303 	umull	r2, r3, r2, r3
 8041292:	0c9b      	lsrs	r3, r3, #18
 8041294:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8041298:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 804129a:	e002      	b.n	80412a2 <HAL_ADC_Start_IT+0x42>
      counter--;
 804129c:	9b01      	ldr	r3, [sp, #4]
 804129e:	3b01      	subs	r3, #1
 80412a0:	9301      	str	r3, [sp, #4]
    while(counter != 0U)
 80412a2:	9b01      	ldr	r3, [sp, #4]
 80412a4:	2b00      	cmp	r3, #0
 80412a6:	d1f9      	bne.n	804129c <HAL_ADC_Start_IT+0x3c>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 80412a8:	6802      	ldr	r2, [r0, #0]
 80412aa:	6893      	ldr	r3, [r2, #8]
 80412ac:	f013 0f01 	tst.w	r3, #1
 80412b0:	d065      	beq.n	804137e <HAL_ADC_Start_IT+0x11e>
    ADC_STATE_CLR_SET(hadc->State,
 80412b2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412b4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80412b8:	f023 0301 	bic.w	r3, r3, #1
 80412bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80412c0:	6403      	str	r3, [r0, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 80412c2:	6853      	ldr	r3, [r2, #4]
 80412c4:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80412c8:	d005      	beq.n	80412d6 <HAL_ADC_Start_IT+0x76>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80412ca:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412cc:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80412d0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80412d4:	6403      	str	r3, [r0, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80412d6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80412d8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80412dc:	d022      	beq.n	8041324 <HAL_ADC_Start_IT+0xc4>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80412de:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80412e0:	f023 0306 	bic.w	r3, r3, #6
 80412e4:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(hadc);
 80412e6:	2300      	movs	r3, #0
 80412e8:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 80412ec:	f06f 0322 	mvn.w	r3, #34	; 0x22
 80412f0:	6013      	str	r3, [r2, #0]
    __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
 80412f2:	6802      	ldr	r2, [r0, #0]
 80412f4:	6853      	ldr	r3, [r2, #4]
 80412f6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80412fa:	f043 0320 	orr.w	r3, r3, #32
 80412fe:	6053      	str	r3, [r2, #4]
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 8041300:	4b24      	ldr	r3, [pc, #144]	; (8041394 <HAL_ADC_Start_IT+0x134>)
 8041302:	685b      	ldr	r3, [r3, #4]
 8041304:	f013 0f1f 	tst.w	r3, #31
 8041308:	d127      	bne.n	804135a <HAL_ADC_Start_IT+0xfa>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 804130a:	6803      	ldr	r3, [r0, #0]
 804130c:	4a22      	ldr	r2, [pc, #136]	; (8041398 <HAL_ADC_Start_IT+0x138>)
 804130e:	4293      	cmp	r3, r2
 8041310:	d011      	beq.n	8041336 <HAL_ADC_Start_IT+0xd6>
 8041312:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8041316:	4293      	cmp	r3, r2
 8041318:	d007      	beq.n	804132a <HAL_ADC_Start_IT+0xca>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 804131a:	4a20      	ldr	r2, [pc, #128]	; (804139c <HAL_ADC_Start_IT+0x13c>)
 804131c:	4293      	cmp	r3, r2
 804131e:	d014      	beq.n	804134a <HAL_ADC_Start_IT+0xea>
  return HAL_OK;
 8041320:	2000      	movs	r0, #0
 8041322:	e02d      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
      ADC_CLEAR_ERRORCODE(hadc);
 8041324:	2300      	movs	r3, #0
 8041326:	6443      	str	r3, [r0, #68]	; 0x44
 8041328:	e7dd      	b.n	80412e6 <HAL_ADC_Start_IT+0x86>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 804132a:	f502 7200 	add.w	r2, r2, #512	; 0x200
 804132e:	6852      	ldr	r2, [r2, #4]
 8041330:	f012 0f1f 	tst.w	r2, #31
 8041334:	d1f1      	bne.n	804131a <HAL_ADC_Start_IT+0xba>
        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 8041336:	689a      	ldr	r2, [r3, #8]
 8041338:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 804133c:	d122      	bne.n	8041384 <HAL_ADC_Start_IT+0x124>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 804133e:	689a      	ldr	r2, [r3, #8]
 8041340:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8041344:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8041346:	2000      	movs	r0, #0
 8041348:	e01a      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 804134a:	f502 7280 	add.w	r2, r2, #256	; 0x100
 804134e:	6852      	ldr	r2, [r2, #4]
 8041350:	f012 0f10 	tst.w	r2, #16
 8041354:	d0ef      	beq.n	8041336 <HAL_ADC_Start_IT+0xd6>
  return HAL_OK;
 8041356:	2000      	movs	r0, #0
 8041358:	e012      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 804135a:	6803      	ldr	r3, [r0, #0]
 804135c:	4a0e      	ldr	r2, [pc, #56]	; (8041398 <HAL_ADC_Start_IT+0x138>)
 804135e:	4293      	cmp	r3, r2
 8041360:	d001      	beq.n	8041366 <HAL_ADC_Start_IT+0x106>
  return HAL_OK;
 8041362:	2000      	movs	r0, #0
 8041364:	e00c      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 8041366:	689a      	ldr	r2, [r3, #8]
 8041368:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 804136c:	d10c      	bne.n	8041388 <HAL_ADC_Start_IT+0x128>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 804136e:	689a      	ldr	r2, [r3, #8]
 8041370:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8041374:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8041376:	2000      	movs	r0, #0
 8041378:	e002      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
  __HAL_LOCK(hadc);
 804137a:	2002      	movs	r0, #2
 804137c:	e000      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
  return HAL_OK;
 804137e:	2000      	movs	r0, #0
}
 8041380:	b002      	add	sp, #8
 8041382:	4770      	bx	lr
  return HAL_OK;
 8041384:	2000      	movs	r0, #0
 8041386:	e7fb      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
 8041388:	2000      	movs	r0, #0
 804138a:	e7f9      	b.n	8041380 <HAL_ADC_Start_IT+0x120>
 804138c:	20003874 	.word	0x20003874
 8041390:	431bde83 	.word	0x431bde83
 8041394:	40012300 	.word	0x40012300
 8041398:	40012000 	.word	0x40012000
 804139c:	40012200 	.word	0x40012200

080413a0 <HAL_ADC_Start_DMA>:
{
 80413a0:	b530      	push	{r4, r5, lr}
 80413a2:	b083      	sub	sp, #12
 80413a4:	4613      	mov	r3, r2
  __IO uint32_t counter = 0U;
 80413a6:	2200      	movs	r2, #0
 80413a8:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 80413aa:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 80413ae:	2a01      	cmp	r2, #1
 80413b0:	f000 809a 	beq.w	80414e8 <HAL_ADC_Start_DMA+0x148>
 80413b4:	4605      	mov	r5, r0
 80413b6:	2201      	movs	r2, #1
 80413b8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 80413bc:	6802      	ldr	r2, [r0, #0]
 80413be:	6890      	ldr	r0, [r2, #8]
 80413c0:	f010 0f01 	tst.w	r0, #1
 80413c4:	d113      	bne.n	80413ee <HAL_ADC_Start_DMA+0x4e>
    __HAL_ADC_ENABLE(hadc);
 80413c6:	6890      	ldr	r0, [r2, #8]
 80413c8:	f040 0001 	orr.w	r0, r0, #1
 80413cc:	6090      	str	r0, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80413ce:	4a4b      	ldr	r2, [pc, #300]	; (80414fc <HAL_ADC_Start_DMA+0x15c>)
 80413d0:	6810      	ldr	r0, [r2, #0]
 80413d2:	4a4b      	ldr	r2, [pc, #300]	; (8041500 <HAL_ADC_Start_DMA+0x160>)
 80413d4:	fba2 2000 	umull	r2, r0, r2, r0
 80413d8:	0c80      	lsrs	r0, r0, #18
 80413da:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80413de:	9001      	str	r0, [sp, #4]
    while(counter != 0U)
 80413e0:	e002      	b.n	80413e8 <HAL_ADC_Start_DMA+0x48>
      counter--;
 80413e2:	9c01      	ldr	r4, [sp, #4]
 80413e4:	3c01      	subs	r4, #1
 80413e6:	9401      	str	r4, [sp, #4]
    while(counter != 0U)
 80413e8:	9801      	ldr	r0, [sp, #4]
 80413ea:	2800      	cmp	r0, #0
 80413ec:	d1f9      	bne.n	80413e2 <HAL_ADC_Start_DMA+0x42>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 80413ee:	682a      	ldr	r2, [r5, #0]
 80413f0:	6890      	ldr	r0, [r2, #8]
 80413f2:	f010 0f01 	tst.w	r0, #1
 80413f6:	d079      	beq.n	80414ec <HAL_ADC_Start_DMA+0x14c>
    ADC_STATE_CLR_SET(hadc->State,
 80413f8:	6c28      	ldr	r0, [r5, #64]	; 0x40
 80413fa:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
 80413fe:	f020 0001 	bic.w	r0, r0, #1
 8041402:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8041406:	6428      	str	r0, [r5, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 8041408:	6852      	ldr	r2, [r2, #4]
 804140a:	f412 6f80 	tst.w	r2, #1024	; 0x400
 804140e:	d005      	beq.n	804141c <HAL_ADC_Start_DMA+0x7c>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8041410:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 8041412:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8041416:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 804141a:	642a      	str	r2, [r5, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 804141c:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 804141e:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 8041422:	d036      	beq.n	8041492 <HAL_ADC_Start_DMA+0xf2>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8041424:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8041426:	f022 0206 	bic.w	r2, r2, #6
 804142a:	646a      	str	r2, [r5, #68]	; 0x44
    __HAL_UNLOCK(hadc);   
 804142c:	2200      	movs	r2, #0
 804142e:	f885 203c 	strb.w	r2, [r5, #60]	; 0x3c
    hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8041432:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8041434:	4833      	ldr	r0, [pc, #204]	; (8041504 <HAL_ADC_Start_DMA+0x164>)
 8041436:	63d0      	str	r0, [r2, #60]	; 0x3c
    hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8041438:	6baa      	ldr	r2, [r5, #56]	; 0x38
 804143a:	4833      	ldr	r0, [pc, #204]	; (8041508 <HAL_ADC_Start_DMA+0x168>)
 804143c:	6410      	str	r0, [r2, #64]	; 0x40
    hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 804143e:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8041440:	4832      	ldr	r0, [pc, #200]	; (804150c <HAL_ADC_Start_DMA+0x16c>)
 8041442:	64d0      	str	r0, [r2, #76]	; 0x4c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 8041444:	682a      	ldr	r2, [r5, #0]
 8041446:	f06f 0022 	mvn.w	r0, #34	; 0x22
 804144a:	6010      	str	r0, [r2, #0]
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 804144c:	6828      	ldr	r0, [r5, #0]
 804144e:	6842      	ldr	r2, [r0, #4]
 8041450:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8041454:	6042      	str	r2, [r0, #4]
    hadc->Instance->CR2 |= ADC_CR2_DMA;
 8041456:	6828      	ldr	r0, [r5, #0]
 8041458:	6882      	ldr	r2, [r0, #8]
 804145a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804145e:	6082      	str	r2, [r0, #8]
    HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8041460:	6828      	ldr	r0, [r5, #0]
 8041462:	460a      	mov	r2, r1
 8041464:	f100 014c 	add.w	r1, r0, #76	; 0x4c
 8041468:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 804146a:	f000 fb6f 	bl	8041b4c <HAL_DMA_Start_IT>
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
 804146e:	4b28      	ldr	r3, [pc, #160]	; (8041510 <HAL_ADC_Start_DMA+0x170>)
 8041470:	685b      	ldr	r3, [r3, #4]
 8041472:	f013 0f1f 	tst.w	r3, #31
 8041476:	d127      	bne.n	80414c8 <HAL_ADC_Start_DMA+0x128>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 8041478:	682b      	ldr	r3, [r5, #0]
 804147a:	4a26      	ldr	r2, [pc, #152]	; (8041514 <HAL_ADC_Start_DMA+0x174>)
 804147c:	4293      	cmp	r3, r2
 804147e:	d011      	beq.n	80414a4 <HAL_ADC_Start_DMA+0x104>
 8041480:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8041484:	4293      	cmp	r3, r2
 8041486:	d007      	beq.n	8041498 <HAL_ADC_Start_DMA+0xf8>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 8041488:	4a23      	ldr	r2, [pc, #140]	; (8041518 <HAL_ADC_Start_DMA+0x178>)
 804148a:	4293      	cmp	r3, r2
 804148c:	d014      	beq.n	80414b8 <HAL_ADC_Start_DMA+0x118>
  return HAL_OK;
 804148e:	2000      	movs	r0, #0
 8041490:	e02d      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
      ADC_CLEAR_ERRORCODE(hadc);
 8041492:	2200      	movs	r2, #0
 8041494:	646a      	str	r2, [r5, #68]	; 0x44
 8041496:	e7c9      	b.n	804142c <HAL_ADC_Start_DMA+0x8c>
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
 8041498:	f502 7200 	add.w	r2, r2, #512	; 0x200
 804149c:	6852      	ldr	r2, [r2, #4]
 804149e:	f012 0f1f 	tst.w	r2, #31
 80414a2:	d1f1      	bne.n	8041488 <HAL_ADC_Start_DMA+0xe8>
        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 80414a4:	689a      	ldr	r2, [r3, #8]
 80414a6:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80414aa:	d122      	bne.n	80414f2 <HAL_ADC_Start_DMA+0x152>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80414ac:	689a      	ldr	r2, [r3, #8]
 80414ae:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80414b2:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80414b4:	2000      	movs	r0, #0
 80414b6:	e01a      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
 80414b8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 80414bc:	6852      	ldr	r2, [r2, #4]
 80414be:	f012 0f10 	tst.w	r2, #16
 80414c2:	d0ef      	beq.n	80414a4 <HAL_ADC_Start_DMA+0x104>
  return HAL_OK;
 80414c4:	2000      	movs	r0, #0
 80414c6:	e012      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80414c8:	682b      	ldr	r3, [r5, #0]
 80414ca:	4a12      	ldr	r2, [pc, #72]	; (8041514 <HAL_ADC_Start_DMA+0x174>)
 80414cc:	4293      	cmp	r3, r2
 80414ce:	d001      	beq.n	80414d4 <HAL_ADC_Start_DMA+0x134>
  return HAL_OK;
 80414d0:	2000      	movs	r0, #0
 80414d2:	e00c      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80414d4:	689a      	ldr	r2, [r3, #8]
 80414d6:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80414da:	d10c      	bne.n	80414f6 <HAL_ADC_Start_DMA+0x156>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80414dc:	689a      	ldr	r2, [r3, #8]
 80414de:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80414e2:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 80414e4:	2000      	movs	r0, #0
 80414e6:	e002      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
  __HAL_LOCK(hadc);
 80414e8:	2002      	movs	r0, #2
 80414ea:	e000      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
  return HAL_OK;
 80414ec:	2000      	movs	r0, #0
}
 80414ee:	b003      	add	sp, #12
 80414f0:	bd30      	pop	{r4, r5, pc}
  return HAL_OK;
 80414f2:	2000      	movs	r0, #0
 80414f4:	e7fb      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
 80414f6:	2000      	movs	r0, #0
 80414f8:	e7f9      	b.n	80414ee <HAL_ADC_Start_DMA+0x14e>
 80414fa:	bf00      	nop
 80414fc:	20003874 	.word	0x20003874
 8041500:	431bde83 	.word	0x431bde83
 8041504:	08041691 	.word	0x08041691
 8041508:	0804151f 	.word	0x0804151f
 804150c:	0804167b 	.word	0x0804167b
 8041510:	40012300 	.word	0x40012300
 8041514:	40012000 	.word	0x40012000
 8041518:	40012200 	.word	0x40012200

0804151c <HAL_ADC_ConvHalfCpltCallback>:
}
 804151c:	4770      	bx	lr

0804151e <ADC_DMAHalfConvCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 804151e:	b508      	push	{r3, lr}
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8041520:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8041522:	f7ff fffb 	bl	804151c <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8041526:	bd08      	pop	{r3, pc}

08041528 <HAL_ADC_LevelOutOfWindowCallback>:
}
 8041528:	4770      	bx	lr

0804152a <HAL_ADC_ErrorCallback>:
}
 804152a:	4770      	bx	lr

0804152c <HAL_ADC_IRQHandler>:
{
 804152c:	b538      	push	{r3, r4, r5, lr}
 804152e:	4604      	mov	r4, r0
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
 8041530:	6802      	ldr	r2, [r0, #0]
 8041532:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
 8041534:	6853      	ldr	r3, [r2, #4]
  if(tmp1 && tmp2)
 8041536:	f011 0f02 	tst.w	r1, #2
 804153a:	d02f      	beq.n	804159c <HAL_ADC_IRQHandler+0x70>
 804153c:	f003 0320 	and.w	r3, r3, #32
 8041540:	b363      	cbz	r3, 804159c <HAL_ADC_IRQHandler+0x70>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8041542:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8041544:	f013 0f10 	tst.w	r3, #16
 8041548:	d103      	bne.n	8041552 <HAL_ADC_IRQHandler+0x26>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 804154a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 804154c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8041550:	6403      	str	r3, [r0, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 8041552:	6893      	ldr	r3, [r2, #8]
 8041554:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 8041558:	d119      	bne.n	804158e <HAL_ADC_IRQHandler+0x62>
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 804155a:	7e23      	ldrb	r3, [r4, #24]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 804155c:	b9bb      	cbnz	r3, 804158e <HAL_ADC_IRQHandler+0x62>
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 804155e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 8041560:	f413 0f70 	tst.w	r3, #15728640	; 0xf00000
 8041564:	d003      	beq.n	804156e <HAL_ADC_IRQHandler+0x42>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 8041566:	6893      	ldr	r3, [r2, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 8041568:	f413 6f80 	tst.w	r3, #1024	; 0x400
 804156c:	d10f      	bne.n	804158e <HAL_ADC_IRQHandler+0x62>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 804156e:	6853      	ldr	r3, [r2, #4]
 8041570:	f023 0320 	bic.w	r3, r3, #32
 8041574:	6053      	str	r3, [r2, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8041576:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041578:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 804157c:	6423      	str	r3, [r4, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 804157e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041580:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8041584:	d103      	bne.n	804158e <HAL_ADC_IRQHandler+0x62>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8041586:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041588:	f043 0301 	orr.w	r3, r3, #1
 804158c:	6423      	str	r3, [r4, #64]	; 0x40
    HAL_ADC_ConvCpltCallback(hadc);
 804158e:	4620      	mov	r0, r4
 8041590:	f00e fe98 	bl	80502c4 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 8041594:	6823      	ldr	r3, [r4, #0]
 8041596:	f06f 0212 	mvn.w	r2, #18
 804159a:	601a      	str	r2, [r3, #0]
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
 804159c:	6823      	ldr	r3, [r4, #0]
 804159e:	6819      	ldr	r1, [r3, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
 80415a0:	685a      	ldr	r2, [r3, #4]
 80415a2:	f002 0280 	and.w	r2, r2, #128	; 0x80
  if(tmp1 && tmp2)
 80415a6:	f011 0f04 	tst.w	r1, #4
 80415aa:	d036      	beq.n	804161a <HAL_ADC_IRQHandler+0xee>
 80415ac:	2a00      	cmp	r2, #0
 80415ae:	d034      	beq.n	804161a <HAL_ADC_IRQHandler+0xee>
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80415b0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80415b2:	f012 0f10 	tst.w	r2, #16
 80415b6:	d103      	bne.n	80415c0 <HAL_ADC_IRQHandler+0x94>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80415b8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80415ba:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80415be:	6422      	str	r2, [r4, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80415c0:	689a      	ldr	r2, [r3, #8]
 80415c2:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 80415c6:	d121      	bne.n	804160c <HAL_ADC_IRQHandler+0xe0>
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80415c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
 80415ca:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 80415ce:	d003      	beq.n	80415d8 <HAL_ADC_IRQHandler+0xac>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80415d0:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
 80415d2:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80415d6:	d119      	bne.n	804160c <HAL_ADC_IRQHandler+0xe0>
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 80415d8:	685a      	ldr	r2, [r3, #4]
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
 80415da:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80415de:	d115      	bne.n	804160c <HAL_ADC_IRQHandler+0xe0>
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 80415e0:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
 80415e2:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80415e6:	d111      	bne.n	804160c <HAL_ADC_IRQHandler+0xe0>
        (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
 80415e8:	7e22      	ldrb	r2, [r4, #24]
        (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
 80415ea:	b97a      	cbnz	r2, 804160c <HAL_ADC_IRQHandler+0xe0>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 80415ec:	685a      	ldr	r2, [r3, #4]
 80415ee:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80415f2:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 80415f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80415f6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80415fa:	6423      	str	r3, [r4, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 80415fc:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80415fe:	f413 7f80 	tst.w	r3, #256	; 0x100
 8041602:	d103      	bne.n	804160c <HAL_ADC_IRQHandler+0xe0>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8041604:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041606:	f043 0301 	orr.w	r3, r3, #1
 804160a:	6423      	str	r3, [r4, #64]	; 0x40
      HAL_ADCEx_InjectedConvCpltCallback(hadc);
 804160c:	4620      	mov	r0, r4
 804160e:	f000 f94b 	bl	80418a8 <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
 8041612:	6823      	ldr	r3, [r4, #0]
 8041614:	f06f 020c 	mvn.w	r2, #12
 8041618:	601a      	str	r2, [r3, #0]
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
 804161a:	6822      	ldr	r2, [r4, #0]
 804161c:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
 804161e:	6853      	ldr	r3, [r2, #4]
 8041620:	f003 0340 	and.w	r3, r3, #64	; 0x40
  if(tmp1 && tmp2)
 8041624:	f011 0f01 	tst.w	r1, #1
 8041628:	d004      	beq.n	8041634 <HAL_ADC_IRQHandler+0x108>
 804162a:	b11b      	cbz	r3, 8041634 <HAL_ADC_IRQHandler+0x108>
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
 804162c:	6813      	ldr	r3, [r2, #0]
 804162e:	f013 0f01 	tst.w	r3, #1
 8041632:	d109      	bne.n	8041648 <HAL_ADC_IRQHandler+0x11c>
  tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
 8041634:	6822      	ldr	r2, [r4, #0]
 8041636:	6811      	ldr	r1, [r2, #0]
  tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
 8041638:	6853      	ldr	r3, [r2, #4]
 804163a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  if(tmp1 && tmp2)
 804163e:	f011 0f20 	tst.w	r1, #32
 8041642:	d000      	beq.n	8041646 <HAL_ADC_IRQHandler+0x11a>
 8041644:	b963      	cbnz	r3, 8041660 <HAL_ADC_IRQHandler+0x134>
}
 8041646:	bd38      	pop	{r3, r4, r5, pc}
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8041648:	6c23      	ldr	r3, [r4, #64]	; 0x40
 804164a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 804164e:	6423      	str	r3, [r4, #64]	; 0x40
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 8041650:	4620      	mov	r0, r4
 8041652:	f7ff ff69 	bl	8041528 <HAL_ADC_LevelOutOfWindowCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 8041656:	6823      	ldr	r3, [r4, #0]
 8041658:	f06f 0201 	mvn.w	r2, #1
 804165c:	601a      	str	r2, [r3, #0]
 804165e:	e7e9      	b.n	8041634 <HAL_ADC_IRQHandler+0x108>
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8041660:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8041662:	f043 0302 	orr.w	r3, r3, #2
 8041666:	6463      	str	r3, [r4, #68]	; 0x44
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8041668:	f06f 0520 	mvn.w	r5, #32
 804166c:	6015      	str	r5, [r2, #0]
      HAL_ADC_ErrorCallback(hadc);
 804166e:	4620      	mov	r0, r4
 8041670:	f7ff ff5b 	bl	804152a <HAL_ADC_ErrorCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8041674:	6823      	ldr	r3, [r4, #0]
 8041676:	601d      	str	r5, [r3, #0]
}
 8041678:	e7e5      	b.n	8041646 <HAL_ADC_IRQHandler+0x11a>

0804167a <ADC_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
{
 804167a:	b508      	push	{r3, lr}
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 804167c:	6b80      	ldr	r0, [r0, #56]	; 0x38
  hadc->State= HAL_ADC_STATE_ERROR_DMA;
 804167e:	2340      	movs	r3, #64	; 0x40
 8041680:	6403      	str	r3, [r0, #64]	; 0x40
  /* Set ADC error code to DMA error */
  hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
 8041682:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8041684:	f043 0304 	orr.w	r3, r3, #4
 8041688:	6443      	str	r3, [r0, #68]	; 0x44
   /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 804168a:	f7ff ff4e 	bl	804152a <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 804168e:	bd08      	pop	{r3, pc}

08041690 <ADC_DMAConvCplt>:
{
 8041690:	b508      	push	{r3, lr}
 8041692:	4603      	mov	r3, r0
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8041694:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 8041696:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8041698:	f012 0f50 	tst.w	r2, #80	; 0x50
 804169c:	d125      	bne.n	80416ea <ADC_DMAConvCplt+0x5a>
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 804169e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416a0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80416a4:	6403      	str	r3, [r0, #64]	; 0x40
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 80416a6:	6803      	ldr	r3, [r0, #0]
 80416a8:	689a      	ldr	r2, [r3, #8]
 80416aa:	f012 5f40 	tst.w	r2, #805306368	; 0x30000000
 80416ae:	d119      	bne.n	80416e4 <ADC_DMAConvCplt+0x54>
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 80416b0:	7e02      	ldrb	r2, [r0, #24]
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 80416b2:	b9ba      	cbnz	r2, 80416e4 <ADC_DMAConvCplt+0x54>
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 80416b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
       (hadc->Init.ContinuousConvMode == DISABLE)            &&
 80416b6:	f412 0f70 	tst.w	r2, #15728640	; 0xf00000
 80416ba:	d003      	beq.n	80416c4 <ADC_DMAConvCplt+0x34>
        HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 80416bc:	689a      	ldr	r2, [r3, #8]
       (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
 80416be:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80416c2:	d10f      	bne.n	80416e4 <ADC_DMAConvCplt+0x54>
      __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 80416c4:	685a      	ldr	r2, [r3, #4]
 80416c6:	f022 0220 	bic.w	r2, r2, #32
 80416ca:	605a      	str	r2, [r3, #4]
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 80416cc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416ce:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80416d2:	6403      	str	r3, [r0, #64]	; 0x40
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80416d4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416d6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80416da:	d103      	bne.n	80416e4 <ADC_DMAConvCplt+0x54>
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80416dc:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80416de:	f043 0301 	orr.w	r3, r3, #1
 80416e2:	6403      	str	r3, [r0, #64]	; 0x40
    HAL_ADC_ConvCpltCallback(hadc);
 80416e4:	f00e fdee 	bl	80502c4 <HAL_ADC_ConvCpltCallback>
}
 80416e8:	bd08      	pop	{r3, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 80416ea:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80416ec:	f012 0f10 	tst.w	r2, #16
 80416f0:	d104      	bne.n	80416fc <ADC_DMAConvCplt+0x6c>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 80416f2:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80416f4:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 80416f6:	4618      	mov	r0, r3
 80416f8:	4790      	blx	r2
}
 80416fa:	e7f5      	b.n	80416e8 <ADC_DMAConvCplt+0x58>
      HAL_ADC_ErrorCallback(hadc);
 80416fc:	f7ff ff15 	bl	804152a <HAL_ADC_ErrorCallback>
 8041700:	e7f2      	b.n	80416e8 <ADC_DMAConvCplt+0x58>
	...

08041704 <HAL_ADC_ConfigChannel>:
{
 8041704:	b430      	push	{r4, r5}
 8041706:	b082      	sub	sp, #8
  __IO uint32_t counter = 0U;
 8041708:	2300      	movs	r3, #0
 804170a:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hadc);
 804170c:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8041710:	2b01      	cmp	r3, #1
 8041712:	f000 80bd 	beq.w	8041890 <HAL_ADC_ConfigChannel+0x18c>
 8041716:	2301      	movs	r3, #1
 8041718:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  if (sConfig->Channel > ADC_CHANNEL_9)
 804171c:	680b      	ldr	r3, [r1, #0]
 804171e:	2b09      	cmp	r3, #9
 8041720:	d93e      	bls.n	80417a0 <HAL_ADC_ConfigChannel+0x9c>
    hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8041722:	6805      	ldr	r5, [r0, #0]
 8041724:	68ea      	ldr	r2, [r5, #12]
 8041726:	b29b      	uxth	r3, r3
 8041728:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 804172c:	3b1e      	subs	r3, #30
 804172e:	2407      	movs	r4, #7
 8041730:	fa04 f303 	lsl.w	r3, r4, r3
 8041734:	ea22 0303 	bic.w	r3, r2, r3
 8041738:	60eb      	str	r3, [r5, #12]
    hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 804173a:	6805      	ldr	r5, [r0, #0]
 804173c:	68ea      	ldr	r2, [r5, #12]
 804173e:	688c      	ldr	r4, [r1, #8]
 8041740:	880b      	ldrh	r3, [r1, #0]
 8041742:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8041746:	3b1e      	subs	r3, #30
 8041748:	fa04 f303 	lsl.w	r3, r4, r3
 804174c:	4313      	orrs	r3, r2
 804174e:	60eb      	str	r3, [r5, #12]
  if (sConfig->Rank < 7U)
 8041750:	684b      	ldr	r3, [r1, #4]
 8041752:	2b06      	cmp	r3, #6
 8041754:	d83a      	bhi.n	80417cc <HAL_ADC_ConfigChannel+0xc8>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8041756:	6805      	ldr	r5, [r0, #0]
 8041758:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 804175a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804175e:	3b05      	subs	r3, #5
 8041760:	241f      	movs	r4, #31
 8041762:	fa04 f303 	lsl.w	r3, r4, r3
 8041766:	ea22 0303 	bic.w	r3, r2, r3
 804176a:	636b      	str	r3, [r5, #52]	; 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 804176c:	6805      	ldr	r5, [r0, #0]
 804176e:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8041770:	684b      	ldr	r3, [r1, #4]
 8041772:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8041776:	3b05      	subs	r3, #5
 8041778:	880c      	ldrh	r4, [r1, #0]
 804177a:	fa04 f303 	lsl.w	r3, r4, r3
 804177e:	4313      	orrs	r3, r2
 8041780:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8041782:	6802      	ldr	r2, [r0, #0]
 8041784:	4b43      	ldr	r3, [pc, #268]	; (8041894 <HAL_ADC_ConfigChannel+0x190>)
 8041786:	429a      	cmp	r2, r3
 8041788:	d050      	beq.n	804182c <HAL_ADC_ConfigChannel+0x128>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 804178a:	6802      	ldr	r2, [r0, #0]
 804178c:	4b41      	ldr	r3, [pc, #260]	; (8041894 <HAL_ADC_ConfigChannel+0x190>)
 804178e:	429a      	cmp	r2, r3
 8041790:	d059      	beq.n	8041846 <HAL_ADC_ConfigChannel+0x142>
  __HAL_UNLOCK(hadc);
 8041792:	2300      	movs	r3, #0
 8041794:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8041798:	4618      	mov	r0, r3
}
 804179a:	b002      	add	sp, #8
 804179c:	bc30      	pop	{r4, r5}
 804179e:	4770      	bx	lr
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 80417a0:	6805      	ldr	r5, [r0, #0]
 80417a2:	692a      	ldr	r2, [r5, #16]
 80417a4:	b29b      	uxth	r3, r3
 80417a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80417aa:	2407      	movs	r4, #7
 80417ac:	fa04 f303 	lsl.w	r3, r4, r3
 80417b0:	ea22 0303 	bic.w	r3, r2, r3
 80417b4:	612b      	str	r3, [r5, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 80417b6:	6805      	ldr	r5, [r0, #0]
 80417b8:	692a      	ldr	r2, [r5, #16]
 80417ba:	688c      	ldr	r4, [r1, #8]
 80417bc:	880b      	ldrh	r3, [r1, #0]
 80417be:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80417c2:	fa04 f303 	lsl.w	r3, r4, r3
 80417c6:	4313      	orrs	r3, r2
 80417c8:	612b      	str	r3, [r5, #16]
 80417ca:	e7c1      	b.n	8041750 <HAL_ADC_ConfigChannel+0x4c>
  else if (sConfig->Rank < 13U)
 80417cc:	2b0c      	cmp	r3, #12
 80417ce:	d816      	bhi.n	80417fe <HAL_ADC_ConfigChannel+0xfa>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 80417d0:	6805      	ldr	r5, [r0, #0]
 80417d2:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80417d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80417d8:	3b23      	subs	r3, #35	; 0x23
 80417da:	241f      	movs	r4, #31
 80417dc:	fa04 f303 	lsl.w	r3, r4, r3
 80417e0:	ea22 0303 	bic.w	r3, r2, r3
 80417e4:	632b      	str	r3, [r5, #48]	; 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80417e6:	6805      	ldr	r5, [r0, #0]
 80417e8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80417ea:	684b      	ldr	r3, [r1, #4]
 80417ec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80417f0:	3b23      	subs	r3, #35	; 0x23
 80417f2:	880c      	ldrh	r4, [r1, #0]
 80417f4:	fa04 f303 	lsl.w	r3, r4, r3
 80417f8:	4313      	orrs	r3, r2
 80417fa:	632b      	str	r3, [r5, #48]	; 0x30
 80417fc:	e7c1      	b.n	8041782 <HAL_ADC_ConfigChannel+0x7e>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 80417fe:	6805      	ldr	r5, [r0, #0]
 8041800:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8041802:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8041806:	3b41      	subs	r3, #65	; 0x41
 8041808:	241f      	movs	r4, #31
 804180a:	fa04 f303 	lsl.w	r3, r4, r3
 804180e:	ea22 0303 	bic.w	r3, r2, r3
 8041812:	62eb      	str	r3, [r5, #44]	; 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8041814:	6805      	ldr	r5, [r0, #0]
 8041816:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8041818:	684b      	ldr	r3, [r1, #4]
 804181a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804181e:	3b41      	subs	r3, #65	; 0x41
 8041820:	880c      	ldrh	r4, [r1, #0]
 8041822:	fa04 f303 	lsl.w	r3, r4, r3
 8041826:	4313      	orrs	r3, r2
 8041828:	62eb      	str	r3, [r5, #44]	; 0x2c
 804182a:	e7aa      	b.n	8041782 <HAL_ADC_ConfigChannel+0x7e>
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 804182c:	680b      	ldr	r3, [r1, #0]
 804182e:	2b12      	cmp	r3, #18
 8041830:	d1ab      	bne.n	804178a <HAL_ADC_ConfigChannel+0x86>
      tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
 8041832:	4b19      	ldr	r3, [pc, #100]	; (8041898 <HAL_ADC_ConfigChannel+0x194>)
 8041834:	685a      	ldr	r2, [r3, #4]
 8041836:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 804183a:	605a      	str	r2, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_VBATE;
 804183c:	685a      	ldr	r2, [r3, #4]
 804183e:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8041842:	605a      	str	r2, [r3, #4]
 8041844:	e7a1      	b.n	804178a <HAL_ADC_ConfigChannel+0x86>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 8041846:	680b      	ldr	r3, [r1, #0]
 8041848:	4a14      	ldr	r2, [pc, #80]	; (804189c <HAL_ADC_ConfigChannel+0x198>)
 804184a:	4293      	cmp	r3, r2
 804184c:	d001      	beq.n	8041852 <HAL_ADC_ConfigChannel+0x14e>
 804184e:	2b11      	cmp	r3, #17
 8041850:	d19f      	bne.n	8041792 <HAL_ADC_ConfigChannel+0x8e>
      tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
 8041852:	4b11      	ldr	r3, [pc, #68]	; (8041898 <HAL_ADC_ConfigChannel+0x194>)
 8041854:	685a      	ldr	r2, [r3, #4]
 8041856:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 804185a:	605a      	str	r2, [r3, #4]
    tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
 804185c:	685a      	ldr	r2, [r3, #4]
 804185e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8041862:	605a      	str	r2, [r3, #4]
    if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8041864:	680a      	ldr	r2, [r1, #0]
 8041866:	4b0d      	ldr	r3, [pc, #52]	; (804189c <HAL_ADC_ConfigChannel+0x198>)
 8041868:	429a      	cmp	r2, r3
 804186a:	d192      	bne.n	8041792 <HAL_ADC_ConfigChannel+0x8e>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 804186c:	4b0c      	ldr	r3, [pc, #48]	; (80418a0 <HAL_ADC_ConfigChannel+0x19c>)
 804186e:	681b      	ldr	r3, [r3, #0]
 8041870:	4a0c      	ldr	r2, [pc, #48]	; (80418a4 <HAL_ADC_ConfigChannel+0x1a0>)
 8041872:	fba2 2303 	umull	r2, r3, r2, r3
 8041876:	0c9b      	lsrs	r3, r3, #18
 8041878:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 804187c:	005b      	lsls	r3, r3, #1
 804187e:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 8041880:	e002      	b.n	8041888 <HAL_ADC_ConfigChannel+0x184>
        counter--;
 8041882:	9b01      	ldr	r3, [sp, #4]
 8041884:	3b01      	subs	r3, #1
 8041886:	9301      	str	r3, [sp, #4]
      while(counter != 0U)
 8041888:	9b01      	ldr	r3, [sp, #4]
 804188a:	2b00      	cmp	r3, #0
 804188c:	d1f9      	bne.n	8041882 <HAL_ADC_ConfigChannel+0x17e>
 804188e:	e780      	b.n	8041792 <HAL_ADC_ConfigChannel+0x8e>
  __HAL_LOCK(hadc);
 8041890:	2002      	movs	r0, #2
 8041892:	e782      	b.n	804179a <HAL_ADC_ConfigChannel+0x96>
 8041894:	40012000 	.word	0x40012000
 8041898:	40012300 	.word	0x40012300
 804189c:	10000012 	.word	0x10000012
 80418a0:	20003874 	.word	0x20003874
 80418a4:	431bde83 	.word	0x431bde83

080418a8 <HAL_ADCEx_InjectedConvCpltCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
   */
}
 80418a8:	4770      	bx	lr
	...

080418ac <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80418ac:	4a07      	ldr	r2, [pc, #28]	; (80418cc <HAL_NVIC_SetPriorityGrouping+0x20>)
 80418ae:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80418b0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80418b4:	041b      	lsls	r3, r3, #16
 80418b6:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80418b8:	0200      	lsls	r0, r0, #8
 80418ba:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80418be:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 80418c0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80418c4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80418c8:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80418ca:	4770      	bx	lr
 80418cc:	e000ed00 	.word	0xe000ed00

080418d0 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80418d0:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80418d2:	4b17      	ldr	r3, [pc, #92]	; (8041930 <HAL_NVIC_SetPriority+0x60>)
 80418d4:	68db      	ldr	r3, [r3, #12]
 80418d6:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80418da:	f1c3 0407 	rsb	r4, r3, #7
 80418de:	2c04      	cmp	r4, #4
 80418e0:	bf28      	it	cs
 80418e2:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80418e4:	1d1d      	adds	r5, r3, #4
 80418e6:	2d06      	cmp	r5, #6
 80418e8:	d918      	bls.n	804191c <HAL_NVIC_SetPriority+0x4c>
 80418ea:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80418ec:	f04f 35ff 	mov.w	r5, #4294967295
 80418f0:	fa05 f404 	lsl.w	r4, r5, r4
 80418f4:	ea21 0104 	bic.w	r1, r1, r4
 80418f8:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80418fa:	fa05 f303 	lsl.w	r3, r5, r3
 80418fe:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8041902:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8041904:	2800      	cmp	r0, #0
 8041906:	db0b      	blt.n	8041920 <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8041908:	0109      	lsls	r1, r1, #4
 804190a:	b2c9      	uxtb	r1, r1
 804190c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8041910:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8041914:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8041918:	bc30      	pop	{r4, r5}
 804191a:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804191c:	2300      	movs	r3, #0
 804191e:	e7e5      	b.n	80418ec <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8041920:	f000 000f 	and.w	r0, r0, #15
 8041924:	0109      	lsls	r1, r1, #4
 8041926:	b2c9      	uxtb	r1, r1
 8041928:	4b02      	ldr	r3, [pc, #8]	; (8041934 <HAL_NVIC_SetPriority+0x64>)
 804192a:	5419      	strb	r1, [r3, r0]
 804192c:	e7f4      	b.n	8041918 <HAL_NVIC_SetPriority+0x48>
 804192e:	bf00      	nop
 8041930:	e000ed00 	.word	0xe000ed00
 8041934:	e000ed14 	.word	0xe000ed14

08041938 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8041938:	2800      	cmp	r0, #0
 804193a:	db07      	blt.n	804194c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 804193c:	f000 021f 	and.w	r2, r0, #31
 8041940:	0940      	lsrs	r0, r0, #5
 8041942:	2301      	movs	r3, #1
 8041944:	4093      	lsls	r3, r2
 8041946:	4a02      	ldr	r2, [pc, #8]	; (8041950 <HAL_NVIC_EnableIRQ+0x18>)
 8041948:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 804194c:	4770      	bx	lr
 804194e:	bf00      	nop
 8041950:	e000e100 	.word	0xe000e100

08041954 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8041954:	3801      	subs	r0, #1
 8041956:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 804195a:	d20a      	bcs.n	8041972 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 804195c:	4b06      	ldr	r3, [pc, #24]	; (8041978 <HAL_SYSTICK_Config+0x24>)
 804195e:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8041960:	4a06      	ldr	r2, [pc, #24]	; (804197c <HAL_SYSTICK_Config+0x28>)
 8041962:	21f0      	movs	r1, #240	; 0xf0
 8041964:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8041968:	2000      	movs	r0, #0
 804196a:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 804196c:	2207      	movs	r2, #7
 804196e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8041970:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8041972:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8041974:	4770      	bx	lr
 8041976:	bf00      	nop
 8041978:	e000e010 	.word	0xe000e010
 804197c:	e000ed00 	.word	0xe000ed00

08041980 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8041980:	b430      	push	{r4, r5}
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8041982:	6805      	ldr	r5, [r0, #0]
 8041984:	682c      	ldr	r4, [r5, #0]
 8041986:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
 804198a:	602c      	str	r4, [r5, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 804198c:	6804      	ldr	r4, [r0, #0]
 804198e:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8041990:	6883      	ldr	r3, [r0, #8]
 8041992:	2b40      	cmp	r3, #64	; 0x40
 8041994:	d005      	beq.n	80419a2 <DMA_SetConfig+0x22>
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Stream source address */
    hdma->Instance->PAR = SrcAddress;
 8041996:	6803      	ldr	r3, [r0, #0]
 8041998:	6099      	str	r1, [r3, #8]

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
 804199a:	6803      	ldr	r3, [r0, #0]
 804199c:	60da      	str	r2, [r3, #12]
  }
}
 804199e:	bc30      	pop	{r4, r5}
 80419a0:	4770      	bx	lr
    hdma->Instance->PAR = DstAddress;
 80419a2:	6803      	ldr	r3, [r0, #0]
 80419a4:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = SrcAddress;
 80419a6:	6803      	ldr	r3, [r0, #0]
 80419a8:	60d9      	str	r1, [r3, #12]
 80419aa:	e7f8      	b.n	804199e <DMA_SetConfig+0x1e>

080419ac <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80419ac:	b410      	push	{r4}
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 80419ae:	6803      	ldr	r3, [r0, #0]
 80419b0:	b2d9      	uxtb	r1, r3
 80419b2:	3910      	subs	r1, #16
 80419b4:	4a0c      	ldr	r2, [pc, #48]	; (80419e8 <DMA_CalcBaseAndBitshift+0x3c>)
 80419b6:	fba2 4201 	umull	r4, r2, r2, r1
 80419ba:	0912      	lsrs	r2, r2, #4
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 80419bc:	4c0b      	ldr	r4, [pc, #44]	; (80419ec <DMA_CalcBaseAndBitshift+0x40>)
 80419be:	5ca2      	ldrb	r2, [r4, r2]
 80419c0:	65c2      	str	r2, [r0, #92]	; 0x5c
  
  if (stream_number > 3U)
 80419c2:	295f      	cmp	r1, #95	; 0x5f
 80419c4:	d909      	bls.n	80419da <DMA_CalcBaseAndBitshift+0x2e>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 80419c6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 80419ca:	f023 0303 	bic.w	r3, r3, #3
 80419ce:	3304      	adds	r3, #4
 80419d0:	6583      	str	r3, [r0, #88]	; 0x58
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 80419d2:	6d80      	ldr	r0, [r0, #88]	; 0x58
 80419d4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80419d8:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 80419da:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 80419de:	f023 0303 	bic.w	r3, r3, #3
 80419e2:	6583      	str	r3, [r0, #88]	; 0x58
 80419e4:	e7f5      	b.n	80419d2 <DMA_CalcBaseAndBitshift+0x26>
 80419e6:	bf00      	nop
 80419e8:	aaaaaaab 	.word	0xaaaaaaab
 80419ec:	080584c8 	.word	0x080584c8

080419f0 <DMA_CheckFifoParam>:
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
 80419f0:	6a83      	ldr	r3, [r0, #40]	; 0x28
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80419f2:	6982      	ldr	r2, [r0, #24]
 80419f4:	b992      	cbnz	r2, 8041a1c <DMA_CheckFifoParam+0x2c>
  {
    switch (tmp)
 80419f6:	2b01      	cmp	r3, #1
 80419f8:	d00a      	beq.n	8041a10 <DMA_CheckFifoParam+0x20>
 80419fa:	2b02      	cmp	r3, #2
 80419fc:	d002      	beq.n	8041a04 <DMA_CheckFifoParam+0x14>
 80419fe:	b10b      	cbz	r3, 8041a04 <DMA_CheckFifoParam+0x14>
 8041a00:	2000      	movs	r0, #0
 8041a02:	4770      	bx	lr
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a04:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a06:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a0a:	d128      	bne.n	8041a5e <DMA_CheckFifoParam+0x6e>
  HAL_StatusTypeDef status = HAL_OK;
 8041a0c:	2000      	movs	r0, #0
 8041a0e:	4770      	bx	lr
      {
        status = HAL_ERROR;
      }
      break;
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8041a10:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a12:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8041a16:	d024      	beq.n	8041a62 <DMA_CheckFifoParam+0x72>
  HAL_StatusTypeDef status = HAL_OK;
 8041a18:	2000      	movs	r0, #0
 8041a1a:	4770      	bx	lr
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8041a1c:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 8041a20:	d009      	beq.n	8041a36 <DMA_CheckFifoParam+0x46>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8041a22:	2b02      	cmp	r3, #2
 8041a24:	d925      	bls.n	8041a72 <DMA_CheckFifoParam+0x82>
 8041a26:	2b03      	cmp	r3, #3
 8041a28:	d125      	bne.n	8041a76 <DMA_CheckFifoParam+0x86>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a2a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a2c:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a30:	d123      	bne.n	8041a7a <DMA_CheckFifoParam+0x8a>
  HAL_StatusTypeDef status = HAL_OK;
 8041a32:	2000      	movs	r0, #0
 8041a34:	4770      	bx	lr
    switch (tmp)
 8041a36:	2b03      	cmp	r3, #3
 8041a38:	d803      	bhi.n	8041a42 <DMA_CheckFifoParam+0x52>
 8041a3a:	e8df f003 	tbb	[pc, r3]
 8041a3e:	0414      	.short	0x0414
 8041a40:	0a14      	.short	0x0a14
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8041a42:	2000      	movs	r0, #0
 8041a44:	4770      	bx	lr
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8041a46:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a48:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8041a4c:	d10d      	bne.n	8041a6a <DMA_CheckFifoParam+0x7a>
  HAL_StatusTypeDef status = HAL_OK;
 8041a4e:	2000      	movs	r0, #0
 8041a50:	4770      	bx	lr
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8041a52:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8041a54:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8041a58:	d009      	beq.n	8041a6e <DMA_CheckFifoParam+0x7e>
  HAL_StatusTypeDef status = HAL_OK;
 8041a5a:	2000      	movs	r0, #0
 8041a5c:	4770      	bx	lr
        status = HAL_ERROR;
 8041a5e:	2001      	movs	r0, #1
 8041a60:	4770      	bx	lr
        status = HAL_ERROR;
 8041a62:	2001      	movs	r0, #1
 8041a64:	4770      	bx	lr
      status = HAL_ERROR;
 8041a66:	2001      	movs	r0, #1
 8041a68:	4770      	bx	lr
        status = HAL_ERROR;
 8041a6a:	2001      	movs	r0, #1
 8041a6c:	4770      	bx	lr
        status = HAL_ERROR;
 8041a6e:	2001      	movs	r0, #1
 8041a70:	4770      	bx	lr
      status = HAL_ERROR;
 8041a72:	2001      	movs	r0, #1
 8041a74:	4770      	bx	lr
    switch (tmp)
 8041a76:	2000      	movs	r0, #0
 8041a78:	4770      	bx	lr
      {
        status = HAL_ERROR;
 8041a7a:	2001      	movs	r0, #1
      break;
    }
  } 
  
  return status; 
}
 8041a7c:	4770      	bx	lr
	...

08041a80 <HAL_DMA_Init>:
{
 8041a80:	b570      	push	{r4, r5, r6, lr}
 8041a82:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8041a84:	f7ff fb0c 	bl	80410a0 <HAL_GetTick>
  if(hdma == NULL)
 8041a88:	2c00      	cmp	r4, #0
 8041a8a:	d05b      	beq.n	8041b44 <HAL_DMA_Init+0xc4>
 8041a8c:	4605      	mov	r5, r0
  __HAL_UNLOCK(hdma);
 8041a8e:	2300      	movs	r3, #0
 8041a90:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_BUSY;
 8041a94:	2302      	movs	r3, #2
 8041a96:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 8041a9a:	6822      	ldr	r2, [r4, #0]
 8041a9c:	6813      	ldr	r3, [r2, #0]
 8041a9e:	f023 0301 	bic.w	r3, r3, #1
 8041aa2:	6013      	str	r3, [r2, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8041aa4:	6823      	ldr	r3, [r4, #0]
 8041aa6:	681a      	ldr	r2, [r3, #0]
 8041aa8:	f012 0f01 	tst.w	r2, #1
 8041aac:	d00a      	beq.n	8041ac4 <HAL_DMA_Init+0x44>
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8041aae:	f7ff faf7 	bl	80410a0 <HAL_GetTick>
 8041ab2:	1b43      	subs	r3, r0, r5
 8041ab4:	2b05      	cmp	r3, #5
 8041ab6:	d9f5      	bls.n	8041aa4 <HAL_DMA_Init+0x24>
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8041ab8:	2320      	movs	r3, #32
 8041aba:	6563      	str	r3, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8041abc:	2003      	movs	r0, #3
 8041abe:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
}
 8041ac2:	bd70      	pop	{r4, r5, r6, pc}
  tmp = hdma->Instance->CR;
 8041ac4:	681a      	ldr	r2, [r3, #0]
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8041ac6:	4820      	ldr	r0, [pc, #128]	; (8041b48 <HAL_DMA_Init+0xc8>)
 8041ac8:	4010      	ands	r0, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041aca:	6861      	ldr	r1, [r4, #4]
 8041acc:	68a2      	ldr	r2, [r4, #8]
 8041ace:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041ad0:	68e1      	ldr	r1, [r4, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041ad2:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041ad4:	6921      	ldr	r1, [r4, #16]
 8041ad6:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041ad8:	6961      	ldr	r1, [r4, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8041ada:	430a      	orrs	r2, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041adc:	69a1      	ldr	r1, [r4, #24]
 8041ade:	430a      	orrs	r2, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8041ae0:	69e1      	ldr	r1, [r4, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8041ae2:	430a      	orrs	r2, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8041ae4:	6a21      	ldr	r1, [r4, #32]
 8041ae6:	430a      	orrs	r2, r1
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8041ae8:	4302      	orrs	r2, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8041aea:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8041aec:	2904      	cmp	r1, #4
 8041aee:	d01e      	beq.n	8041b2e <HAL_DMA_Init+0xae>
  hdma->Instance->CR = tmp;  
 8041af0:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 8041af2:	6826      	ldr	r6, [r4, #0]
 8041af4:	6975      	ldr	r5, [r6, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8041af6:	f025 0507 	bic.w	r5, r5, #7
  tmp |= hdma->Init.FIFOMode;
 8041afa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8041afc:	431d      	orrs	r5, r3
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8041afe:	2b04      	cmp	r3, #4
 8041b00:	d107      	bne.n	8041b12 <HAL_DMA_Init+0x92>
    tmp |= hdma->Init.FIFOThreshold;
 8041b02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8041b04:	431d      	orrs	r5, r3
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8041b06:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8041b08:	b11b      	cbz	r3, 8041b12 <HAL_DMA_Init+0x92>
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8041b0a:	4620      	mov	r0, r4
 8041b0c:	f7ff ff70 	bl	80419f0 <DMA_CheckFifoParam>
 8041b10:	b990      	cbnz	r0, 8041b38 <HAL_DMA_Init+0xb8>
  hdma->Instance->FCR = tmp;
 8041b12:	6175      	str	r5, [r6, #20]
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8041b14:	4620      	mov	r0, r4
 8041b16:	f7ff ff49 	bl	80419ac <DMA_CalcBaseAndBitshift>
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041b1a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041b1c:	233f      	movs	r3, #63	; 0x3f
 8041b1e:	4093      	lsls	r3, r2
 8041b20:	6083      	str	r3, [r0, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8041b22:	2000      	movs	r0, #0
 8041b24:	6560      	str	r0, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 8041b26:	2301      	movs	r3, #1
 8041b28:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  return HAL_OK;
 8041b2c:	e7c9      	b.n	8041ac2 <HAL_DMA_Init+0x42>
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8041b2e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8041b30:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8041b32:	4301      	orrs	r1, r0
 8041b34:	430a      	orrs	r2, r1
 8041b36:	e7db      	b.n	8041af0 <HAL_DMA_Init+0x70>
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8041b38:	2340      	movs	r3, #64	; 0x40
 8041b3a:	6563      	str	r3, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 8041b3c:	2001      	movs	r0, #1
 8041b3e:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        return HAL_ERROR; 
 8041b42:	e7be      	b.n	8041ac2 <HAL_DMA_Init+0x42>
    return HAL_ERROR;
 8041b44:	2001      	movs	r0, #1
 8041b46:	e7bc      	b.n	8041ac2 <HAL_DMA_Init+0x42>
 8041b48:	f010803f 	.word	0xf010803f

08041b4c <HAL_DMA_Start_IT>:
{
 8041b4c:	b538      	push	{r3, r4, r5, lr}
 8041b4e:	4604      	mov	r4, r0
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8041b50:	6d85      	ldr	r5, [r0, #88]	; 0x58
  __HAL_LOCK(hdma);
 8041b52:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
 8041b56:	2801      	cmp	r0, #1
 8041b58:	d030      	beq.n	8041bbc <HAL_DMA_Start_IT+0x70>
 8041b5a:	2001      	movs	r0, #1
 8041b5c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8041b60:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
 8041b64:	b2c0      	uxtb	r0, r0
 8041b66:	2801      	cmp	r0, #1
 8041b68:	d004      	beq.n	8041b74 <HAL_DMA_Start_IT+0x28>
    __HAL_UNLOCK(hdma);	  
 8041b6a:	2300      	movs	r3, #0
 8041b6c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    status = HAL_BUSY;
 8041b70:	2002      	movs	r0, #2
}
 8041b72:	bd38      	pop	{r3, r4, r5, pc}
    hdma->State = HAL_DMA_STATE_BUSY;
 8041b74:	2002      	movs	r0, #2
 8041b76:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8041b7a:	2000      	movs	r0, #0
 8041b7c:	6560      	str	r0, [r4, #84]	; 0x54
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8041b7e:	4620      	mov	r0, r4
 8041b80:	f7ff fefe 	bl	8041980 <DMA_SetConfig>
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041b84:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041b86:	233f      	movs	r3, #63	; 0x3f
 8041b88:	4093      	lsls	r3, r2
 8041b8a:	60ab      	str	r3, [r5, #8]
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8041b8c:	6822      	ldr	r2, [r4, #0]
 8041b8e:	6813      	ldr	r3, [r2, #0]
 8041b90:	f043 0316 	orr.w	r3, r3, #22
 8041b94:	6013      	str	r3, [r2, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8041b96:	6822      	ldr	r2, [r4, #0]
 8041b98:	6953      	ldr	r3, [r2, #20]
 8041b9a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8041b9e:	6153      	str	r3, [r2, #20]
    if(hdma->XferHalfCpltCallback != NULL)
 8041ba0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041ba2:	b123      	cbz	r3, 8041bae <HAL_DMA_Start_IT+0x62>
      hdma->Instance->CR  |= DMA_IT_HT;
 8041ba4:	6822      	ldr	r2, [r4, #0]
 8041ba6:	6813      	ldr	r3, [r2, #0]
 8041ba8:	f043 0308 	orr.w	r3, r3, #8
 8041bac:	6013      	str	r3, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 8041bae:	6822      	ldr	r2, [r4, #0]
 8041bb0:	6813      	ldr	r3, [r2, #0]
 8041bb2:	f043 0301 	orr.w	r3, r3, #1
 8041bb6:	6013      	str	r3, [r2, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8041bb8:	2000      	movs	r0, #0
 8041bba:	e7da      	b.n	8041b72 <HAL_DMA_Start_IT+0x26>
  __HAL_LOCK(hdma);
 8041bbc:	2002      	movs	r0, #2
 8041bbe:	e7d8      	b.n	8041b72 <HAL_DMA_Start_IT+0x26>

08041bc0 <HAL_DMA_Abort_IT>:
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8041bc0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8041bc4:	b2db      	uxtb	r3, r3
 8041bc6:	2b02      	cmp	r3, #2
 8041bc8:	d003      	beq.n	8041bd2 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8041bca:	2380      	movs	r3, #128	; 0x80
 8041bcc:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8041bce:	2001      	movs	r0, #1
 8041bd0:	4770      	bx	lr
    hdma->State = HAL_DMA_STATE_ABORT;
 8041bd2:	2305      	movs	r3, #5
 8041bd4:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8041bd8:	6802      	ldr	r2, [r0, #0]
 8041bda:	6813      	ldr	r3, [r2, #0]
 8041bdc:	f023 0301 	bic.w	r3, r3, #1
 8041be0:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8041be2:	2000      	movs	r0, #0
}
 8041be4:	4770      	bx	lr
	...

08041be8 <HAL_DMA_IRQHandler>:
{
 8041be8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8041bea:	b083      	sub	sp, #12
 8041bec:	4604      	mov	r4, r0
  __IO uint32_t count = 0U;
 8041bee:	2300      	movs	r3, #0
 8041bf0:	9301      	str	r3, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8041bf2:	4b72      	ldr	r3, [pc, #456]	; (8041dbc <HAL_DMA_IRQHandler+0x1d4>)
 8041bf4:	681d      	ldr	r5, [r3, #0]
 8041bf6:	4b72      	ldr	r3, [pc, #456]	; (8041dc0 <HAL_DMA_IRQHandler+0x1d8>)
 8041bf8:	fba3 3505 	umull	r3, r5, r3, r5
 8041bfc:	0aad      	lsrs	r5, r5, #10
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8041bfe:	6d87      	ldr	r7, [r0, #88]	; 0x58
  tmpisr = regs->ISR;
 8041c00:	683e      	ldr	r6, [r7, #0]
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c02:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8041c04:	2308      	movs	r3, #8
 8041c06:	4093      	lsls	r3, r2
 8041c08:	4233      	tst	r3, r6
 8041c0a:	d010      	beq.n	8041c2e <HAL_DMA_IRQHandler+0x46>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 8041c0c:	6803      	ldr	r3, [r0, #0]
 8041c0e:	681a      	ldr	r2, [r3, #0]
 8041c10:	f012 0f04 	tst.w	r2, #4
 8041c14:	d00b      	beq.n	8041c2e <HAL_DMA_IRQHandler+0x46>
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8041c16:	681a      	ldr	r2, [r3, #0]
 8041c18:	f022 0204 	bic.w	r2, r2, #4
 8041c1c:	601a      	str	r2, [r3, #0]
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8041c1e:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8041c20:	2308      	movs	r3, #8
 8041c22:	4093      	lsls	r3, r2
 8041c24:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8041c26:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8041c28:	f043 0301 	orr.w	r3, r3, #1
 8041c2c:	6543      	str	r3, [r0, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c2e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041c30:	2301      	movs	r3, #1
 8041c32:	4093      	lsls	r3, r2
 8041c34:	4233      	tst	r3, r6
 8041c36:	d009      	beq.n	8041c4c <HAL_DMA_IRQHandler+0x64>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8041c38:	6822      	ldr	r2, [r4, #0]
 8041c3a:	6952      	ldr	r2, [r2, #20]
 8041c3c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8041c40:	d004      	beq.n	8041c4c <HAL_DMA_IRQHandler+0x64>
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 8041c42:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8041c44:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041c46:	f043 0302 	orr.w	r3, r3, #2
 8041c4a:	6563      	str	r3, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8041c4c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041c4e:	2304      	movs	r3, #4
 8041c50:	4093      	lsls	r3, r2
 8041c52:	4233      	tst	r3, r6
 8041c54:	d009      	beq.n	8041c6a <HAL_DMA_IRQHandler+0x82>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8041c56:	6822      	ldr	r2, [r4, #0]
 8041c58:	6812      	ldr	r2, [r2, #0]
 8041c5a:	f012 0f02 	tst.w	r2, #2
 8041c5e:	d004      	beq.n	8041c6a <HAL_DMA_IRQHandler+0x82>
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8041c60:	60bb      	str	r3, [r7, #8]
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8041c62:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041c64:	f043 0304 	orr.w	r3, r3, #4
 8041c68:	6563      	str	r3, [r4, #84]	; 0x54
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8041c6a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041c6c:	2310      	movs	r3, #16
 8041c6e:	4093      	lsls	r3, r2
 8041c70:	4233      	tst	r3, r6
 8041c72:	d024      	beq.n	8041cbe <HAL_DMA_IRQHandler+0xd6>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8041c74:	6822      	ldr	r2, [r4, #0]
 8041c76:	6812      	ldr	r2, [r2, #0]
 8041c78:	f012 0f08 	tst.w	r2, #8
 8041c7c:	d01f      	beq.n	8041cbe <HAL_DMA_IRQHandler+0xd6>
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 8041c7e:	60bb      	str	r3, [r7, #8]
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8041c80:	6823      	ldr	r3, [r4, #0]
 8041c82:	681a      	ldr	r2, [r3, #0]
 8041c84:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 8041c88:	d00d      	beq.n	8041ca6 <HAL_DMA_IRQHandler+0xbe>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8041c8a:	681b      	ldr	r3, [r3, #0]
 8041c8c:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8041c90:	d104      	bne.n	8041c9c <HAL_DMA_IRQHandler+0xb4>
          if(hdma->XferHalfCpltCallback != NULL)
 8041c92:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041c94:	b19b      	cbz	r3, 8041cbe <HAL_DMA_IRQHandler+0xd6>
            hdma->XferHalfCpltCallback(hdma);
 8041c96:	4620      	mov	r0, r4
 8041c98:	4798      	blx	r3
 8041c9a:	e010      	b.n	8041cbe <HAL_DMA_IRQHandler+0xd6>
          if(hdma->XferM1HalfCpltCallback != NULL)
 8041c9c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8041c9e:	b173      	cbz	r3, 8041cbe <HAL_DMA_IRQHandler+0xd6>
            hdma->XferM1HalfCpltCallback(hdma);
 8041ca0:	4620      	mov	r0, r4
 8041ca2:	4798      	blx	r3
 8041ca4:	e00b      	b.n	8041cbe <HAL_DMA_IRQHandler+0xd6>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8041ca6:	681a      	ldr	r2, [r3, #0]
 8041ca8:	f412 7f80 	tst.w	r2, #256	; 0x100
 8041cac:	d103      	bne.n	8041cb6 <HAL_DMA_IRQHandler+0xce>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8041cae:	681a      	ldr	r2, [r3, #0]
 8041cb0:	f022 0208 	bic.w	r2, r2, #8
 8041cb4:	601a      	str	r2, [r3, #0]
        if(hdma->XferHalfCpltCallback != NULL)
 8041cb6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041cb8:	b10b      	cbz	r3, 8041cbe <HAL_DMA_IRQHandler+0xd6>
          hdma->XferHalfCpltCallback(hdma);
 8041cba:	4620      	mov	r0, r4
 8041cbc:	4798      	blx	r3
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8041cbe:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041cc0:	2320      	movs	r3, #32
 8041cc2:	4093      	lsls	r3, r2
 8041cc4:	4233      	tst	r3, r6
 8041cc6:	d055      	beq.n	8041d74 <HAL_DMA_IRQHandler+0x18c>
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8041cc8:	6822      	ldr	r2, [r4, #0]
 8041cca:	6812      	ldr	r2, [r2, #0]
 8041ccc:	f012 0f10 	tst.w	r2, #16
 8041cd0:	d050      	beq.n	8041d74 <HAL_DMA_IRQHandler+0x18c>
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8041cd2:	60bb      	str	r3, [r7, #8]
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8041cd4:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8041cd8:	b2db      	uxtb	r3, r3
 8041cda:	2b05      	cmp	r3, #5
 8041cdc:	d00e      	beq.n	8041cfc <HAL_DMA_IRQHandler+0x114>
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8041cde:	6823      	ldr	r3, [r4, #0]
 8041ce0:	681a      	ldr	r2, [r3, #0]
 8041ce2:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 8041ce6:	d033      	beq.n	8041d50 <HAL_DMA_IRQHandler+0x168>
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8041ce8:	681b      	ldr	r3, [r3, #0]
 8041cea:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8041cee:	d12a      	bne.n	8041d46 <HAL_DMA_IRQHandler+0x15e>
          if(hdma->XferM1CpltCallback != NULL)
 8041cf0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8041cf2:	2b00      	cmp	r3, #0
 8041cf4:	d03e      	beq.n	8041d74 <HAL_DMA_IRQHandler+0x18c>
            hdma->XferM1CpltCallback(hdma);
 8041cf6:	4620      	mov	r0, r4
 8041cf8:	4798      	blx	r3
 8041cfa:	e03b      	b.n	8041d74 <HAL_DMA_IRQHandler+0x18c>
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8041cfc:	6822      	ldr	r2, [r4, #0]
 8041cfe:	6813      	ldr	r3, [r2, #0]
 8041d00:	f023 0316 	bic.w	r3, r3, #22
 8041d04:	6013      	str	r3, [r2, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8041d06:	6822      	ldr	r2, [r4, #0]
 8041d08:	6953      	ldr	r3, [r2, #20]
 8041d0a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8041d0e:	6153      	str	r3, [r2, #20]
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8041d10:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8041d12:	b1a3      	cbz	r3, 8041d3e <HAL_DMA_IRQHandler+0x156>
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8041d14:	6822      	ldr	r2, [r4, #0]
 8041d16:	6813      	ldr	r3, [r2, #0]
 8041d18:	f023 0308 	bic.w	r3, r3, #8
 8041d1c:	6013      	str	r3, [r2, #0]
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8041d1e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8041d20:	233f      	movs	r3, #63	; 0x3f
 8041d22:	4093      	lsls	r3, r2
 8041d24:	60bb      	str	r3, [r7, #8]
        __HAL_UNLOCK(hdma);
 8041d26:	2300      	movs	r3, #0
 8041d28:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_READY;
 8041d2c:	2301      	movs	r3, #1
 8041d2e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferAbortCallback != NULL)
 8041d32:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8041d34:	2b00      	cmp	r3, #0
 8041d36:	d03f      	beq.n	8041db8 <HAL_DMA_IRQHandler+0x1d0>
          hdma->XferAbortCallback(hdma);
 8041d38:	4620      	mov	r0, r4
 8041d3a:	4798      	blx	r3
        return;
 8041d3c:	e03c      	b.n	8041db8 <HAL_DMA_IRQHandler+0x1d0>
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8041d3e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8041d40:	2b00      	cmp	r3, #0
 8041d42:	d1e7      	bne.n	8041d14 <HAL_DMA_IRQHandler+0x12c>
 8041d44:	e7eb      	b.n	8041d1e <HAL_DMA_IRQHandler+0x136>
          if(hdma->XferCpltCallback != NULL)
 8041d46:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8041d48:	b1a3      	cbz	r3, 8041d74 <HAL_DMA_IRQHandler+0x18c>
            hdma->XferCpltCallback(hdma);
 8041d4a:	4620      	mov	r0, r4
 8041d4c:	4798      	blx	r3
 8041d4e:	e011      	b.n	8041d74 <HAL_DMA_IRQHandler+0x18c>
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8041d50:	681a      	ldr	r2, [r3, #0]
 8041d52:	f412 7f80 	tst.w	r2, #256	; 0x100
 8041d56:	d109      	bne.n	8041d6c <HAL_DMA_IRQHandler+0x184>
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8041d58:	681a      	ldr	r2, [r3, #0]
 8041d5a:	f022 0210 	bic.w	r2, r2, #16
 8041d5e:	601a      	str	r2, [r3, #0]
          __HAL_UNLOCK(hdma);
 8041d60:	2300      	movs	r3, #0
 8041d62:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8041d66:	2301      	movs	r3, #1
 8041d68:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8041d6c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8041d6e:	b10b      	cbz	r3, 8041d74 <HAL_DMA_IRQHandler+0x18c>
          hdma->XferCpltCallback(hdma);
 8041d70:	4620      	mov	r0, r4
 8041d72:	4798      	blx	r3
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8041d74:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041d76:	b1fb      	cbz	r3, 8041db8 <HAL_DMA_IRQHandler+0x1d0>
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8041d78:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8041d7a:	f013 0f01 	tst.w	r3, #1
 8041d7e:	d017      	beq.n	8041db0 <HAL_DMA_IRQHandler+0x1c8>
      hdma->State = HAL_DMA_STATE_ABORT;
 8041d80:	2305      	movs	r3, #5
 8041d82:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8041d86:	6822      	ldr	r2, [r4, #0]
 8041d88:	6813      	ldr	r3, [r2, #0]
 8041d8a:	f023 0301 	bic.w	r3, r3, #1
 8041d8e:	6013      	str	r3, [r2, #0]
        if (++count > timeout)
 8041d90:	9b01      	ldr	r3, [sp, #4]
 8041d92:	3301      	adds	r3, #1
 8041d94:	9301      	str	r3, [sp, #4]
 8041d96:	42ab      	cmp	r3, r5
 8041d98:	d804      	bhi.n	8041da4 <HAL_DMA_IRQHandler+0x1bc>
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8041d9a:	6823      	ldr	r3, [r4, #0]
 8041d9c:	681b      	ldr	r3, [r3, #0]
 8041d9e:	f013 0f01 	tst.w	r3, #1
 8041da2:	d1f5      	bne.n	8041d90 <HAL_DMA_IRQHandler+0x1a8>
      __HAL_UNLOCK(hdma);
 8041da4:	2300      	movs	r3, #0
 8041da6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8041daa:	2301      	movs	r3, #1
 8041dac:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    if(hdma->XferErrorCallback != NULL)
 8041db0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8041db2:	b10b      	cbz	r3, 8041db8 <HAL_DMA_IRQHandler+0x1d0>
      hdma->XferErrorCallback(hdma);
 8041db4:	4620      	mov	r0, r4
 8041db6:	4798      	blx	r3
}
 8041db8:	b003      	add	sp, #12
 8041dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8041dbc:	20003874 	.word	0x20003874
 8041dc0:	1b4e81b5 	.word	0x1b4e81b5

08041dc4 <HAL_DMA_GetState>:
  return hdma->State;
 8041dc4:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 8041dc8:	4770      	bx	lr
	...

08041dcc <ETH_MACAddressConfig>:

  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg1 = ((uint32_t)Addr[5U] << 8U) | (uint32_t)Addr[4U];
 8041dcc:	7950      	ldrb	r0, [r2, #5]
 8041dce:	7913      	ldrb	r3, [r2, #4]
 8041dd0:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
 8041dd4:	4807      	ldr	r0, [pc, #28]	; (8041df4 <ETH_MACAddressConfig+0x28>)
 8041dd6:	500b      	str	r3, [r1, r0]
  /* Calculate the selected MAC address low register */
  tmpreg1 = ((uint32_t)Addr[3U] << 24U) | ((uint32_t)Addr[2U] << 16U) | ((uint32_t)Addr[1U] << 8U) | Addr[0U];
 8041dd8:	78d0      	ldrb	r0, [r2, #3]
 8041dda:	7893      	ldrb	r3, [r2, #2]
 8041ddc:	041b      	lsls	r3, r3, #16
 8041dde:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8041de2:	7850      	ldrb	r0, [r2, #1]
 8041de4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8041de8:	7812      	ldrb	r2, [r2, #0]
 8041dea:	4313      	orrs	r3, r2
  
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg1;
 8041dec:	4a02      	ldr	r2, [pc, #8]	; (8041df8 <ETH_MACAddressConfig+0x2c>)
 8041dee:	508b      	str	r3, [r1, r2]
}
 8041df0:	4770      	bx	lr
 8041df2:	bf00      	nop
 8041df4:	40028040 	.word	0x40028040
 8041df8:	40028044 	.word	0x40028044

08041dfc <ETH_DMATransmissionEnable>:
  * @retval None
  */
static void ETH_DMATransmissionEnable(ETH_HandleTypeDef *heth)
{
  /* Enable the DMA transmission */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;  
 8041dfc:	6801      	ldr	r1, [r0, #0]
 8041dfe:	f241 0218 	movw	r2, #4120	; 0x1018
 8041e02:	588b      	ldr	r3, [r1, r2]
 8041e04:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8041e08:	508b      	str	r3, [r1, r2]
}
 8041e0a:	4770      	bx	lr

08041e0c <ETH_DMAReceptionEnable>:
  * @retval None
  */
static void ETH_DMAReceptionEnable(ETH_HandleTypeDef *heth)
{  
  /* Enable the DMA reception */
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;  
 8041e0c:	6801      	ldr	r1, [r0, #0]
 8041e0e:	f241 0218 	movw	r2, #4120	; 0x1018
 8041e12:	588b      	ldr	r3, [r1, r2]
 8041e14:	f043 0302 	orr.w	r3, r3, #2
 8041e18:	508b      	str	r3, [r1, r2]
}
 8041e1a:	4770      	bx	lr

08041e1c <ETH_Delay>:
  * @brief  This function provides delay (in milliseconds) based on CPU cycles method.
  * @param  mdelay specifies the delay time length, in milliseconds.
  * @retval None
  */
static void ETH_Delay(uint32_t mdelay)
{
 8041e1c:	b082      	sub	sp, #8
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 8041e1e:	4b08      	ldr	r3, [pc, #32]	; (8041e40 <ETH_Delay+0x24>)
 8041e20:	681b      	ldr	r3, [r3, #0]
 8041e22:	4a08      	ldr	r2, [pc, #32]	; (8041e44 <ETH_Delay+0x28>)
 8041e24:	fba2 2303 	umull	r2, r3, r2, r3
 8041e28:	0a5b      	lsrs	r3, r3, #9
 8041e2a:	fb00 f303 	mul.w	r3, r0, r3
 8041e2e:	9301      	str	r3, [sp, #4]
  do 
  {
    __NOP();
 8041e30:	bf00      	nop
  } 
  while (Delay --);
 8041e32:	9b01      	ldr	r3, [sp, #4]
 8041e34:	1e5a      	subs	r2, r3, #1
 8041e36:	9201      	str	r2, [sp, #4]
 8041e38:	2b00      	cmp	r3, #0
 8041e3a:	d1f9      	bne.n	8041e30 <ETH_Delay+0x14>
}
 8041e3c:	b002      	add	sp, #8
 8041e3e:	4770      	bx	lr
 8041e40:	20003874 	.word	0x20003874
 8041e44:	10624dd3 	.word	0x10624dd3

08041e48 <ETH_MACTransmissionEnable>:
{ 
 8041e48:	b510      	push	{r4, lr}
 8041e4a:	b082      	sub	sp, #8
 8041e4c:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041e4e:	2300      	movs	r3, #0
 8041e50:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_TE;
 8041e52:	6802      	ldr	r2, [r0, #0]
 8041e54:	6813      	ldr	r3, [r2, #0]
 8041e56:	f043 0308 	orr.w	r3, r3, #8
 8041e5a:	6013      	str	r3, [r2, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041e5c:	6803      	ldr	r3, [r0, #0]
 8041e5e:	681b      	ldr	r3, [r3, #0]
 8041e60:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041e62:	2001      	movs	r0, #1
 8041e64:	f7ff ffda 	bl	8041e1c <ETH_Delay>
  (heth->Instance)->MACCR = tmpreg1;
 8041e68:	6823      	ldr	r3, [r4, #0]
 8041e6a:	9a01      	ldr	r2, [sp, #4]
 8041e6c:	601a      	str	r2, [r3, #0]
}
 8041e6e:	b002      	add	sp, #8
 8041e70:	bd10      	pop	{r4, pc}

08041e72 <ETH_MACReceptionEnable>:
{ 
 8041e72:	b510      	push	{r4, lr}
 8041e74:	b082      	sub	sp, #8
 8041e76:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041e78:	2300      	movs	r3, #0
 8041e7a:	9301      	str	r3, [sp, #4]
  (heth->Instance)->MACCR |= ETH_MACCR_RE;
 8041e7c:	6802      	ldr	r2, [r0, #0]
 8041e7e:	6813      	ldr	r3, [r2, #0]
 8041e80:	f043 0304 	orr.w	r3, r3, #4
 8041e84:	6013      	str	r3, [r2, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041e86:	6803      	ldr	r3, [r0, #0]
 8041e88:	681b      	ldr	r3, [r3, #0]
 8041e8a:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041e8c:	2001      	movs	r0, #1
 8041e8e:	f7ff ffc5 	bl	8041e1c <ETH_Delay>
  (heth->Instance)->MACCR = tmpreg1;
 8041e92:	6823      	ldr	r3, [r4, #0]
 8041e94:	9a01      	ldr	r2, [sp, #4]
 8041e96:	601a      	str	r2, [r3, #0]
}
 8041e98:	b002      	add	sp, #8
 8041e9a:	bd10      	pop	{r4, pc}

08041e9c <ETH_FlushTransmitFIFO>:
{
 8041e9c:	b530      	push	{r4, r5, lr}
 8041e9e:	b083      	sub	sp, #12
 8041ea0:	4604      	mov	r4, r0
  __IO uint32_t tmpreg1 = 0U;
 8041ea2:	2300      	movs	r3, #0
 8041ea4:	9301      	str	r3, [sp, #4]
  (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
 8041ea6:	6802      	ldr	r2, [r0, #0]
 8041ea8:	f241 0518 	movw	r5, #4120	; 0x1018
 8041eac:	5953      	ldr	r3, [r2, r5]
 8041eae:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8041eb2:	5153      	str	r3, [r2, r5]
  tmpreg1 = (heth->Instance)->DMAOMR;
 8041eb4:	6803      	ldr	r3, [r0, #0]
 8041eb6:	595b      	ldr	r3, [r3, r5]
 8041eb8:	9301      	str	r3, [sp, #4]
  ETH_Delay(ETH_REG_WRITE_DELAY);
 8041eba:	2001      	movs	r0, #1
 8041ebc:	f7ff ffae 	bl	8041e1c <ETH_Delay>
  (heth->Instance)->DMAOMR = tmpreg1;
 8041ec0:	6823      	ldr	r3, [r4, #0]
 8041ec2:	9a01      	ldr	r2, [sp, #4]
 8041ec4:	515a      	str	r2, [r3, r5]
}
 8041ec6:	b003      	add	sp, #12
 8041ec8:	bd30      	pop	{r4, r5, pc}
	...

08041ecc <ETH_MACDMAConfig>:
{
 8041ecc:	b570      	push	{r4, r5, r6, lr}
 8041ece:	b09e      	sub	sp, #120	; 0x78
 8041ed0:	4604      	mov	r4, r0
  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 8041ed2:	b129      	cbz	r1, 8041ee0 <ETH_MACDMAConfig+0x14>
    (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
 8041ed4:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8041ed8:	60c3      	str	r3, [r0, #12]
    (heth->Init).Speed = ETH_SPEED_100M;
 8041eda:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8041ede:	6083      	str	r3, [r0, #8]
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 8041ee0:	69e3      	ldr	r3, [r4, #28]
 8041ee2:	2b00      	cmp	r3, #0
 8041ee4:	d16a      	bne.n	8041fbc <ETH_MACDMAConfig+0xf0>
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 8041ee6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8041eea:	9307      	str	r3, [sp, #28]
  tmpreg1 = (heth->Instance)->MACCR;
 8041eec:	6821      	ldr	r1, [r4, #0]
 8041eee:	680b      	ldr	r3, [r1, #0]
  tmpreg1 &= ETH_MACCR_CLEAR_MASK;
 8041ef0:	4a39      	ldr	r2, [pc, #228]	; (8041fd8 <ETH_MACDMAConfig+0x10c>)
 8041ef2:	401a      	ands	r2, r3
                       (heth->Init).Speed | 
 8041ef4:	68a3      	ldr	r3, [r4, #8]
                       (heth->Init).DuplexMode | 
 8041ef6:	68e0      	ldr	r0, [r4, #12]
                       macinit.LoopbackMode |
 8041ef8:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 8041efa:	9807      	ldr	r0, [sp, #28]
                       (heth->Init).DuplexMode | 
 8041efc:	4303      	orrs	r3, r0
                       macinit.ChecksumOffload |    
 8041efe:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  tmpreg1 |= (uint32_t)(macinit.Watchdog | 
 8041f02:	4313      	orrs	r3, r2
  (heth->Instance)->MACCR = (uint32_t)tmpreg1;
 8041f04:	600b      	str	r3, [r1, #0]
  tmpreg1 = (heth->Instance)->MACCR;
 8041f06:	6823      	ldr	r3, [r4, #0]
 8041f08:	681d      	ldr	r5, [r3, #0]
  HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f0a:	2001      	movs	r0, #1
 8041f0c:	f7ff f8ce 	bl	80410ac <HAL_Delay>
  (heth->Instance)->MACCR = tmpreg1; 
 8041f10:	6823      	ldr	r3, [r4, #0]
 8041f12:	601d      	str	r5, [r3, #0]
  (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll | 
 8041f14:	6823      	ldr	r3, [r4, #0]
 8041f16:	2240      	movs	r2, #64	; 0x40
 8041f18:	605a      	str	r2, [r3, #4]
   tmpreg1 = (heth->Instance)->MACFFR;
 8041f1a:	6823      	ldr	r3, [r4, #0]
 8041f1c:	685d      	ldr	r5, [r3, #4]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f1e:	2001      	movs	r0, #1
 8041f20:	f7ff f8c4 	bl	80410ac <HAL_Delay>
   (heth->Instance)->MACFFR = tmpreg1;
 8041f24:	6823      	ldr	r3, [r4, #0]
 8041f26:	605d      	str	r5, [r3, #4]
   (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8041f28:	6823      	ldr	r3, [r4, #0]
 8041f2a:	2500      	movs	r5, #0
 8041f2c:	609d      	str	r5, [r3, #8]
   (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
 8041f2e:	6823      	ldr	r3, [r4, #0]
 8041f30:	60dd      	str	r5, [r3, #12]
   tmpreg1 = (heth->Instance)->MACFCR;
 8041f32:	6822      	ldr	r2, [r4, #0]
 8041f34:	6993      	ldr	r3, [r2, #24]
   tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
 8041f36:	f023 03be 	bic.w	r3, r3, #190	; 0xbe
 8041f3a:	041b      	lsls	r3, r3, #16
 8041f3c:	0c1b      	lsrs	r3, r3, #16
   tmpreg1 |= (uint32_t)((macinit.PauseTime << 16U) | 
 8041f3e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
 8041f42:	6193      	str	r3, [r2, #24]
   tmpreg1 = (heth->Instance)->MACFCR;
 8041f44:	6823      	ldr	r3, [r4, #0]
 8041f46:	699e      	ldr	r6, [r3, #24]
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f48:	2001      	movs	r0, #1
 8041f4a:	f7ff f8af 	bl	80410ac <HAL_Delay>
   (heth->Instance)->MACFCR = tmpreg1;
 8041f4e:	6823      	ldr	r3, [r4, #0]
 8041f50:	619e      	str	r6, [r3, #24]
   (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison | 
 8041f52:	6823      	ldr	r3, [r4, #0]
 8041f54:	61dd      	str	r5, [r3, #28]
    tmpreg1 = (heth->Instance)->MACVLANTR;
 8041f56:	6823      	ldr	r3, [r4, #0]
 8041f58:	69dd      	ldr	r5, [r3, #28]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f5a:	2001      	movs	r0, #1
 8041f5c:	f7ff f8a6 	bl	80410ac <HAL_Delay>
    (heth->Instance)->MACVLANTR = tmpreg1;
 8041f60:	6823      	ldr	r3, [r4, #0]
 8041f62:	61dd      	str	r5, [r3, #28]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8041f64:	6822      	ldr	r2, [r4, #0]
 8041f66:	f241 0518 	movw	r5, #4120	; 0x1018
 8041f6a:	5951      	ldr	r1, [r2, r5]
    tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
 8041f6c:	4b1b      	ldr	r3, [pc, #108]	; (8041fdc <ETH_MACDMAConfig+0x110>)
 8041f6e:	400b      	ands	r3, r1
    tmpreg1 |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame | 
 8041f70:	f043 7308 	orr.w	r3, r3, #35651584	; 0x2200000
 8041f74:	f043 0304 	orr.w	r3, r3, #4
    (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
 8041f78:	5153      	str	r3, [r2, r5]
    tmpreg1 = (heth->Instance)->DMAOMR;
 8041f7a:	6823      	ldr	r3, [r4, #0]
 8041f7c:	595e      	ldr	r6, [r3, r5]
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f7e:	2001      	movs	r0, #1
 8041f80:	f7ff f894 	bl	80410ac <HAL_Delay>
    (heth->Instance)->DMAOMR = tmpreg1;
 8041f84:	6823      	ldr	r3, [r4, #0]
 8041f86:	515e      	str	r6, [r3, r5]
    (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats | 
 8041f88:	6823      	ldr	r3, [r4, #0]
 8041f8a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041f8e:	4a14      	ldr	r2, [pc, #80]	; (8041fe0 <ETH_MACDMAConfig+0x114>)
 8041f90:	601a      	str	r2, [r3, #0]
     tmpreg1 = (heth->Instance)->DMABMR;
 8041f92:	6823      	ldr	r3, [r4, #0]
 8041f94:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041f98:	681d      	ldr	r5, [r3, #0]
     HAL_Delay(ETH_REG_WRITE_DELAY);
 8041f9a:	2001      	movs	r0, #1
 8041f9c:	f7ff f886 	bl	80410ac <HAL_Delay>
     (heth->Instance)->DMABMR = tmpreg1;
 8041fa0:	6823      	ldr	r3, [r4, #0]
 8041fa2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8041fa6:	601d      	str	r5, [r3, #0]
     if((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
 8041fa8:	69a3      	ldr	r3, [r4, #24]
 8041faa:	2b01      	cmp	r3, #1
 8041fac:	d009      	beq.n	8041fc2 <ETH_MACDMAConfig+0xf6>
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 8041fae:	6962      	ldr	r2, [r4, #20]
 8041fb0:	2100      	movs	r1, #0
 8041fb2:	4620      	mov	r0, r4
 8041fb4:	f7ff ff0a 	bl	8041dcc <ETH_MACAddressConfig>
}
 8041fb8:	b01e      	add	sp, #120	; 0x78
 8041fba:	bd70      	pop	{r4, r5, r6, pc}
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 8041fbc:	2300      	movs	r3, #0
 8041fbe:	9307      	str	r3, [sp, #28]
 8041fc0:	e794      	b.n	8041eec <ETH_MACDMAConfig+0x20>
       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8041fc2:	6821      	ldr	r1, [r4, #0]
 8041fc4:	f241 021c 	movw	r2, #4124	; 0x101c
 8041fc8:	588b      	ldr	r3, [r1, r2]
 8041fca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8041fce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8041fd2:	508b      	str	r3, [r1, r2]
 8041fd4:	e7eb      	b.n	8041fae <ETH_MACDMAConfig+0xe2>
 8041fd6:	bf00      	nop
 8041fd8:	ff20810f 	.word	0xff20810f
 8041fdc:	f8de3f23 	.word	0xf8de3f23
 8041fe0:	02c12080 	.word	0x02c12080

08041fe4 <HAL_ETH_DMATxDescListInit>:
{
 8041fe4:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 8041fe6:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 8041fea:	2c01      	cmp	r4, #1
 8041fec:	d032      	beq.n	8042054 <HAL_ETH_DMATxDescListInit+0x70>
 8041fee:	2401      	movs	r4, #1
 8041ff0:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8041ff4:	2402      	movs	r4, #2
 8041ff6:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->TxDesc = DMATxDescTab;
 8041ffa:	62c1      	str	r1, [r0, #44]	; 0x2c
  for(i=0U; i < TxBuffCount; i++)
 8041ffc:	2400      	movs	r4, #0
 8041ffe:	e001      	b.n	8042004 <HAL_ETH_DMATxDescListInit+0x20>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
 8042000:	60f1      	str	r1, [r6, #12]
  for(i=0U; i < TxBuffCount; i++)
 8042002:	3401      	adds	r4, #1
 8042004:	429c      	cmp	r4, r3
 8042006:	d218      	bcs.n	804203a <HAL_ETH_DMATxDescListInit+0x56>
    dmatxdesc = DMATxDescTab + i;
 8042008:	0167      	lsls	r7, r4, #5
 804200a:	eb01 1644 	add.w	r6, r1, r4, lsl #5
    dmatxdesc->Status = ETH_DMATXDESC_TCH;  
 804200e:	f44f 1580 	mov.w	r5, #1048576	; 0x100000
 8042012:	51cd      	str	r5, [r1, r7]
    dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 8042014:	f240 55f4 	movw	r5, #1524	; 0x5f4
 8042018:	fb05 2504 	mla	r5, r5, r4, r2
 804201c:	60b5      	str	r5, [r6, #8]
    if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 804201e:	69c5      	ldr	r5, [r0, #28]
 8042020:	b91d      	cbnz	r5, 804202a <HAL_ETH_DMATxDescListInit+0x46>
      dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8042022:	59cd      	ldr	r5, [r1, r7]
 8042024:	f445 0540 	orr.w	r5, r5, #12582912	; 0xc00000
 8042028:	51cd      	str	r5, [r1, r7]
    if(i < (TxBuffCount-1U))
 804202a:	1e5d      	subs	r5, r3, #1
 804202c:	42a5      	cmp	r5, r4
 804202e:	d9e7      	bls.n	8042000 <HAL_ETH_DMATxDescListInit+0x1c>
      dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1U);
 8042030:	1c65      	adds	r5, r4, #1
 8042032:	eb01 1545 	add.w	r5, r1, r5, lsl #5
 8042036:	60f5      	str	r5, [r6, #12]
 8042038:	e7e3      	b.n	8042002 <HAL_ETH_DMATxDescListInit+0x1e>
  (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
 804203a:	6802      	ldr	r2, [r0, #0]
 804203c:	f241 0310 	movw	r3, #4112	; 0x1010
 8042040:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 8042042:	2301      	movs	r3, #1
 8042044:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8042048:	2300      	movs	r3, #0
 804204a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 804204e:	4618      	mov	r0, r3
}
 8042050:	bcf0      	pop	{r4, r5, r6, r7}
 8042052:	4770      	bx	lr
  __HAL_LOCK(heth);
 8042054:	2002      	movs	r0, #2
 8042056:	e7fb      	b.n	8042050 <HAL_ETH_DMATxDescListInit+0x6c>

08042058 <HAL_ETH_DMARxDescListInit>:
{
 8042058:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(heth);
 804205a:	f890 4045 	ldrb.w	r4, [r0, #69]	; 0x45
 804205e:	2c01      	cmp	r4, #1
 8042060:	d02f      	beq.n	80420c2 <HAL_ETH_DMARxDescListInit+0x6a>
 8042062:	2401      	movs	r4, #1
 8042064:	f880 4045 	strb.w	r4, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 8042068:	2402      	movs	r4, #2
 804206a:	f880 4044 	strb.w	r4, [r0, #68]	; 0x44
  heth->RxDesc = DMARxDescTab; 
 804206e:	6281      	str	r1, [r0, #40]	; 0x28
  for(i=0U; i < RxBuffCount; i++)
 8042070:	2400      	movs	r4, #0
 8042072:	e001      	b.n	8042078 <HAL_ETH_DMARxDescListInit+0x20>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
 8042074:	60e9      	str	r1, [r5, #12]
  for(i=0U; i < RxBuffCount; i++)
 8042076:	3401      	adds	r4, #1
 8042078:	429c      	cmp	r4, r3
 804207a:	d215      	bcs.n	80420a8 <HAL_ETH_DMARxDescListInit+0x50>
    DMARxDesc = DMARxDescTab+i;
 804207c:	0166      	lsls	r6, r4, #5
 804207e:	eb01 1544 	add.w	r5, r1, r4, lsl #5
    DMARxDesc->Status = ETH_DMARXDESC_OWN;
 8042082:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 8042086:	518f      	str	r7, [r1, r6]
    DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;  
 8042088:	f244 56f4 	movw	r6, #17908	; 0x45f4
 804208c:	606e      	str	r6, [r5, #4]
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 804208e:	f240 56f4 	movw	r6, #1524	; 0x5f4
 8042092:	fb06 2604 	mla	r6, r6, r4, r2
 8042096:	60ae      	str	r6, [r5, #8]
    if(i < (RxBuffCount-1U))
 8042098:	1e5e      	subs	r6, r3, #1
 804209a:	42a6      	cmp	r6, r4
 804209c:	d9ea      	bls.n	8042074 <HAL_ETH_DMARxDescListInit+0x1c>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1U); 
 804209e:	1c66      	adds	r6, r4, #1
 80420a0:	eb01 1646 	add.w	r6, r1, r6, lsl #5
 80420a4:	60ee      	str	r6, [r5, #12]
 80420a6:	e7e6      	b.n	8042076 <HAL_ETH_DMARxDescListInit+0x1e>
  (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
 80420a8:	6802      	ldr	r2, [r0, #0]
 80420aa:	f241 030c 	movw	r3, #4108	; 0x100c
 80420ae:	50d1      	str	r1, [r2, r3]
  heth->State= HAL_ETH_STATE_READY;
 80420b0:	2301      	movs	r3, #1
 80420b2:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80420b6:	2300      	movs	r3, #0
 80420b8:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 80420bc:	4618      	mov	r0, r3
}
 80420be:	bcf0      	pop	{r4, r5, r6, r7}
 80420c0:	4770      	bx	lr
  __HAL_LOCK(heth);
 80420c2:	2002      	movs	r0, #2
 80420c4:	e7fb      	b.n	80420be <HAL_ETH_DMARxDescListInit+0x66>
	...

080420c8 <HAL_ETH_TransmitFrame>:
  __HAL_LOCK(heth);
 80420c8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80420cc:	2b01      	cmp	r3, #1
 80420ce:	f000 8085 	beq.w	80421dc <HAL_ETH_TransmitFrame+0x114>
 80420d2:	2301      	movs	r3, #1
 80420d4:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 80420d8:	2302      	movs	r3, #2
 80420da:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if (FrameLength == 0U) 
 80420de:	b1b1      	cbz	r1, 804210e <HAL_ETH_TransmitFrame+0x46>
  if(((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 80420e0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80420e2:	681a      	ldr	r2, [r3, #0]
 80420e4:	2a00      	cmp	r2, #0
 80420e6:	db1a      	blt.n	804211e <HAL_ETH_TransmitFrame+0x56>
{
 80420e8:	b430      	push	{r4, r5}
  if (FrameLength > ETH_TX_BUF_SIZE)
 80420ea:	f240 52f4 	movw	r2, #1524	; 0x5f4
 80420ee:	4291      	cmp	r1, r2
 80420f0:	d91d      	bls.n	804212e <HAL_ETH_TransmitFrame+0x66>
    bufcount = FrameLength/ETH_TX_BUF_SIZE;
 80420f2:	4c3b      	ldr	r4, [pc, #236]	; (80421e0 <HAL_ETH_TransmitFrame+0x118>)
 80420f4:	fba4 2401 	umull	r2, r4, r4, r1
 80420f8:	0aa4      	lsrs	r4, r4, #10
    if (FrameLength % ETH_TX_BUF_SIZE) 
 80420fa:	f240 52f4 	movw	r2, #1524	; 0x5f4
 80420fe:	fb02 1214 	mls	r2, r2, r4, r1
 8042102:	b102      	cbz	r2, 8042106 <HAL_ETH_TransmitFrame+0x3e>
      bufcount++;
 8042104:	3401      	adds	r4, #1
  if (bufcount == 1U)
 8042106:	2c01      	cmp	r4, #1
 8042108:	d011      	beq.n	804212e <HAL_ETH_TransmitFrame+0x66>
    for (i=0U; i< bufcount; i++)
 804210a:	2300      	movs	r3, #0
 804210c:	e048      	b.n	80421a0 <HAL_ETH_TransmitFrame+0xd8>
    heth->State = HAL_ETH_STATE_READY;
 804210e:	2301      	movs	r3, #1
 8042110:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8042114:	2200      	movs	r2, #0
 8042116:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
    return  HAL_ERROR;                                    
 804211a:	4618      	mov	r0, r3
 804211c:	4770      	bx	lr
    heth->State = HAL_ETH_STATE_BUSY_TX;
 804211e:	2312      	movs	r3, #18
 8042120:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
    __HAL_UNLOCK(heth);
 8042124:	2300      	movs	r3, #0
 8042126:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    return HAL_ERROR;
 804212a:	2001      	movs	r0, #1
 804212c:	4770      	bx	lr
    heth->TxDesc->Status |=ETH_DMATXDESC_FS|ETH_DMATXDESC_LS;
 804212e:	681a      	ldr	r2, [r3, #0]
 8042130:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 8042134:	601a      	str	r2, [r3, #0]
    heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
 8042136:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8042138:	f3c1 010c 	ubfx	r1, r1, #0, #13
 804213c:	6059      	str	r1, [r3, #4]
    heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 804213e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8042140:	6813      	ldr	r3, [r2, #0]
 8042142:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8042146:	6013      	str	r3, [r2, #0]
    heth->TxDesc= (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 8042148:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 804214a:	68db      	ldr	r3, [r3, #12]
 804214c:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
 804214e:	6803      	ldr	r3, [r0, #0]
 8042150:	f241 0214 	movw	r2, #4116	; 0x1014
 8042154:	589a      	ldr	r2, [r3, r2]
 8042156:	f012 0f04 	tst.w	r2, #4
 804215a:	d008      	beq.n	804216e <HAL_ETH_TransmitFrame+0xa6>
    (heth->Instance)->DMASR = ETH_DMASR_TBUS;
 804215c:	f241 0214 	movw	r2, #4116	; 0x1014
 8042160:	2104      	movs	r1, #4
 8042162:	5099      	str	r1, [r3, r2]
    (heth->Instance)->DMATPDR = 0U;
 8042164:	6802      	ldr	r2, [r0, #0]
 8042166:	f241 0304 	movw	r3, #4100	; 0x1004
 804216a:	2100      	movs	r1, #0
 804216c:	50d1      	str	r1, [r2, r3]
  heth->State = HAL_ETH_STATE_READY;
 804216e:	2301      	movs	r3, #1
 8042170:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8042174:	2300      	movs	r3, #0
 8042176:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  return HAL_OK;
 804217a:	4618      	mov	r0, r3
}
 804217c:	bc30      	pop	{r4, r5}
 804217e:	4770      	bx	lr
      heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
 8042180:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8042182:	f240 55f4 	movw	r5, #1524	; 0x5f4
 8042186:	6055      	str	r5, [r2, #4]
      if (i == (bufcount-1U))
 8042188:	1e62      	subs	r2, r4, #1
 804218a:	429a      	cmp	r2, r3
 804218c:	d017      	beq.n	80421be <HAL_ETH_TransmitFrame+0xf6>
      heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
 804218e:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 8042190:	682a      	ldr	r2, [r5, #0]
 8042192:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8042196:	602a      	str	r2, [r5, #0]
      heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
 8042198:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 804219a:	68d2      	ldr	r2, [r2, #12]
 804219c:	62c2      	str	r2, [r0, #44]	; 0x2c
    for (i=0U; i< bufcount; i++)
 804219e:	3301      	adds	r3, #1
 80421a0:	429c      	cmp	r4, r3
 80421a2:	d9d4      	bls.n	804214e <HAL_ETH_TransmitFrame+0x86>
      heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
 80421a4:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421a6:	682a      	ldr	r2, [r5, #0]
 80421a8:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80421ac:	602a      	str	r2, [r5, #0]
      if (i == 0U) 
 80421ae:	2b00      	cmp	r3, #0
 80421b0:	d1e6      	bne.n	8042180 <HAL_ETH_TransmitFrame+0xb8>
        heth->TxDesc->Status |= ETH_DMATXDESC_FS;  
 80421b2:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421b4:	682a      	ldr	r2, [r5, #0]
 80421b6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80421ba:	602a      	str	r2, [r5, #0]
 80421bc:	e7e0      	b.n	8042180 <HAL_ETH_TransmitFrame+0xb8>
        heth->TxDesc->Status |= ETH_DMATXDESC_LS;
 80421be:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421c0:	682a      	ldr	r2, [r5, #0]
 80421c2:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80421c6:	602a      	str	r2, [r5, #0]
        size = FrameLength - (bufcount-1U)*ETH_TX_BUF_SIZE;
 80421c8:	4a06      	ldr	r2, [pc, #24]	; (80421e4 <HAL_ETH_TransmitFrame+0x11c>)
 80421ca:	fb02 1204 	mla	r2, r2, r4, r1
 80421ce:	f202 52f4 	addw	r2, r2, #1524	; 0x5f4
        heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
 80421d2:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
 80421d4:	f3c2 020c 	ubfx	r2, r2, #0, #13
 80421d8:	606a      	str	r2, [r5, #4]
 80421da:	e7d8      	b.n	804218e <HAL_ETH_TransmitFrame+0xc6>
  __HAL_LOCK(heth);
 80421dc:	2002      	movs	r0, #2
}
 80421de:	4770      	bx	lr
 80421e0:	ac02b00b 	.word	0xac02b00b
 80421e4:	fffffa0c 	.word	0xfffffa0c

080421e8 <HAL_ETH_GetReceivedFrame>:
  __HAL_LOCK(heth);
 80421e8:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80421ec:	2b01      	cmp	r3, #1
 80421ee:	d040      	beq.n	8042272 <HAL_ETH_GetReceivedFrame+0x8a>
 80421f0:	2301      	movs	r3, #1
 80421f2:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 80421f6:	2302      	movs	r3, #2
 80421f8:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  if(((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET))
 80421fc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80421fe:	681a      	ldr	r2, [r3, #0]
 8042200:	2a00      	cmp	r2, #0
 8042202:	db0e      	blt.n	8042222 <HAL_ETH_GetReceivedFrame+0x3a>
    if(((heth->RxDesc->Status & ETH_DMARXDESC_LS) != (uint32_t)RESET)) 
 8042204:	681a      	ldr	r2, [r3, #0]
 8042206:	f412 7f80 	tst.w	r2, #256	; 0x100
 804220a:	d112      	bne.n	8042232 <HAL_ETH_GetReceivedFrame+0x4a>
    else if((heth->RxDesc->Status & ETH_DMARXDESC_FS) != (uint32_t)RESET)
 804220c:	681a      	ldr	r2, [r3, #0]
 804220e:	f412 7f00 	tst.w	r2, #512	; 0x200
 8042212:	d028      	beq.n	8042266 <HAL_ETH_GetReceivedFrame+0x7e>
      (heth->RxFrameInfos).FSRxDesc = heth->RxDesc;
 8042214:	6303      	str	r3, [r0, #48]	; 0x30
      (heth->RxFrameInfos).LSRxDesc = NULL;
 8042216:	2200      	movs	r2, #0
 8042218:	6342      	str	r2, [r0, #52]	; 0x34
      (heth->RxFrameInfos).SegCount = 1U;
 804221a:	2201      	movs	r2, #1
 804221c:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 804221e:	68db      	ldr	r3, [r3, #12]
 8042220:	6283      	str	r3, [r0, #40]	; 0x28
  heth->State = HAL_ETH_STATE_READY;
 8042222:	2301      	movs	r3, #1
 8042224:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  __HAL_UNLOCK(heth);
 8042228:	2200      	movs	r2, #0
 804222a:	f880 2045 	strb.w	r2, [r0, #69]	; 0x45
  return HAL_ERROR;
 804222e:	4618      	mov	r0, r3
 8042230:	4770      	bx	lr
      (heth->RxFrameInfos).SegCount++;
 8042232:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042234:	3201      	adds	r2, #1
 8042236:	6382      	str	r2, [r0, #56]	; 0x38
      if ((heth->RxFrameInfos).SegCount == 1U)
 8042238:	2a01      	cmp	r2, #1
 804223a:	d012      	beq.n	8042262 <HAL_ETH_GetReceivedFrame+0x7a>
      heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
 804223c:	6343      	str	r3, [r0, #52]	; 0x34
      framelength = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
 804223e:	681a      	ldr	r2, [r3, #0]
 8042240:	f3c2 420d 	ubfx	r2, r2, #16, #14
 8042244:	3a04      	subs	r2, #4
      heth->RxFrameInfos.length = framelength;
 8042246:	63c2      	str	r2, [r0, #60]	; 0x3c
      heth->RxFrameInfos.buffer = ((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
 8042248:	6b02      	ldr	r2, [r0, #48]	; 0x30
 804224a:	6892      	ldr	r2, [r2, #8]
 804224c:	6402      	str	r2, [r0, #64]	; 0x40
      heth->RxDesc = (ETH_DMADescTypeDef*) ((heth->RxDesc)->Buffer2NextDescAddr);
 804224e:	68db      	ldr	r3, [r3, #12]
 8042250:	6283      	str	r3, [r0, #40]	; 0x28
      heth->State = HAL_ETH_STATE_READY;
 8042252:	2301      	movs	r3, #1
 8042254:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
      __HAL_UNLOCK(heth);
 8042258:	2300      	movs	r3, #0
 804225a:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
      return HAL_OK;
 804225e:	4618      	mov	r0, r3
 8042260:	4770      	bx	lr
        (heth->RxFrameInfos).FSRxDesc =heth->RxDesc;
 8042262:	6303      	str	r3, [r0, #48]	; 0x30
 8042264:	e7ea      	b.n	804223c <HAL_ETH_GetReceivedFrame+0x54>
      (heth->RxFrameInfos).SegCount++;
 8042266:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042268:	3201      	adds	r2, #1
 804226a:	6382      	str	r2, [r0, #56]	; 0x38
      heth->RxDesc = (ETH_DMADescTypeDef*) (heth->RxDesc->Buffer2NextDescAddr);
 804226c:	68db      	ldr	r3, [r3, #12]
 804226e:	6283      	str	r3, [r0, #40]	; 0x28
 8042270:	e7d7      	b.n	8042222 <HAL_ETH_GetReceivedFrame+0x3a>
  __HAL_LOCK(heth);
 8042272:	2002      	movs	r0, #2
}
 8042274:	4770      	bx	lr

08042276 <HAL_ETH_ReadPHYRegister>:
{
 8042276:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(heth->State == HAL_ETH_STATE_BUSY_RD)
 8042278:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 804227c:	b2db      	uxtb	r3, r3
 804227e:	2b82      	cmp	r3, #130	; 0x82
 8042280:	d033      	beq.n	80422ea <HAL_ETH_ReadPHYRegister+0x74>
 8042282:	4605      	mov	r5, r0
 8042284:	4616      	mov	r6, r2
  heth->State = HAL_ETH_STATE_BUSY_RD;
 8042286:	2382      	movs	r3, #130	; 0x82
 8042288:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 804228c:	6800      	ldr	r0, [r0, #0]
 804228e:	6902      	ldr	r2, [r0, #16]
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 8042290:	f002 021c 	and.w	r2, r2, #28
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress << 11U) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
 8042294:	8a2b      	ldrh	r3, [r5, #16]
 8042296:	02db      	lsls	r3, r3, #11
 8042298:	b29b      	uxth	r3, r3
 804229a:	4313      	orrs	r3, r2
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                   /* Set the PHY register address */
 804229c:	018c      	lsls	r4, r1, #6
 804229e:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
  tmpreg1 &= ~ETH_MACMIIAR_MW;                                            /* Set the read mode            */
 80422a2:	431c      	orrs	r4, r3
  tmpreg1 |= ETH_MACMIIAR_MB;                                             /* Set the MII Busy bit         */
 80422a4:	f044 0401 	orr.w	r4, r4, #1
  heth->Instance->MACMIIAR = tmpreg1;
 80422a8:	6104      	str	r4, [r0, #16]
  tickstart = HAL_GetTick();
 80422aa:	f7fe fef9 	bl	80410a0 <HAL_GetTick>
 80422ae:	4607      	mov	r7, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 80422b0:	f014 0f01 	tst.w	r4, #1
 80422b4:	d010      	beq.n	80422d8 <HAL_ETH_ReadPHYRegister+0x62>
    if((HAL_GetTick() - tickstart ) > PHY_READ_TO)
 80422b6:	f7fe fef3 	bl	80410a0 <HAL_GetTick>
 80422ba:	1bc3      	subs	r3, r0, r7
 80422bc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80422c0:	d202      	bcs.n	80422c8 <HAL_ETH_ReadPHYRegister+0x52>
    tmpreg1 = heth->Instance->MACMIIAR;
 80422c2:	682b      	ldr	r3, [r5, #0]
 80422c4:	691c      	ldr	r4, [r3, #16]
 80422c6:	e7f3      	b.n	80422b0 <HAL_ETH_ReadPHYRegister+0x3a>
      heth->State= HAL_ETH_STATE_READY;
 80422c8:	2301      	movs	r3, #1
 80422ca:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 80422ce:	2300      	movs	r3, #0
 80422d0:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 80422d4:	2003      	movs	r0, #3
 80422d6:	e007      	b.n	80422e8 <HAL_ETH_ReadPHYRegister+0x72>
  *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
 80422d8:	682b      	ldr	r3, [r5, #0]
 80422da:	695b      	ldr	r3, [r3, #20]
 80422dc:	b29b      	uxth	r3, r3
 80422de:	6033      	str	r3, [r6, #0]
  heth->State = HAL_ETH_STATE_READY;
 80422e0:	2301      	movs	r3, #1
 80422e2:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK;
 80422e6:	2000      	movs	r0, #0
}
 80422e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80422ea:	2002      	movs	r0, #2
 80422ec:	e7fc      	b.n	80422e8 <HAL_ETH_ReadPHYRegister+0x72>

080422ee <HAL_ETH_WritePHYRegister>:
  if(heth->State == HAL_ETH_STATE_BUSY_WR)
 80422ee:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 80422f2:	b2db      	uxtb	r3, r3
 80422f4:	2b42      	cmp	r3, #66	; 0x42
 80422f6:	d032      	beq.n	804235e <HAL_ETH_WritePHYRegister+0x70>
{
 80422f8:	b570      	push	{r4, r5, r6, lr}
 80422fa:	4605      	mov	r5, r0
  heth->State = HAL_ETH_STATE_BUSY_WR;
 80422fc:	2342      	movs	r3, #66	; 0x42
 80422fe:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  tmpreg1 = heth->Instance->MACMIIAR;
 8042302:	6806      	ldr	r6, [r0, #0]
 8042304:	6930      	ldr	r0, [r6, #16]
  tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
 8042306:	f000 001c 	and.w	r0, r0, #28
  tmpreg1 |=(((uint32_t)heth->Init.PhyAddress<<11U) & ETH_MACMIIAR_PA); /* Set the PHY device address */
 804230a:	8a2b      	ldrh	r3, [r5, #16]
 804230c:	02db      	lsls	r3, r3, #11
 804230e:	b29b      	uxth	r3, r3
 8042310:	4303      	orrs	r3, r0
  tmpreg1 |=(((uint32_t)PHYReg<<6U) & ETH_MACMIIAR_MR);                 /* Set the PHY register address */
 8042312:	018c      	lsls	r4, r1, #6
 8042314:	f404 64f8 	and.w	r4, r4, #1984	; 0x7c0
 8042318:	431c      	orrs	r4, r3
  tmpreg1 |= ETH_MACMIIAR_MB;                                           /* Set the MII Busy bit */
 804231a:	f044 0403 	orr.w	r4, r4, #3
  heth->Instance->MACMIIDR = (uint16_t)RegValue;
 804231e:	b292      	uxth	r2, r2
 8042320:	6172      	str	r2, [r6, #20]
  heth->Instance->MACMIIAR = tmpreg1;
 8042322:	682b      	ldr	r3, [r5, #0]
 8042324:	611c      	str	r4, [r3, #16]
  tickstart = HAL_GetTick();
 8042326:	f7fe febb 	bl	80410a0 <HAL_GetTick>
 804232a:	4606      	mov	r6, r0
  while((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
 804232c:	f014 0f01 	tst.w	r4, #1
 8042330:	d010      	beq.n	8042354 <HAL_ETH_WritePHYRegister+0x66>
    if((HAL_GetTick() - tickstart ) > PHY_WRITE_TO)
 8042332:	f7fe feb5 	bl	80410a0 <HAL_GetTick>
 8042336:	1b83      	subs	r3, r0, r6
 8042338:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 804233c:	d202      	bcs.n	8042344 <HAL_ETH_WritePHYRegister+0x56>
    tmpreg1 = heth->Instance->MACMIIAR;
 804233e:	682b      	ldr	r3, [r5, #0]
 8042340:	691c      	ldr	r4, [r3, #16]
 8042342:	e7f3      	b.n	804232c <HAL_ETH_WritePHYRegister+0x3e>
      heth->State= HAL_ETH_STATE_READY;
 8042344:	2301      	movs	r3, #1
 8042346:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
      __HAL_UNLOCK(heth);
 804234a:	2300      	movs	r3, #0
 804234c:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
      return HAL_TIMEOUT;
 8042350:	2003      	movs	r0, #3
 8042352:	e003      	b.n	804235c <HAL_ETH_WritePHYRegister+0x6e>
  heth->State = HAL_ETH_STATE_READY;
 8042354:	2301      	movs	r3, #1
 8042356:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
  return HAL_OK; 
 804235a:	2000      	movs	r0, #0
}
 804235c:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 804235e:	2002      	movs	r0, #2
}
 8042360:	4770      	bx	lr
	...

08042364 <HAL_ETH_Init>:
{
 8042364:	b570      	push	{r4, r5, r6, lr}
 8042366:	b082      	sub	sp, #8
  uint32_t tmpreg1 = 0U, phyreg = 0U;
 8042368:	2300      	movs	r3, #0
 804236a:	9301      	str	r3, [sp, #4]
  if(heth == NULL)
 804236c:	2800      	cmp	r0, #0
 804236e:	f000 810e 	beq.w	804258e <HAL_ETH_Init+0x22a>
 8042372:	4604      	mov	r4, r0
  if(heth->State == HAL_ETH_STATE_RESET)
 8042374:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8042378:	2b00      	cmp	r3, #0
 804237a:	d034      	beq.n	80423e6 <HAL_ETH_Init+0x82>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 804237c:	2300      	movs	r3, #0
 804237e:	9300      	str	r3, [sp, #0]
 8042380:	4b84      	ldr	r3, [pc, #528]	; (8042594 <HAL_ETH_Init+0x230>)
 8042382:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8042384:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8042388:	645a      	str	r2, [r3, #68]	; 0x44
 804238a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 804238c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8042390:	9300      	str	r3, [sp, #0]
 8042392:	9b00      	ldr	r3, [sp, #0]
  SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8042394:	4b80      	ldr	r3, [pc, #512]	; (8042598 <HAL_ETH_Init+0x234>)
 8042396:	685a      	ldr	r2, [r3, #4]
 8042398:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 804239c:	605a      	str	r2, [r3, #4]
  SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 804239e:	685a      	ldr	r2, [r3, #4]
 80423a0:	6a21      	ldr	r1, [r4, #32]
 80423a2:	430a      	orrs	r2, r1
 80423a4:	605a      	str	r2, [r3, #4]
  (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
 80423a6:	6823      	ldr	r3, [r4, #0]
 80423a8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80423ac:	681a      	ldr	r2, [r3, #0]
 80423ae:	f042 0201 	orr.w	r2, r2, #1
 80423b2:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 80423b4:	f7fe fe74 	bl	80410a0 <HAL_GetTick>
 80423b8:	4605      	mov	r5, r0
  while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 80423ba:	6823      	ldr	r3, [r4, #0]
 80423bc:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 80423c0:	6812      	ldr	r2, [r2, #0]
 80423c2:	f012 0f01 	tst.w	r2, #1
 80423c6:	d013      	beq.n	80423f0 <HAL_ETH_Init+0x8c>
    if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_SWRESET)
 80423c8:	f7fe fe6a 	bl	80410a0 <HAL_GetTick>
 80423cc:	1b40      	subs	r0, r0, r5
 80423ce:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 80423d2:	d9f2      	bls.n	80423ba <HAL_ETH_Init+0x56>
      heth->State= HAL_ETH_STATE_TIMEOUT;
 80423d4:	2503      	movs	r5, #3
 80423d6:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      __HAL_UNLOCK(heth);
 80423da:	2300      	movs	r3, #0
 80423dc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
}
 80423e0:	4628      	mov	r0, r5
 80423e2:	b002      	add	sp, #8
 80423e4:	bd70      	pop	{r4, r5, r6, pc}
    heth->Lock = HAL_UNLOCKED;
 80423e6:	f880 3045 	strb.w	r3, [r0, #69]	; 0x45
    HAL_ETH_MspInit(heth);
 80423ea:	f009 fae9 	bl	804b9c0 <HAL_ETH_MspInit>
 80423ee:	e7c5      	b.n	804237c <HAL_ETH_Init+0x18>
  tmpreg1 = (heth->Instance)->MACMIIAR;
 80423f0:	691d      	ldr	r5, [r3, #16]
  tmpreg1 &= ETH_MACMIIAR_CR_MASK;
 80423f2:	f025 051c 	bic.w	r5, r5, #28
  hclk = HAL_RCC_GetHCLKFreq();
 80423f6:	f001 fffd 	bl	80443f4 <HAL_RCC_GetHCLKFreq>
  if((hclk >= 20000000U)&&(hclk < 35000000U))
 80423fa:	4b68      	ldr	r3, [pc, #416]	; (804259c <HAL_ETH_Init+0x238>)
 80423fc:	4403      	add	r3, r0
 80423fe:	4a68      	ldr	r2, [pc, #416]	; (80425a0 <HAL_ETH_Init+0x23c>)
 8042400:	4293      	cmp	r3, r2
 8042402:	d255      	bcs.n	80424b0 <HAL_ETH_Init+0x14c>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 8042404:	f045 0508 	orr.w	r5, r5, #8
  (heth->Instance)->MACMIIAR = (uint32_t)tmpreg1;
 8042408:	6823      	ldr	r3, [r4, #0]
 804240a:	611d      	str	r5, [r3, #16]
  if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
 804240c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8042410:	2100      	movs	r1, #0
 8042412:	4620      	mov	r0, r4
 8042414:	f7ff ff6b 	bl	80422ee <HAL_ETH_WritePHYRegister>
 8042418:	4605      	mov	r5, r0
 804241a:	2800      	cmp	r0, #0
 804241c:	d160      	bne.n	80424e0 <HAL_ETH_Init+0x17c>
  HAL_Delay(PHY_RESET_DELAY);
 804241e:	20ff      	movs	r0, #255	; 0xff
 8042420:	f7fe fe44 	bl	80410ac <HAL_Delay>
  if((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
 8042424:	6863      	ldr	r3, [r4, #4]
 8042426:	2b00      	cmp	r3, #0
 8042428:	f000 8091 	beq.w	804254e <HAL_ETH_Init+0x1ea>
    tickstart = HAL_GetTick();
 804242c:	f7fe fe38 	bl	80410a0 <HAL_GetTick>
 8042430:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8042432:	aa01      	add	r2, sp, #4
 8042434:	2101      	movs	r1, #1
 8042436:	4620      	mov	r0, r4
 8042438:	f7ff ff1d 	bl	8042276 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_LINKED_STATE)
 804243c:	f7fe fe30 	bl	80410a0 <HAL_GetTick>
 8042440:	1b80      	subs	r0, r0, r6
 8042442:	f241 3388 	movw	r3, #5000	; 0x1388
 8042446:	4298      	cmp	r0, r3
 8042448:	d852      	bhi.n	80424f0 <HAL_ETH_Init+0x18c>
    } while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
 804244a:	9b01      	ldr	r3, [sp, #4]
 804244c:	f013 0f04 	tst.w	r3, #4
 8042450:	d0ef      	beq.n	8042432 <HAL_ETH_Init+0xce>
    if((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
 8042452:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8042456:	2100      	movs	r1, #0
 8042458:	4620      	mov	r0, r4
 804245a:	f7ff ff48 	bl	80422ee <HAL_ETH_WritePHYRegister>
 804245e:	2800      	cmp	r0, #0
 8042460:	d152      	bne.n	8042508 <HAL_ETH_Init+0x1a4>
    tickstart = HAL_GetTick();
 8042462:	f7fe fe1d 	bl	80410a0 <HAL_GetTick>
 8042466:	4606      	mov	r6, r0
      HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
 8042468:	aa01      	add	r2, sp, #4
 804246a:	2101      	movs	r1, #1
 804246c:	4620      	mov	r0, r4
 804246e:	f7ff ff02 	bl	8042276 <HAL_ETH_ReadPHYRegister>
      if((HAL_GetTick() - tickstart ) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
 8042472:	f7fe fe15 	bl	80410a0 <HAL_GetTick>
 8042476:	1b80      	subs	r0, r0, r6
 8042478:	f241 3388 	movw	r3, #5000	; 0x1388
 804247c:	4298      	cmp	r0, r3
 804247e:	d84b      	bhi.n	8042518 <HAL_ETH_Init+0x1b4>
    } while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
 8042480:	9b01      	ldr	r3, [sp, #4]
 8042482:	f013 0f20 	tst.w	r3, #32
 8042486:	d0ef      	beq.n	8042468 <HAL_ETH_Init+0x104>
    if((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
 8042488:	aa01      	add	r2, sp, #4
 804248a:	211f      	movs	r1, #31
 804248c:	4620      	mov	r0, r4
 804248e:	f7ff fef2 	bl	8042276 <HAL_ETH_ReadPHYRegister>
 8042492:	2800      	cmp	r0, #0
 8042494:	d14c      	bne.n	8042530 <HAL_ETH_Init+0x1cc>
    if((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 8042496:	9b01      	ldr	r3, [sp, #4]
 8042498:	f013 0f10 	tst.w	r3, #16
 804249c:	d050      	beq.n	8042540 <HAL_ETH_Init+0x1dc>
      (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;  
 804249e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80424a2:	60e2      	str	r2, [r4, #12]
    if((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
 80424a4:	f013 0f04 	tst.w	r3, #4
 80424a8:	d04d      	beq.n	8042546 <HAL_ETH_Init+0x1e2>
      (heth->Init).Speed = ETH_SPEED_10M; 
 80424aa:	2300      	movs	r3, #0
 80424ac:	60a3      	str	r3, [r4, #8]
 80424ae:	e05e      	b.n	804256e <HAL_ETH_Init+0x20a>
  else if((hclk >= 35000000U)&&(hclk < 60000000U))
 80424b0:	4b3c      	ldr	r3, [pc, #240]	; (80425a4 <HAL_ETH_Init+0x240>)
 80424b2:	4403      	add	r3, r0
 80424b4:	4a3c      	ldr	r2, [pc, #240]	; (80425a8 <HAL_ETH_Init+0x244>)
 80424b6:	4293      	cmp	r3, r2
 80424b8:	d802      	bhi.n	80424c0 <HAL_ETH_Init+0x15c>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div26;
 80424ba:	f045 050c 	orr.w	r5, r5, #12
 80424be:	e7a3      	b.n	8042408 <HAL_ETH_Init+0xa4>
  else if((hclk >= 60000000U)&&(hclk < 100000000U))
 80424c0:	4b3a      	ldr	r3, [pc, #232]	; (80425ac <HAL_ETH_Init+0x248>)
 80424c2:	4403      	add	r3, r0
 80424c4:	4a3a      	ldr	r2, [pc, #232]	; (80425b0 <HAL_ETH_Init+0x24c>)
 80424c6:	4293      	cmp	r3, r2
 80424c8:	d39e      	bcc.n	8042408 <HAL_ETH_Init+0xa4>
  else if((hclk >= 100000000U)&&(hclk < 150000000U))
 80424ca:	4b3a      	ldr	r3, [pc, #232]	; (80425b4 <HAL_ETH_Init+0x250>)
 80424cc:	4403      	add	r3, r0
 80424ce:	4a3a      	ldr	r2, [pc, #232]	; (80425b8 <HAL_ETH_Init+0x254>)
 80424d0:	4293      	cmp	r3, r2
 80424d2:	d802      	bhi.n	80424da <HAL_ETH_Init+0x176>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 80424d4:	f045 0504 	orr.w	r5, r5, #4
 80424d8:	e796      	b.n	8042408 <HAL_ETH_Init+0xa4>
    tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_Div102;    
 80424da:	f045 0510 	orr.w	r5, r5, #16
 80424de:	e793      	b.n	8042408 <HAL_ETH_Init+0xa4>
    ETH_MACDMAConfig(heth, err);
 80424e0:	2101      	movs	r1, #1
 80424e2:	4620      	mov	r0, r4
 80424e4:	f7ff fcf2 	bl	8041ecc <ETH_MACDMAConfig>
    heth->State = HAL_ETH_STATE_READY;
 80424e8:	2501      	movs	r5, #1
 80424ea:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
    return HAL_ERROR;
 80424ee:	e777      	b.n	80423e0 <HAL_ETH_Init+0x7c>
        ETH_MACDMAConfig(heth, err);
 80424f0:	2101      	movs	r1, #1
 80424f2:	4620      	mov	r0, r4
 80424f4:	f7ff fcea 	bl	8041ecc <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 80424f8:	2301      	movs	r3, #1
 80424fa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 80424fe:	2300      	movs	r3, #0
 8042500:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 8042504:	2503      	movs	r5, #3
 8042506:	e76b      	b.n	80423e0 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 8042508:	2101      	movs	r1, #1
 804250a:	4620      	mov	r0, r4
 804250c:	f7ff fcde 	bl	8041ecc <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8042510:	2501      	movs	r5, #1
 8042512:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 8042516:	e763      	b.n	80423e0 <HAL_ETH_Init+0x7c>
        ETH_MACDMAConfig(heth, err);
 8042518:	2101      	movs	r1, #1
 804251a:	4620      	mov	r0, r4
 804251c:	f7ff fcd6 	bl	8041ecc <ETH_MACDMAConfig>
        heth->State= HAL_ETH_STATE_READY;
 8042520:	2301      	movs	r3, #1
 8042522:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(heth);
 8042526:	2300      	movs	r3, #0
 8042528:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
        return HAL_TIMEOUT;
 804252c:	2503      	movs	r5, #3
 804252e:	e757      	b.n	80423e0 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 8042530:	2101      	movs	r1, #1
 8042532:	4620      	mov	r0, r4
 8042534:	f7ff fcca 	bl	8041ecc <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8042538:	2501      	movs	r5, #1
 804253a:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;   
 804253e:	e74f      	b.n	80423e0 <HAL_ETH_Init+0x7c>
      (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;           
 8042540:	2200      	movs	r2, #0
 8042542:	60e2      	str	r2, [r4, #12]
 8042544:	e7ae      	b.n	80424a4 <HAL_ETH_Init+0x140>
      (heth->Init).Speed = ETH_SPEED_100M;
 8042546:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 804254a:	60a3      	str	r3, [r4, #8]
 804254c:	e00f      	b.n	804256e <HAL_ETH_Init+0x20a>
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 804254e:	68e2      	ldr	r2, [r4, #12]
 8042550:	f3c2 02cf 	ubfx	r2, r2, #3, #16
                                                (uint16_t)((heth->Init).Speed >> 1U))) != HAL_OK)
 8042554:	68a3      	ldr	r3, [r4, #8]
 8042556:	f3c3 034f 	ubfx	r3, r3, #1, #16
    if(HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
 804255a:	431a      	orrs	r2, r3
 804255c:	2100      	movs	r1, #0
 804255e:	4620      	mov	r0, r4
 8042560:	f7ff fec5 	bl	80422ee <HAL_ETH_WritePHYRegister>
 8042564:	b958      	cbnz	r0, 804257e <HAL_ETH_Init+0x21a>
    HAL_Delay(PHY_CONFIG_DELAY);
 8042566:	f640 70ff 	movw	r0, #4095	; 0xfff
 804256a:	f7fe fd9f 	bl	80410ac <HAL_Delay>
  ETH_MACDMAConfig(heth, err);
 804256e:	2100      	movs	r1, #0
 8042570:	4620      	mov	r0, r4
 8042572:	f7ff fcab 	bl	8041ecc <ETH_MACDMAConfig>
  heth->State= HAL_ETH_STATE_READY;
 8042576:	2301      	movs	r3, #1
 8042578:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
  return HAL_OK;
 804257c:	e730      	b.n	80423e0 <HAL_ETH_Init+0x7c>
      ETH_MACDMAConfig(heth, err);
 804257e:	2101      	movs	r1, #1
 8042580:	4620      	mov	r0, r4
 8042582:	f7ff fca3 	bl	8041ecc <ETH_MACDMAConfig>
      heth->State = HAL_ETH_STATE_READY;
 8042586:	2501      	movs	r5, #1
 8042588:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
      return HAL_ERROR;
 804258c:	e728      	b.n	80423e0 <HAL_ETH_Init+0x7c>
    return HAL_ERROR;
 804258e:	2501      	movs	r5, #1
 8042590:	e726      	b.n	80423e0 <HAL_ETH_Init+0x7c>
 8042592:	bf00      	nop
 8042594:	40023800 	.word	0x40023800
 8042598:	40013800 	.word	0x40013800
 804259c:	feced300 	.word	0xfeced300
 80425a0:	00e4e1c0 	.word	0x00e4e1c0
 80425a4:	fde9f140 	.word	0xfde9f140
 80425a8:	017d783f 	.word	0x017d783f
 80425ac:	fc6c7900 	.word	0xfc6c7900
 80425b0:	02625a00 	.word	0x02625a00
 80425b4:	fa0a1f00 	.word	0xfa0a1f00
 80425b8:	02faf07f 	.word	0x02faf07f

080425bc <HAL_ETH_Start>:
{  
 80425bc:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(heth);
 80425be:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 80425c2:	2b01      	cmp	r3, #1
 80425c4:	d01a      	beq.n	80425fc <HAL_ETH_Start+0x40>
 80425c6:	4604      	mov	r4, r0
 80425c8:	2501      	movs	r5, #1
 80425ca:	f880 5045 	strb.w	r5, [r0, #69]	; 0x45
  heth->State = HAL_ETH_STATE_BUSY;
 80425ce:	2302      	movs	r3, #2
 80425d0:	f880 3044 	strb.w	r3, [r0, #68]	; 0x44
  ETH_MACTransmissionEnable(heth);
 80425d4:	f7ff fc38 	bl	8041e48 <ETH_MACTransmissionEnable>
  ETH_MACReceptionEnable(heth);
 80425d8:	4620      	mov	r0, r4
 80425da:	f7ff fc4a 	bl	8041e72 <ETH_MACReceptionEnable>
  ETH_FlushTransmitFIFO(heth);
 80425de:	4620      	mov	r0, r4
 80425e0:	f7ff fc5c 	bl	8041e9c <ETH_FlushTransmitFIFO>
  ETH_DMATransmissionEnable(heth);
 80425e4:	4620      	mov	r0, r4
 80425e6:	f7ff fc09 	bl	8041dfc <ETH_DMATransmissionEnable>
  ETH_DMAReceptionEnable(heth);
 80425ea:	4620      	mov	r0, r4
 80425ec:	f7ff fc0e 	bl	8041e0c <ETH_DMAReceptionEnable>
  heth->State= HAL_ETH_STATE_READY;
 80425f0:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
  __HAL_UNLOCK(heth);
 80425f4:	2000      	movs	r0, #0
 80425f6:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
}
 80425fa:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(heth);
 80425fc:	2002      	movs	r0, #2
 80425fe:	e7fc      	b.n	80425fa <HAL_ETH_Start+0x3e>

08042600 <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 8042600:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042602:	4909      	ldr	r1, [pc, #36]	; (8042628 <FLASH_Program_DoubleWord+0x28>)
 8042604:	690c      	ldr	r4, [r1, #16]
 8042606:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 804260a:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 804260c:	690c      	ldr	r4, [r1, #16]
 804260e:	f444 7440 	orr.w	r4, r4, #768	; 0x300
 8042612:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_CR_PG;
 8042614:	690c      	ldr	r4, [r1, #16]
 8042616:	f044 0401 	orr.w	r4, r4, #1
 804261a:	610c      	str	r4, [r1, #16]

  /* Program the double-word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 804261c:	6002      	str	r2, [r0, #0]
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 804261e:	6043      	str	r3, [r0, #4]
}
 8042620:	f85d 4b04 	ldr.w	r4, [sp], #4
 8042624:	4770      	bx	lr
 8042626:	bf00      	nop
 8042628:	40023c00 	.word	0x40023c00

0804262c <FLASH_Program_Word>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 804262c:	4b07      	ldr	r3, [pc, #28]	; (804264c <FLASH_Program_Word+0x20>)
 804262e:	691a      	ldr	r2, [r3, #16]
 8042630:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8042634:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8042636:	691a      	ldr	r2, [r3, #16]
 8042638:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 804263c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 804263e:	691a      	ldr	r2, [r3, #16]
 8042640:	f042 0201 	orr.w	r2, r2, #1
 8042644:	611a      	str	r2, [r3, #16]

  *(__IO uint32_t*)Address = Data;
 8042646:	6001      	str	r1, [r0, #0]
}
 8042648:	4770      	bx	lr
 804264a:	bf00      	nop
 804264c:	40023c00 	.word	0x40023c00

08042650 <FLASH_Program_HalfWord>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042650:	4b07      	ldr	r3, [pc, #28]	; (8042670 <FLASH_Program_HalfWord+0x20>)
 8042652:	691a      	ldr	r2, [r3, #16]
 8042654:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8042658:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 804265a:	691a      	ldr	r2, [r3, #16]
 804265c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8042660:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8042662:	691a      	ldr	r2, [r3, #16]
 8042664:	f042 0201 	orr.w	r2, r2, #1
 8042668:	611a      	str	r2, [r3, #16]

  *(__IO uint16_t*)Address = Data;
 804266a:	8001      	strh	r1, [r0, #0]
}
 804266c:	4770      	bx	lr
 804266e:	bf00      	nop
 8042670:	40023c00 	.word	0x40023c00

08042674 <FLASH_Program_Byte>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042674:	4b06      	ldr	r3, [pc, #24]	; (8042690 <FLASH_Program_Byte+0x1c>)
 8042676:	691a      	ldr	r2, [r3, #16]
 8042678:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 804267c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 804267e:	691a      	ldr	r2, [r3, #16]
 8042680:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8042682:	691a      	ldr	r2, [r3, #16]
 8042684:	f042 0201 	orr.w	r2, r2, #1
 8042688:	611a      	str	r2, [r3, #16]

  *(__IO uint8_t*)Address = Data;
 804268a:	7001      	strb	r1, [r0, #0]
}
 804268c:	4770      	bx	lr
 804268e:	bf00      	nop
 8042690:	40023c00 	.word	0x40023c00

08042694 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8042694:	4b27      	ldr	r3, [pc, #156]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 8042696:	68db      	ldr	r3, [r3, #12]
 8042698:	f013 0f10 	tst.w	r3, #16
 804269c:	d007      	beq.n	80426ae <FLASH_SetErrorCode+0x1a>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 804269e:	4a26      	ldr	r2, [pc, #152]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 80426a0:	69d3      	ldr	r3, [r2, #28]
 80426a2:	f043 0310 	orr.w	r3, r3, #16
 80426a6:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 80426a8:	4b22      	ldr	r3, [pc, #136]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426aa:	2210      	movs	r2, #16
 80426ac:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 80426ae:	4b21      	ldr	r3, [pc, #132]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426b0:	68db      	ldr	r3, [r3, #12]
 80426b2:	f013 0f20 	tst.w	r3, #32
 80426b6:	d007      	beq.n	80426c8 <FLASH_SetErrorCode+0x34>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 80426b8:	4a1f      	ldr	r2, [pc, #124]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 80426ba:	69d3      	ldr	r3, [r2, #28]
 80426bc:	f043 0308 	orr.w	r3, r3, #8
 80426c0:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 80426c2:	4b1c      	ldr	r3, [pc, #112]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426c4:	2220      	movs	r2, #32
 80426c6:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 80426c8:	4b1a      	ldr	r3, [pc, #104]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426ca:	68db      	ldr	r3, [r3, #12]
 80426cc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80426d0:	d007      	beq.n	80426e2 <FLASH_SetErrorCode+0x4e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 80426d2:	4a19      	ldr	r2, [pc, #100]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 80426d4:	69d3      	ldr	r3, [r2, #28]
 80426d6:	f043 0304 	orr.w	r3, r3, #4
 80426da:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 80426dc:	4b15      	ldr	r3, [pc, #84]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426de:	2240      	movs	r2, #64	; 0x40
 80426e0:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 80426e2:	4b14      	ldr	r3, [pc, #80]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426e4:	68db      	ldr	r3, [r3, #12]
 80426e6:	f013 0f80 	tst.w	r3, #128	; 0x80
 80426ea:	d007      	beq.n	80426fc <FLASH_SetErrorCode+0x68>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 80426ec:	4a12      	ldr	r2, [pc, #72]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 80426ee:	69d3      	ldr	r3, [r2, #28]
 80426f0:	f043 0302 	orr.w	r3, r3, #2
 80426f4:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 80426f6:	4b0f      	ldr	r3, [pc, #60]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426f8:	2280      	movs	r2, #128	; 0x80
 80426fa:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 80426fc:	4b0d      	ldr	r3, [pc, #52]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 80426fe:	68db      	ldr	r3, [r3, #12]
 8042700:	f413 7f80 	tst.w	r3, #256	; 0x100
 8042704:	d008      	beq.n	8042718 <FLASH_SetErrorCode+0x84>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8042706:	4a0c      	ldr	r2, [pc, #48]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 8042708:	69d3      	ldr	r3, [r2, #28]
 804270a:	f043 0301 	orr.w	r3, r3, #1
 804270e:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8042710:	4b08      	ldr	r3, [pc, #32]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 8042712:	f44f 7280 	mov.w	r2, #256	; 0x100
 8042716:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8042718:	4b06      	ldr	r3, [pc, #24]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 804271a:	68db      	ldr	r3, [r3, #12]
 804271c:	f013 0f02 	tst.w	r3, #2
 8042720:	d007      	beq.n	8042732 <FLASH_SetErrorCode+0x9e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8042722:	4a05      	ldr	r2, [pc, #20]	; (8042738 <FLASH_SetErrorCode+0xa4>)
 8042724:	69d3      	ldr	r3, [r2, #28]
 8042726:	f043 0320 	orr.w	r3, r3, #32
 804272a:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 804272c:	4b01      	ldr	r3, [pc, #4]	; (8042734 <FLASH_SetErrorCode+0xa0>)
 804272e:	2202      	movs	r2, #2
 8042730:	60da      	str	r2, [r3, #12]
  }
}
 8042732:	4770      	bx	lr
 8042734:	40023c00 	.word	0x40023c00
 8042738:	2000544c 	.word	0x2000544c

0804273c <HAL_FLASH_EndOfOperationCallback>:
}
 804273c:	4770      	bx	lr

0804273e <HAL_FLASH_OperationErrorCallback>:
}
 804273e:	4770      	bx	lr

08042740 <HAL_FLASH_IRQHandler>:
{
 8042740:	b510      	push	{r4, lr}
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 8042742:	4b3b      	ldr	r3, [pc, #236]	; (8042830 <HAL_FLASH_IRQHandler+0xf0>)
 8042744:	68db      	ldr	r3, [r3, #12]
 8042746:	f413 7ff9 	tst.w	r3, #498	; 0x1f2
 804274a:	d013      	beq.n	8042774 <HAL_FLASH_IRQHandler+0x34>
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
 804274c:	4b39      	ldr	r3, [pc, #228]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 804274e:	781b      	ldrb	r3, [r3, #0]
 8042750:	b2db      	uxtb	r3, r3
 8042752:	2b01      	cmp	r3, #1
 8042754:	d03d      	beq.n	80427d2 <HAL_FLASH_IRQHandler+0x92>
    else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
 8042756:	4b37      	ldr	r3, [pc, #220]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042758:	781b      	ldrb	r3, [r3, #0]
 804275a:	b2db      	uxtb	r3, r3
 804275c:	2b02      	cmp	r3, #2
 804275e:	d03e      	beq.n	80427de <HAL_FLASH_IRQHandler+0x9e>
      addresstmp = pFlash.Address;
 8042760:	4b34      	ldr	r3, [pc, #208]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042762:	695c      	ldr	r4, [r3, #20]
    FLASH_SetErrorCode();
 8042764:	f7ff ff96 	bl	8042694 <FLASH_SetErrorCode>
    HAL_FLASH_OperationErrorCallback(addresstmp);
 8042768:	4620      	mov	r0, r4
 804276a:	f7ff ffe8 	bl	804273e <HAL_FLASH_OperationErrorCallback>
    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 804276e:	4b31      	ldr	r3, [pc, #196]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042770:	2200      	movs	r2, #0
 8042772:	701a      	strb	r2, [r3, #0]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8042774:	4b2e      	ldr	r3, [pc, #184]	; (8042830 <HAL_FLASH_IRQHandler+0xf0>)
 8042776:	68db      	ldr	r3, [r3, #12]
 8042778:	f013 0f01 	tst.w	r3, #1
 804277c:	d013      	beq.n	80427a6 <HAL_FLASH_IRQHandler+0x66>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 804277e:	4b2c      	ldr	r3, [pc, #176]	; (8042830 <HAL_FLASH_IRQHandler+0xf0>)
 8042780:	2201      	movs	r2, #1
 8042782:	60da      	str	r2, [r3, #12]
    if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
 8042784:	4b2b      	ldr	r3, [pc, #172]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042786:	781b      	ldrb	r3, [r3, #0]
 8042788:	b2db      	uxtb	r3, r3
 804278a:	4293      	cmp	r3, r2
 804278c:	d02a      	beq.n	80427e4 <HAL_FLASH_IRQHandler+0xa4>
      if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE) 
 804278e:	4b29      	ldr	r3, [pc, #164]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042790:	781b      	ldrb	r3, [r3, #0]
 8042792:	b2db      	uxtb	r3, r3
 8042794:	2b02      	cmp	r3, #2
 8042796:	d043      	beq.n	8042820 <HAL_FLASH_IRQHandler+0xe0>
        HAL_FLASH_EndOfOperationCallback(pFlash.Address);
 8042798:	4b26      	ldr	r3, [pc, #152]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 804279a:	6958      	ldr	r0, [r3, #20]
 804279c:	f7ff ffce 	bl	804273c <HAL_FLASH_EndOfOperationCallback>
      pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 80427a0:	4b24      	ldr	r3, [pc, #144]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427a2:	2200      	movs	r2, #0
 80427a4:	701a      	strb	r2, [r3, #0]
  if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
 80427a6:	4b23      	ldr	r3, [pc, #140]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427a8:	781b      	ldrb	r3, [r3, #0]
 80427aa:	b98b      	cbnz	r3, 80427d0 <HAL_FLASH_IRQHandler+0x90>
    CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_SER | FLASH_CR_SNB | FLASH_MER_BIT));
 80427ac:	4b20      	ldr	r3, [pc, #128]	; (8042830 <HAL_FLASH_IRQHandler+0xf0>)
 80427ae:	691a      	ldr	r2, [r3, #16]
 80427b0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80427b4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80427b8:	611a      	str	r2, [r3, #16]
    __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
 80427ba:	691a      	ldr	r2, [r3, #16]
 80427bc:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80427c0:	611a      	str	r2, [r3, #16]
    __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
 80427c2:	691a      	ldr	r2, [r3, #16]
 80427c4:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 80427c8:	611a      	str	r2, [r3, #16]
    __HAL_UNLOCK(&pFlash);
 80427ca:	4b1a      	ldr	r3, [pc, #104]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427cc:	2200      	movs	r2, #0
 80427ce:	761a      	strb	r2, [r3, #24]
}
 80427d0:	bd10      	pop	{r4, pc}
      addresstmp = pFlash.Sector;
 80427d2:	4b18      	ldr	r3, [pc, #96]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427d4:	68dc      	ldr	r4, [r3, #12]
      pFlash.Sector = 0xFFFFFFFFU;
 80427d6:	f04f 32ff 	mov.w	r2, #4294967295
 80427da:	60da      	str	r2, [r3, #12]
 80427dc:	e7c2      	b.n	8042764 <HAL_FLASH_IRQHandler+0x24>
      addresstmp = pFlash.Bank;
 80427de:	4b15      	ldr	r3, [pc, #84]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427e0:	691c      	ldr	r4, [r3, #16]
 80427e2:	e7bf      	b.n	8042764 <HAL_FLASH_IRQHandler+0x24>
      pFlash.NbSectorsToErase--;
 80427e4:	4b13      	ldr	r3, [pc, #76]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427e6:	685a      	ldr	r2, [r3, #4]
 80427e8:	3a01      	subs	r2, #1
 80427ea:	605a      	str	r2, [r3, #4]
      if(pFlash.NbSectorsToErase != 0U)
 80427ec:	685b      	ldr	r3, [r3, #4]
 80427ee:	b15b      	cbz	r3, 8042808 <HAL_FLASH_IRQHandler+0xc8>
        addresstmp = pFlash.Sector;
 80427f0:	4c10      	ldr	r4, [pc, #64]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 80427f2:	68e0      	ldr	r0, [r4, #12]
        HAL_FLASH_EndOfOperationCallback(addresstmp);
 80427f4:	f7ff ffa2 	bl	804273c <HAL_FLASH_EndOfOperationCallback>
        pFlash.Sector++;
 80427f8:	68e3      	ldr	r3, [r4, #12]
 80427fa:	3301      	adds	r3, #1
 80427fc:	60e3      	str	r3, [r4, #12]
        addresstmp = pFlash.Sector;
 80427fe:	68e0      	ldr	r0, [r4, #12]
        FLASH_Erase_Sector(addresstmp, pFlash.VoltageForErase);
 8042800:	7a21      	ldrb	r1, [r4, #8]
 8042802:	f000 f8cf 	bl	80429a4 <FLASH_Erase_Sector>
 8042806:	e7ce      	b.n	80427a6 <HAL_FLASH_IRQHandler+0x66>
        pFlash.Sector = addresstmp = 0xFFFFFFFFU;
 8042808:	4b0a      	ldr	r3, [pc, #40]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 804280a:	f04f 34ff 	mov.w	r4, #4294967295
 804280e:	60dc      	str	r4, [r3, #12]
        pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
 8042810:	2200      	movs	r2, #0
 8042812:	701a      	strb	r2, [r3, #0]
        FLASH_FlushCaches() ;
 8042814:	f000 f8f4 	bl	8042a00 <FLASH_FlushCaches>
        HAL_FLASH_EndOfOperationCallback(addresstmp);
 8042818:	4620      	mov	r0, r4
 804281a:	f7ff ff8f 	bl	804273c <HAL_FLASH_EndOfOperationCallback>
 804281e:	e7c2      	b.n	80427a6 <HAL_FLASH_IRQHandler+0x66>
        FLASH_FlushCaches() ;
 8042820:	f000 f8ee 	bl	8042a00 <FLASH_FlushCaches>
        HAL_FLASH_EndOfOperationCallback(pFlash.Bank);
 8042824:	4b03      	ldr	r3, [pc, #12]	; (8042834 <HAL_FLASH_IRQHandler+0xf4>)
 8042826:	6918      	ldr	r0, [r3, #16]
 8042828:	f7ff ff88 	bl	804273c <HAL_FLASH_EndOfOperationCallback>
 804282c:	e7b8      	b.n	80427a0 <HAL_FLASH_IRQHandler+0x60>
 804282e:	bf00      	nop
 8042830:	40023c00 	.word	0x40023c00
 8042834:	2000544c 	.word	0x2000544c

08042838 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8042838:	4b09      	ldr	r3, [pc, #36]	; (8042860 <HAL_FLASH_Unlock+0x28>)
 804283a:	691b      	ldr	r3, [r3, #16]
 804283c:	2b00      	cmp	r3, #0
 804283e:	db01      	blt.n	8042844 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 8042840:	2000      	movs	r0, #0
 8042842:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8042844:	4b06      	ldr	r3, [pc, #24]	; (8042860 <HAL_FLASH_Unlock+0x28>)
 8042846:	4a07      	ldr	r2, [pc, #28]	; (8042864 <HAL_FLASH_Unlock+0x2c>)
 8042848:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 804284a:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 804284e:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8042850:	691b      	ldr	r3, [r3, #16]
 8042852:	2b00      	cmp	r3, #0
 8042854:	db01      	blt.n	804285a <HAL_FLASH_Unlock+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 8042856:	2000      	movs	r0, #0
 8042858:	4770      	bx	lr
      status = HAL_ERROR;
 804285a:	2001      	movs	r0, #1
}
 804285c:	4770      	bx	lr
 804285e:	bf00      	nop
 8042860:	40023c00 	.word	0x40023c00
 8042864:	45670123 	.word	0x45670123

08042868 <HAL_FLASH_Lock>:
  FLASH->CR |= FLASH_CR_LOCK;
 8042868:	4a03      	ldr	r2, [pc, #12]	; (8042878 <HAL_FLASH_Lock+0x10>)
 804286a:	6913      	ldr	r3, [r2, #16]
 804286c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8042870:	6113      	str	r3, [r2, #16]
}
 8042872:	2000      	movs	r0, #0
 8042874:	4770      	bx	lr
 8042876:	bf00      	nop
 8042878:	40023c00 	.word	0x40023c00

0804287c <FLASH_WaitForLastOperation>:
{ 
 804287c:	b538      	push	{r3, r4, r5, lr}
 804287e:	4604      	mov	r4, r0
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8042880:	4b14      	ldr	r3, [pc, #80]	; (80428d4 <FLASH_WaitForLastOperation+0x58>)
 8042882:	2200      	movs	r2, #0
 8042884:	61da      	str	r2, [r3, #28]
  tickstart = HAL_GetTick();
 8042886:	f7fe fc0b 	bl	80410a0 <HAL_GetTick>
 804288a:	4605      	mov	r5, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 804288c:	4b12      	ldr	r3, [pc, #72]	; (80428d8 <FLASH_WaitForLastOperation+0x5c>)
 804288e:	68db      	ldr	r3, [r3, #12]
 8042890:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8042894:	d00a      	beq.n	80428ac <FLASH_WaitForLastOperation+0x30>
    if(Timeout != HAL_MAX_DELAY)
 8042896:	f1b4 3fff 	cmp.w	r4, #4294967295
 804289a:	d0f7      	beq.n	804288c <FLASH_WaitForLastOperation+0x10>
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 804289c:	b124      	cbz	r4, 80428a8 <FLASH_WaitForLastOperation+0x2c>
 804289e:	f7fe fbff 	bl	80410a0 <HAL_GetTick>
 80428a2:	1b40      	subs	r0, r0, r5
 80428a4:	42a0      	cmp	r0, r4
 80428a6:	d9f1      	bls.n	804288c <FLASH_WaitForLastOperation+0x10>
        return HAL_TIMEOUT;
 80428a8:	2003      	movs	r0, #3
 80428aa:	e00d      	b.n	80428c8 <FLASH_WaitForLastOperation+0x4c>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 80428ac:	4b0a      	ldr	r3, [pc, #40]	; (80428d8 <FLASH_WaitForLastOperation+0x5c>)
 80428ae:	68db      	ldr	r3, [r3, #12]
 80428b0:	f013 0f01 	tst.w	r3, #1
 80428b4:	d002      	beq.n	80428bc <FLASH_WaitForLastOperation+0x40>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80428b6:	4b08      	ldr	r3, [pc, #32]	; (80428d8 <FLASH_WaitForLastOperation+0x5c>)
 80428b8:	2201      	movs	r2, #1
 80428ba:	60da      	str	r2, [r3, #12]
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 80428bc:	4b06      	ldr	r3, [pc, #24]	; (80428d8 <FLASH_WaitForLastOperation+0x5c>)
 80428be:	68db      	ldr	r3, [r3, #12]
 80428c0:	f413 7ff9 	tst.w	r3, #498	; 0x1f2
 80428c4:	d101      	bne.n	80428ca <FLASH_WaitForLastOperation+0x4e>
  return HAL_OK;
 80428c6:	2000      	movs	r0, #0
}  
 80428c8:	bd38      	pop	{r3, r4, r5, pc}
    FLASH_SetErrorCode();
 80428ca:	f7ff fee3 	bl	8042694 <FLASH_SetErrorCode>
    return HAL_ERROR;
 80428ce:	2001      	movs	r0, #1
 80428d0:	e7fa      	b.n	80428c8 <FLASH_WaitForLastOperation+0x4c>
 80428d2:	bf00      	nop
 80428d4:	2000544c 	.word	0x2000544c
 80428d8:	40023c00 	.word	0x40023c00

080428dc <HAL_FLASH_Program>:
{
 80428dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80428de:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
 80428e0:	4a1b      	ldr	r2, [pc, #108]	; (8042950 <HAL_FLASH_Program+0x74>)
 80428e2:	7e12      	ldrb	r2, [r2, #24]
 80428e4:	2a01      	cmp	r2, #1
 80428e6:	d030      	beq.n	804294a <HAL_FLASH_Program+0x6e>
 80428e8:	4604      	mov	r4, r0
 80428ea:	460d      	mov	r5, r1
 80428ec:	461f      	mov	r7, r3
 80428ee:	4b18      	ldr	r3, [pc, #96]	; (8042950 <HAL_FLASH_Program+0x74>)
 80428f0:	2201      	movs	r2, #1
 80428f2:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80428f4:	f24c 3050 	movw	r0, #50000	; 0xc350
 80428f8:	f7ff ffc0 	bl	804287c <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 80428fc:	b990      	cbnz	r0, 8042924 <HAL_FLASH_Program+0x48>
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 80428fe:	b1ac      	cbz	r4, 804292c <HAL_FLASH_Program+0x50>
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 8042900:	2c01      	cmp	r4, #1
 8042902:	d018      	beq.n	8042936 <HAL_FLASH_Program+0x5a>
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8042904:	2c02      	cmp	r4, #2
 8042906:	d01b      	beq.n	8042940 <HAL_FLASH_Program+0x64>
      FLASH_Program_DoubleWord(Address, Data);
 8042908:	4632      	mov	r2, r6
 804290a:	463b      	mov	r3, r7
 804290c:	4628      	mov	r0, r5
 804290e:	f7ff fe77 	bl	8042600 <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042912:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042916:	f7ff ffb1 	bl	804287c <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);  
 804291a:	4a0e      	ldr	r2, [pc, #56]	; (8042954 <HAL_FLASH_Program+0x78>)
 804291c:	6913      	ldr	r3, [r2, #16]
 804291e:	f023 0301 	bic.w	r3, r3, #1
 8042922:	6113      	str	r3, [r2, #16]
  __HAL_UNLOCK(&pFlash);
 8042924:	4b0a      	ldr	r3, [pc, #40]	; (8042950 <HAL_FLASH_Program+0x74>)
 8042926:	2200      	movs	r2, #0
 8042928:	761a      	strb	r2, [r3, #24]
}
 804292a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_Byte(Address, (uint8_t) Data);
 804292c:	b2f1      	uxtb	r1, r6
 804292e:	4628      	mov	r0, r5
 8042930:	f7ff fea0 	bl	8042674 <FLASH_Program_Byte>
 8042934:	e7ed      	b.n	8042912 <HAL_FLASH_Program+0x36>
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8042936:	b2b1      	uxth	r1, r6
 8042938:	4628      	mov	r0, r5
 804293a:	f7ff fe89 	bl	8042650 <FLASH_Program_HalfWord>
 804293e:	e7e8      	b.n	8042912 <HAL_FLASH_Program+0x36>
      FLASH_Program_Word(Address, (uint32_t) Data);
 8042940:	4631      	mov	r1, r6
 8042942:	4628      	mov	r0, r5
 8042944:	f7ff fe72 	bl	804262c <FLASH_Program_Word>
 8042948:	e7e3      	b.n	8042912 <HAL_FLASH_Program+0x36>
  __HAL_LOCK(&pFlash);
 804294a:	2002      	movs	r0, #2
 804294c:	e7ed      	b.n	804292a <HAL_FLASH_Program+0x4e>
 804294e:	bf00      	nop
 8042950:	2000544c 	.word	0x2000544c
 8042954:	40023c00 	.word	0x40023c00

08042958 <FLASH_MassErase>:
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* if the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8042958:	4a11      	ldr	r2, [pc, #68]	; (80429a0 <FLASH_MassErase+0x48>)
 804295a:	6913      	ldr	r3, [r2, #16]
 804295c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8042960:	6113      	str	r3, [r2, #16]

  if(Banks == FLASH_BANK_BOTH)
 8042962:	2903      	cmp	r1, #3
 8042964:	d00e      	beq.n	8042984 <FLASH_MassErase+0x2c>
  {
    /* bank1 & bank2 will be erased*/
    FLASH->CR |= FLASH_MER_BIT;
  }
  else if(Banks == FLASH_BANK_1)
 8042966:	2901      	cmp	r1, #1
 8042968:	d013      	beq.n	8042992 <FLASH_MassErase+0x3a>
    FLASH->CR |= FLASH_CR_MER1;
  }
  else
  {
    /*Only bank2 will be erased*/
    FLASH->CR |= FLASH_CR_MER2;
 804296a:	4a0d      	ldr	r2, [pc, #52]	; (80429a0 <FLASH_MassErase+0x48>)
 804296c:	6913      	ldr	r3, [r2, #16]
 804296e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8042972:	6113      	str	r3, [r2, #16]
  }
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8U);
 8042974:	4a0a      	ldr	r2, [pc, #40]	; (80429a0 <FLASH_MassErase+0x48>)
 8042976:	6913      	ldr	r3, [r2, #16]
 8042978:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 804297c:	f440 3080 	orr.w	r0, r0, #65536	; 0x10000
 8042980:	6110      	str	r0, [r2, #16]
}
 8042982:	4770      	bx	lr
    FLASH->CR |= FLASH_MER_BIT;
 8042984:	6913      	ldr	r3, [r2, #16]
 8042986:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 804298a:	f043 0304 	orr.w	r3, r3, #4
 804298e:	6113      	str	r3, [r2, #16]
 8042990:	e7f0      	b.n	8042974 <FLASH_MassErase+0x1c>
    FLASH->CR |= FLASH_CR_MER1;
 8042992:	4a03      	ldr	r2, [pc, #12]	; (80429a0 <FLASH_MassErase+0x48>)
 8042994:	6913      	ldr	r3, [r2, #16]
 8042996:	f043 0304 	orr.w	r3, r3, #4
 804299a:	6113      	str	r3, [r2, #16]
 804299c:	e7ea      	b.n	8042974 <FLASH_MassErase+0x1c>
 804299e:	bf00      	nop
 80429a0:	40023c00 	.word	0x40023c00

080429a4 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  * 
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 80429a4:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == FLASH_VOLTAGE_RANGE_1)
 80429a6:	b149      	cbz	r1, 80429bc <FLASH_Erase_Sector+0x18>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_2)
 80429a8:	2901      	cmp	r1, #1
 80429aa:	d024      	beq.n	80429f6 <FLASH_Erase_Sector+0x52>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
  }
  else if(VoltageRange == FLASH_VOLTAGE_RANGE_3)
 80429ac:	2902      	cmp	r1, #2
 80429ae:	d002      	beq.n	80429b6 <FLASH_Erase_Sector+0x12>
  {
    tmp_psize = FLASH_PSIZE_WORD;
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 80429b0:	f44f 7440 	mov.w	r4, #768	; 0x300
 80429b4:	e003      	b.n	80429be <FLASH_Erase_Sector+0x1a>
    tmp_psize = FLASH_PSIZE_WORD;
 80429b6:	f44f 7400 	mov.w	r4, #512	; 0x200
 80429ba:	e000      	b.n	80429be <FLASH_Erase_Sector+0x1a>
     tmp_psize = FLASH_PSIZE_BYTE;
 80429bc:	2400      	movs	r4, #0
  }

  /* Need to add offset of 4 when sector higher than FLASH_SECTOR_11 */
  if(Sector > FLASH_SECTOR_11) 
 80429be:	280b      	cmp	r0, #11
 80429c0:	d900      	bls.n	80429c4 <FLASH_Erase_Sector+0x20>
  {
    Sector += 4U;
 80429c2:	3004      	adds	r0, #4
  }
  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80429c4:	4b0d      	ldr	r3, [pc, #52]	; (80429fc <FLASH_Erase_Sector+0x58>)
 80429c6:	6919      	ldr	r1, [r3, #16]
 80429c8:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 80429cc:	6119      	str	r1, [r3, #16]
  FLASH->CR |= tmp_psize;
 80429ce:	691a      	ldr	r2, [r3, #16]
 80429d0:	4322      	orrs	r2, r4
 80429d2:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 80429d4:	691a      	ldr	r2, [r3, #16]
 80429d6:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 80429da:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 80429dc:	691a      	ldr	r2, [r3, #16]
 80429de:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
 80429e2:	f040 0002 	orr.w	r0, r0, #2
 80429e6:	6118      	str	r0, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 80429e8:	691a      	ldr	r2, [r3, #16]
 80429ea:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80429ee:	611a      	str	r2, [r3, #16]
}
 80429f0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80429f4:	4770      	bx	lr
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 80429f6:	f44f 7480 	mov.w	r4, #256	; 0x100
 80429fa:	e7e0      	b.n	80429be <FLASH_Erase_Sector+0x1a>
 80429fc:	40023c00 	.word	0x40023c00

08042a00 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN)!= RESET)
 8042a00:	4b16      	ldr	r3, [pc, #88]	; (8042a5c <FLASH_FlushCaches+0x5c>)
 8042a02:	681b      	ldr	r3, [r3, #0]
 8042a04:	f413 7f00 	tst.w	r3, #512	; 0x200
 8042a08:	d010      	beq.n	8042a2c <FLASH_FlushCaches+0x2c>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8042a0a:	4b14      	ldr	r3, [pc, #80]	; (8042a5c <FLASH_FlushCaches+0x5c>)
 8042a0c:	681a      	ldr	r2, [r3, #0]
 8042a0e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8042a12:	601a      	str	r2, [r3, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8042a14:	681a      	ldr	r2, [r3, #0]
 8042a16:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8042a1a:	601a      	str	r2, [r3, #0]
 8042a1c:	681a      	ldr	r2, [r3, #0]
 8042a1e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8042a22:	601a      	str	r2, [r3, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8042a24:	681a      	ldr	r2, [r3, #0]
 8042a26:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042a2a:	601a      	str	r2, [r3, #0]
  }
  
  /* Flush data cache */
  if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8042a2c:	4b0b      	ldr	r3, [pc, #44]	; (8042a5c <FLASH_FlushCaches+0x5c>)
 8042a2e:	681b      	ldr	r3, [r3, #0]
 8042a30:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8042a34:	d010      	beq.n	8042a58 <FLASH_FlushCaches+0x58>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8042a36:	4b09      	ldr	r3, [pc, #36]	; (8042a5c <FLASH_FlushCaches+0x5c>)
 8042a38:	681a      	ldr	r2, [r3, #0]
 8042a3a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8042a3e:	601a      	str	r2, [r3, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8042a40:	681a      	ldr	r2, [r3, #0]
 8042a42:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8042a46:	601a      	str	r2, [r3, #0]
 8042a48:	681a      	ldr	r2, [r3, #0]
 8042a4a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8042a4e:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8042a50:	681a      	ldr	r2, [r3, #0]
 8042a52:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8042a56:	601a      	str	r2, [r3, #0]
  }
}
 8042a58:	4770      	bx	lr
 8042a5a:	bf00      	nop
 8042a5c:	40023c00 	.word	0x40023c00

08042a60 <HAL_FLASHEx_Erase>:
{
 8042a60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 8042a62:	4b23      	ldr	r3, [pc, #140]	; (8042af0 <HAL_FLASHEx_Erase+0x90>)
 8042a64:	7e1b      	ldrb	r3, [r3, #24]
 8042a66:	2b01      	cmp	r3, #1
 8042a68:	d040      	beq.n	8042aec <HAL_FLASHEx_Erase+0x8c>
 8042a6a:	4604      	mov	r4, r0
 8042a6c:	460e      	mov	r6, r1
 8042a6e:	4b20      	ldr	r3, [pc, #128]	; (8042af0 <HAL_FLASHEx_Erase+0x90>)
 8042a70:	2201      	movs	r2, #1
 8042a72:	761a      	strb	r2, [r3, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042a74:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042a78:	f7ff ff00 	bl	804287c <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8042a7c:	4607      	mov	r7, r0
 8042a7e:	bb80      	cbnz	r0, 8042ae2 <HAL_FLASHEx_Erase+0x82>
    *SectorError = 0xFFFFFFFFU;
 8042a80:	f04f 33ff 	mov.w	r3, #4294967295
 8042a84:	6033      	str	r3, [r6, #0]
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8042a86:	6823      	ldr	r3, [r4, #0]
 8042a88:	2b01      	cmp	r3, #1
 8042a8a:	d016      	beq.n	8042aba <HAL_FLASHEx_Erase+0x5a>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8042a8c:	68a5      	ldr	r5, [r4, #8]
 8042a8e:	68e3      	ldr	r3, [r4, #12]
 8042a90:	68a2      	ldr	r2, [r4, #8]
 8042a92:	4413      	add	r3, r2
 8042a94:	42ab      	cmp	r3, r5
 8042a96:	d922      	bls.n	8042ade <HAL_FLASHEx_Erase+0x7e>
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8042a98:	7c21      	ldrb	r1, [r4, #16]
 8042a9a:	4628      	mov	r0, r5
 8042a9c:	f7ff ff82 	bl	80429a4 <FLASH_Erase_Sector>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042aa0:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042aa4:	f7ff feea 	bl	804287c <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8042aa8:	4a12      	ldr	r2, [pc, #72]	; (8042af4 <HAL_FLASHEx_Erase+0x94>)
 8042aaa:	6913      	ldr	r3, [r2, #16]
 8042aac:	f023 03fa 	bic.w	r3, r3, #250	; 0xfa
 8042ab0:	6113      	str	r3, [r2, #16]
        if(status != HAL_OK) 
 8042ab2:	4607      	mov	r7, r0
 8042ab4:	b990      	cbnz	r0, 8042adc <HAL_FLASHEx_Erase+0x7c>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8042ab6:	3501      	adds	r5, #1
 8042ab8:	e7e9      	b.n	8042a8e <HAL_FLASHEx_Erase+0x2e>
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8042aba:	6861      	ldr	r1, [r4, #4]
 8042abc:	7c20      	ldrb	r0, [r4, #16]
 8042abe:	f7ff ff4b 	bl	8042958 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8042ac2:	f24c 3050 	movw	r0, #50000	; 0xc350
 8042ac6:	f7ff fed9 	bl	804287c <FLASH_WaitForLastOperation>
 8042aca:	4607      	mov	r7, r0
      FLASH->CR &= (~FLASH_MER_BIT);
 8042acc:	4a09      	ldr	r2, [pc, #36]	; (8042af4 <HAL_FLASHEx_Erase+0x94>)
 8042ace:	6913      	ldr	r3, [r2, #16]
 8042ad0:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8042ad4:	f023 0304 	bic.w	r3, r3, #4
 8042ad8:	6113      	str	r3, [r2, #16]
 8042ada:	e000      	b.n	8042ade <HAL_FLASHEx_Erase+0x7e>
          *SectorError = index;
 8042adc:	6035      	str	r5, [r6, #0]
    FLASH_FlushCaches();    
 8042ade:	f7ff ff8f 	bl	8042a00 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 8042ae2:	4b03      	ldr	r3, [pc, #12]	; (8042af0 <HAL_FLASHEx_Erase+0x90>)
 8042ae4:	2200      	movs	r2, #0
 8042ae6:	761a      	strb	r2, [r3, #24]
}
 8042ae8:	4638      	mov	r0, r7
 8042aea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(&pFlash);
 8042aec:	2702      	movs	r7, #2
 8042aee:	e7fb      	b.n	8042ae8 <HAL_FLASHEx_Erase+0x88>
 8042af0:	2000544c 	.word	0x2000544c
 8042af4:	40023c00 	.word	0x40023c00

08042af8 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8042af8:	2300      	movs	r3, #0
 8042afa:	2b0f      	cmp	r3, #15
 8042afc:	f200 80e5 	bhi.w	8042cca <HAL_GPIO_Init+0x1d2>
{
 8042b00:	b4f0      	push	{r4, r5, r6, r7}
 8042b02:	b082      	sub	sp, #8
 8042b04:	e039      	b.n	8042b7a <HAL_GPIO_Init+0x82>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8042b06:	2209      	movs	r2, #9
 8042b08:	e000      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042b0a:	2200      	movs	r2, #0
 8042b0c:	40b2      	lsls	r2, r6
 8042b0e:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2U] = temp;
 8042b10:	3402      	adds	r4, #2
 8042b12:	4e6e      	ldr	r6, [pc, #440]	; (8042ccc <HAL_GPIO_Init+0x1d4>)
 8042b14:	f846 2024 	str.w	r2, [r6, r4, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8042b18:	4a6d      	ldr	r2, [pc, #436]	; (8042cd0 <HAL_GPIO_Init+0x1d8>)
 8042b1a:	6814      	ldr	r4, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8042b1c:	43ea      	mvns	r2, r5
 8042b1e:	ea24 0605 	bic.w	r6, r4, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8042b22:	684f      	ldr	r7, [r1, #4]
 8042b24:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 8042b28:	d001      	beq.n	8042b2e <HAL_GPIO_Init+0x36>
        {
          temp |= iocurrent;
 8042b2a:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->IMR = temp;
 8042b2e:	4c68      	ldr	r4, [pc, #416]	; (8042cd0 <HAL_GPIO_Init+0x1d8>)
 8042b30:	6026      	str	r6, [r4, #0]

        temp = EXTI->EMR;
 8042b32:	6864      	ldr	r4, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 8042b34:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8042b38:	684f      	ldr	r7, [r1, #4]
 8042b3a:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8042b3e:	d001      	beq.n	8042b44 <HAL_GPIO_Init+0x4c>
        {
          temp |= iocurrent;
 8042b40:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->EMR = temp;
 8042b44:	4c62      	ldr	r4, [pc, #392]	; (8042cd0 <HAL_GPIO_Init+0x1d8>)
 8042b46:	6066      	str	r6, [r4, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8042b48:	68a4      	ldr	r4, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 8042b4a:	ea02 0604 	and.w	r6, r2, r4
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8042b4e:	684f      	ldr	r7, [r1, #4]
 8042b50:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 8042b54:	d001      	beq.n	8042b5a <HAL_GPIO_Init+0x62>
        {
          temp |= iocurrent;
 8042b56:	ea45 0604 	orr.w	r6, r5, r4
        }
        EXTI->RTSR = temp;
 8042b5a:	4c5d      	ldr	r4, [pc, #372]	; (8042cd0 <HAL_GPIO_Init+0x1d8>)
 8042b5c:	60a6      	str	r6, [r4, #8]

        temp = EXTI->FTSR;
 8042b5e:	68e4      	ldr	r4, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 8042b60:	4022      	ands	r2, r4
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8042b62:	684e      	ldr	r6, [r1, #4]
 8042b64:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8042b68:	d001      	beq.n	8042b6e <HAL_GPIO_Init+0x76>
        {
          temp |= iocurrent;
 8042b6a:	ea45 0204 	orr.w	r2, r5, r4
        }
        EXTI->FTSR = temp;
 8042b6e:	4c58      	ldr	r4, [pc, #352]	; (8042cd0 <HAL_GPIO_Init+0x1d8>)
 8042b70:	60e2      	str	r2, [r4, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8042b72:	3301      	adds	r3, #1
 8042b74:	2b0f      	cmp	r3, #15
 8042b76:	f200 80a5 	bhi.w	8042cc4 <HAL_GPIO_Init+0x1cc>
    ioposition = 0x01U << position;
 8042b7a:	2201      	movs	r2, #1
 8042b7c:	409a      	lsls	r2, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8042b7e:	680c      	ldr	r4, [r1, #0]
 8042b80:	ea04 0502 	and.w	r5, r4, r2
    if(iocurrent == ioposition)
 8042b84:	ea32 0404 	bics.w	r4, r2, r4
 8042b88:	d1f3      	bne.n	8042b72 <HAL_GPIO_Init+0x7a>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8042b8a:	684c      	ldr	r4, [r1, #4]
 8042b8c:	2c02      	cmp	r4, #2
 8042b8e:	d001      	beq.n	8042b94 <HAL_GPIO_Init+0x9c>
 8042b90:	2c12      	cmp	r4, #18
 8042b92:	d110      	bne.n	8042bb6 <HAL_GPIO_Init+0xbe>
        temp = GPIOx->AFR[position >> 3U];
 8042b94:	08de      	lsrs	r6, r3, #3
 8042b96:	3608      	adds	r6, #8
 8042b98:	f850 c026 	ldr.w	ip, [r0, r6, lsl #2]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8042b9c:	f003 0407 	and.w	r4, r3, #7
 8042ba0:	00a7      	lsls	r7, r4, #2
 8042ba2:	240f      	movs	r4, #15
 8042ba4:	40bc      	lsls	r4, r7
 8042ba6:	ea2c 0c04 	bic.w	ip, ip, r4
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8042baa:	690c      	ldr	r4, [r1, #16]
 8042bac:	40bc      	lsls	r4, r7
 8042bae:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->AFR[position >> 3U] = temp;
 8042bb2:	f840 4026 	str.w	r4, [r0, r6, lsl #2]
      temp = GPIOx->MODER;
 8042bb6:	f8d0 c000 	ldr.w	ip, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8042bba:	005e      	lsls	r6, r3, #1
 8042bbc:	2403      	movs	r4, #3
 8042bbe:	40b4      	lsls	r4, r6
 8042bc0:	43e7      	mvns	r7, r4
 8042bc2:	ea2c 0c04 	bic.w	ip, ip, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8042bc6:	684c      	ldr	r4, [r1, #4]
 8042bc8:	f004 0403 	and.w	r4, r4, #3
 8042bcc:	40b4      	lsls	r4, r6
 8042bce:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8042bd2:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8042bd4:	684c      	ldr	r4, [r1, #4]
 8042bd6:	f104 3cff 	add.w	ip, r4, #4294967295
 8042bda:	f1bc 0f01 	cmp.w	ip, #1
 8042bde:	d903      	bls.n	8042be8 <HAL_GPIO_Init+0xf0>
 8042be0:	2c11      	cmp	r4, #17
 8042be2:	d001      	beq.n	8042be8 <HAL_GPIO_Init+0xf0>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8042be4:	2c12      	cmp	r4, #18
 8042be6:	d110      	bne.n	8042c0a <HAL_GPIO_Init+0x112>
        temp = GPIOx->OSPEEDR; 
 8042be8:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8042bea:	ea07 0c04 	and.w	ip, r7, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8042bee:	68cc      	ldr	r4, [r1, #12]
 8042bf0:	40b4      	lsls	r4, r6
 8042bf2:	ea44 040c 	orr.w	r4, r4, ip
        GPIOx->OSPEEDR = temp;
 8042bf6:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 8042bf8:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8042bfa:	ea24 0202 	bic.w	r2, r4, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8042bfe:	684c      	ldr	r4, [r1, #4]
 8042c00:	f3c4 1400 	ubfx	r4, r4, #4, #1
 8042c04:	409c      	lsls	r4, r3
 8042c06:	4314      	orrs	r4, r2
        GPIOx->OTYPER = temp;
 8042c08:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 8042c0a:	68c2      	ldr	r2, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8042c0c:	4017      	ands	r7, r2
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8042c0e:	688a      	ldr	r2, [r1, #8]
 8042c10:	40b2      	lsls	r2, r6
 8042c12:	433a      	orrs	r2, r7
      GPIOx->PUPDR = temp;
 8042c14:	60c2      	str	r2, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8042c16:	684a      	ldr	r2, [r1, #4]
 8042c18:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 8042c1c:	d0a9      	beq.n	8042b72 <HAL_GPIO_Init+0x7a>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8042c1e:	2200      	movs	r2, #0
 8042c20:	9201      	str	r2, [sp, #4]
 8042c22:	4a2c      	ldr	r2, [pc, #176]	; (8042cd4 <HAL_GPIO_Init+0x1dc>)
 8042c24:	6c54      	ldr	r4, [r2, #68]	; 0x44
 8042c26:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
 8042c2a:	6454      	str	r4, [r2, #68]	; 0x44
 8042c2c:	6c52      	ldr	r2, [r2, #68]	; 0x44
 8042c2e:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8042c32:	9201      	str	r2, [sp, #4]
 8042c34:	9a01      	ldr	r2, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2U];
 8042c36:	089c      	lsrs	r4, r3, #2
 8042c38:	1ca6      	adds	r6, r4, #2
 8042c3a:	4a24      	ldr	r2, [pc, #144]	; (8042ccc <HAL_GPIO_Init+0x1d4>)
 8042c3c:	f852 7026 	ldr.w	r7, [r2, r6, lsl #2]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8042c40:	f003 0203 	and.w	r2, r3, #3
 8042c44:	0096      	lsls	r6, r2, #2
 8042c46:	220f      	movs	r2, #15
 8042c48:	40b2      	lsls	r2, r6
 8042c4a:	ea27 0702 	bic.w	r7, r7, r2
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8042c4e:	4a22      	ldr	r2, [pc, #136]	; (8042cd8 <HAL_GPIO_Init+0x1e0>)
 8042c50:	4290      	cmp	r0, r2
 8042c52:	f43f af5a 	beq.w	8042b0a <HAL_GPIO_Init+0x12>
 8042c56:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c5a:	4290      	cmp	r0, r2
 8042c5c:	d022      	beq.n	8042ca4 <HAL_GPIO_Init+0x1ac>
 8042c5e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c62:	4290      	cmp	r0, r2
 8042c64:	d020      	beq.n	8042ca8 <HAL_GPIO_Init+0x1b0>
 8042c66:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c6a:	4290      	cmp	r0, r2
 8042c6c:	d01e      	beq.n	8042cac <HAL_GPIO_Init+0x1b4>
 8042c6e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c72:	4290      	cmp	r0, r2
 8042c74:	d01c      	beq.n	8042cb0 <HAL_GPIO_Init+0x1b8>
 8042c76:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c7a:	4290      	cmp	r0, r2
 8042c7c:	d01a      	beq.n	8042cb4 <HAL_GPIO_Init+0x1bc>
 8042c7e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c82:	4290      	cmp	r0, r2
 8042c84:	d018      	beq.n	8042cb8 <HAL_GPIO_Init+0x1c0>
 8042c86:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c8a:	4290      	cmp	r0, r2
 8042c8c:	d016      	beq.n	8042cbc <HAL_GPIO_Init+0x1c4>
 8042c8e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c92:	4290      	cmp	r0, r2
 8042c94:	d014      	beq.n	8042cc0 <HAL_GPIO_Init+0x1c8>
 8042c96:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8042c9a:	4290      	cmp	r0, r2
 8042c9c:	f43f af33 	beq.w	8042b06 <HAL_GPIO_Init+0xe>
 8042ca0:	220a      	movs	r2, #10
 8042ca2:	e733      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042ca4:	2201      	movs	r2, #1
 8042ca6:	e731      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042ca8:	2202      	movs	r2, #2
 8042caa:	e72f      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cac:	2203      	movs	r2, #3
 8042cae:	e72d      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cb0:	2204      	movs	r2, #4
 8042cb2:	e72b      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cb4:	2205      	movs	r2, #5
 8042cb6:	e729      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cb8:	2206      	movs	r2, #6
 8042cba:	e727      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cbc:	2207      	movs	r2, #7
 8042cbe:	e725      	b.n	8042b0c <HAL_GPIO_Init+0x14>
 8042cc0:	2208      	movs	r2, #8
 8042cc2:	e723      	b.n	8042b0c <HAL_GPIO_Init+0x14>
      }
    }
  }
}
 8042cc4:	b002      	add	sp, #8
 8042cc6:	bcf0      	pop	{r4, r5, r6, r7}
 8042cc8:	4770      	bx	lr
 8042cca:	4770      	bx	lr
 8042ccc:	40013800 	.word	0x40013800
 8042cd0:	40013c00 	.word	0x40013c00
 8042cd4:	40023800 	.word	0x40023800
 8042cd8:	40020000 	.word	0x40020000

08042cdc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8042cdc:	b10a      	cbz	r2, 8042ce2 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8042cde:	6181      	str	r1, [r0, #24]
 8042ce0:	4770      	bx	lr
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8042ce2:	0409      	lsls	r1, r1, #16
 8042ce4:	6181      	str	r1, [r0, #24]
  }
}
 8042ce6:	4770      	bx	lr

08042ce8 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 8042ce8:	6943      	ldr	r3, [r0, #20]
 8042cea:	ea31 0303 	bics.w	r3, r1, r3
 8042cee:	d001      	beq.n	8042cf4 <HAL_GPIO_TogglePin+0xc>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
 8042cf0:	6181      	str	r1, [r0, #24]
  }
}
 8042cf2:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8042cf4:	0409      	lsls	r1, r1, #16
 8042cf6:	6181      	str	r1, [r0, #24]
 8042cf8:	4770      	bx	lr

08042cfa <I2C_Master_SB>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8042cfa:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8042cfe:	b2db      	uxtb	r3, r3
 8042d00:	2b40      	cmp	r3, #64	; 0x40
 8042d02:	d010      	beq.n	8042d26 <I2C_Master_SB+0x2c>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
    }
  }
  else
  {
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8042d04:	6903      	ldr	r3, [r0, #16]
 8042d06:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8042d0a:	d01b      	beq.n	8042d44 <I2C_Master_SB+0x4a>
        }
      }
    }
    else
    {
      if (hi2c->EventCount == 0U)
 8042d0c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042d0e:	2b00      	cmp	r3, #0
 8042d10:	d13c      	bne.n	8042d8c <I2C_Master_SB+0x92>
      {
        /* Send header of slave address */
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 8042d12:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d14:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 8042d18:	6802      	ldr	r2, [r0, #0]
 8042d1a:	f003 0306 	and.w	r3, r3, #6
 8042d1e:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8042d22:	6113      	str	r3, [r2, #16]
 8042d24:	4770      	bx	lr
    if (hi2c->EventCount == 0U)
 8042d26:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042d28:	b92b      	cbnz	r3, 8042d36 <I2C_Master_SB+0x3c>
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8042d2a:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d2c:	6802      	ldr	r2, [r0, #0]
 8042d2e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8042d32:	6113      	str	r3, [r2, #16]
 8042d34:	4770      	bx	lr
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8042d36:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d38:	6802      	ldr	r2, [r0, #0]
 8042d3a:	f043 0301 	orr.w	r3, r3, #1
 8042d3e:	b2db      	uxtb	r3, r3
 8042d40:	6113      	str	r3, [r2, #16]
 8042d42:	4770      	bx	lr
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8042d44:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8042d48:	b2db      	uxtb	r3, r3
 8042d4a:	2b21      	cmp	r3, #33	; 0x21
 8042d4c:	d00f      	beq.n	8042d6e <I2C_Master_SB+0x74>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 8042d4e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d50:	6802      	ldr	r2, [r0, #0]
 8042d52:	f043 0301 	orr.w	r3, r3, #1
 8042d56:	b2db      	uxtb	r3, r3
 8042d58:	6113      	str	r3, [r2, #16]
      if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042d5a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8042d5c:	b16b      	cbz	r3, 8042d7a <I2C_Master_SB+0x80>
        if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042d5e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042d60:	b17b      	cbz	r3, 8042d82 <I2C_Master_SB+0x88>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8042d62:	6802      	ldr	r2, [r0, #0]
 8042d64:	6853      	ldr	r3, [r2, #4]
 8042d66:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042d6a:	6053      	str	r3, [r2, #4]
 8042d6c:	4770      	bx	lr
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 8042d6e:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d70:	6802      	ldr	r2, [r0, #0]
 8042d72:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8042d76:	6113      	str	r3, [r2, #16]
 8042d78:	e7ef      	b.n	8042d5a <I2C_Master_SB+0x60>
      if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042d7a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042d7c:	2a00      	cmp	r2, #0
 8042d7e:	d1ee      	bne.n	8042d5e <I2C_Master_SB+0x64>
 8042d80:	e007      	b.n	8042d92 <I2C_Master_SB+0x98>
        if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042d82:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8042d84:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042d86:	2b00      	cmp	r3, #0
 8042d88:	d1eb      	bne.n	8042d62 <I2C_Master_SB+0x68>
 8042d8a:	e002      	b.n	8042d92 <I2C_Master_SB+0x98>
      }
      else if (hi2c->EventCount == 1U)
 8042d8c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042d8e:	2b01      	cmp	r3, #1
 8042d90:	d000      	beq.n	8042d94 <I2C_Master_SB+0x9a>
      {
        /* Do nothing */
      }
    }
  }
}
 8042d92:	4770      	bx	lr
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 8042d94:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042d96:	f3c3 13c8 	ubfx	r3, r3, #7, #9
 8042d9a:	6802      	ldr	r2, [r0, #0]
 8042d9c:	f003 0306 	and.w	r3, r3, #6
 8042da0:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
 8042da4:	6113      	str	r3, [r2, #16]
}
 8042da6:	e7f4      	b.n	8042d92 <I2C_Master_SB+0x98>

08042da8 <I2C_Master_ADD10>:
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 8042da8:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8042daa:	6802      	ldr	r2, [r0, #0]
 8042dac:	b2db      	uxtb	r3, r3
 8042dae:	6113      	str	r3, [r2, #16]

  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042db0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8042db2:	b13b      	cbz	r3, 8042dc4 <I2C_Master_ADD10+0x1c>
  {
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042db4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042db6:	b14b      	cbz	r3, 8042dcc <I2C_Master_ADD10+0x24>
    {
      /* Enable DMA Request */
      SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8042db8:	6802      	ldr	r2, [r0, #0]
 8042dba:	6853      	ldr	r3, [r2, #4]
 8042dbc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042dc0:	6053      	str	r3, [r2, #4]
    }
  }
}
 8042dc2:	4770      	bx	lr
  if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
 8042dc4:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8042dc6:	2a00      	cmp	r2, #0
 8042dc8:	d1f4      	bne.n	8042db4 <I2C_Master_ADD10+0xc>
 8042dca:	e7fa      	b.n	8042dc2 <I2C_Master_ADD10+0x1a>
    if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
 8042dcc:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8042dce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8042dd0:	2b00      	cmp	r3, #0
 8042dd2:	d1f1      	bne.n	8042db8 <I2C_Master_ADD10+0x10>
 8042dd4:	e7f5      	b.n	8042dc2 <I2C_Master_ADD10+0x1a>

08042dd6 <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 8042dd6:	b410      	push	{r4}
 8042dd8:	b08b      	sub	sp, #44	; 0x2c
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 8042dda:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8042dde:	b2da      	uxtb	r2, r3
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 8042de0:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
  uint32_t Prev_State                   = hi2c->PreviousState;
 8042de2:	6b04      	ldr	r4, [r0, #48]	; 0x30

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8042de4:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8042de8:	b2db      	uxtb	r3, r3
 8042dea:	2b22      	cmp	r3, #34	; 0x22
 8042dec:	d00b      	beq.n	8042e06 <I2C_Master_ADDR+0x30>
    }
  }
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042dee:	2300      	movs	r3, #0
 8042df0:	9309      	str	r3, [sp, #36]	; 0x24
 8042df2:	6803      	ldr	r3, [r0, #0]
 8042df4:	695a      	ldr	r2, [r3, #20]
 8042df6:	9209      	str	r2, [sp, #36]	; 0x24
 8042df8:	699b      	ldr	r3, [r3, #24]
 8042dfa:	9309      	str	r3, [sp, #36]	; 0x24
 8042dfc:	9b09      	ldr	r3, [sp, #36]	; 0x24
  }
}
 8042dfe:	b00b      	add	sp, #44	; 0x2c
 8042e00:	f85d 4b04 	ldr.w	r4, [sp], #4
 8042e04:	4770      	bx	lr
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 8042e06:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042e08:	b90b      	cbnz	r3, 8042e0e <I2C_Master_ADDR+0x38>
 8042e0a:	2a40      	cmp	r2, #64	; 0x40
 8042e0c:	d017      	beq.n	8042e3e <I2C_Master_ADDR+0x68>
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 8042e0e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042e10:	b91b      	cbnz	r3, 8042e1a <I2C_Master_ADDR+0x44>
 8042e12:	6903      	ldr	r3, [r0, #16]
 8042e14:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8042e18:	d019      	beq.n	8042e4e <I2C_Master_ADDR+0x78>
      if (hi2c->XferCount == 0U)
 8042e1a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042e1c:	b29b      	uxth	r3, r3
 8042e1e:	2b00      	cmp	r3, #0
 8042e20:	d125      	bne.n	8042e6e <I2C_Master_ADDR+0x98>
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e22:	9302      	str	r3, [sp, #8]
 8042e24:	6803      	ldr	r3, [r0, #0]
 8042e26:	695a      	ldr	r2, [r3, #20]
 8042e28:	9202      	str	r2, [sp, #8]
 8042e2a:	699a      	ldr	r2, [r3, #24]
 8042e2c:	9202      	str	r2, [sp, #8]
 8042e2e:	9a02      	ldr	r2, [sp, #8]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042e30:	681a      	ldr	r2, [r3, #0]
 8042e32:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042e36:	601a      	str	r2, [r3, #0]
      hi2c->EventCount = 0U;
 8042e38:	2300      	movs	r3, #0
 8042e3a:	6503      	str	r3, [r0, #80]	; 0x50
 8042e3c:	e7df      	b.n	8042dfe <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e3e:	9300      	str	r3, [sp, #0]
 8042e40:	6803      	ldr	r3, [r0, #0]
 8042e42:	695a      	ldr	r2, [r3, #20]
 8042e44:	9200      	str	r2, [sp, #0]
 8042e46:	699b      	ldr	r3, [r3, #24]
 8042e48:	9300      	str	r3, [sp, #0]
 8042e4a:	9b00      	ldr	r3, [sp, #0]
 8042e4c:	e7d7      	b.n	8042dfe <I2C_Master_ADDR+0x28>
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042e4e:	2300      	movs	r3, #0
 8042e50:	9301      	str	r3, [sp, #4]
 8042e52:	6803      	ldr	r3, [r0, #0]
 8042e54:	695a      	ldr	r2, [r3, #20]
 8042e56:	9201      	str	r2, [sp, #4]
 8042e58:	699a      	ldr	r2, [r3, #24]
 8042e5a:	9201      	str	r2, [sp, #4]
 8042e5c:	9a01      	ldr	r2, [sp, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 8042e5e:	681a      	ldr	r2, [r3, #0]
 8042e60:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8042e64:	601a      	str	r2, [r3, #0]
      hi2c->EventCount++;
 8042e66:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8042e68:	3301      	adds	r3, #1
 8042e6a:	6503      	str	r3, [r0, #80]	; 0x50
 8042e6c:	e7c7      	b.n	8042dfe <I2C_Master_ADDR+0x28>
      else if (hi2c->XferCount == 1U)
 8042e6e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042e70:	b29b      	uxth	r3, r3
 8042e72:	2b01      	cmp	r3, #1
 8042e74:	d025      	beq.n	8042ec2 <I2C_Master_ADDR+0xec>
      else if (hi2c->XferCount == 2U)
 8042e76:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042e78:	b29b      	uxth	r3, r3
 8042e7a:	2b02      	cmp	r3, #2
 8042e7c:	d07b      	beq.n	8042f76 <I2C_Master_ADDR+0x1a0>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042e7e:	6802      	ldr	r2, [r0, #0]
 8042e80:	6813      	ldr	r3, [r2, #0]
 8042e82:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042e86:	6013      	str	r3, [r2, #0]
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8042e88:	6803      	ldr	r3, [r0, #0]
 8042e8a:	685a      	ldr	r2, [r3, #4]
 8042e8c:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042e90:	d00e      	beq.n	8042eb0 <I2C_Master_ADDR+0xda>
 8042e92:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042e96:	d007      	beq.n	8042ea8 <I2C_Master_ADDR+0xd2>
 8042e98:	2901      	cmp	r1, #1
 8042e9a:	d005      	beq.n	8042ea8 <I2C_Master_ADDR+0xd2>
 8042e9c:	2908      	cmp	r1, #8
 8042e9e:	d003      	beq.n	8042ea8 <I2C_Master_ADDR+0xd2>
 8042ea0:	2910      	cmp	r1, #16
 8042ea2:	d001      	beq.n	8042ea8 <I2C_Master_ADDR+0xd2>
 8042ea4:	2920      	cmp	r1, #32
 8042ea6:	d103      	bne.n	8042eb0 <I2C_Master_ADDR+0xda>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8042ea8:	685a      	ldr	r2, [r3, #4]
 8042eaa:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8042eae:	605a      	str	r2, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042eb0:	2300      	movs	r3, #0
 8042eb2:	9308      	str	r3, [sp, #32]
 8042eb4:	6803      	ldr	r3, [r0, #0]
 8042eb6:	695a      	ldr	r2, [r3, #20]
 8042eb8:	9208      	str	r2, [sp, #32]
 8042eba:	699b      	ldr	r3, [r3, #24]
 8042ebc:	9308      	str	r3, [sp, #32]
 8042ebe:	9b08      	ldr	r3, [sp, #32]
 8042ec0:	e7ba      	b.n	8042e38 <I2C_Master_ADDR+0x62>
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 8042ec2:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042ec6:	d011      	beq.n	8042eec <I2C_Master_ADDR+0x116>
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 8042ec8:	2908      	cmp	r1, #8
 8042eca:	d034      	beq.n	8042f36 <I2C_Master_ADDR+0x160>
 8042ecc:	2920      	cmp	r1, #32
 8042ece:	d032      	beq.n	8042f36 <I2C_Master_ADDR+0x160>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8042ed0:	2c12      	cmp	r4, #18
 8042ed2:	d02e      	beq.n	8042f32 <I2C_Master_ADDR+0x15c>
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8042ed4:	2904      	cmp	r1, #4
 8042ed6:	d040      	beq.n	8042f5a <I2C_Master_ADDR+0x184>
 8042ed8:	2902      	cmp	r1, #2
 8042eda:	d03e      	beq.n	8042f5a <I2C_Master_ADDR+0x184>
 8042edc:	2910      	cmp	r1, #16
 8042ede:	d03c      	beq.n	8042f5a <I2C_Master_ADDR+0x184>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042ee0:	6802      	ldr	r2, [r0, #0]
 8042ee2:	6813      	ldr	r3, [r2, #0]
 8042ee4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042ee8:	6013      	str	r3, [r2, #0]
 8042eea:	e03b      	b.n	8042f64 <I2C_Master_ADDR+0x18e>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042eec:	6802      	ldr	r2, [r0, #0]
 8042eee:	6813      	ldr	r3, [r2, #0]
 8042ef0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042ef4:	6013      	str	r3, [r2, #0]
          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 8042ef6:	6803      	ldr	r3, [r0, #0]
 8042ef8:	685a      	ldr	r2, [r3, #4]
 8042efa:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042efe:	d00c      	beq.n	8042f1a <I2C_Master_ADDR+0x144>
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f00:	681a      	ldr	r2, [r3, #0]
 8042f02:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8042f06:	601a      	str	r2, [r3, #0]
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f08:	2300      	movs	r3, #0
 8042f0a:	9303      	str	r3, [sp, #12]
 8042f0c:	6803      	ldr	r3, [r0, #0]
 8042f0e:	695a      	ldr	r2, [r3, #20]
 8042f10:	9203      	str	r2, [sp, #12]
 8042f12:	699b      	ldr	r3, [r3, #24]
 8042f14:	9303      	str	r3, [sp, #12]
 8042f16:	9b03      	ldr	r3, [sp, #12]
 8042f18:	e78e      	b.n	8042e38 <I2C_Master_ADDR+0x62>
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f1a:	2200      	movs	r2, #0
 8042f1c:	9204      	str	r2, [sp, #16]
 8042f1e:	695a      	ldr	r2, [r3, #20]
 8042f20:	9204      	str	r2, [sp, #16]
 8042f22:	699a      	ldr	r2, [r3, #24]
 8042f24:	9204      	str	r2, [sp, #16]
 8042f26:	9a04      	ldr	r2, [sp, #16]
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042f28:	681a      	ldr	r2, [r3, #0]
 8042f2a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042f2e:	601a      	str	r2, [r3, #0]
 8042f30:	e782      	b.n	8042e38 <I2C_Master_ADDR+0x62>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 8042f32:	2901      	cmp	r1, #1
 8042f34:	d0ce      	beq.n	8042ed4 <I2C_Master_ADDR+0xfe>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f36:	6802      	ldr	r2, [r0, #0]
 8042f38:	6813      	ldr	r3, [r2, #0]
 8042f3a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042f3e:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f40:	2300      	movs	r3, #0
 8042f42:	9306      	str	r3, [sp, #24]
 8042f44:	6803      	ldr	r3, [r0, #0]
 8042f46:	695a      	ldr	r2, [r3, #20]
 8042f48:	9206      	str	r2, [sp, #24]
 8042f4a:	699a      	ldr	r2, [r3, #24]
 8042f4c:	9206      	str	r2, [sp, #24]
 8042f4e:	9a06      	ldr	r2, [sp, #24]
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8042f50:	681a      	ldr	r2, [r3, #0]
 8042f52:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8042f56:	601a      	str	r2, [r3, #0]
 8042f58:	e76e      	b.n	8042e38 <I2C_Master_ADDR+0x62>
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f5a:	6802      	ldr	r2, [r0, #0]
 8042f5c:	6813      	ldr	r3, [r2, #0]
 8042f5e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042f62:	6013      	str	r3, [r2, #0]
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042f64:	2300      	movs	r3, #0
 8042f66:	9305      	str	r3, [sp, #20]
 8042f68:	6803      	ldr	r3, [r0, #0]
 8042f6a:	695a      	ldr	r2, [r3, #20]
 8042f6c:	9205      	str	r2, [sp, #20]
 8042f6e:	699b      	ldr	r3, [r3, #24]
 8042f70:	9305      	str	r3, [sp, #20]
 8042f72:	9b05      	ldr	r3, [sp, #20]
 8042f74:	e760      	b.n	8042e38 <I2C_Master_ADDR+0x62>
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 8042f76:	2904      	cmp	r1, #4
 8042f78:	d00e      	beq.n	8042f98 <I2C_Master_ADDR+0x1c2>
 8042f7a:	2902      	cmp	r1, #2
 8042f7c:	d00c      	beq.n	8042f98 <I2C_Master_ADDR+0x1c2>
 8042f7e:	2910      	cmp	r1, #16
 8042f80:	d00a      	beq.n	8042f98 <I2C_Master_ADDR+0x1c2>
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f82:	6802      	ldr	r2, [r0, #0]
 8042f84:	6813      	ldr	r3, [r2, #0]
 8042f86:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8042f8a:	6013      	str	r3, [r2, #0]
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 8042f8c:	6802      	ldr	r2, [r0, #0]
 8042f8e:	6813      	ldr	r3, [r2, #0]
 8042f90:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8042f94:	6013      	str	r3, [r2, #0]
 8042f96:	e004      	b.n	8042fa2 <I2C_Master_ADDR+0x1cc>
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8042f98:	6802      	ldr	r2, [r0, #0]
 8042f9a:	6813      	ldr	r3, [r2, #0]
 8042f9c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8042fa0:	6013      	str	r3, [r2, #0]
        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 8042fa2:	6803      	ldr	r3, [r0, #0]
 8042fa4:	685a      	ldr	r2, [r3, #4]
 8042fa6:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8042faa:	d00e      	beq.n	8042fca <I2C_Master_ADDR+0x1f4>
 8042fac:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8042fb0:	d007      	beq.n	8042fc2 <I2C_Master_ADDR+0x1ec>
 8042fb2:	2901      	cmp	r1, #1
 8042fb4:	d005      	beq.n	8042fc2 <I2C_Master_ADDR+0x1ec>
 8042fb6:	2908      	cmp	r1, #8
 8042fb8:	d003      	beq.n	8042fc2 <I2C_Master_ADDR+0x1ec>
 8042fba:	2910      	cmp	r1, #16
 8042fbc:	d001      	beq.n	8042fc2 <I2C_Master_ADDR+0x1ec>
 8042fbe:	2920      	cmp	r1, #32
 8042fc0:	d103      	bne.n	8042fca <I2C_Master_ADDR+0x1f4>
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 8042fc2:	685a      	ldr	r2, [r3, #4]
 8042fc4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8042fc8:	605a      	str	r2, [r3, #4]
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8042fca:	2300      	movs	r3, #0
 8042fcc:	9307      	str	r3, [sp, #28]
 8042fce:	6803      	ldr	r3, [r0, #0]
 8042fd0:	695a      	ldr	r2, [r3, #20]
 8042fd2:	9207      	str	r2, [sp, #28]
 8042fd4:	699b      	ldr	r3, [r3, #24]
 8042fd6:	9307      	str	r3, [sp, #28]
 8042fd8:	9b07      	ldr	r3, [sp, #28]
 8042fda:	e72d      	b.n	8042e38 <I2C_Master_ADDR+0x62>

08042fdc <I2C_SlaveTransmit_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 8042fdc:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042fde:	b29b      	uxth	r3, r3
 8042fe0:	b15b      	cbz	r3, 8042ffa <I2C_SlaveTransmit_BTF+0x1e>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 8042fe2:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8042fe4:	6803      	ldr	r3, [r0, #0]
 8042fe6:	7812      	ldrb	r2, [r2, #0]
 8042fe8:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 8042fea:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8042fec:	3301      	adds	r3, #1
 8042fee:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8042ff0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042ff2:	b29b      	uxth	r3, r3
 8042ff4:	3b01      	subs	r3, #1
 8042ff6:	b29b      	uxth	r3, r3
 8042ff8:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 8042ffa:	4770      	bx	lr

08042ffc <I2C_SlaveReceive_BTF>:
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->XferCount != 0U)
 8042ffc:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8042ffe:	b29b      	uxth	r3, r3
 8043000:	b15b      	cbz	r3, 804301a <I2C_SlaveReceive_BTF+0x1e>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043002:	6803      	ldr	r3, [r0, #0]
 8043004:	691a      	ldr	r2, [r3, #16]
 8043006:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043008:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 804300a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804300c:	3301      	adds	r3, #1
 804300e:	6243      	str	r3, [r0, #36]	; 0x24

    /* Update counter */
    hi2c->XferCount--;
 8043010:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043012:	b29b      	uxth	r3, r3
 8043014:	3b01      	subs	r3, #1
 8043016:	b29b      	uxth	r3, r3
 8043018:	8543      	strh	r3, [r0, #42]	; 0x2a
  }
}
 804301a:	4770      	bx	lr

0804301c <I2C_ConvertOtherXferOptions>:
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 804301c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 804301e:	f5b3 0f2a 	cmp.w	r3, #11141120	; 0xaa0000
 8043022:	d004      	beq.n	804302e <I2C_ConvertOtherXferOptions+0x12>
  }
  /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
  /* it request implicitly to generate a restart condition    */
  /* then generate a stop condition at the end of transfer    */
  /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 8043024:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8043026:	f1b3 4f2a 	cmp.w	r3, #2852126720	; 0xaa000000
 804302a:	d003      	beq.n	8043034 <I2C_ConvertOtherXferOptions+0x18>
  }
  else
  {
    /* Nothing to do */
  }
}
 804302c:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_FRAME;
 804302e:	2301      	movs	r3, #1
 8043030:	62c3      	str	r3, [r0, #44]	; 0x2c
 8043032:	4770      	bx	lr
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 8043034:	2308      	movs	r3, #8
 8043036:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8043038:	e7f8      	b.n	804302c <I2C_ConvertOtherXferOptions+0x10>
	...

0804303c <HAL_I2C_Init>:
  if (hi2c == NULL)
 804303c:	2800      	cmp	r0, #0
 804303e:	f000 80c2 	beq.w	80431c6 <HAL_I2C_Init+0x18a>
{
 8043042:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8043044:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8043046:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804304a:	2b00      	cmp	r3, #0
 804304c:	d06d      	beq.n	804312a <HAL_I2C_Init+0xee>
  hi2c->State = HAL_I2C_STATE_BUSY;
 804304e:	2324      	movs	r3, #36	; 0x24
 8043050:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8043054:	6822      	ldr	r2, [r4, #0]
 8043056:	6813      	ldr	r3, [r2, #0]
 8043058:	f023 0301 	bic.w	r3, r3, #1
 804305c:	6013      	str	r3, [r2, #0]
  pclk1 = HAL_RCC_GetPCLK1Freq();
 804305e:	f001 f9cf 	bl	8044400 <HAL_RCC_GetPCLK1Freq>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8043062:	6862      	ldr	r2, [r4, #4]
 8043064:	4b5a      	ldr	r3, [pc, #360]	; (80431d0 <HAL_I2C_Init+0x194>)
 8043066:	429a      	cmp	r2, r3
 8043068:	d864      	bhi.n	8043134 <HAL_I2C_Init+0xf8>
 804306a:	4b5a      	ldr	r3, [pc, #360]	; (80431d4 <HAL_I2C_Init+0x198>)
 804306c:	4298      	cmp	r0, r3
 804306e:	bf8c      	ite	hi
 8043070:	2300      	movhi	r3, #0
 8043072:	2301      	movls	r3, #1
 8043074:	2b00      	cmp	r3, #0
 8043076:	f040 80a8 	bne.w	80431ca <HAL_I2C_Init+0x18e>
  freqrange = I2C_FREQRANGE(pclk1);
 804307a:	4d57      	ldr	r5, [pc, #348]	; (80431d8 <HAL_I2C_Init+0x19c>)
 804307c:	fba5 3500 	umull	r3, r5, r5, r0
 8043080:	0caf      	lsrs	r7, r5, #18
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 8043082:	6826      	ldr	r6, [r4, #0]
 8043084:	6871      	ldr	r1, [r6, #4]
 8043086:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 804308a:	ea41 4195 	orr.w	r1, r1, r5, lsr #18
 804308e:	6071      	str	r1, [r6, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8043090:	6821      	ldr	r1, [r4, #0]
 8043092:	6a0b      	ldr	r3, [r1, #32]
 8043094:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8043098:	6865      	ldr	r5, [r4, #4]
 804309a:	4a4d      	ldr	r2, [pc, #308]	; (80431d0 <HAL_I2C_Init+0x194>)
 804309c:	4295      	cmp	r5, r2
 804309e:	d84f      	bhi.n	8043140 <HAL_I2C_Init+0x104>
 80430a0:	1c7a      	adds	r2, r7, #1
 80430a2:	4313      	orrs	r3, r2
 80430a4:	620b      	str	r3, [r1, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80430a6:	6825      	ldr	r5, [r4, #0]
 80430a8:	69e9      	ldr	r1, [r5, #28]
 80430aa:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 80430ae:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 80430b2:	6863      	ldr	r3, [r4, #4]
 80430b4:	4a46      	ldr	r2, [pc, #280]	; (80431d0 <HAL_I2C_Init+0x194>)
 80430b6:	4293      	cmp	r3, r2
 80430b8:	d84c      	bhi.n	8043154 <HAL_I2C_Init+0x118>
 80430ba:	3801      	subs	r0, #1
 80430bc:	005b      	lsls	r3, r3, #1
 80430be:	fbb0 f0f3 	udiv	r0, r0, r3
 80430c2:	3001      	adds	r0, #1
 80430c4:	f640 73fc 	movw	r3, #4092	; 0xffc
 80430c8:	4218      	tst	r0, r3
 80430ca:	d078      	beq.n	80431be <HAL_I2C_Init+0x182>
 80430cc:	f3c0 030b 	ubfx	r3, r0, #0, #12
 80430d0:	430b      	orrs	r3, r1
 80430d2:	61eb      	str	r3, [r5, #28]
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 80430d4:	6821      	ldr	r1, [r4, #0]
 80430d6:	680b      	ldr	r3, [r1, #0]
 80430d8:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80430dc:	69e2      	ldr	r2, [r4, #28]
 80430de:	6a20      	ldr	r0, [r4, #32]
 80430e0:	4302      	orrs	r2, r0
 80430e2:	4313      	orrs	r3, r2
 80430e4:	600b      	str	r3, [r1, #0]
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 80430e6:	6821      	ldr	r1, [r4, #0]
 80430e8:	688b      	ldr	r3, [r1, #8]
 80430ea:	f423 4303 	bic.w	r3, r3, #33536	; 0x8300
 80430ee:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80430f2:	6922      	ldr	r2, [r4, #16]
 80430f4:	68e0      	ldr	r0, [r4, #12]
 80430f6:	4302      	orrs	r2, r0
 80430f8:	4313      	orrs	r3, r2
 80430fa:	608b      	str	r3, [r1, #8]
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 80430fc:	6821      	ldr	r1, [r4, #0]
 80430fe:	68cb      	ldr	r3, [r1, #12]
 8043100:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8043104:	6962      	ldr	r2, [r4, #20]
 8043106:	69a0      	ldr	r0, [r4, #24]
 8043108:	4302      	orrs	r2, r0
 804310a:	4313      	orrs	r3, r2
 804310c:	60cb      	str	r3, [r1, #12]
  __HAL_I2C_ENABLE(hi2c);
 804310e:	6822      	ldr	r2, [r4, #0]
 8043110:	6813      	ldr	r3, [r2, #0]
 8043112:	f043 0301 	orr.w	r3, r3, #1
 8043116:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8043118:	2000      	movs	r0, #0
 804311a:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 804311c:	2320      	movs	r3, #32
 804311e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8043122:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8043124:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
}
 8043128:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Lock = HAL_UNLOCKED;
 804312a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 804312e:	f00a f98b 	bl	804d448 <HAL_I2C_MspInit>
 8043132:	e78c      	b.n	804304e <HAL_I2C_Init+0x12>
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8043134:	4b29      	ldr	r3, [pc, #164]	; (80431dc <HAL_I2C_Init+0x1a0>)
 8043136:	4298      	cmp	r0, r3
 8043138:	bf8c      	ite	hi
 804313a:	2300      	movhi	r3, #0
 804313c:	2301      	movls	r3, #1
 804313e:	e799      	b.n	8043074 <HAL_I2C_Init+0x38>
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8043140:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8043144:	fb02 f207 	mul.w	r2, r2, r7
 8043148:	4d25      	ldr	r5, [pc, #148]	; (80431e0 <HAL_I2C_Init+0x1a4>)
 804314a:	fba5 5202 	umull	r5, r2, r5, r2
 804314e:	0992      	lsrs	r2, r2, #6
 8043150:	3201      	adds	r2, #1
 8043152:	e7a6      	b.n	80430a2 <HAL_I2C_Init+0x66>
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 8043154:	68a2      	ldr	r2, [r4, #8]
 8043156:	b9ba      	cbnz	r2, 8043188 <HAL_I2C_Init+0x14c>
 8043158:	1e46      	subs	r6, r0, #1
 804315a:	eb03 0743 	add.w	r7, r3, r3, lsl #1
 804315e:	fbb6 f6f7 	udiv	r6, r6, r7
 8043162:	3601      	adds	r6, #1
 8043164:	f3c6 060b 	ubfx	r6, r6, #0, #12
 8043168:	fab6 f686 	clz	r6, r6
 804316c:	0976      	lsrs	r6, r6, #5
 804316e:	bb46      	cbnz	r6, 80431c2 <HAL_I2C_Init+0x186>
 8043170:	b9c2      	cbnz	r2, 80431a4 <HAL_I2C_Init+0x168>
 8043172:	1e42      	subs	r2, r0, #1
 8043174:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8043178:	fbb2 f2f3 	udiv	r2, r2, r3
 804317c:	3201      	adds	r2, #1
 804317e:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8043182:	f442 4300 	orr.w	r3, r2, #32768	; 0x8000
 8043186:	e7a3      	b.n	80430d0 <HAL_I2C_Init+0x94>
 8043188:	1e46      	subs	r6, r0, #1
 804318a:	eb03 0783 	add.w	r7, r3, r3, lsl #2
 804318e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8043192:	fbb6 f6f7 	udiv	r6, r6, r7
 8043196:	3601      	adds	r6, #1
 8043198:	f3c6 060b 	ubfx	r6, r6, #0, #12
 804319c:	fab6 f686 	clz	r6, r6
 80431a0:	0976      	lsrs	r6, r6, #5
 80431a2:	e7e4      	b.n	804316e <HAL_I2C_Init+0x132>
 80431a4:	1e42      	subs	r2, r0, #1
 80431a6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80431aa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80431ae:	fbb2 f2f3 	udiv	r2, r2, r3
 80431b2:	3201      	adds	r2, #1
 80431b4:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80431b8:	f442 4340 	orr.w	r3, r2, #49152	; 0xc000
 80431bc:	e788      	b.n	80430d0 <HAL_I2C_Init+0x94>
 80431be:	2304      	movs	r3, #4
 80431c0:	e786      	b.n	80430d0 <HAL_I2C_Init+0x94>
 80431c2:	2301      	movs	r3, #1
 80431c4:	e784      	b.n	80430d0 <HAL_I2C_Init+0x94>
    return HAL_ERROR;
 80431c6:	2001      	movs	r0, #1
}
 80431c8:	4770      	bx	lr
    return HAL_ERROR;
 80431ca:	2001      	movs	r0, #1
 80431cc:	e7ac      	b.n	8043128 <HAL_I2C_Init+0xec>
 80431ce:	bf00      	nop
 80431d0:	000186a0 	.word	0x000186a0
 80431d4:	001e847f 	.word	0x001e847f
 80431d8:	431bde83 	.word	0x431bde83
 80431dc:	003d08ff 	.word	0x003d08ff
 80431e0:	10624dd3 	.word	0x10624dd3

080431e4 <HAL_I2C_MasterTxCpltCallback>:
}
 80431e4:	4770      	bx	lr

080431e6 <HAL_I2C_MasterRxCpltCallback>:
}
 80431e6:	4770      	bx	lr

080431e8 <HAL_I2C_SlaveTxCpltCallback>:
}
 80431e8:	4770      	bx	lr

080431ea <I2C_SlaveTransmit_TXE>:
{
 80431ea:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80431ec:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80431f0:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 80431f2:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80431f4:	b29b      	uxth	r3, r3
 80431f6:	b183      	cbz	r3, 804321a <I2C_SlaveTransmit_TXE+0x30>
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 80431f8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80431fa:	6803      	ldr	r3, [r0, #0]
 80431fc:	7809      	ldrb	r1, [r1, #0]
 80431fe:	6119      	str	r1, [r3, #16]
    hi2c->pBuffPtr++;
 8043200:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043202:	3301      	adds	r3, #1
 8043204:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043206:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043208:	b29b      	uxth	r3, r3
 804320a:	3b01      	subs	r3, #1
 804320c:	b29b      	uxth	r3, r3
 804320e:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8043210:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043212:	b29b      	uxth	r3, r3
 8043214:	b90b      	cbnz	r3, 804321a <I2C_SlaveTransmit_TXE+0x30>
 8043216:	2a29      	cmp	r2, #41	; 0x29
 8043218:	d000      	beq.n	804321c <I2C_SlaveTransmit_TXE+0x32>
}
 804321a:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 804321c:	6802      	ldr	r2, [r0, #0]
 804321e:	6853      	ldr	r3, [r2, #4]
 8043220:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043224:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8043226:	2321      	movs	r3, #33	; 0x21
 8043228:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 804322a:	2328      	movs	r3, #40	; 0x28
 804322c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 8043230:	f7ff ffda 	bl	80431e8 <HAL_I2C_SlaveTxCpltCallback>
}
 8043234:	e7f1      	b.n	804321a <I2C_SlaveTransmit_TXE+0x30>

08043236 <HAL_I2C_SlaveRxCpltCallback>:
}
 8043236:	4770      	bx	lr

08043238 <I2C_SlaveReceive_RXNE>:
{
 8043238:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804323a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804323e:	b2da      	uxtb	r2, r3
  if (hi2c->XferCount != 0U)
 8043240:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043242:	b29b      	uxth	r3, r3
 8043244:	b183      	cbz	r3, 8043268 <I2C_SlaveReceive_RXNE+0x30>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043246:	6803      	ldr	r3, [r0, #0]
 8043248:	6919      	ldr	r1, [r3, #16]
 804324a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804324c:	7019      	strb	r1, [r3, #0]
    hi2c->pBuffPtr++;
 804324e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043250:	3301      	adds	r3, #1
 8043252:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043254:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043256:	b29b      	uxth	r3, r3
 8043258:	3b01      	subs	r3, #1
 804325a:	b29b      	uxth	r3, r3
 804325c:	8543      	strh	r3, [r0, #42]	; 0x2a
    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 804325e:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043260:	b29b      	uxth	r3, r3
 8043262:	b90b      	cbnz	r3, 8043268 <I2C_SlaveReceive_RXNE+0x30>
 8043264:	2a2a      	cmp	r2, #42	; 0x2a
 8043266:	d000      	beq.n	804326a <I2C_SlaveReceive_RXNE+0x32>
}
 8043268:	bd08      	pop	{r3, pc}
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 804326a:	6802      	ldr	r2, [r0, #0]
 804326c:	6853      	ldr	r3, [r2, #4]
 804326e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043272:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8043274:	2322      	movs	r3, #34	; 0x22
 8043276:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8043278:	2328      	movs	r3, #40	; 0x28
 804327a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 804327e:	f7ff ffda 	bl	8043236 <HAL_I2C_SlaveRxCpltCallback>
}
 8043282:	e7f1      	b.n	8043268 <I2C_SlaveReceive_RXNE+0x30>

08043284 <HAL_I2C_AddrCallback>:
}
 8043284:	4770      	bx	lr

08043286 <I2C_Slave_ADDR>:
{
 8043286:	b508      	push	{r3, lr}
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8043288:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804328c:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8043290:	2b28      	cmp	r3, #40	; 0x28
 8043292:	d007      	beq.n	80432a4 <I2C_Slave_ADDR+0x1e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8043294:	6803      	ldr	r3, [r0, #0]
 8043296:	f06f 0202 	mvn.w	r2, #2
 804329a:	615a      	str	r2, [r3, #20]
    __HAL_UNLOCK(hi2c);
 804329c:	2300      	movs	r3, #0
 804329e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
}
 80432a2:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 80432a4:	6802      	ldr	r2, [r0, #0]
 80432a6:	6853      	ldr	r3, [r2, #4]
 80432a8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80432ac:	6053      	str	r3, [r2, #4]
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 80432ae:	f011 0f04 	tst.w	r1, #4
 80432b2:	d00b      	beq.n	80432cc <I2C_Slave_ADDR+0x46>
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 80432b4:	2300      	movs	r3, #0
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 80432b6:	f011 0f80 	tst.w	r1, #128	; 0x80
 80432ba:	d109      	bne.n	80432d0 <I2C_Slave_ADDR+0x4a>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 80432bc:	8982      	ldrh	r2, [r0, #12]
    __HAL_UNLOCK(hi2c);
 80432be:	2100      	movs	r1, #0
 80432c0:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 80432c4:	4619      	mov	r1, r3
 80432c6:	f7ff ffdd 	bl	8043284 <HAL_I2C_AddrCallback>
 80432ca:	e7ea      	b.n	80432a2 <I2C_Slave_ADDR+0x1c>
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 80432cc:	2301      	movs	r3, #1
 80432ce:	e7f2      	b.n	80432b6 <I2C_Slave_ADDR+0x30>
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 80432d0:	8b02      	ldrh	r2, [r0, #24]
 80432d2:	e7f4      	b.n	80432be <I2C_Slave_ADDR+0x38>

080432d4 <HAL_I2C_ListenCpltCallback>:
}
 80432d4:	4770      	bx	lr
	...

080432d8 <I2C_Slave_AF>:
{
 80432d8:	b508      	push	{r3, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80432da:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80432de:	b2db      	uxtb	r3, r3
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 80432e0:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 80432e2:	2a08      	cmp	r2, #8
 80432e4:	d001      	beq.n	80432ea <I2C_Slave_AF+0x12>
 80432e6:	2a20      	cmp	r2, #32
 80432e8:	d101      	bne.n	80432ee <I2C_Slave_AF+0x16>
 80432ea:	2b28      	cmp	r3, #40	; 0x28
 80432ec:	d006      	beq.n	80432fc <I2C_Slave_AF+0x24>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 80432ee:	2b21      	cmp	r3, #33	; 0x21
 80432f0:	d01e      	beq.n	8043330 <I2C_Slave_AF+0x58>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80432f2:	6803      	ldr	r3, [r0, #0]
 80432f4:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 80432f8:	615a      	str	r2, [r3, #20]
}
 80432fa:	bd08      	pop	{r3, pc}
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80432fc:	4b1a      	ldr	r3, [pc, #104]	; (8043368 <I2C_Slave_AF+0x90>)
 80432fe:	62c3      	str	r3, [r0, #44]	; 0x2c
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043300:	6802      	ldr	r2, [r0, #0]
 8043302:	6853      	ldr	r3, [r2, #4]
 8043304:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043308:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 804330a:	6803      	ldr	r3, [r0, #0]
 804330c:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043310:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043312:	6802      	ldr	r2, [r0, #0]
 8043314:	6813      	ldr	r3, [r2, #0]
 8043316:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804331a:	6013      	str	r3, [r2, #0]
    hi2c->PreviousState = I2C_STATE_NONE;
 804331c:	2300      	movs	r3, #0
 804331e:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8043320:	2220      	movs	r2, #32
 8043322:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8043326:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 804332a:	f7ff ffd3 	bl	80432d4 <HAL_I2C_ListenCpltCallback>
 804332e:	e7e4      	b.n	80432fa <I2C_Slave_AF+0x22>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8043330:	4b0d      	ldr	r3, [pc, #52]	; (8043368 <I2C_Slave_AF+0x90>)
 8043332:	62c3      	str	r3, [r0, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8043334:	2321      	movs	r3, #33	; 0x21
 8043336:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 8043338:	2320      	movs	r3, #32
 804333a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 804333e:	2300      	movs	r3, #0
 8043340:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043344:	6802      	ldr	r2, [r0, #0]
 8043346:	6853      	ldr	r3, [r2, #4]
 8043348:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 804334c:	6053      	str	r3, [r2, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 804334e:	6803      	ldr	r3, [r0, #0]
 8043350:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043354:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043356:	6802      	ldr	r2, [r0, #0]
 8043358:	6813      	ldr	r3, [r2, #0]
 804335a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804335e:	6013      	str	r3, [r2, #0]
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8043360:	f7ff ff42 	bl	80431e8 <HAL_I2C_SlaveTxCpltCallback>
 8043364:	e7c9      	b.n	80432fa <I2C_Slave_AF+0x22>
 8043366:	bf00      	nop
 8043368:	ffff0000 	.word	0xffff0000

0804336c <I2C_MasterTransmit_TXE>:
{
 804336c:	b510      	push	{r4, lr}
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804336e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043372:	b2db      	uxtb	r3, r3
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8043374:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 8043378:	b2d2      	uxtb	r2, r2
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 804337a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 804337c:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 804337e:	b909      	cbnz	r1, 8043384 <I2C_MasterTransmit_TXE+0x18>
 8043380:	2b21      	cmp	r3, #33	; 0x21
 8043382:	d004      	beq.n	804338e <I2C_MasterTransmit_TXE+0x22>
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 8043384:	2b21      	cmp	r3, #33	; 0x21
 8043386:	d03b      	beq.n	8043400 <I2C_MasterTransmit_TXE+0x94>
 8043388:	2a40      	cmp	r2, #64	; 0x40
 804338a:	d037      	beq.n	80433fc <I2C_MasterTransmit_TXE+0x90>
}
 804338c:	bd10      	pop	{r4, pc}
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 804338e:	2c08      	cmp	r4, #8
 8043390:	d004      	beq.n	804339c <I2C_MasterTransmit_TXE+0x30>
 8043392:	2c20      	cmp	r4, #32
 8043394:	d002      	beq.n	804339c <I2C_MasterTransmit_TXE+0x30>
 8043396:	f514 3f80 	cmn.w	r4, #65536	; 0x10000
 804339a:	d119      	bne.n	80433d0 <I2C_MasterTransmit_TXE+0x64>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 804339c:	6802      	ldr	r2, [r0, #0]
 804339e:	6853      	ldr	r3, [r2, #4]
 80433a0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80433a4:	6053      	str	r3, [r2, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 80433a6:	6802      	ldr	r2, [r0, #0]
 80433a8:	6813      	ldr	r3, [r2, #0]
 80433aa:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80433ae:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 80433b0:	2300      	movs	r3, #0
 80433b2:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 80433b4:	2320      	movs	r3, #32
 80433b6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80433ba:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80433be:	b2db      	uxtb	r3, r3
 80433c0:	2b40      	cmp	r3, #64	; 0x40
 80433c2:	d015      	beq.n	80433f0 <I2C_MasterTransmit_TXE+0x84>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80433c4:	2300      	movs	r3, #0
 80433c6:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MasterTxCpltCallback(hi2c);
 80433ca:	f7ff ff0b 	bl	80431e4 <HAL_I2C_MasterTxCpltCallback>
 80433ce:	e7dd      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80433d0:	6802      	ldr	r2, [r0, #0]
 80433d2:	6853      	ldr	r3, [r2, #4]
 80433d4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80433d8:	6053      	str	r3, [r2, #4]
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 80433da:	2311      	movs	r3, #17
 80433dc:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80433de:	2300      	movs	r3, #0
 80433e0:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 80433e4:	2320      	movs	r3, #32
 80433e6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      HAL_I2C_MasterTxCpltCallback(hi2c);
 80433ea:	f7ff fefb 	bl	80431e4 <HAL_I2C_MasterTxCpltCallback>
 80433ee:	e7cd      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80433f0:	2300      	movs	r3, #0
 80433f2:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        HAL_I2C_MemTxCpltCallback(hi2c);
 80433f6:	f00d f84f 	bl	8050498 <HAL_I2C_MemTxCpltCallback>
 80433fa:	e7c7      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 80433fc:	2b22      	cmp	r3, #34	; 0x22
 80433fe:	d1c5      	bne.n	804338c <I2C_MasterTransmit_TXE+0x20>
    if (hi2c->XferCount == 0U)
 8043400:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043402:	b29b      	uxth	r3, r3
 8043404:	b92b      	cbnz	r3, 8043412 <I2C_MasterTransmit_TXE+0xa6>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8043406:	6802      	ldr	r2, [r0, #0]
 8043408:	6853      	ldr	r3, [r2, #4]
 804340a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804340e:	6053      	str	r3, [r2, #4]
 8043410:	e7bc      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043412:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043416:	b2db      	uxtb	r3, r3
 8043418:	2b40      	cmp	r3, #64	; 0x40
 804341a:	d00c      	beq.n	8043436 <I2C_MasterTransmit_TXE+0xca>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 804341c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 804341e:	6803      	ldr	r3, [r0, #0]
 8043420:	7812      	ldrb	r2, [r2, #0]
 8043422:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 8043424:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043426:	3301      	adds	r3, #1
 8043428:	6243      	str	r3, [r0, #36]	; 0x24
        hi2c->XferCount--;
 804342a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804342c:	b29b      	uxth	r3, r3
 804342e:	3b01      	subs	r3, #1
 8043430:	b29b      	uxth	r3, r3
 8043432:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043434:	e7aa      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
        if (hi2c->EventCount == 0U)
 8043436:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043438:	b99b      	cbnz	r3, 8043462 <I2C_MasterTransmit_TXE+0xf6>
          if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 804343a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 804343c:	2b01      	cmp	r3, #1
 804343e:	d008      	beq.n	8043452 <I2C_MasterTransmit_TXE+0xe6>
            hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 8043440:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8043442:	f3c3 2307 	ubfx	r3, r3, #8, #8
 8043446:	6802      	ldr	r2, [r0, #0]
 8043448:	6113      	str	r3, [r2, #16]
            hi2c->EventCount++;
 804344a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804344c:	3301      	adds	r3, #1
 804344e:	6503      	str	r3, [r0, #80]	; 0x50
 8043450:	e79c      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 8043452:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8043454:	6802      	ldr	r2, [r0, #0]
 8043456:	b2db      	uxtb	r3, r3
 8043458:	6113      	str	r3, [r2, #16]
            hi2c->EventCount += 2U;
 804345a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804345c:	3302      	adds	r3, #2
 804345e:	6503      	str	r3, [r0, #80]	; 0x50
 8043460:	e794      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
        else if (hi2c->EventCount == 1U)
 8043462:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043464:	2b01      	cmp	r3, #1
 8043466:	d019      	beq.n	804349c <I2C_MasterTransmit_TXE+0x130>
        else if (hi2c->EventCount == 2U)
 8043468:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804346a:	2b02      	cmp	r3, #2
 804346c:	d18e      	bne.n	804338c <I2C_MasterTransmit_TXE+0x20>
          if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 804346e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043472:	b2db      	uxtb	r3, r3
 8043474:	2b22      	cmp	r3, #34	; 0x22
 8043476:	d019      	beq.n	80434ac <I2C_MasterTransmit_TXE+0x140>
          else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8043478:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804347c:	b2db      	uxtb	r3, r3
 804347e:	2b21      	cmp	r3, #33	; 0x21
 8043480:	d184      	bne.n	804338c <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->DR = *hi2c->pBuffPtr;
 8043482:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8043484:	6803      	ldr	r3, [r0, #0]
 8043486:	7812      	ldrb	r2, [r2, #0]
 8043488:	611a      	str	r2, [r3, #16]
            hi2c->pBuffPtr++;
 804348a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804348c:	3301      	adds	r3, #1
 804348e:	6243      	str	r3, [r0, #36]	; 0x24
            hi2c->XferCount--;
 8043490:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043492:	b29b      	uxth	r3, r3
 8043494:	3b01      	subs	r3, #1
 8043496:	b29b      	uxth	r3, r3
 8043498:	8543      	strh	r3, [r0, #42]	; 0x2a
 804349a:	e777      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
          hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 804349c:	6c83      	ldr	r3, [r0, #72]	; 0x48
 804349e:	6802      	ldr	r2, [r0, #0]
 80434a0:	b2db      	uxtb	r3, r3
 80434a2:	6113      	str	r3, [r2, #16]
          hi2c->EventCount++;
 80434a4:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80434a6:	3301      	adds	r3, #1
 80434a8:	6503      	str	r3, [r0, #80]	; 0x50
 80434aa:	e76f      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>
            hi2c->Instance->CR1 |= I2C_CR1_START;
 80434ac:	6802      	ldr	r2, [r0, #0]
 80434ae:	6813      	ldr	r3, [r2, #0]
 80434b0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80434b4:	6013      	str	r3, [r2, #0]
 80434b6:	e769      	b.n	804338c <I2C_MasterTransmit_TXE+0x20>

080434b8 <I2C_MasterTransmit_BTF>:
{
 80434b8:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 80434ba:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80434bc:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80434c0:	b2db      	uxtb	r3, r3
 80434c2:	2b21      	cmp	r3, #33	; 0x21
 80434c4:	d000      	beq.n	80434c8 <I2C_MasterTransmit_BTF+0x10>
}
 80434c6:	bd08      	pop	{r3, pc}
    if (hi2c->XferCount != 0U)
 80434c8:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80434ca:	b29b      	uxth	r3, r3
 80434cc:	b163      	cbz	r3, 80434e8 <I2C_MasterTransmit_BTF+0x30>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 80434ce:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80434d0:	6803      	ldr	r3, [r0, #0]
 80434d2:	7812      	ldrb	r2, [r2, #0]
 80434d4:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 80434d6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80434d8:	3301      	adds	r3, #1
 80434da:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 80434dc:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80434de:	b29b      	uxth	r3, r3
 80434e0:	3b01      	subs	r3, #1
 80434e2:	b29b      	uxth	r3, r3
 80434e4:	8543      	strh	r3, [r0, #42]	; 0x2a
 80434e6:	e7ee      	b.n	80434c6 <I2C_MasterTransmit_BTF+0xe>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 80434e8:	2a08      	cmp	r2, #8
 80434ea:	d004      	beq.n	80434f6 <I2C_MasterTransmit_BTF+0x3e>
 80434ec:	2a20      	cmp	r2, #32
 80434ee:	d002      	beq.n	80434f6 <I2C_MasterTransmit_BTF+0x3e>
 80434f0:	f512 3f80 	cmn.w	r2, #65536	; 0x10000
 80434f4:	d119      	bne.n	804352a <I2C_MasterTransmit_BTF+0x72>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80434f6:	6802      	ldr	r2, [r0, #0]
 80434f8:	6853      	ldr	r3, [r2, #4]
 80434fa:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80434fe:	6053      	str	r3, [r2, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8043500:	6802      	ldr	r2, [r0, #0]
 8043502:	6813      	ldr	r3, [r2, #0]
 8043504:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8043508:	6013      	str	r3, [r2, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 804350a:	2300      	movs	r3, #0
 804350c:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 804350e:	2320      	movs	r3, #32
 8043510:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8043514:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043518:	b2db      	uxtb	r3, r3
 804351a:	2b40      	cmp	r3, #64	; 0x40
 804351c:	d015      	beq.n	804354a <I2C_MasterTransmit_BTF+0x92>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 804351e:	2300      	movs	r3, #0
 8043520:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
          HAL_I2C_MasterTxCpltCallback(hi2c);
 8043524:	f7ff fe5e 	bl	80431e4 <HAL_I2C_MasterTxCpltCallback>
}
 8043528:	e7cd      	b.n	80434c6 <I2C_MasterTransmit_BTF+0xe>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 804352a:	6802      	ldr	r2, [r0, #0]
 804352c:	6853      	ldr	r3, [r2, #4]
 804352e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8043532:	6053      	str	r3, [r2, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8043534:	2311      	movs	r3, #17
 8043536:	6303      	str	r3, [r0, #48]	; 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043538:	2300      	movs	r3, #0
 804353a:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 804353e:	2320      	movs	r3, #32
 8043540:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 8043544:	f7ff fe4e 	bl	80431e4 <HAL_I2C_MasterTxCpltCallback>
 8043548:	e7bd      	b.n	80434c6 <I2C_MasterTransmit_BTF+0xe>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 804354a:	2300      	movs	r3, #0
 804354c:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
          HAL_I2C_MemTxCpltCallback(hi2c);
 8043550:	f00c ffa2 	bl	8050498 <HAL_I2C_MemTxCpltCallback>
 8043554:	e7b7      	b.n	80434c6 <I2C_MasterTransmit_BTF+0xe>

08043556 <I2C_MasterReceive_RXNE>:
{
 8043556:	b508      	push	{r3, lr}
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8043558:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804355c:	b2db      	uxtb	r3, r3
 804355e:	2b22      	cmp	r3, #34	; 0x22
 8043560:	d000      	beq.n	8043564 <I2C_MasterReceive_RXNE+0xe>
}
 8043562:	bd08      	pop	{r3, pc}
    tmp = hi2c->XferCount;
 8043564:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043566:	b29b      	uxth	r3, r3
    if (tmp > 3U)
 8043568:	2b03      	cmp	r3, #3
 804356a:	d915      	bls.n	8043598 <I2C_MasterReceive_RXNE+0x42>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 804356c:	6803      	ldr	r3, [r0, #0]
 804356e:	691a      	ldr	r2, [r3, #16]
 8043570:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043572:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8043574:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043576:	3301      	adds	r3, #1
 8043578:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 804357a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804357c:	b29b      	uxth	r3, r3
 804357e:	3b01      	subs	r3, #1
 8043580:	b29b      	uxth	r3, r3
 8043582:	8543      	strh	r3, [r0, #42]	; 0x2a
      if (hi2c->XferCount == (uint16_t)3)
 8043584:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043586:	b29b      	uxth	r3, r3
 8043588:	2b03      	cmp	r3, #3
 804358a:	d1ea      	bne.n	8043562 <I2C_MasterReceive_RXNE+0xc>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 804358c:	6802      	ldr	r2, [r0, #0]
 804358e:	6853      	ldr	r3, [r2, #4]
 8043590:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043594:	6053      	str	r3, [r2, #4]
 8043596:	e7e4      	b.n	8043562 <I2C_MasterReceive_RXNE+0xc>
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 8043598:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 804359a:	2a02      	cmp	r2, #2
 804359c:	d0e1      	beq.n	8043562 <I2C_MasterReceive_RXNE+0xc>
 804359e:	2b01      	cmp	r3, #1
 80435a0:	d8df      	bhi.n	8043562 <I2C_MasterReceive_RXNE+0xc>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80435a2:	6802      	ldr	r2, [r0, #0]
 80435a4:	6813      	ldr	r3, [r2, #0]
 80435a6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80435aa:	6013      	str	r3, [r2, #0]
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80435ac:	6802      	ldr	r2, [r0, #0]
 80435ae:	6853      	ldr	r3, [r2, #4]
 80435b0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80435b4:	6053      	str	r3, [r2, #4]
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80435b6:	6803      	ldr	r3, [r0, #0]
 80435b8:	691a      	ldr	r2, [r3, #16]
 80435ba:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80435bc:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80435be:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80435c0:	3301      	adds	r3, #1
 80435c2:	6243      	str	r3, [r0, #36]	; 0x24
      hi2c->XferCount--;
 80435c4:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80435c6:	b29b      	uxth	r3, r3
 80435c8:	3b01      	subs	r3, #1
 80435ca:	b29b      	uxth	r3, r3
 80435cc:	8543      	strh	r3, [r0, #42]	; 0x2a
      hi2c->State = HAL_I2C_STATE_READY;
 80435ce:	2320      	movs	r3, #32
 80435d0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80435d4:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80435d8:	b2db      	uxtb	r3, r3
 80435da:	2b40      	cmp	r3, #64	; 0x40
 80435dc:	d007      	beq.n	80435ee <I2C_MasterReceive_RXNE+0x98>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80435de:	2300      	movs	r3, #0
 80435e0:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80435e4:	2312      	movs	r3, #18
 80435e6:	6303      	str	r3, [r0, #48]	; 0x30
        HAL_I2C_MasterRxCpltCallback(hi2c);
 80435e8:	f7ff fdfd 	bl	80431e6 <HAL_I2C_MasterRxCpltCallback>
}
 80435ec:	e7b9      	b.n	8043562 <I2C_MasterReceive_RXNE+0xc>
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80435ee:	2300      	movs	r3, #0
 80435f0:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
        hi2c->PreviousState = I2C_STATE_NONE;
 80435f4:	6303      	str	r3, [r0, #48]	; 0x30
        HAL_I2C_MemRxCpltCallback(hi2c);
 80435f6:	f00c ff05 	bl	8050404 <HAL_I2C_MemRxCpltCallback>
 80435fa:	e7b2      	b.n	8043562 <I2C_MasterReceive_RXNE+0xc>

080435fc <I2C_MasterReceive_BTF>:
{
 80435fc:	b508      	push	{r3, lr}
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 80435fe:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  if (hi2c->XferCount == 4U)
 8043600:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043602:	b29b      	uxth	r3, r3
 8043604:	2b04      	cmp	r3, #4
 8043606:	d014      	beq.n	8043632 <I2C_MasterReceive_BTF+0x36>
  else if (hi2c->XferCount == 3U)
 8043608:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804360a:	b29b      	uxth	r3, r3
 804360c:	2b03      	cmp	r3, #3
 804360e:	d022      	beq.n	8043656 <I2C_MasterReceive_BTF+0x5a>
  else if (hi2c->XferCount == 2U)
 8043610:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043612:	b29b      	uxth	r3, r3
 8043614:	2b02      	cmp	r3, #2
 8043616:	d039      	beq.n	804368c <I2C_MasterReceive_BTF+0x90>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043618:	6803      	ldr	r3, [r0, #0]
 804361a:	691a      	ldr	r2, [r3, #16]
 804361c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804361e:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8043620:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043622:	3301      	adds	r3, #1
 8043624:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043626:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043628:	b29b      	uxth	r3, r3
 804362a:	3b01      	subs	r3, #1
 804362c:	b29b      	uxth	r3, r3
 804362e:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043630:	e010      	b.n	8043654 <I2C_MasterReceive_BTF+0x58>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8043632:	6802      	ldr	r2, [r0, #0]
 8043634:	6853      	ldr	r3, [r2, #4]
 8043636:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804363a:	6053      	str	r3, [r2, #4]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 804363c:	6803      	ldr	r3, [r0, #0]
 804363e:	691a      	ldr	r2, [r3, #16]
 8043640:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043642:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8043644:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043646:	3301      	adds	r3, #1
 8043648:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 804364a:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 804364c:	b29b      	uxth	r3, r3
 804364e:	3b01      	subs	r3, #1
 8043650:	b29b      	uxth	r3, r3
 8043652:	8543      	strh	r3, [r0, #42]	; 0x2a
}
 8043654:	bd08      	pop	{r3, pc}
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 8043656:	6801      	ldr	r1, [r0, #0]
 8043658:	684b      	ldr	r3, [r1, #4]
 804365a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804365e:	604b      	str	r3, [r1, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 8043660:	2a04      	cmp	r2, #4
 8043662:	d006      	beq.n	8043672 <I2C_MasterReceive_BTF+0x76>
 8043664:	2a02      	cmp	r2, #2
 8043666:	d004      	beq.n	8043672 <I2C_MasterReceive_BTF+0x76>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043668:	6802      	ldr	r2, [r0, #0]
 804366a:	6813      	ldr	r3, [r2, #0]
 804366c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8043670:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043672:	6803      	ldr	r3, [r0, #0]
 8043674:	691a      	ldr	r2, [r3, #16]
 8043676:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8043678:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 804367a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 804367c:	3301      	adds	r3, #1
 804367e:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 8043680:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 8043682:	b29b      	uxth	r3, r3
 8043684:	3b01      	subs	r3, #1
 8043686:	b29b      	uxth	r3, r3
 8043688:	8543      	strh	r3, [r0, #42]	; 0x2a
 804368a:	e7e3      	b.n	8043654 <I2C_MasterReceive_BTF+0x58>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 804368c:	2a01      	cmp	r2, #1
 804368e:	d00b      	beq.n	80436a8 <I2C_MasterReceive_BTF+0xac>
 8043690:	2a10      	cmp	r2, #16
 8043692:	d009      	beq.n	80436a8 <I2C_MasterReceive_BTF+0xac>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 8043694:	2a04      	cmp	r2, #4
 8043696:	d038      	beq.n	804370a <I2C_MasterReceive_BTF+0x10e>
 8043698:	2a02      	cmp	r2, #2
 804369a:	d036      	beq.n	804370a <I2C_MasterReceive_BTF+0x10e>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 804369c:	6802      	ldr	r2, [r0, #0]
 804369e:	6813      	ldr	r3, [r2, #0]
 80436a0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80436a4:	6013      	str	r3, [r2, #0]
 80436a6:	e004      	b.n	80436b2 <I2C_MasterReceive_BTF+0xb6>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 80436a8:	6802      	ldr	r2, [r0, #0]
 80436aa:	6813      	ldr	r3, [r2, #0]
 80436ac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80436b0:	6013      	str	r3, [r2, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80436b2:	6803      	ldr	r3, [r0, #0]
 80436b4:	691a      	ldr	r2, [r3, #16]
 80436b6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80436b8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 80436ba:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80436bc:	1c53      	adds	r3, r2, #1
 80436be:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 80436c0:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80436c2:	b29b      	uxth	r3, r3
 80436c4:	3b01      	subs	r3, #1
 80436c6:	b29b      	uxth	r3, r3
 80436c8:	8543      	strh	r3, [r0, #42]	; 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80436ca:	6803      	ldr	r3, [r0, #0]
 80436cc:	691b      	ldr	r3, [r3, #16]
 80436ce:	7053      	strb	r3, [r2, #1]
    hi2c->pBuffPtr++;
 80436d0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80436d2:	3301      	adds	r3, #1
 80436d4:	6243      	str	r3, [r0, #36]	; 0x24
    hi2c->XferCount--;
 80436d6:	8d43      	ldrh	r3, [r0, #42]	; 0x2a
 80436d8:	b29b      	uxth	r3, r3
 80436da:	3b01      	subs	r3, #1
 80436dc:	b29b      	uxth	r3, r3
 80436de:	8543      	strh	r3, [r0, #42]	; 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 80436e0:	6802      	ldr	r2, [r0, #0]
 80436e2:	6853      	ldr	r3, [r2, #4]
 80436e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80436e8:	6053      	str	r3, [r2, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80436ea:	2320      	movs	r3, #32
 80436ec:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80436f0:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 80436f4:	b2db      	uxtb	r3, r3
 80436f6:	2b40      	cmp	r3, #64	; 0x40
 80436f8:	d00d      	beq.n	8043716 <I2C_MasterReceive_BTF+0x11a>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80436fa:	2300      	movs	r3, #0
 80436fc:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8043700:	2312      	movs	r3, #18
 8043702:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8043704:	f7ff fd6f 	bl	80431e6 <HAL_I2C_MasterRxCpltCallback>
 8043708:	e7a4      	b.n	8043654 <I2C_MasterReceive_BTF+0x58>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 804370a:	6802      	ldr	r2, [r0, #0]
 804370c:	6813      	ldr	r3, [r2, #0]
 804370e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8043712:	6013      	str	r3, [r2, #0]
 8043714:	e7cd      	b.n	80436b2 <I2C_MasterReceive_BTF+0xb6>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8043716:	2300      	movs	r3, #0
 8043718:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 804371c:	6303      	str	r3, [r0, #48]	; 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 804371e:	f00c fe71 	bl	8050404 <HAL_I2C_MemRxCpltCallback>
 8043722:	e797      	b.n	8043654 <I2C_MasterReceive_BTF+0x58>

08043724 <HAL_I2C_AbortCpltCallback>:
}
 8043724:	4770      	bx	lr

08043726 <I2C_DMAAbort>:
{
 8043726:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 8043728:	6b80      	ldr	r0, [r0, #56]	; 0x38
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804372a:	f890 203d 	ldrb.w	r2, [r0, #61]	; 0x3d
  hi2c->hdmatx->XferCpltCallback = NULL;
 804372e:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8043730:	2300      	movs	r3, #0
 8043732:	63cb      	str	r3, [r1, #60]	; 0x3c
  hi2c->hdmarx->XferCpltCallback = NULL;
 8043734:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8043736:	63cb      	str	r3, [r1, #60]	; 0x3c
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043738:	6804      	ldr	r4, [r0, #0]
 804373a:	6821      	ldr	r1, [r4, #0]
 804373c:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 8043740:	6021      	str	r1, [r4, #0]
  hi2c->XferCount = 0U;
 8043742:	8543      	strh	r3, [r0, #42]	; 0x2a
  hi2c->hdmatx->XferAbortCallback = NULL;
 8043744:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8043746:	650b      	str	r3, [r1, #80]	; 0x50
  hi2c->hdmarx->XferAbortCallback = NULL;
 8043748:	6b81      	ldr	r1, [r0, #56]	; 0x38
 804374a:	650b      	str	r3, [r1, #80]	; 0x50
  __HAL_I2C_DISABLE(hi2c);
 804374c:	6801      	ldr	r1, [r0, #0]
 804374e:	680b      	ldr	r3, [r1, #0]
 8043750:	f023 0301 	bic.w	r3, r3, #1
 8043754:	600b      	str	r3, [r1, #0]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8043756:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804375a:	b2db      	uxtb	r3, r3
 804375c:	2b60      	cmp	r3, #96	; 0x60
 804375e:	d00d      	beq.n	804377c <I2C_DMAAbort+0x56>
 8043760:	b2d2      	uxtb	r2, r2
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8043762:	f002 0228 	and.w	r2, r2, #40	; 0x28
 8043766:	2a28      	cmp	r2, #40	; 0x28
 8043768:	d012      	beq.n	8043790 <I2C_DMAAbort+0x6a>
      hi2c->State = HAL_I2C_STATE_READY;
 804376a:	2320      	movs	r3, #32
 804376c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8043770:	2300      	movs	r3, #0
 8043772:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 8043776:	f00c fdc3 	bl	8050300 <HAL_I2C_ErrorCallback>
}
 804377a:	bd10      	pop	{r4, pc}
    hi2c->State         = HAL_I2C_STATE_READY;
 804377c:	2320      	movs	r3, #32
 804377e:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8043782:	2300      	movs	r3, #0
 8043784:	f880 303e 	strb.w	r3, [r0, #62]	; 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 8043788:	6403      	str	r3, [r0, #64]	; 0x40
    HAL_I2C_AbortCpltCallback(hi2c);
 804378a:	f7ff ffcb 	bl	8043724 <HAL_I2C_AbortCpltCallback>
 804378e:	e7f4      	b.n	804377a <I2C_DMAAbort+0x54>
      __HAL_I2C_ENABLE(hi2c);
 8043790:	6802      	ldr	r2, [r0, #0]
 8043792:	6813      	ldr	r3, [r2, #0]
 8043794:	f043 0301 	orr.w	r3, r3, #1
 8043798:	6013      	str	r3, [r2, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 804379a:	6802      	ldr	r2, [r0, #0]
 804379c:	6813      	ldr	r3, [r2, #0]
 804379e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80437a2:	6013      	str	r3, [r2, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 80437a4:	2300      	movs	r3, #0
 80437a6:	6303      	str	r3, [r0, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 80437a8:	2328      	movs	r3, #40	; 0x28
 80437aa:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
 80437ae:	e7e2      	b.n	8043776 <I2C_DMAAbort+0x50>

080437b0 <I2C_ITError>:
{
 80437b0:	b510      	push	{r4, lr}
 80437b2:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 80437b4:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80437b8:	b2db      	uxtb	r3, r3
  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 80437ba:	f890 203e 	ldrb.w	r2, [r0, #62]	; 0x3e
 80437be:	b2d2      	uxtb	r2, r2
 80437c0:	2a10      	cmp	r2, #16
 80437c2:	d033      	beq.n	804382c <I2C_ITError+0x7c>
  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 80437c4:	f003 0228 	and.w	r2, r3, #40	; 0x28
 80437c8:	2a28      	cmp	r2, #40	; 0x28
 80437ca:	d037      	beq.n	804383c <I2C_ITError+0x8c>
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 80437cc:	6822      	ldr	r2, [r4, #0]
 80437ce:	6852      	ldr	r2, [r2, #4]
 80437d0:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80437d4:	d104      	bne.n	80437e0 <I2C_ITError+0x30>
 80437d6:	2b60      	cmp	r3, #96	; 0x60
 80437d8:	d002      	beq.n	80437e0 <I2C_ITError+0x30>
      hi2c->State = HAL_I2C_STATE_READY;
 80437da:	2320      	movs	r3, #32
 80437dc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->PreviousState = I2C_STATE_NONE;
 80437e0:	2300      	movs	r3, #0
 80437e2:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80437e4:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 80437e8:	6823      	ldr	r3, [r4, #0]
 80437ea:	685a      	ldr	r2, [r3, #4]
 80437ec:	f412 6f00 	tst.w	r2, #2048	; 0x800
 80437f0:	d048      	beq.n	8043884 <I2C_ITError+0xd4>
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 80437f2:	685a      	ldr	r2, [r3, #4]
 80437f4:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80437f8:	605a      	str	r2, [r3, #4]
    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 80437fa:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80437fc:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8043800:	b2db      	uxtb	r3, r3
 8043802:	2b01      	cmp	r3, #1
 8043804:	d020      	beq.n	8043848 <I2C_ITError+0x98>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8043806:	4b42      	ldr	r3, [pc, #264]	; (8043910 <I2C_ITError+0x160>)
 8043808:	6513      	str	r3, [r2, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 804380a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 804380c:	f7fe f9d8 	bl	8041bc0 <HAL_DMA_Abort_IT>
 8043810:	2800      	cmp	r0, #0
 8043812:	d049      	beq.n	80438a8 <I2C_ITError+0xf8>
        __HAL_I2C_DISABLE(hi2c);
 8043814:	6822      	ldr	r2, [r4, #0]
 8043816:	6813      	ldr	r3, [r2, #0]
 8043818:	f023 0301 	bic.w	r3, r3, #1
 804381c:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 804381e:	2320      	movs	r3, #32
 8043820:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8043824:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8043826:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043828:	4798      	blx	r3
 804382a:	e03d      	b.n	80438a8 <I2C_ITError+0xf8>
  if ((hi2c->Mode == HAL_I2C_MODE_MASTER) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 804382c:	2b22      	cmp	r3, #34	; 0x22
 804382e:	d1c9      	bne.n	80437c4 <I2C_ITError+0x14>
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 8043830:	6801      	ldr	r1, [r0, #0]
 8043832:	680a      	ldr	r2, [r1, #0]
 8043834:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8043838:	600a      	str	r2, [r1, #0]
 804383a:	e7c3      	b.n	80437c4 <I2C_ITError+0x14>
    hi2c->PreviousState = I2C_STATE_NONE;
 804383c:	2300      	movs	r3, #0
 804383e:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 8043840:	2328      	movs	r3, #40	; 0x28
 8043842:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
 8043846:	e7cf      	b.n	80437e8 <I2C_ITError+0x38>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8043848:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 804384a:	4a31      	ldr	r2, [pc, #196]	; (8043910 <I2C_ITError+0x160>)
 804384c:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 804384e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043850:	f7fe f9b6 	bl	8041bc0 <HAL_DMA_Abort_IT>
 8043854:	b340      	cbz	r0, 80438a8 <I2C_ITError+0xf8>
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 8043856:	6823      	ldr	r3, [r4, #0]
 8043858:	695a      	ldr	r2, [r3, #20]
 804385a:	f012 0f40 	tst.w	r2, #64	; 0x40
 804385e:	d005      	beq.n	804386c <I2C_ITError+0xbc>
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043860:	691a      	ldr	r2, [r3, #16]
 8043862:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043864:	701a      	strb	r2, [r3, #0]
          hi2c->pBuffPtr++;
 8043866:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043868:	3301      	adds	r3, #1
 804386a:	6263      	str	r3, [r4, #36]	; 0x24
        __HAL_I2C_DISABLE(hi2c);
 804386c:	6822      	ldr	r2, [r4, #0]
 804386e:	6813      	ldr	r3, [r2, #0]
 8043870:	f023 0301 	bic.w	r3, r3, #1
 8043874:	6013      	str	r3, [r2, #0]
        hi2c->State = HAL_I2C_STATE_READY;
 8043876:	2320      	movs	r3, #32
 8043878:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 804387c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 804387e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043880:	4798      	blx	r3
 8043882:	e011      	b.n	80438a8 <I2C_ITError+0xf8>
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 8043884:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8043888:	b2d2      	uxtb	r2, r2
 804388a:	2a60      	cmp	r2, #96	; 0x60
 804388c:	d016      	beq.n	80438bc <I2C_ITError+0x10c>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 804388e:	695a      	ldr	r2, [r3, #20]
 8043890:	f012 0f40 	tst.w	r2, #64	; 0x40
 8043894:	d005      	beq.n	80438a2 <I2C_ITError+0xf2>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 8043896:	691a      	ldr	r2, [r3, #16]
 8043898:	6a63      	ldr	r3, [r4, #36]	; 0x24
 804389a:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 804389c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 804389e:	3301      	adds	r3, #1
 80438a0:	6263      	str	r3, [r4, #36]	; 0x24
    HAL_I2C_ErrorCallback(hi2c);
 80438a2:	4620      	mov	r0, r4
 80438a4:	f00c fd2c 	bl	8050300 <HAL_I2C_ErrorCallback>
  CurrentState = hi2c->State;
 80438a8:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80438ac:	b2db      	uxtb	r3, r3
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 80438ae:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80438b0:	f012 0f04 	tst.w	r2, #4
 80438b4:	d001      	beq.n	80438ba <I2C_ITError+0x10a>
 80438b6:	2b28      	cmp	r3, #40	; 0x28
 80438b8:	d018      	beq.n	80438ec <I2C_ITError+0x13c>
}
 80438ba:	bd10      	pop	{r4, pc}
    hi2c->State = HAL_I2C_STATE_READY;
 80438bc:	2220      	movs	r2, #32
 80438be:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80438c2:	2200      	movs	r2, #0
 80438c4:	6422      	str	r2, [r4, #64]	; 0x40
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80438c6:	695a      	ldr	r2, [r3, #20]
 80438c8:	f012 0f40 	tst.w	r2, #64	; 0x40
 80438cc:	d005      	beq.n	80438da <I2C_ITError+0x12a>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80438ce:	691a      	ldr	r2, [r3, #16]
 80438d0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438d2:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80438d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80438d6:	3301      	adds	r3, #1
 80438d8:	6263      	str	r3, [r4, #36]	; 0x24
    __HAL_I2C_DISABLE(hi2c);
 80438da:	6822      	ldr	r2, [r4, #0]
 80438dc:	6813      	ldr	r3, [r2, #0]
 80438de:	f023 0301 	bic.w	r3, r3, #1
 80438e2:	6013      	str	r3, [r2, #0]
    HAL_I2C_AbortCpltCallback(hi2c);
 80438e4:	4620      	mov	r0, r4
 80438e6:	f7ff ff1d 	bl	8043724 <HAL_I2C_AbortCpltCallback>
 80438ea:	e7dd      	b.n	80438a8 <I2C_ITError+0xf8>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 80438ec:	6822      	ldr	r2, [r4, #0]
 80438ee:	6853      	ldr	r3, [r2, #4]
 80438f0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80438f4:	6053      	str	r3, [r2, #4]
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80438f6:	4b07      	ldr	r3, [pc, #28]	; (8043914 <I2C_ITError+0x164>)
 80438f8:	62e3      	str	r3, [r4, #44]	; 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 80438fa:	2300      	movs	r3, #0
 80438fc:	6323      	str	r3, [r4, #48]	; 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 80438fe:	2220      	movs	r2, #32
 8043900:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 8043904:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    HAL_I2C_ListenCpltCallback(hi2c);
 8043908:	4620      	mov	r0, r4
 804390a:	f7ff fce3 	bl	80432d4 <HAL_I2C_ListenCpltCallback>
}
 804390e:	e7d4      	b.n	80438ba <I2C_ITError+0x10a>
 8043910:	08043727 	.word	0x08043727
 8043914:	ffff0000 	.word	0xffff0000

08043918 <I2C_Slave_STOPF>:
{
 8043918:	b530      	push	{r4, r5, lr}
 804391a:	b083      	sub	sp, #12
 804391c:	4604      	mov	r4, r0
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 804391e:	f890 503d 	ldrb.w	r5, [r0, #61]	; 0x3d
 8043922:	b2ed      	uxtb	r5, r5
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8043924:	6802      	ldr	r2, [r0, #0]
 8043926:	6853      	ldr	r3, [r2, #4]
 8043928:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 804392c:	6053      	str	r3, [r2, #4]
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 804392e:	2300      	movs	r3, #0
 8043930:	9301      	str	r3, [sp, #4]
 8043932:	6803      	ldr	r3, [r0, #0]
 8043934:	695a      	ldr	r2, [r3, #20]
 8043936:	9201      	str	r2, [sp, #4]
 8043938:	681a      	ldr	r2, [r3, #0]
 804393a:	f042 0201 	orr.w	r2, r2, #1
 804393e:	601a      	str	r2, [r3, #0]
 8043940:	9b01      	ldr	r3, [sp, #4]
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 8043942:	6802      	ldr	r2, [r0, #0]
 8043944:	6813      	ldr	r3, [r2, #0]
 8043946:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 804394a:	6013      	str	r3, [r2, #0]
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 804394c:	6803      	ldr	r3, [r0, #0]
 804394e:	685a      	ldr	r2, [r3, #4]
 8043950:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043954:	d038      	beq.n	80439c8 <I2C_Slave_STOPF+0xb0>
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8043956:	2d22      	cmp	r5, #34	; 0x22
 8043958:	d021      	beq.n	804399e <I2C_Slave_STOPF+0x86>
 804395a:	2d2a      	cmp	r5, #42	; 0x2a
 804395c:	d01f      	beq.n	804399e <I2C_Slave_STOPF+0x86>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
 804395e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8043960:	6812      	ldr	r2, [r2, #0]
 8043962:	6852      	ldr	r2, [r2, #4]
 8043964:	b292      	uxth	r2, r2
 8043966:	8542      	strh	r2, [r0, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 8043968:	8d42      	ldrh	r2, [r0, #42]	; 0x2a
 804396a:	b292      	uxth	r2, r2
 804396c:	b11a      	cbz	r2, 8043976 <I2C_Slave_STOPF+0x5e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 804396e:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8043970:	f042 0204 	orr.w	r2, r2, #4
 8043974:	6402      	str	r2, [r0, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 8043976:	685a      	ldr	r2, [r3, #4]
 8043978:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 804397c:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 804397e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8043980:	f7fe fa20 	bl	8041dc4 <HAL_DMA_GetState>
 8043984:	2801      	cmp	r0, #1
 8043986:	d01f      	beq.n	80439c8 <I2C_Slave_STOPF+0xb0>
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8043988:	6b63      	ldr	r3, [r4, #52]	; 0x34
 804398a:	4a44      	ldr	r2, [pc, #272]	; (8043a9c <I2C_Slave_STOPF+0x184>)
 804398c:	651a      	str	r2, [r3, #80]	; 0x50
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 804398e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8043990:	f7fe f916 	bl	8041bc0 <HAL_DMA_Abort_IT>
 8043994:	b1c0      	cbz	r0, 80439c8 <I2C_Slave_STOPF+0xb0>
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8043996:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8043998:	6d03      	ldr	r3, [r0, #80]	; 0x50
 804399a:	4798      	blx	r3
 804399c:	e014      	b.n	80439c8 <I2C_Slave_STOPF+0xb0>
      hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
 804399e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80439a0:	6812      	ldr	r2, [r2, #0]
 80439a2:	6852      	ldr	r2, [r2, #4]
 80439a4:	b292      	uxth	r2, r2
 80439a6:	8562      	strh	r2, [r4, #42]	; 0x2a
      if (hi2c->XferCount != 0U)
 80439a8:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80439aa:	b292      	uxth	r2, r2
 80439ac:	b11a      	cbz	r2, 80439b6 <I2C_Slave_STOPF+0x9e>
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80439ae:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80439b0:	f042 0204 	orr.w	r2, r2, #4
 80439b4:	6422      	str	r2, [r4, #64]	; 0x40
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 80439b6:	685a      	ldr	r2, [r3, #4]
 80439b8:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80439bc:	605a      	str	r2, [r3, #4]
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 80439be:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80439c0:	f7fe fa00 	bl	8041dc4 <HAL_DMA_GetState>
 80439c4:	2801      	cmp	r0, #1
 80439c6:	d142      	bne.n	8043a4e <I2C_Slave_STOPF+0x136>
  if (hi2c->XferCount != 0U)
 80439c8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80439ca:	b29b      	uxth	r3, r3
 80439cc:	b333      	cbz	r3, 8043a1c <I2C_Slave_STOPF+0x104>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 80439ce:	6823      	ldr	r3, [r4, #0]
 80439d0:	695a      	ldr	r2, [r3, #20]
 80439d2:	f012 0f04 	tst.w	r2, #4
 80439d6:	d00a      	beq.n	80439ee <I2C_Slave_STOPF+0xd6>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80439d8:	691a      	ldr	r2, [r3, #16]
 80439da:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80439dc:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80439de:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80439e0:	3301      	adds	r3, #1
 80439e2:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 80439e4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80439e6:	b29b      	uxth	r3, r3
 80439e8:	3b01      	subs	r3, #1
 80439ea:	b29b      	uxth	r3, r3
 80439ec:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 80439ee:	6823      	ldr	r3, [r4, #0]
 80439f0:	695a      	ldr	r2, [r3, #20]
 80439f2:	f012 0f40 	tst.w	r2, #64	; 0x40
 80439f6:	d00a      	beq.n	8043a0e <I2C_Slave_STOPF+0xf6>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 80439f8:	691a      	ldr	r2, [r3, #16]
 80439fa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80439fc:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 80439fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8043a00:	3301      	adds	r3, #1
 8043a02:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8043a04:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a06:	b29b      	uxth	r3, r3
 8043a08:	3b01      	subs	r3, #1
 8043a0a:	b29b      	uxth	r3, r3
 8043a0c:	8563      	strh	r3, [r4, #42]	; 0x2a
    if (hi2c->XferCount != 0U)
 8043a0e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8043a10:	b29b      	uxth	r3, r3
 8043a12:	b11b      	cbz	r3, 8043a1c <I2C_Slave_STOPF+0x104>
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8043a14:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043a16:	f043 0304 	orr.w	r3, r3, #4
 8043a1a:	6423      	str	r3, [r4, #64]	; 0x40
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043a1c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043a1e:	bb13      	cbnz	r3, 8043a66 <I2C_Slave_STOPF+0x14e>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 8043a20:	2d2a      	cmp	r5, #42	; 0x2a
 8043a22:	d025      	beq.n	8043a70 <I2C_Slave_STOPF+0x158>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8043a24:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 8043a28:	b2db      	uxtb	r3, r3
 8043a2a:	2b28      	cmp	r3, #40	; 0x28
 8043a2c:	d029      	beq.n	8043a82 <I2C_Slave_STOPF+0x16a>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 8043a2e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8043a30:	2b22      	cmp	r3, #34	; 0x22
 8043a32:	d001      	beq.n	8043a38 <I2C_Slave_STOPF+0x120>
 8043a34:	2d22      	cmp	r5, #34	; 0x22
 8043a36:	d119      	bne.n	8043a6c <I2C_Slave_STOPF+0x154>
        hi2c->PreviousState = I2C_STATE_NONE;
 8043a38:	2300      	movs	r3, #0
 8043a3a:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 8043a3c:	2220      	movs	r2, #32
 8043a3e:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8043a42:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 8043a46:	4620      	mov	r0, r4
 8043a48:	f7ff fbf5 	bl	8043236 <HAL_I2C_SlaveRxCpltCallback>
}
 8043a4c:	e00e      	b.n	8043a6c <I2C_Slave_STOPF+0x154>
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8043a4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8043a50:	4a12      	ldr	r2, [pc, #72]	; (8043a9c <I2C_Slave_STOPF+0x184>)
 8043a52:	651a      	str	r2, [r3, #80]	; 0x50
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8043a54:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043a56:	f7fe f8b3 	bl	8041bc0 <HAL_DMA_Abort_IT>
 8043a5a:	2800      	cmp	r0, #0
 8043a5c:	d0b4      	beq.n	80439c8 <I2C_Slave_STOPF+0xb0>
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8043a5e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8043a60:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8043a62:	4798      	blx	r3
 8043a64:	e7b0      	b.n	80439c8 <I2C_Slave_STOPF+0xb0>
    I2C_ITError(hi2c);
 8043a66:	4620      	mov	r0, r4
 8043a68:	f7ff fea2 	bl	80437b0 <I2C_ITError>
}
 8043a6c:	b003      	add	sp, #12
 8043a6e:	bd30      	pop	{r4, r5, pc}
      hi2c->PreviousState = I2C_STATE_NONE;
 8043a70:	2300      	movs	r3, #0
 8043a72:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 8043a74:	2328      	movs	r3, #40	; 0x28
 8043a76:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 8043a7a:	4620      	mov	r0, r4
 8043a7c:	f7ff fbdb 	bl	8043236 <HAL_I2C_SlaveRxCpltCallback>
 8043a80:	e7d0      	b.n	8043a24 <I2C_Slave_STOPF+0x10c>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8043a82:	4b07      	ldr	r3, [pc, #28]	; (8043aa0 <I2C_Slave_STOPF+0x188>)
 8043a84:	62e3      	str	r3, [r4, #44]	; 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 8043a86:	2300      	movs	r3, #0
 8043a88:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 8043a8a:	2220      	movs	r2, #32
 8043a8c:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8043a90:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 8043a94:	4620      	mov	r0, r4
 8043a96:	f7ff fc1d 	bl	80432d4 <HAL_I2C_ListenCpltCallback>
 8043a9a:	e7e7      	b.n	8043a6c <I2C_Slave_STOPF+0x154>
 8043a9c:	08043727 	.word	0x08043727
 8043aa0:	ffff0000 	.word	0xffff0000

08043aa4 <HAL_I2C_EV_IRQHandler>:
{
 8043aa4:	b570      	push	{r4, r5, r6, lr}
 8043aa6:	4604      	mov	r4, r0
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 8043aa8:	6802      	ldr	r2, [r0, #0]
 8043aaa:	6855      	ldr	r5, [r2, #4]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 8043aac:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 8043aae:	f890 303e 	ldrb.w	r3, [r0, #62]	; 0x3e
 8043ab2:	b2db      	uxtb	r3, r3
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 8043ab4:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 8043ab8:	2b10      	cmp	r3, #16
 8043aba:	d014      	beq.n	8043ae6 <HAL_I2C_EV_IRQHandler+0x42>
 8043abc:	b2c8      	uxtb	r0, r1
 8043abe:	2b40      	cmp	r3, #64	; 0x40
 8043ac0:	d011      	beq.n	8043ae6 <HAL_I2C_EV_IRQHandler+0x42>
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043ac2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043ac4:	2b00      	cmp	r3, #0
 8043ac6:	d071      	beq.n	8043bac <HAL_I2C_EV_IRQHandler+0x108>
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043ac8:	6953      	ldr	r3, [r2, #20]
  uint32_t sr2itflags               = 0U;
 8043aca:	2100      	movs	r1, #0
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043acc:	f013 0f02 	tst.w	r3, #2
 8043ad0:	d06f      	beq.n	8043bb2 <HAL_I2C_EV_IRQHandler+0x10e>
 8043ad2:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043ad6:	d06c      	beq.n	8043bb2 <HAL_I2C_EV_IRQHandler+0x10e>
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8043ad8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043ada:	b103      	cbz	r3, 8043ade <HAL_I2C_EV_IRQHandler+0x3a>
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043adc:	6991      	ldr	r1, [r2, #24]
      I2C_Slave_ADDR(hi2c, sr2itflags);
 8043ade:	4620      	mov	r0, r4
 8043ae0:	f7ff fbd1 	bl	8043286 <I2C_Slave_ADDR>
}
 8043ae4:	bd70      	pop	{r4, r5, r6, pc}
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043ae6:	6990      	ldr	r0, [r2, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043ae8:	6953      	ldr	r3, [r2, #20]
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 8043aea:	f013 0101 	ands.w	r1, r3, #1
 8043aee:	d105      	bne.n	8043afc <HAL_I2C_EV_IRQHandler+0x58>
 8043af0:	f5b6 0f2a 	cmp.w	r6, #11141120	; 0xaa0000
 8043af4:	d0f6      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
 8043af6:	f1b6 4f2a 	cmp.w	r6, #2852126720	; 0xaa000000
 8043afa:	d0f3      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043afc:	b111      	cbz	r1, 8043b04 <HAL_I2C_EV_IRQHandler+0x60>
 8043afe:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b02:	d125      	bne.n	8043b50 <HAL_I2C_EV_IRQHandler+0xac>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b04:	f013 0f08 	tst.w	r3, #8
 8043b08:	d002      	beq.n	8043b10 <HAL_I2C_EV_IRQHandler+0x6c>
 8043b0a:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b0e:	d126      	bne.n	8043b5e <HAL_I2C_EV_IRQHandler+0xba>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b10:	f013 0f02 	tst.w	r3, #2
 8043b14:	d002      	beq.n	8043b1c <HAL_I2C_EV_IRQHandler+0x78>
 8043b16:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b1a:	d124      	bne.n	8043b66 <HAL_I2C_EV_IRQHandler+0xc2>
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 8043b1c:	f010 0f04 	tst.w	r0, #4
 8043b20:	d029      	beq.n	8043b76 <HAL_I2C_EV_IRQHandler+0xd2>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8043b22:	6852      	ldr	r2, [r2, #4]
 8043b24:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043b28:	d1dc      	bne.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043b2a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8043b2e:	d005      	beq.n	8043b3c <HAL_I2C_EV_IRQHandler+0x98>
 8043b30:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043b34:	d002      	beq.n	8043b3c <HAL_I2C_EV_IRQHandler+0x98>
 8043b36:	f013 0f04 	tst.w	r3, #4
 8043b3a:	d018      	beq.n	8043b6e <HAL_I2C_EV_IRQHandler+0xca>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b3c:	f013 0f04 	tst.w	r3, #4
 8043b40:	d0d0      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
 8043b42:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b46:	d0cd      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterTransmit_BTF(hi2c);
 8043b48:	4620      	mov	r0, r4
 8043b4a:	f7ff fcb5 	bl	80434b8 <I2C_MasterTransmit_BTF>
 8043b4e:	e7c9      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_ConvertOtherXferOptions(hi2c);
 8043b50:	4620      	mov	r0, r4
 8043b52:	f7ff fa63 	bl	804301c <I2C_ConvertOtherXferOptions>
      I2C_Master_SB(hi2c);
 8043b56:	4620      	mov	r0, r4
 8043b58:	f7ff f8cf 	bl	8042cfa <I2C_Master_SB>
 8043b5c:	e7c2      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADD10(hi2c);
 8043b5e:	4620      	mov	r0, r4
 8043b60:	f7ff f922 	bl	8042da8 <I2C_Master_ADD10>
 8043b64:	e7be      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Master_ADDR(hi2c);
 8043b66:	4620      	mov	r0, r4
 8043b68:	f7ff f935 	bl	8042dd6 <I2C_Master_ADDR>
 8043b6c:	e7ba      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterTransmit_TXE(hi2c);
 8043b6e:	4620      	mov	r0, r4
 8043b70:	f7ff fbfc 	bl	804336c <I2C_MasterTransmit_TXE>
 8043b74:	e7b6      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 8043b76:	6852      	ldr	r2, [r2, #4]
 8043b78:	f412 6f00 	tst.w	r2, #2048	; 0x800
 8043b7c:	d1b2      	bne.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043b7e:	f013 0f40 	tst.w	r3, #64	; 0x40
 8043b82:	d005      	beq.n	8043b90 <HAL_I2C_EV_IRQHandler+0xec>
 8043b84:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043b88:	d002      	beq.n	8043b90 <HAL_I2C_EV_IRQHandler+0xec>
 8043b8a:	f013 0f04 	tst.w	r3, #4
 8043b8e:	d009      	beq.n	8043ba4 <HAL_I2C_EV_IRQHandler+0x100>
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043b90:	f013 0f04 	tst.w	r3, #4
 8043b94:	d0a6      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
 8043b96:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043b9a:	d0a3      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_BTF(hi2c);
 8043b9c:	4620      	mov	r0, r4
 8043b9e:	f7ff fd2d 	bl	80435fc <I2C_MasterReceive_BTF>
 8043ba2:	e79f      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
          I2C_MasterReceive_RXNE(hi2c);
 8043ba4:	4620      	mov	r0, r4
 8043ba6:	f7ff fcd6 	bl	8043556 <I2C_MasterReceive_RXNE>
 8043baa:	e79b      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 8043bac:	6991      	ldr	r1, [r2, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 8043bae:	6953      	ldr	r3, [r2, #20]
 8043bb0:	e78c      	b.n	8043acc <HAL_I2C_EV_IRQHandler+0x28>
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043bb2:	f013 0f10 	tst.w	r3, #16
 8043bb6:	d002      	beq.n	8043bbe <HAL_I2C_EV_IRQHandler+0x11a>
 8043bb8:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043bbc:	d117      	bne.n	8043bee <HAL_I2C_EV_IRQHandler+0x14a>
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8043bbe:	2821      	cmp	r0, #33	; 0x21
 8043bc0:	d019      	beq.n	8043bf6 <HAL_I2C_EV_IRQHandler+0x152>
 8043bc2:	2829      	cmp	r0, #41	; 0x29
 8043bc4:	d017      	beq.n	8043bf6 <HAL_I2C_EV_IRQHandler+0x152>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043bc6:	f013 0f40 	tst.w	r3, #64	; 0x40
 8043bca:	d005      	beq.n	8043bd8 <HAL_I2C_EV_IRQHandler+0x134>
 8043bcc:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043bd0:	d002      	beq.n	8043bd8 <HAL_I2C_EV_IRQHandler+0x134>
 8043bd2:	f013 0f04 	tst.w	r3, #4
 8043bd6:	d027      	beq.n	8043c28 <HAL_I2C_EV_IRQHandler+0x184>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043bd8:	f013 0f04 	tst.w	r3, #4
 8043bdc:	d082      	beq.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
 8043bde:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043be2:	f43f af7f 	beq.w	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_BTF(hi2c);
 8043be6:	4620      	mov	r0, r4
 8043be8:	f7ff fa08 	bl	8042ffc <I2C_SlaveReceive_BTF>
      }
 8043bec:	e77a      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      I2C_Slave_STOPF(hi2c);
 8043bee:	4620      	mov	r0, r4
 8043bf0:	f7ff fe92 	bl	8043918 <I2C_Slave_STOPF>
 8043bf4:	e776      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 8043bf6:	f013 0f80 	tst.w	r3, #128	; 0x80
 8043bfa:	d005      	beq.n	8043c08 <HAL_I2C_EV_IRQHandler+0x164>
 8043bfc:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043c00:	d002      	beq.n	8043c08 <HAL_I2C_EV_IRQHandler+0x164>
 8043c02:	f013 0f04 	tst.w	r3, #4
 8043c06:	d00b      	beq.n	8043c20 <HAL_I2C_EV_IRQHandler+0x17c>
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 8043c08:	f013 0f04 	tst.w	r3, #4
 8043c0c:	f43f af6a 	beq.w	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
 8043c10:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c14:	f43f af66 	beq.w	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_BTF(hi2c);
 8043c18:	4620      	mov	r0, r4
 8043c1a:	f7ff f9df 	bl	8042fdc <I2C_SlaveTransmit_BTF>
 8043c1e:	e761      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveTransmit_TXE(hi2c);
 8043c20:	4620      	mov	r0, r4
 8043c22:	f7ff fae2 	bl	80431ea <I2C_SlaveTransmit_TXE>
 8043c26:	e75d      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>
        I2C_SlaveReceive_RXNE(hi2c);
 8043c28:	4620      	mov	r0, r4
 8043c2a:	f7ff fb05 	bl	8043238 <I2C_SlaveReceive_RXNE>
 8043c2e:	e759      	b.n	8043ae4 <HAL_I2C_EV_IRQHandler+0x40>

08043c30 <HAL_I2C_ER_IRQHandler>:
{
 8043c30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8043c32:	4604      	mov	r4, r0
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 8043c34:	6803      	ldr	r3, [r0, #0]
 8043c36:	695d      	ldr	r5, [r3, #20]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 8043c38:	685f      	ldr	r7, [r3, #4]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043c3a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8043c3e:	d007      	beq.n	8043c50 <HAL_I2C_ER_IRQHandler+0x20>
 8043c40:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043c44:	d03b      	beq.n	8043cbe <HAL_I2C_ER_IRQHandler+0x8e>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8043c46:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8043c4a:	615a      	str	r2, [r3, #20]
    error |= HAL_I2C_ERROR_BERR;
 8043c4c:	2601      	movs	r6, #1
 8043c4e:	e000      	b.n	8043c52 <HAL_I2C_ER_IRQHandler+0x22>
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8043c50:	2600      	movs	r6, #0
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043c52:	f415 7f00 	tst.w	r5, #512	; 0x200
 8043c56:	d008      	beq.n	8043c6a <HAL_I2C_ER_IRQHandler+0x3a>
 8043c58:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043c5c:	d005      	beq.n	8043c6a <HAL_I2C_ER_IRQHandler+0x3a>
    error |= HAL_I2C_ERROR_ARLO;
 8043c5e:	f046 0602 	orr.w	r6, r6, #2
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8043c62:	6823      	ldr	r3, [r4, #0]
 8043c64:	f46f 7200 	mvn.w	r2, #512	; 0x200
 8043c68:	615a      	str	r2, [r3, #20]
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043c6a:	f415 6f80 	tst.w	r5, #1024	; 0x400
 8043c6e:	d018      	beq.n	8043ca2 <HAL_I2C_ER_IRQHandler+0x72>
 8043c70:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043c74:	d015      	beq.n	8043ca2 <HAL_I2C_ER_IRQHandler+0x72>
    tmp1 = hi2c->Mode;
 8043c76:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8043c7a:	b2db      	uxtb	r3, r3
    tmp2 = hi2c->XferCount;
 8043c7c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8043c7e:	b291      	uxth	r1, r2
    tmp3 = hi2c->State;
 8043c80:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8043c84:	b2d2      	uxtb	r2, r2
    tmp4 = hi2c->PreviousState;
 8043c86:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8043c88:	2b20      	cmp	r3, #32
 8043c8a:	d01a      	beq.n	8043cc2 <HAL_I2C_ER_IRQHandler+0x92>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8043c8c:	6823      	ldr	r3, [r4, #0]
 8043c8e:	f46f 6280 	mvn.w	r2, #1024	; 0x400
 8043c92:	615a      	str	r2, [r3, #20]
      error |= HAL_I2C_ERROR_AF;
 8043c94:	f046 0604 	orr.w	r6, r6, #4
      if (hi2c->Mode == HAL_I2C_MODE_MASTER)
 8043c98:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
 8043c9c:	b2db      	uxtb	r3, r3
 8043c9e:	2b10      	cmp	r3, #16
 8043ca0:	d01d      	beq.n	8043cde <HAL_I2C_ER_IRQHandler+0xae>
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 8043ca2:	f415 6f00 	tst.w	r5, #2048	; 0x800
 8043ca6:	d008      	beq.n	8043cba <HAL_I2C_ER_IRQHandler+0x8a>
 8043ca8:	f417 7f80 	tst.w	r7, #256	; 0x100
 8043cac:	d005      	beq.n	8043cba <HAL_I2C_ER_IRQHandler+0x8a>
    error |= HAL_I2C_ERROR_OVR;
 8043cae:	f046 0608 	orr.w	r6, r6, #8
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8043cb2:	6823      	ldr	r3, [r4, #0]
 8043cb4:	f46f 6200 	mvn.w	r2, #2048	; 0x800
 8043cb8:	615a      	str	r2, [r3, #20]
  if (error != HAL_I2C_ERROR_NONE)
 8043cba:	b9b6      	cbnz	r6, 8043cea <HAL_I2C_ER_IRQHandler+0xba>
}
 8043cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t error      = HAL_I2C_ERROR_NONE;
 8043cbe:	2600      	movs	r6, #0
 8043cc0:	e7c7      	b.n	8043c52 <HAL_I2C_ER_IRQHandler+0x22>
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 8043cc2:	2900      	cmp	r1, #0
 8043cc4:	d1e2      	bne.n	8043c8c <HAL_I2C_ER_IRQHandler+0x5c>
 8043cc6:	2a21      	cmp	r2, #33	; 0x21
 8043cc8:	d005      	beq.n	8043cd6 <HAL_I2C_ER_IRQHandler+0xa6>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 8043cca:	2a29      	cmp	r2, #41	; 0x29
 8043ccc:	d003      	beq.n	8043cd6 <HAL_I2C_ER_IRQHandler+0xa6>
 8043cce:	2a28      	cmp	r2, #40	; 0x28
 8043cd0:	d1dc      	bne.n	8043c8c <HAL_I2C_ER_IRQHandler+0x5c>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 8043cd2:	2821      	cmp	r0, #33	; 0x21
 8043cd4:	d1da      	bne.n	8043c8c <HAL_I2C_ER_IRQHandler+0x5c>
      I2C_Slave_AF(hi2c);
 8043cd6:	4620      	mov	r0, r4
 8043cd8:	f7ff fafe 	bl	80432d8 <I2C_Slave_AF>
 8043cdc:	e7e1      	b.n	8043ca2 <HAL_I2C_ER_IRQHandler+0x72>
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 8043cde:	6822      	ldr	r2, [r4, #0]
 8043ce0:	6813      	ldr	r3, [r2, #0]
 8043ce2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8043ce6:	6013      	str	r3, [r2, #0]
 8043ce8:	e7db      	b.n	8043ca2 <HAL_I2C_ER_IRQHandler+0x72>
    hi2c->ErrorCode |= error;
 8043cea:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8043cec:	431e      	orrs	r6, r3
 8043cee:	6426      	str	r6, [r4, #64]	; 0x40
    I2C_ITError(hi2c);
 8043cf0:	4620      	mov	r0, r4
 8043cf2:	f7ff fd5d 	bl	80437b0 <I2C_ITError>
}
 8043cf6:	e7e1      	b.n	8043cbc <HAL_I2C_ER_IRQHandler+0x8c>

08043cf8 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8043cf8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043cfc:	b2db      	uxtb	r3, r3
 8043cfe:	2b20      	cmp	r3, #32
 8043d00:	d001      	beq.n	8043d06 <HAL_I2CEx_ConfigAnalogFilter+0xe>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8043d02:	2002      	movs	r0, #2
  }
}
 8043d04:	4770      	bx	lr
    hi2c->State = HAL_I2C_STATE_BUSY;
 8043d06:	2324      	movs	r3, #36	; 0x24
 8043d08:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    __HAL_I2C_DISABLE(hi2c);
 8043d0c:	6802      	ldr	r2, [r0, #0]
 8043d0e:	6813      	ldr	r3, [r2, #0]
 8043d10:	f023 0301 	bic.w	r3, r3, #1
 8043d14:	6013      	str	r3, [r2, #0]
    hi2c->Instance->FLTR &= ~(I2C_FLTR_ANOFF);
 8043d16:	6802      	ldr	r2, [r0, #0]
 8043d18:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043d1a:	f023 0310 	bic.w	r3, r3, #16
 8043d1e:	6253      	str	r3, [r2, #36]	; 0x24
    hi2c->Instance->FLTR |= AnalogFilter;
 8043d20:	6802      	ldr	r2, [r0, #0]
 8043d22:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043d24:	4319      	orrs	r1, r3
 8043d26:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_I2C_ENABLE(hi2c);
 8043d28:	6802      	ldr	r2, [r0, #0]
 8043d2a:	6813      	ldr	r3, [r2, #0]
 8043d2c:	f043 0301 	orr.w	r3, r3, #1
 8043d30:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8043d32:	2320      	movs	r3, #32
 8043d34:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    return HAL_OK;
 8043d38:	2000      	movs	r0, #0
 8043d3a:	4770      	bx	lr

08043d3c <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8043d3c:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8043d40:	b2db      	uxtb	r3, r3
 8043d42:	2b20      	cmp	r3, #32
 8043d44:	d001      	beq.n	8043d4a <HAL_I2CEx_ConfigDigitalFilter+0xe>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8043d46:	2002      	movs	r0, #2
  }
}
 8043d48:	4770      	bx	lr
    hi2c->State = HAL_I2C_STATE_BUSY;
 8043d4a:	2324      	movs	r3, #36	; 0x24
 8043d4c:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    __HAL_I2C_DISABLE(hi2c);
 8043d50:	6802      	ldr	r2, [r0, #0]
 8043d52:	6813      	ldr	r3, [r2, #0]
 8043d54:	f023 0301 	bic.w	r3, r3, #1
 8043d58:	6013      	str	r3, [r2, #0]
    tmpreg = hi2c->Instance->FLTR;
 8043d5a:	6802      	ldr	r2, [r0, #0]
 8043d5c:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8043d5e:	b29b      	uxth	r3, r3
    tmpreg &= ~(I2C_FLTR_DNF);
 8043d60:	f023 030f 	bic.w	r3, r3, #15
    tmpreg |= DigitalFilter;
 8043d64:	4319      	orrs	r1, r3
 8043d66:	b289      	uxth	r1, r1
    hi2c->Instance->FLTR = tmpreg;
 8043d68:	6251      	str	r1, [r2, #36]	; 0x24
    __HAL_I2C_ENABLE(hi2c);
 8043d6a:	6802      	ldr	r2, [r0, #0]
 8043d6c:	6813      	ldr	r3, [r2, #0]
 8043d6e:	f043 0301 	orr.w	r3, r3, #1
 8043d72:	6013      	str	r3, [r2, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8043d74:	2320      	movs	r3, #32
 8043d76:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
    return HAL_OK;
 8043d7a:	2000      	movs	r0, #0
 8043d7c:	4770      	bx	lr

08043d7e <HAL_IWDG_Init>:
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if (hiwdg == NULL)
 8043d7e:	b308      	cbz	r0, 8043dc4 <HAL_IWDG_Init+0x46>
{
 8043d80:	b538      	push	{r3, r4, r5, lr}
 8043d82:	4604      	mov	r4, r0
  assert_param(IS_IWDG_ALL_INSTANCE(hiwdg->Instance));
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));

  /* Enable IWDG. LSI is turned on automatically */
  __HAL_IWDG_START(hiwdg);
 8043d84:	6803      	ldr	r3, [r0, #0]
 8043d86:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8043d8a:	601a      	str	r2, [r3, #0]

  /* Enable write access to IWDG_PR and IWDG_RLR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 8043d8c:	6803      	ldr	r3, [r0, #0]
 8043d8e:	f245 5255 	movw	r2, #21845	; 0x5555
 8043d92:	601a      	str	r2, [r3, #0]

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
 8043d94:	6803      	ldr	r3, [r0, #0]
 8043d96:	6842      	ldr	r2, [r0, #4]
 8043d98:	605a      	str	r2, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 8043d9a:	6803      	ldr	r3, [r0, #0]
 8043d9c:	6882      	ldr	r2, [r0, #8]
 8043d9e:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
 8043da0:	f7fd f97e 	bl	80410a0 <HAL_GetTick>
 8043da4:	4605      	mov	r5, r0

  /* Wait for register to be updated */
  while (hiwdg->Instance->SR != 0x00u)
 8043da6:	6823      	ldr	r3, [r4, #0]
 8043da8:	68da      	ldr	r2, [r3, #12]
 8043daa:	b132      	cbz	r2, 8043dba <HAL_IWDG_Init+0x3c>
  {
    if ((HAL_GetTick() - tickstart) > HAL_IWDG_DEFAULT_TIMEOUT)
 8043dac:	f7fd f978 	bl	80410a0 <HAL_GetTick>
 8043db0:	1b40      	subs	r0, r0, r5
 8043db2:	2830      	cmp	r0, #48	; 0x30
 8043db4:	d9f7      	bls.n	8043da6 <HAL_IWDG_Init+0x28>
    {
      return HAL_TIMEOUT;
 8043db6:	2003      	movs	r0, #3
 8043db8:	e003      	b.n	8043dc2 <HAL_IWDG_Init+0x44>
    }
  }

  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8043dba:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8043dbe:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
 8043dc0:	2000      	movs	r0, #0
}
 8043dc2:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8043dc4:	2001      	movs	r0, #1
}
 8043dc6:	4770      	bx	lr

08043dc8 <HAL_IWDG_Refresh>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Refresh(IWDG_HandleTypeDef *hiwdg)
{
  /* Reload IWDG counter with value defined in the reload register */
  __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8043dc8:	6803      	ldr	r3, [r0, #0]
 8043dca:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8043dce:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8043dd0:	2000      	movs	r0, #0
 8043dd2:	4770      	bx	lr

08043dd4 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8043dd4:	b510      	push	{r4, lr}
 8043dd6:	b082      	sub	sp, #8
  uint32_t tickstart = 0U;

  __HAL_RCC_PWR_CLK_ENABLE();
 8043dd8:	2300      	movs	r3, #0
 8043dda:	9301      	str	r3, [sp, #4]
 8043ddc:	4b19      	ldr	r3, [pc, #100]	; (8043e44 <HAL_PWREx_EnableOverDrive+0x70>)
 8043dde:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8043de0:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8043de4:	641a      	str	r2, [r3, #64]	; 0x40
 8043de6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8043de8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8043dec:	9301      	str	r3, [sp, #4]
 8043dee:	9b01      	ldr	r3, [sp, #4]
  
  /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8043df0:	4b15      	ldr	r3, [pc, #84]	; (8043e48 <HAL_PWREx_EnableOverDrive+0x74>)
 8043df2:	2201      	movs	r2, #1
 8043df4:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8043df6:	f7fd f953 	bl	80410a0 <HAL_GetTick>
 8043dfa:	4604      	mov	r4, r0

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8043dfc:	4b13      	ldr	r3, [pc, #76]	; (8043e4c <HAL_PWREx_EnableOverDrive+0x78>)
 8043dfe:	685b      	ldr	r3, [r3, #4]
 8043e00:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8043e04:	d108      	bne.n	8043e18 <HAL_PWREx_EnableOverDrive+0x44>
  {
    if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8043e06:	f7fd f94b 	bl	80410a0 <HAL_GetTick>
 8043e0a:	1b00      	subs	r0, r0, r4
 8043e0c:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8043e10:	d9f4      	bls.n	8043dfc <HAL_PWREx_EnableOverDrive+0x28>
    {
      return HAL_TIMEOUT;
 8043e12:	2003      	movs	r0, #3
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
}
 8043e14:	b002      	add	sp, #8
 8043e16:	bd10      	pop	{r4, pc}
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8043e18:	4b0d      	ldr	r3, [pc, #52]	; (8043e50 <HAL_PWREx_EnableOverDrive+0x7c>)
 8043e1a:	2201      	movs	r2, #1
 8043e1c:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8043e1e:	f7fd f93f 	bl	80410a0 <HAL_GetTick>
 8043e22:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8043e24:	4b09      	ldr	r3, [pc, #36]	; (8043e4c <HAL_PWREx_EnableOverDrive+0x78>)
 8043e26:	685b      	ldr	r3, [r3, #4]
 8043e28:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043e2c:	d107      	bne.n	8043e3e <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8043e2e:	f7fd f937 	bl	80410a0 <HAL_GetTick>
 8043e32:	1b00      	subs	r0, r0, r4
 8043e34:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8043e38:	d9f4      	bls.n	8043e24 <HAL_PWREx_EnableOverDrive+0x50>
      return HAL_TIMEOUT;
 8043e3a:	2003      	movs	r0, #3
 8043e3c:	e7ea      	b.n	8043e14 <HAL_PWREx_EnableOverDrive+0x40>
  return HAL_OK;
 8043e3e:	2000      	movs	r0, #0
 8043e40:	e7e8      	b.n	8043e14 <HAL_PWREx_EnableOverDrive+0x40>
 8043e42:	bf00      	nop
 8043e44:	40023800 	.word	0x40023800
 8043e48:	420e0040 	.word	0x420e0040
 8043e4c:	40007000 	.word	0x40007000
 8043e50:	420e0044 	.word	0x420e0044

08043e54 <HAL_RCC_OscConfig>:
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8043e54:	2800      	cmp	r0, #0
 8043e56:	f000 81b9 	beq.w	80441cc <HAL_RCC_OscConfig+0x378>
{
 8043e5a:	b570      	push	{r4, r5, r6, lr}
 8043e5c:	b082      	sub	sp, #8
 8043e5e:	4604      	mov	r4, r0
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8043e60:	6803      	ldr	r3, [r0, #0]
 8043e62:	f013 0f01 	tst.w	r3, #1
 8043e66:	d03b      	beq.n	8043ee0 <HAL_RCC_OscConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8043e68:	4ba6      	ldr	r3, [pc, #664]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043e6a:	689b      	ldr	r3, [r3, #8]
 8043e6c:	f003 030c 	and.w	r3, r3, #12
 8043e70:	2b04      	cmp	r3, #4
 8043e72:	d02c      	beq.n	8043ece <HAL_RCC_OscConfig+0x7a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8043e74:	4ba3      	ldr	r3, [pc, #652]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043e76:	689b      	ldr	r3, [r3, #8]
 8043e78:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8043e7c:	2b08      	cmp	r3, #8
 8043e7e:	d021      	beq.n	8043ec4 <HAL_RCC_OscConfig+0x70>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8043e80:	6863      	ldr	r3, [r4, #4]
 8043e82:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8043e86:	d04f      	beq.n	8043f28 <HAL_RCC_OscConfig+0xd4>
 8043e88:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8043e8c:	d052      	beq.n	8043f34 <HAL_RCC_OscConfig+0xe0>
 8043e8e:	4b9d      	ldr	r3, [pc, #628]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043e90:	681a      	ldr	r2, [r3, #0]
 8043e92:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8043e96:	601a      	str	r2, [r3, #0]
 8043e98:	681a      	ldr	r2, [r3, #0]
 8043e9a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8043e9e:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8043ea0:	6863      	ldr	r3, [r4, #4]
 8043ea2:	2b00      	cmp	r3, #0
 8043ea4:	d050      	beq.n	8043f48 <HAL_RCC_OscConfig+0xf4>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8043ea6:	f7fd f8fb 	bl	80410a0 <HAL_GetTick>
 8043eaa:	4605      	mov	r5, r0

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8043eac:	4b95      	ldr	r3, [pc, #596]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043eae:	681b      	ldr	r3, [r3, #0]
 8043eb0:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043eb4:	d114      	bne.n	8043ee0 <HAL_RCC_OscConfig+0x8c>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8043eb6:	f7fd f8f3 	bl	80410a0 <HAL_GetTick>
 8043eba:	1b40      	subs	r0, r0, r5
 8043ebc:	2864      	cmp	r0, #100	; 0x64
 8043ebe:	d9f5      	bls.n	8043eac <HAL_RCC_OscConfig+0x58>
          {
            return HAL_TIMEOUT;
 8043ec0:	2003      	movs	r0, #3
 8043ec2:	e18a      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8043ec4:	4b8f      	ldr	r3, [pc, #572]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043ec6:	685b      	ldr	r3, [r3, #4]
 8043ec8:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8043ecc:	d0d8      	beq.n	8043e80 <HAL_RCC_OscConfig+0x2c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8043ece:	4b8d      	ldr	r3, [pc, #564]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043ed0:	681b      	ldr	r3, [r3, #0]
 8043ed2:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043ed6:	d003      	beq.n	8043ee0 <HAL_RCC_OscConfig+0x8c>
 8043ed8:	6863      	ldr	r3, [r4, #4]
 8043eda:	2b00      	cmp	r3, #0
 8043edc:	f000 8178 	beq.w	80441d0 <HAL_RCC_OscConfig+0x37c>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8043ee0:	6823      	ldr	r3, [r4, #0]
 8043ee2:	f013 0f02 	tst.w	r3, #2
 8043ee6:	d054      	beq.n	8043f92 <HAL_RCC_OscConfig+0x13e>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8043ee8:	4b86      	ldr	r3, [pc, #536]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043eea:	689b      	ldr	r3, [r3, #8]
 8043eec:	f013 0f0c 	tst.w	r3, #12
 8043ef0:	d03e      	beq.n	8043f70 <HAL_RCC_OscConfig+0x11c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8043ef2:	4b84      	ldr	r3, [pc, #528]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043ef4:	689b      	ldr	r3, [r3, #8]
 8043ef6:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8043efa:	2b08      	cmp	r3, #8
 8043efc:	d033      	beq.n	8043f66 <HAL_RCC_OscConfig+0x112>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8043efe:	68e3      	ldr	r3, [r4, #12]
 8043f00:	2b00      	cmp	r3, #0
 8043f02:	d067      	beq.n	8043fd4 <HAL_RCC_OscConfig+0x180>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8043f04:	4b80      	ldr	r3, [pc, #512]	; (8044108 <HAL_RCC_OscConfig+0x2b4>)
 8043f06:	2201      	movs	r2, #1
 8043f08:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8043f0a:	f7fd f8c9 	bl	80410a0 <HAL_GetTick>
 8043f0e:	4605      	mov	r5, r0

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8043f10:	4b7c      	ldr	r3, [pc, #496]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f12:	681b      	ldr	r3, [r3, #0]
 8043f14:	f013 0f02 	tst.w	r3, #2
 8043f18:	d153      	bne.n	8043fc2 <HAL_RCC_OscConfig+0x16e>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8043f1a:	f7fd f8c1 	bl	80410a0 <HAL_GetTick>
 8043f1e:	1b40      	subs	r0, r0, r5
 8043f20:	2802      	cmp	r0, #2
 8043f22:	d9f5      	bls.n	8043f10 <HAL_RCC_OscConfig+0xbc>
          {
            return HAL_TIMEOUT;
 8043f24:	2003      	movs	r0, #3
 8043f26:	e158      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8043f28:	4a76      	ldr	r2, [pc, #472]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f2a:	6813      	ldr	r3, [r2, #0]
 8043f2c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8043f30:	6013      	str	r3, [r2, #0]
 8043f32:	e7b5      	b.n	8043ea0 <HAL_RCC_OscConfig+0x4c>
 8043f34:	4b73      	ldr	r3, [pc, #460]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f36:	681a      	ldr	r2, [r3, #0]
 8043f38:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8043f3c:	601a      	str	r2, [r3, #0]
 8043f3e:	681a      	ldr	r2, [r3, #0]
 8043f40:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8043f44:	601a      	str	r2, [r3, #0]
 8043f46:	e7ab      	b.n	8043ea0 <HAL_RCC_OscConfig+0x4c>
        tickstart = HAL_GetTick();
 8043f48:	f7fd f8aa 	bl	80410a0 <HAL_GetTick>
 8043f4c:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8043f4e:	4b6d      	ldr	r3, [pc, #436]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f50:	681b      	ldr	r3, [r3, #0]
 8043f52:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8043f56:	d0c3      	beq.n	8043ee0 <HAL_RCC_OscConfig+0x8c>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8043f58:	f7fd f8a2 	bl	80410a0 <HAL_GetTick>
 8043f5c:	1b40      	subs	r0, r0, r5
 8043f5e:	2864      	cmp	r0, #100	; 0x64
 8043f60:	d9f5      	bls.n	8043f4e <HAL_RCC_OscConfig+0xfa>
            return HAL_TIMEOUT;
 8043f62:	2003      	movs	r0, #3
 8043f64:	e139      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8043f66:	4b67      	ldr	r3, [pc, #412]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f68:	685b      	ldr	r3, [r3, #4]
 8043f6a:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8043f6e:	d1c6      	bne.n	8043efe <HAL_RCC_OscConfig+0xaa>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8043f70:	4b64      	ldr	r3, [pc, #400]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f72:	681b      	ldr	r3, [r3, #0]
 8043f74:	f013 0f02 	tst.w	r3, #2
 8043f78:	d003      	beq.n	8043f82 <HAL_RCC_OscConfig+0x12e>
 8043f7a:	68e3      	ldr	r3, [r4, #12]
 8043f7c:	2b01      	cmp	r3, #1
 8043f7e:	f040 8129 	bne.w	80441d4 <HAL_RCC_OscConfig+0x380>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8043f82:	4a60      	ldr	r2, [pc, #384]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043f84:	6813      	ldr	r3, [r2, #0]
 8043f86:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8043f8a:	6921      	ldr	r1, [r4, #16]
 8043f8c:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8043f90:	6013      	str	r3, [r2, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8043f92:	6823      	ldr	r3, [r4, #0]
 8043f94:	f013 0f08 	tst.w	r3, #8
 8043f98:	d040      	beq.n	804401c <HAL_RCC_OscConfig+0x1c8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8043f9a:	6963      	ldr	r3, [r4, #20]
 8043f9c:	b363      	cbz	r3, 8043ff8 <HAL_RCC_OscConfig+0x1a4>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8043f9e:	4b5b      	ldr	r3, [pc, #364]	; (804410c <HAL_RCC_OscConfig+0x2b8>)
 8043fa0:	2201      	movs	r2, #1
 8043fa2:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8043fa4:	f7fd f87c 	bl	80410a0 <HAL_GetTick>
 8043fa8:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8043faa:	4b56      	ldr	r3, [pc, #344]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043fac:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8043fae:	f013 0f02 	tst.w	r3, #2
 8043fb2:	d133      	bne.n	804401c <HAL_RCC_OscConfig+0x1c8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8043fb4:	f7fd f874 	bl	80410a0 <HAL_GetTick>
 8043fb8:	1b40      	subs	r0, r0, r5
 8043fba:	2802      	cmp	r0, #2
 8043fbc:	d9f5      	bls.n	8043faa <HAL_RCC_OscConfig+0x156>
        {
          return HAL_TIMEOUT;
 8043fbe:	2003      	movs	r0, #3
 8043fc0:	e10b      	b.n	80441da <HAL_RCC_OscConfig+0x386>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8043fc2:	4a50      	ldr	r2, [pc, #320]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043fc4:	6813      	ldr	r3, [r2, #0]
 8043fc6:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8043fca:	6921      	ldr	r1, [r4, #16]
 8043fcc:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8043fd0:	6013      	str	r3, [r2, #0]
 8043fd2:	e7de      	b.n	8043f92 <HAL_RCC_OscConfig+0x13e>
        __HAL_RCC_HSI_DISABLE();
 8043fd4:	4b4c      	ldr	r3, [pc, #304]	; (8044108 <HAL_RCC_OscConfig+0x2b4>)
 8043fd6:	2200      	movs	r2, #0
 8043fd8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8043fda:	f7fd f861 	bl	80410a0 <HAL_GetTick>
 8043fde:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8043fe0:	4b48      	ldr	r3, [pc, #288]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8043fe2:	681b      	ldr	r3, [r3, #0]
 8043fe4:	f013 0f02 	tst.w	r3, #2
 8043fe8:	d0d3      	beq.n	8043f92 <HAL_RCC_OscConfig+0x13e>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8043fea:	f7fd f859 	bl	80410a0 <HAL_GetTick>
 8043fee:	1b40      	subs	r0, r0, r5
 8043ff0:	2802      	cmp	r0, #2
 8043ff2:	d9f5      	bls.n	8043fe0 <HAL_RCC_OscConfig+0x18c>
            return HAL_TIMEOUT;
 8043ff4:	2003      	movs	r0, #3
 8043ff6:	e0f0      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8043ff8:	4b44      	ldr	r3, [pc, #272]	; (804410c <HAL_RCC_OscConfig+0x2b8>)
 8043ffa:	2200      	movs	r2, #0
 8043ffc:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8043ffe:	f7fd f84f 	bl	80410a0 <HAL_GetTick>
 8044002:	4605      	mov	r5, r0

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8044004:	4b3f      	ldr	r3, [pc, #252]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8044006:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8044008:	f013 0f02 	tst.w	r3, #2
 804400c:	d006      	beq.n	804401c <HAL_RCC_OscConfig+0x1c8>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 804400e:	f7fd f847 	bl	80410a0 <HAL_GetTick>
 8044012:	1b40      	subs	r0, r0, r5
 8044014:	2802      	cmp	r0, #2
 8044016:	d9f5      	bls.n	8044004 <HAL_RCC_OscConfig+0x1b0>
        {
          return HAL_TIMEOUT;
 8044018:	2003      	movs	r0, #3
 804401a:	e0de      	b.n	80441da <HAL_RCC_OscConfig+0x386>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 804401c:	6823      	ldr	r3, [r4, #0]
 804401e:	f013 0f04 	tst.w	r3, #4
 8044022:	d078      	beq.n	8044116 <HAL_RCC_OscConfig+0x2c2>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8044024:	4b37      	ldr	r3, [pc, #220]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8044026:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8044028:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 804402c:	d10d      	bne.n	804404a <HAL_RCC_OscConfig+0x1f6>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 804402e:	2300      	movs	r3, #0
 8044030:	9301      	str	r3, [sp, #4]
 8044032:	4b34      	ldr	r3, [pc, #208]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8044034:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8044036:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 804403a:	641a      	str	r2, [r3, #64]	; 0x40
 804403c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804403e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8044042:	9301      	str	r3, [sp, #4]
 8044044:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8044046:	2501      	movs	r5, #1
 8044048:	e000      	b.n	804404c <HAL_RCC_OscConfig+0x1f8>
    FlagStatus       pwrclkchanged = RESET;
 804404a:	2500      	movs	r5, #0
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 804404c:	4b30      	ldr	r3, [pc, #192]	; (8044110 <HAL_RCC_OscConfig+0x2bc>)
 804404e:	681b      	ldr	r3, [r3, #0]
 8044050:	f413 7f80 	tst.w	r3, #256	; 0x100
 8044054:	d021      	beq.n	804409a <HAL_RCC_OscConfig+0x246>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8044056:	68a3      	ldr	r3, [r4, #8]
 8044058:	2b01      	cmp	r3, #1
 804405a:	d032      	beq.n	80440c2 <HAL_RCC_OscConfig+0x26e>
 804405c:	2b05      	cmp	r3, #5
 804405e:	d036      	beq.n	80440ce <HAL_RCC_OscConfig+0x27a>
 8044060:	4b28      	ldr	r3, [pc, #160]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8044062:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8044064:	f022 0201 	bic.w	r2, r2, #1
 8044068:	671a      	str	r2, [r3, #112]	; 0x70
 804406a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 804406c:	f022 0204 	bic.w	r2, r2, #4
 8044070:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8044072:	68a3      	ldr	r3, [r4, #8]
 8044074:	2b00      	cmp	r3, #0
 8044076:	d034      	beq.n	80440e2 <HAL_RCC_OscConfig+0x28e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8044078:	f7fd f812 	bl	80410a0 <HAL_GetTick>
 804407c:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 804407e:	4b21      	ldr	r3, [pc, #132]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 8044080:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8044082:	f013 0f02 	tst.w	r3, #2
 8044086:	d145      	bne.n	8044114 <HAL_RCC_OscConfig+0x2c0>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8044088:	f7fd f80a 	bl	80410a0 <HAL_GetTick>
 804408c:	1b80      	subs	r0, r0, r6
 804408e:	f241 3388 	movw	r3, #5000	; 0x1388
 8044092:	4298      	cmp	r0, r3
 8044094:	d9f3      	bls.n	804407e <HAL_RCC_OscConfig+0x22a>
        {
          return HAL_TIMEOUT;
 8044096:	2003      	movs	r0, #3
 8044098:	e09f      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 804409a:	4a1d      	ldr	r2, [pc, #116]	; (8044110 <HAL_RCC_OscConfig+0x2bc>)
 804409c:	6813      	ldr	r3, [r2, #0]
 804409e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80440a2:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80440a4:	f7fc fffc 	bl	80410a0 <HAL_GetTick>
 80440a8:	4606      	mov	r6, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80440aa:	4b19      	ldr	r3, [pc, #100]	; (8044110 <HAL_RCC_OscConfig+0x2bc>)
 80440ac:	681b      	ldr	r3, [r3, #0]
 80440ae:	f413 7f80 	tst.w	r3, #256	; 0x100
 80440b2:	d1d0      	bne.n	8044056 <HAL_RCC_OscConfig+0x202>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80440b4:	f7fc fff4 	bl	80410a0 <HAL_GetTick>
 80440b8:	1b80      	subs	r0, r0, r6
 80440ba:	2802      	cmp	r0, #2
 80440bc:	d9f5      	bls.n	80440aa <HAL_RCC_OscConfig+0x256>
          return HAL_TIMEOUT;
 80440be:	2003      	movs	r0, #3
 80440c0:	e08b      	b.n	80441da <HAL_RCC_OscConfig+0x386>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80440c2:	4a10      	ldr	r2, [pc, #64]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 80440c4:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80440c6:	f043 0301 	orr.w	r3, r3, #1
 80440ca:	6713      	str	r3, [r2, #112]	; 0x70
 80440cc:	e7d1      	b.n	8044072 <HAL_RCC_OscConfig+0x21e>
 80440ce:	4b0d      	ldr	r3, [pc, #52]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 80440d0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80440d2:	f042 0204 	orr.w	r2, r2, #4
 80440d6:	671a      	str	r2, [r3, #112]	; 0x70
 80440d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80440da:	f042 0201 	orr.w	r2, r2, #1
 80440de:	671a      	str	r2, [r3, #112]	; 0x70
 80440e0:	e7c7      	b.n	8044072 <HAL_RCC_OscConfig+0x21e>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80440e2:	f7fc ffdd 	bl	80410a0 <HAL_GetTick>
 80440e6:	4606      	mov	r6, r0

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80440e8:	4b06      	ldr	r3, [pc, #24]	; (8044104 <HAL_RCC_OscConfig+0x2b0>)
 80440ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80440ec:	f013 0f02 	tst.w	r3, #2
 80440f0:	d010      	beq.n	8044114 <HAL_RCC_OscConfig+0x2c0>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80440f2:	f7fc ffd5 	bl	80410a0 <HAL_GetTick>
 80440f6:	1b80      	subs	r0, r0, r6
 80440f8:	f241 3388 	movw	r3, #5000	; 0x1388
 80440fc:	4298      	cmp	r0, r3
 80440fe:	d9f3      	bls.n	80440e8 <HAL_RCC_OscConfig+0x294>
        {
          return HAL_TIMEOUT;
 8044100:	2003      	movs	r0, #3
 8044102:	e06a      	b.n	80441da <HAL_RCC_OscConfig+0x386>
 8044104:	40023800 	.word	0x40023800
 8044108:	42470000 	.word	0x42470000
 804410c:	42470e80 	.word	0x42470e80
 8044110:	40007000 	.word	0x40007000
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8044114:	b9e5      	cbnz	r5, 8044150 <HAL_RCC_OscConfig+0x2fc>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8044116:	69a3      	ldr	r3, [r4, #24]
 8044118:	2b00      	cmp	r3, #0
 804411a:	d05d      	beq.n	80441d8 <HAL_RCC_OscConfig+0x384>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 804411c:	4a31      	ldr	r2, [pc, #196]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 804411e:	6892      	ldr	r2, [r2, #8]
 8044120:	f002 020c 	and.w	r2, r2, #12
 8044124:	2a08      	cmp	r2, #8
 8044126:	d05a      	beq.n	80441de <HAL_RCC_OscConfig+0x38a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8044128:	2b02      	cmp	r3, #2
 804412a:	d017      	beq.n	804415c <HAL_RCC_OscConfig+0x308>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 804412c:	4b2e      	ldr	r3, [pc, #184]	; (80441e8 <HAL_RCC_OscConfig+0x394>)
 804412e:	2200      	movs	r2, #0
 8044130:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8044132:	f7fc ffb5 	bl	80410a0 <HAL_GetTick>
 8044136:	4604      	mov	r4, r0

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8044138:	4b2a      	ldr	r3, [pc, #168]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 804413a:	681b      	ldr	r3, [r3, #0]
 804413c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8044140:	d042      	beq.n	80441c8 <HAL_RCC_OscConfig+0x374>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8044142:	f7fc ffad 	bl	80410a0 <HAL_GetTick>
 8044146:	1b00      	subs	r0, r0, r4
 8044148:	2802      	cmp	r0, #2
 804414a:	d9f5      	bls.n	8044138 <HAL_RCC_OscConfig+0x2e4>
          {
            return HAL_TIMEOUT;
 804414c:	2003      	movs	r0, #3
 804414e:	e044      	b.n	80441da <HAL_RCC_OscConfig+0x386>
      __HAL_RCC_PWR_CLK_DISABLE();
 8044150:	4a24      	ldr	r2, [pc, #144]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 8044152:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8044154:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8044158:	6413      	str	r3, [r2, #64]	; 0x40
 804415a:	e7dc      	b.n	8044116 <HAL_RCC_OscConfig+0x2c2>
        __HAL_RCC_PLL_DISABLE();
 804415c:	4b22      	ldr	r3, [pc, #136]	; (80441e8 <HAL_RCC_OscConfig+0x394>)
 804415e:	2200      	movs	r2, #0
 8044160:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8044162:	f7fc ff9d 	bl	80410a0 <HAL_GetTick>
 8044166:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8044168:	4b1e      	ldr	r3, [pc, #120]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 804416a:	681b      	ldr	r3, [r3, #0]
 804416c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8044170:	d006      	beq.n	8044180 <HAL_RCC_OscConfig+0x32c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8044172:	f7fc ff95 	bl	80410a0 <HAL_GetTick>
 8044176:	1b40      	subs	r0, r0, r5
 8044178:	2802      	cmp	r0, #2
 804417a:	d9f5      	bls.n	8044168 <HAL_RCC_OscConfig+0x314>
            return HAL_TIMEOUT;
 804417c:	2003      	movs	r0, #3
 804417e:	e02c      	b.n	80441da <HAL_RCC_OscConfig+0x386>
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8044180:	69e3      	ldr	r3, [r4, #28]
 8044182:	6a22      	ldr	r2, [r4, #32]
 8044184:	4313      	orrs	r3, r2
 8044186:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8044188:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 804418c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 804418e:	0852      	lsrs	r2, r2, #1
 8044190:	3a01      	subs	r2, #1
 8044192:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8044196:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8044198:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804419c:	4a11      	ldr	r2, [pc, #68]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 804419e:	6053      	str	r3, [r2, #4]
        __HAL_RCC_PLL_ENABLE();
 80441a0:	4b11      	ldr	r3, [pc, #68]	; (80441e8 <HAL_RCC_OscConfig+0x394>)
 80441a2:	2201      	movs	r2, #1
 80441a4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80441a6:	f7fc ff7b 	bl	80410a0 <HAL_GetTick>
 80441aa:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80441ac:	4b0d      	ldr	r3, [pc, #52]	; (80441e4 <HAL_RCC_OscConfig+0x390>)
 80441ae:	681b      	ldr	r3, [r3, #0]
 80441b0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80441b4:	d106      	bne.n	80441c4 <HAL_RCC_OscConfig+0x370>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80441b6:	f7fc ff73 	bl	80410a0 <HAL_GetTick>
 80441ba:	1b00      	subs	r0, r0, r4
 80441bc:	2802      	cmp	r0, #2
 80441be:	d9f5      	bls.n	80441ac <HAL_RCC_OscConfig+0x358>
            return HAL_TIMEOUT;
 80441c0:	2003      	movs	r0, #3
 80441c2:	e00a      	b.n	80441da <HAL_RCC_OscConfig+0x386>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 80441c4:	2000      	movs	r0, #0
 80441c6:	e008      	b.n	80441da <HAL_RCC_OscConfig+0x386>
 80441c8:	2000      	movs	r0, #0
 80441ca:	e006      	b.n	80441da <HAL_RCC_OscConfig+0x386>
    return HAL_ERROR;
 80441cc:	2001      	movs	r0, #1
}
 80441ce:	4770      	bx	lr
        return HAL_ERROR;
 80441d0:	2001      	movs	r0, #1
 80441d2:	e002      	b.n	80441da <HAL_RCC_OscConfig+0x386>
        return HAL_ERROR;
 80441d4:	2001      	movs	r0, #1
 80441d6:	e000      	b.n	80441da <HAL_RCC_OscConfig+0x386>
  return HAL_OK;
 80441d8:	2000      	movs	r0, #0
}
 80441da:	b002      	add	sp, #8
 80441dc:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 80441de:	2001      	movs	r0, #1
 80441e0:	e7fb      	b.n	80441da <HAL_RCC_OscConfig+0x386>
 80441e2:	bf00      	nop
 80441e4:	40023800 	.word	0x40023800
 80441e8:	42470060 	.word	0x42470060

080441ec <HAL_RCC_EnableCSS>:
  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.
  * @retval None
  */
void HAL_RCC_EnableCSS(void)
{
  *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
 80441ec:	4b01      	ldr	r3, [pc, #4]	; (80441f4 <HAL_RCC_EnableCSS+0x8>)
 80441ee:	2201      	movs	r2, #1
 80441f0:	601a      	str	r2, [r3, #0]
}
 80441f2:	4770      	bx	lr
 80441f4:	4247004c 	.word	0x4247004c

080441f8 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80441f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80441fa:	4b24      	ldr	r3, [pc, #144]	; (804428c <HAL_RCC_GetSysClockFreq+0x94>)
 80441fc:	689b      	ldr	r3, [r3, #8]
 80441fe:	f003 030c 	and.w	r3, r3, #12
 8044202:	2b04      	cmp	r3, #4
 8044204:	d03d      	beq.n	8044282 <HAL_RCC_GetSysClockFreq+0x8a>
 8044206:	2b08      	cmp	r3, #8
 8044208:	d13d      	bne.n	8044286 <HAL_RCC_GetSysClockFreq+0x8e>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 804420a:	4b20      	ldr	r3, [pc, #128]	; (804428c <HAL_RCC_GetSysClockFreq+0x94>)
 804420c:	685a      	ldr	r2, [r3, #4]
 804420e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8044212:	685b      	ldr	r3, [r3, #4]
 8044214:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8044218:	d012      	beq.n	8044240 <HAL_RCC_GetSysClockFreq+0x48>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 804421a:	4b1c      	ldr	r3, [pc, #112]	; (804428c <HAL_RCC_GetSysClockFreq+0x94>)
 804421c:	6859      	ldr	r1, [r3, #4]
 804421e:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8044222:	2300      	movs	r3, #0
 8044224:	481a      	ldr	r0, [pc, #104]	; (8044290 <HAL_RCC_GetSysClockFreq+0x98>)
 8044226:	fba1 0100 	umull	r0, r1, r1, r0
 804422a:	f7fc fd3d 	bl	8040ca8 <__aeabi_uldivmod>
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 804422e:	4b17      	ldr	r3, [pc, #92]	; (804428c <HAL_RCC_GetSysClockFreq+0x94>)
 8044230:	685b      	ldr	r3, [r3, #4]
 8044232:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8044236:	3301      	adds	r3, #1
 8044238:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 804423a:	fbb0 f0f3 	udiv	r0, r0, r3
      break;
 804423e:	e023      	b.n	8044288 <HAL_RCC_GetSysClockFreq+0x90>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8044240:	4b12      	ldr	r3, [pc, #72]	; (804428c <HAL_RCC_GetSysClockFreq+0x94>)
 8044242:	685b      	ldr	r3, [r3, #4]
 8044244:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8044248:	015c      	lsls	r4, r3, #5
 804424a:	2500      	movs	r5, #0
 804424c:	1ae4      	subs	r4, r4, r3
 804424e:	f165 0500 	sbc.w	r5, r5, #0
 8044252:	01ae      	lsls	r6, r5, #6
 8044254:	ea46 6694 	orr.w	r6, r6, r4, lsr #26
 8044258:	01a7      	lsls	r7, r4, #6
 804425a:	1b38      	subs	r0, r7, r4
 804425c:	eb66 0105 	sbc.w	r1, r6, r5
 8044260:	00cc      	lsls	r4, r1, #3
 8044262:	ea44 7450 	orr.w	r4, r4, r0, lsr #29
 8044266:	00c5      	lsls	r5, r0, #3
 8044268:	18e8      	adds	r0, r5, r3
 804426a:	f144 0100 	adc.w	r1, r4, #0
 804426e:	028b      	lsls	r3, r1, #10
 8044270:	ea43 5390 	orr.w	r3, r3, r0, lsr #22
 8044274:	0284      	lsls	r4, r0, #10
 8044276:	4620      	mov	r0, r4
 8044278:	4619      	mov	r1, r3
 804427a:	2300      	movs	r3, #0
 804427c:	f7fc fd14 	bl	8040ca8 <__aeabi_uldivmod>
 8044280:	e7d5      	b.n	804422e <HAL_RCC_GetSysClockFreq+0x36>
      sysclockfreq = HSE_VALUE;
 8044282:	4803      	ldr	r0, [pc, #12]	; (8044290 <HAL_RCC_GetSysClockFreq+0x98>)
 8044284:	e000      	b.n	8044288 <HAL_RCC_GetSysClockFreq+0x90>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8044286:	4803      	ldr	r0, [pc, #12]	; (8044294 <HAL_RCC_GetSysClockFreq+0x9c>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8044288:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804428a:	bf00      	nop
 804428c:	40023800 	.word	0x40023800
 8044290:	017d7840 	.word	0x017d7840
 8044294:	00f42400 	.word	0x00f42400

08044298 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8044298:	2800      	cmp	r0, #0
 804429a:	f000 809a 	beq.w	80443d2 <HAL_RCC_ClockConfig+0x13a>
{
 804429e:	b570      	push	{r4, r5, r6, lr}
 80442a0:	460d      	mov	r5, r1
 80442a2:	4604      	mov	r4, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 80442a4:	4b4f      	ldr	r3, [pc, #316]	; (80443e4 <HAL_RCC_ClockConfig+0x14c>)
 80442a6:	681b      	ldr	r3, [r3, #0]
 80442a8:	f003 030f 	and.w	r3, r3, #15
 80442ac:	428b      	cmp	r3, r1
 80442ae:	d208      	bcs.n	80442c2 <HAL_RCC_ClockConfig+0x2a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80442b0:	b2cb      	uxtb	r3, r1
 80442b2:	4a4c      	ldr	r2, [pc, #304]	; (80443e4 <HAL_RCC_ClockConfig+0x14c>)
 80442b4:	7013      	strb	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80442b6:	6813      	ldr	r3, [r2, #0]
 80442b8:	f003 030f 	and.w	r3, r3, #15
 80442bc:	428b      	cmp	r3, r1
 80442be:	f040 808a 	bne.w	80443d6 <HAL_RCC_ClockConfig+0x13e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80442c2:	6823      	ldr	r3, [r4, #0]
 80442c4:	f013 0f02 	tst.w	r3, #2
 80442c8:	d017      	beq.n	80442fa <HAL_RCC_ClockConfig+0x62>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80442ca:	f013 0f04 	tst.w	r3, #4
 80442ce:	d004      	beq.n	80442da <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80442d0:	4a45      	ldr	r2, [pc, #276]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 80442d2:	6893      	ldr	r3, [r2, #8]
 80442d4:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 80442d8:	6093      	str	r3, [r2, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80442da:	6823      	ldr	r3, [r4, #0]
 80442dc:	f013 0f08 	tst.w	r3, #8
 80442e0:	d004      	beq.n	80442ec <HAL_RCC_ClockConfig+0x54>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80442e2:	4a41      	ldr	r2, [pc, #260]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 80442e4:	6893      	ldr	r3, [r2, #8]
 80442e6:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 80442ea:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80442ec:	4a3e      	ldr	r2, [pc, #248]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 80442ee:	6893      	ldr	r3, [r2, #8]
 80442f0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80442f4:	68a1      	ldr	r1, [r4, #8]
 80442f6:	430b      	orrs	r3, r1
 80442f8:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80442fa:	6823      	ldr	r3, [r4, #0]
 80442fc:	f013 0f01 	tst.w	r3, #1
 8044300:	d032      	beq.n	8044368 <HAL_RCC_ClockConfig+0xd0>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8044302:	6863      	ldr	r3, [r4, #4]
 8044304:	2b01      	cmp	r3, #1
 8044306:	d021      	beq.n	804434c <HAL_RCC_ClockConfig+0xb4>
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8044308:	1e9a      	subs	r2, r3, #2
 804430a:	2a01      	cmp	r2, #1
 804430c:	d925      	bls.n	804435a <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 804430e:	4a36      	ldr	r2, [pc, #216]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 8044310:	6812      	ldr	r2, [r2, #0]
 8044312:	f012 0f02 	tst.w	r2, #2
 8044316:	d060      	beq.n	80443da <HAL_RCC_ClockConfig+0x142>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8044318:	4933      	ldr	r1, [pc, #204]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 804431a:	688a      	ldr	r2, [r1, #8]
 804431c:	f022 0203 	bic.w	r2, r2, #3
 8044320:	4313      	orrs	r3, r2
 8044322:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8044324:	f7fc febc 	bl	80410a0 <HAL_GetTick>
 8044328:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 804432a:	4b2f      	ldr	r3, [pc, #188]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 804432c:	689b      	ldr	r3, [r3, #8]
 804432e:	f003 030c 	and.w	r3, r3, #12
 8044332:	6862      	ldr	r2, [r4, #4]
 8044334:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8044338:	d016      	beq.n	8044368 <HAL_RCC_ClockConfig+0xd0>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 804433a:	f7fc feb1 	bl	80410a0 <HAL_GetTick>
 804433e:	1b80      	subs	r0, r0, r6
 8044340:	f241 3388 	movw	r3, #5000	; 0x1388
 8044344:	4298      	cmp	r0, r3
 8044346:	d9f0      	bls.n	804432a <HAL_RCC_ClockConfig+0x92>
        return HAL_TIMEOUT;
 8044348:	2003      	movs	r0, #3
 804434a:	e041      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 804434c:	4a26      	ldr	r2, [pc, #152]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 804434e:	6812      	ldr	r2, [r2, #0]
 8044350:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8044354:	d1e0      	bne.n	8044318 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 8044356:	2001      	movs	r0, #1
 8044358:	e03a      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 804435a:	4a23      	ldr	r2, [pc, #140]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 804435c:	6812      	ldr	r2, [r2, #0]
 804435e:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8044362:	d1d9      	bne.n	8044318 <HAL_RCC_ClockConfig+0x80>
        return HAL_ERROR;
 8044364:	2001      	movs	r0, #1
 8044366:	e033      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8044368:	4b1e      	ldr	r3, [pc, #120]	; (80443e4 <HAL_RCC_ClockConfig+0x14c>)
 804436a:	681b      	ldr	r3, [r3, #0]
 804436c:	f003 030f 	and.w	r3, r3, #15
 8044370:	42ab      	cmp	r3, r5
 8044372:	d907      	bls.n	8044384 <HAL_RCC_ClockConfig+0xec>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8044374:	b2ea      	uxtb	r2, r5
 8044376:	4b1b      	ldr	r3, [pc, #108]	; (80443e4 <HAL_RCC_ClockConfig+0x14c>)
 8044378:	701a      	strb	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 804437a:	681b      	ldr	r3, [r3, #0]
 804437c:	f003 030f 	and.w	r3, r3, #15
 8044380:	42ab      	cmp	r3, r5
 8044382:	d12c      	bne.n	80443de <HAL_RCC_ClockConfig+0x146>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8044384:	6823      	ldr	r3, [r4, #0]
 8044386:	f013 0f04 	tst.w	r3, #4
 804438a:	d006      	beq.n	804439a <HAL_RCC_ClockConfig+0x102>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 804438c:	4a16      	ldr	r2, [pc, #88]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 804438e:	6893      	ldr	r3, [r2, #8]
 8044390:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 8044394:	68e1      	ldr	r1, [r4, #12]
 8044396:	430b      	orrs	r3, r1
 8044398:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 804439a:	6823      	ldr	r3, [r4, #0]
 804439c:	f013 0f08 	tst.w	r3, #8
 80443a0:	d007      	beq.n	80443b2 <HAL_RCC_ClockConfig+0x11a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80443a2:	4a11      	ldr	r2, [pc, #68]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 80443a4:	6893      	ldr	r3, [r2, #8]
 80443a6:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80443aa:	6921      	ldr	r1, [r4, #16]
 80443ac:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80443b0:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80443b2:	f7ff ff21 	bl	80441f8 <HAL_RCC_GetSysClockFreq>
 80443b6:	4b0c      	ldr	r3, [pc, #48]	; (80443e8 <HAL_RCC_ClockConfig+0x150>)
 80443b8:	689b      	ldr	r3, [r3, #8]
 80443ba:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80443be:	4a0b      	ldr	r2, [pc, #44]	; (80443ec <HAL_RCC_ClockConfig+0x154>)
 80443c0:	5cd3      	ldrb	r3, [r2, r3]
 80443c2:	40d8      	lsrs	r0, r3
 80443c4:	4b0a      	ldr	r3, [pc, #40]	; (80443f0 <HAL_RCC_ClockConfig+0x158>)
 80443c6:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80443c8:	2000      	movs	r0, #0
 80443ca:	f7fc fe1f 	bl	804100c <HAL_InitTick>
  return HAL_OK;
 80443ce:	2000      	movs	r0, #0
}
 80443d0:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80443d2:	2001      	movs	r0, #1
}
 80443d4:	4770      	bx	lr
      return HAL_ERROR;
 80443d6:	2001      	movs	r0, #1
 80443d8:	e7fa      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
        return HAL_ERROR;
 80443da:	2001      	movs	r0, #1
 80443dc:	e7f8      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
      return HAL_ERROR;
 80443de:	2001      	movs	r0, #1
 80443e0:	e7f6      	b.n	80443d0 <HAL_RCC_ClockConfig+0x138>
 80443e2:	bf00      	nop
 80443e4:	40023c00 	.word	0x40023c00
 80443e8:	40023800 	.word	0x40023800
 80443ec:	080585e4 	.word	0x080585e4
 80443f0:	20003874 	.word	0x20003874

080443f4 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80443f4:	4b01      	ldr	r3, [pc, #4]	; (80443fc <HAL_RCC_GetHCLKFreq+0x8>)
 80443f6:	6818      	ldr	r0, [r3, #0]
 80443f8:	4770      	bx	lr
 80443fa:	bf00      	nop
 80443fc:	20003874 	.word	0x20003874

08044400 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8044400:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8044402:	f7ff fff7 	bl	80443f4 <HAL_RCC_GetHCLKFreq>
 8044406:	4b04      	ldr	r3, [pc, #16]	; (8044418 <HAL_RCC_GetPCLK1Freq+0x18>)
 8044408:	689b      	ldr	r3, [r3, #8]
 804440a:	f3c3 2382 	ubfx	r3, r3, #10, #3
 804440e:	4a03      	ldr	r2, [pc, #12]	; (804441c <HAL_RCC_GetPCLK1Freq+0x1c>)
 8044410:	5cd3      	ldrb	r3, [r2, r3]
}
 8044412:	40d8      	lsrs	r0, r3
 8044414:	bd08      	pop	{r3, pc}
 8044416:	bf00      	nop
 8044418:	40023800 	.word	0x40023800
 804441c:	080585f4 	.word	0x080585f4

08044420 <HAL_RCC_CSSCallback>:
__weak void HAL_RCC_CSSCallback(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
 8044420:	4770      	bx	lr
	...

08044424 <HAL_RCC_NMI_IRQHandler>:
{
 8044424:	b508      	push	{r3, lr}
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 8044426:	4b06      	ldr	r3, [pc, #24]	; (8044440 <HAL_RCC_NMI_IRQHandler+0x1c>)
 8044428:	68db      	ldr	r3, [r3, #12]
 804442a:	f013 0f80 	tst.w	r3, #128	; 0x80
 804442e:	d100      	bne.n	8044432 <HAL_RCC_NMI_IRQHandler+0xe>
}
 8044430:	bd08      	pop	{r3, pc}
    HAL_RCC_CSSCallback();
 8044432:	f7ff fff5 	bl	8044420 <HAL_RCC_CSSCallback>
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8044436:	4b03      	ldr	r3, [pc, #12]	; (8044444 <HAL_RCC_NMI_IRQHandler+0x20>)
 8044438:	2280      	movs	r2, #128	; 0x80
 804443a:	701a      	strb	r2, [r3, #0]
}
 804443c:	e7f8      	b.n	8044430 <HAL_RCC_NMI_IRQHandler+0xc>
 804443e:	bf00      	nop
 8044440:	40023800 	.word	0x40023800
 8044444:	4002380e 	.word	0x4002380e

08044448 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8044448:	b530      	push	{r4, r5, lr}
 804444a:	b083      	sub	sp, #12
 804444c:	4604      	mov	r4, r0

  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
  /*----------------------- Common configuration SAI/I2S ---------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 804444e:	6803      	ldr	r3, [r0, #0]
 8044450:	f013 0f03 	tst.w	r3, #3
 8044454:	d114      	bne.n	8044480 <HAL_RCCEx_PeriphCLKConfig+0x38>

  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
  /*----------------------- Common configuration SAI/LTDC --------------------*/
  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||
 8044456:	6823      	ldr	r3, [r4, #0]
 8044458:	f013 0f0c 	tst.w	r3, #12
 804445c:	d15a      	bne.n	8044514 <HAL_RCCEx_PeriphCLKConfig+0xcc>
    }
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 804445e:	6823      	ldr	r3, [r4, #0]
 8044460:	f013 0f20 	tst.w	r3, #32
 8044464:	f040 80af 	bne.w	80445c6 <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8044468:	6823      	ldr	r3, [r4, #0]
 804446a:	f013 0f10 	tst.w	r3, #16
 804446e:	f000 8111 	beq.w	8044694 <HAL_RCCEx_PeriphCLKConfig+0x24c>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8044472:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
 8044476:	4b88      	ldr	r3, [pc, #544]	; (8044698 <HAL_RCCEx_PeriphCLKConfig+0x250>)
 8044478:	601a      	str	r2, [r3, #0]
  }
  return HAL_OK;
 804447a:	2000      	movs	r0, #0
}
 804447c:	b003      	add	sp, #12
 804447e:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PLLI2S_DISABLE();
 8044480:	4b86      	ldr	r3, [pc, #536]	; (804469c <HAL_RCCEx_PeriphCLKConfig+0x254>)
 8044482:	2200      	movs	r2, #0
 8044484:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8044486:	f7fc fe0b 	bl	80410a0 <HAL_GetTick>
 804448a:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 804448c:	4b84      	ldr	r3, [pc, #528]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 804448e:	681b      	ldr	r3, [r3, #0]
 8044490:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8044494:	d006      	beq.n	80444a4 <HAL_RCCEx_PeriphCLKConfig+0x5c>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8044496:	f7fc fe03 	bl	80410a0 <HAL_GetTick>
 804449a:	1b43      	subs	r3, r0, r5
 804449c:	2b02      	cmp	r3, #2
 804449e:	d9f5      	bls.n	804448c <HAL_RCCEx_PeriphCLKConfig+0x44>
        return HAL_TIMEOUT;
 80444a0:	2003      	movs	r0, #3
 80444a2:	e7eb      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80444a4:	6823      	ldr	r3, [r4, #0]
 80444a6:	f013 0f01 	tst.w	r3, #1
 80444aa:	d007      	beq.n	80444bc <HAL_RCCEx_PeriphCLKConfig+0x74>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 80444ac:	6862      	ldr	r2, [r4, #4]
 80444ae:	68a3      	ldr	r3, [r4, #8]
 80444b0:	071b      	lsls	r3, r3, #28
 80444b2:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80444b6:	4a7a      	ldr	r2, [pc, #488]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80444b8:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
 80444bc:	6823      	ldr	r3, [r4, #0]
 80444be:	f013 0f02 	tst.w	r3, #2
 80444c2:	d015      	beq.n	80444f0 <HAL_RCCEx_PeriphCLKConfig+0xa8>
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80444c4:	4a76      	ldr	r2, [pc, #472]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80444c6:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);
 80444ca:	6860      	ldr	r0, [r4, #4]
 80444cc:	68e3      	ldr	r3, [r4, #12]
 80444ce:	061b      	lsls	r3, r3, #24
 80444d0:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 80444d4:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 80444d8:	430b      	orrs	r3, r1
 80444da:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80444de:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 80444e2:	f023 031f 	bic.w	r3, r3, #31
 80444e6:	69e1      	ldr	r1, [r4, #28]
 80444e8:	3901      	subs	r1, #1
 80444ea:	430b      	orrs	r3, r1
 80444ec:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLI2S_ENABLE();
 80444f0:	4b6a      	ldr	r3, [pc, #424]	; (804469c <HAL_RCCEx_PeriphCLKConfig+0x254>)
 80444f2:	2201      	movs	r2, #1
 80444f4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80444f6:	f7fc fdd3 	bl	80410a0 <HAL_GetTick>
 80444fa:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80444fc:	4b68      	ldr	r3, [pc, #416]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80444fe:	681b      	ldr	r3, [r3, #0]
 8044500:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8044504:	d1a7      	bne.n	8044456 <HAL_RCCEx_PeriphCLKConfig+0xe>
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8044506:	f7fc fdcb 	bl	80410a0 <HAL_GetTick>
 804450a:	1b40      	subs	r0, r0, r5
 804450c:	2802      	cmp	r0, #2
 804450e:	d9f5      	bls.n	80444fc <HAL_RCCEx_PeriphCLKConfig+0xb4>
        return HAL_TIMEOUT;
 8044510:	2003      	movs	r0, #3
 8044512:	e7b3      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PLLSAI_DISABLE();
 8044514:	4b63      	ldr	r3, [pc, #396]	; (80446a4 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8044516:	2200      	movs	r2, #0
 8044518:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 804451a:	f7fc fdc1 	bl	80410a0 <HAL_GetTick>
 804451e:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8044520:	4b5f      	ldr	r3, [pc, #380]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044522:	681b      	ldr	r3, [r3, #0]
 8044524:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 8044528:	d006      	beq.n	8044538 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 804452a:	f7fc fdb9 	bl	80410a0 <HAL_GetTick>
 804452e:	1b43      	subs	r3, r0, r5
 8044530:	2b02      	cmp	r3, #2
 8044532:	d9f5      	bls.n	8044520 <HAL_RCCEx_PeriphCLKConfig+0xd8>
        return HAL_TIMEOUT;
 8044534:	2003      	movs	r0, #3
 8044536:	e7a1      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
 8044538:	6823      	ldr	r3, [r4, #0]
 804453a:	f013 0f04 	tst.w	r3, #4
 804453e:	d016      	beq.n	804456e <HAL_RCCEx_PeriphCLKConfig+0x126>
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8044540:	4a57      	ldr	r2, [pc, #348]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044542:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8044546:	6920      	ldr	r0, [r4, #16]
 8044548:	6963      	ldr	r3, [r4, #20]
 804454a:	061b      	lsls	r3, r3, #24
 804454c:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8044550:	f001 41e0 	and.w	r1, r1, #1879048192	; 0x70000000
 8044554:	430b      	orrs	r3, r1
 8044556:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 804455a:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 804455e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8044562:	6a21      	ldr	r1, [r4, #32]
 8044564:	3901      	subs	r1, #1
 8044566:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 804456a:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 804456e:	6823      	ldr	r3, [r4, #0]
 8044570:	f013 0f08 	tst.w	r3, #8
 8044574:	d014      	beq.n	80445a0 <HAL_RCCEx_PeriphCLKConfig+0x158>
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8044576:	4a4a      	ldr	r2, [pc, #296]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044578:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);
 804457c:	6921      	ldr	r1, [r4, #16]
 804457e:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 8044582:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8044586:	69a1      	ldr	r1, [r4, #24]
 8044588:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 804458c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8044590:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8044594:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8044598:	6a61      	ldr	r1, [r4, #36]	; 0x24
 804459a:	430b      	orrs	r3, r1
 804459c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 80445a0:	4b40      	ldr	r3, [pc, #256]	; (80446a4 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 80445a2:	2201      	movs	r2, #1
 80445a4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80445a6:	f7fc fd7b 	bl	80410a0 <HAL_GetTick>
 80445aa:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80445ac:	4b3c      	ldr	r3, [pc, #240]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80445ae:	681b      	ldr	r3, [r3, #0]
 80445b0:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
 80445b4:	f47f af53 	bne.w	804445e <HAL_RCCEx_PeriphCLKConfig+0x16>
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 80445b8:	f7fc fd72 	bl	80410a0 <HAL_GetTick>
 80445bc:	1b40      	subs	r0, r0, r5
 80445be:	2802      	cmp	r0, #2
 80445c0:	d9f4      	bls.n	80445ac <HAL_RCCEx_PeriphCLKConfig+0x164>
        return HAL_TIMEOUT;
 80445c2:	2003      	movs	r0, #3
 80445c4:	e75a      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_PWR_CLK_ENABLE();
 80445c6:	2300      	movs	r3, #0
 80445c8:	9301      	str	r3, [sp, #4]
 80445ca:	4b35      	ldr	r3, [pc, #212]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 80445cc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80445ce:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80445d2:	641a      	str	r2, [r3, #64]	; 0x40
 80445d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80445d6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80445da:	9301      	str	r3, [sp, #4]
 80445dc:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 80445de:	4a32      	ldr	r2, [pc, #200]	; (80446a8 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80445e0:	6813      	ldr	r3, [r2, #0]
 80445e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80445e6:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 80445e8:	f7fc fd5a 	bl	80410a0 <HAL_GetTick>
 80445ec:	4605      	mov	r5, r0
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80445ee:	4b2e      	ldr	r3, [pc, #184]	; (80446a8 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 80445f0:	681b      	ldr	r3, [r3, #0]
 80445f2:	f413 7f80 	tst.w	r3, #256	; 0x100
 80445f6:	d106      	bne.n	8044606 <HAL_RCCEx_PeriphCLKConfig+0x1be>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80445f8:	f7fc fd52 	bl	80410a0 <HAL_GetTick>
 80445fc:	1b40      	subs	r0, r0, r5
 80445fe:	2802      	cmp	r0, #2
 8044600:	d9f5      	bls.n	80445ee <HAL_RCCEx_PeriphCLKConfig+0x1a6>
        return HAL_TIMEOUT;
 8044602:	2003      	movs	r0, #3
 8044604:	e73a      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8044606:	4b26      	ldr	r3, [pc, #152]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044608:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 804460a:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 804460e:	d012      	beq.n	8044636 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 8044610:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8044612:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8044616:	429a      	cmp	r2, r3
 8044618:	d00d      	beq.n	8044636 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 804461a:	4b21      	ldr	r3, [pc, #132]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 804461c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 804461e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8044622:	4922      	ldr	r1, [pc, #136]	; (80446ac <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8044624:	2001      	movs	r0, #1
 8044626:	6008      	str	r0, [r1, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8044628:	2000      	movs	r0, #0
 804462a:	6008      	str	r0, [r1, #0]
      RCC->BDCR = tmpreg1;
 804462c:	671a      	str	r2, [r3, #112]	; 0x70
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 804462e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8044630:	f013 0f01 	tst.w	r3, #1
 8044634:	d112      	bne.n	804465c <HAL_RCCEx_PeriphCLKConfig+0x214>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8044636:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8044638:	f403 7240 	and.w	r2, r3, #768	; 0x300
 804463c:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 8044640:	d01d      	beq.n	804467e <HAL_RCCEx_PeriphCLKConfig+0x236>
 8044642:	4a17      	ldr	r2, [pc, #92]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044644:	6893      	ldr	r3, [r2, #8]
 8044646:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 804464a:	6093      	str	r3, [r2, #8]
 804464c:	4914      	ldr	r1, [pc, #80]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 804464e:	6f0b      	ldr	r3, [r1, #112]	; 0x70
 8044650:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8044652:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8044656:	4313      	orrs	r3, r2
 8044658:	670b      	str	r3, [r1, #112]	; 0x70
 804465a:	e705      	b.n	8044468 <HAL_RCCEx_PeriphCLKConfig+0x20>
        tickstart = HAL_GetTick();
 804465c:	f7fc fd20 	bl	80410a0 <HAL_GetTick>
 8044660:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8044662:	4b0f      	ldr	r3, [pc, #60]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044664:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8044666:	f013 0f02 	tst.w	r3, #2
 804466a:	d1e4      	bne.n	8044636 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 804466c:	f7fc fd18 	bl	80410a0 <HAL_GetTick>
 8044670:	1b40      	subs	r0, r0, r5
 8044672:	f241 3388 	movw	r3, #5000	; 0x1388
 8044676:	4298      	cmp	r0, r3
 8044678:	d9f3      	bls.n	8044662 <HAL_RCCEx_PeriphCLKConfig+0x21a>
            return HAL_TIMEOUT;
 804467a:	2003      	movs	r0, #3
 804467c:	e6fe      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 804467e:	4908      	ldr	r1, [pc, #32]	; (80446a0 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8044680:	688a      	ldr	r2, [r1, #8]
 8044682:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 8044686:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 804468a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 804468e:	4313      	orrs	r3, r2
 8044690:	608b      	str	r3, [r1, #8]
 8044692:	e7db      	b.n	804464c <HAL_RCCEx_PeriphCLKConfig+0x204>
  return HAL_OK;
 8044694:	2000      	movs	r0, #0
 8044696:	e6f1      	b.n	804447c <HAL_RCCEx_PeriphCLKConfig+0x34>
 8044698:	424711e0 	.word	0x424711e0
 804469c:	42470068 	.word	0x42470068
 80446a0:	40023800 	.word	0x40023800
 80446a4:	42470070 	.word	0x42470070
 80446a8:	40007000 	.word	0x40007000
 80446ac:	42470e40 	.word	0x42470e40

080446b0 <HAL_RTC_AlarmIRQHandler>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
{
 80446b0:	b510      	push	{r4, lr}
 80446b2:	4604      	mov	r4, r0
  if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRA))
 80446b4:	6803      	ldr	r3, [r0, #0]
 80446b6:	68da      	ldr	r2, [r3, #12]
 80446b8:	f412 7f80 	tst.w	r2, #256	; 0x100
 80446bc:	d003      	beq.n	80446c6 <HAL_RTC_AlarmIRQHandler+0x16>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRA) != (uint32_t)RESET)
 80446be:	689b      	ldr	r3, [r3, #8]
 80446c0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80446c4:	d10f      	bne.n	80446e6 <HAL_RTC_AlarmIRQHandler+0x36>
      /* Clear the Alarm interrupt pending bit */
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
    }
  }

  if(__HAL_RTC_ALARM_GET_IT(hrtc, RTC_IT_ALRB))
 80446c6:	6823      	ldr	r3, [r4, #0]
 80446c8:	68da      	ldr	r2, [r3, #12]
 80446ca:	f412 7f00 	tst.w	r2, #512	; 0x200
 80446ce:	d003      	beq.n	80446d8 <HAL_RTC_AlarmIRQHandler+0x28>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_ALRB) != (uint32_t)RESET)
 80446d0:	689b      	ldr	r3, [r3, #8]
 80446d2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 80446d6:	d10f      	bne.n	80446f8 <HAL_RTC_AlarmIRQHandler+0x48>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
    }
  }

  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 80446d8:	4b0c      	ldr	r3, [pc, #48]	; (804470c <HAL_RTC_AlarmIRQHandler+0x5c>)
 80446da:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 80446de:	615a      	str	r2, [r3, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80446e0:	2301      	movs	r3, #1
 80446e2:	7763      	strb	r3, [r4, #29]
}
 80446e4:	bd10      	pop	{r4, pc}
      HAL_RTC_AlarmAEventCallback(hrtc);
 80446e6:	f00c f8fa 	bl	80508de <HAL_RTC_AlarmAEventCallback>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
 80446ea:	6822      	ldr	r2, [r4, #0]
 80446ec:	68d3      	ldr	r3, [r2, #12]
 80446ee:	b2db      	uxtb	r3, r3
 80446f0:	f463 73c0 	orn	r3, r3, #384	; 0x180
 80446f4:	60d3      	str	r3, [r2, #12]
 80446f6:	e7e6      	b.n	80446c6 <HAL_RTC_AlarmIRQHandler+0x16>
      HAL_RTCEx_AlarmBEventCallback(hrtc);
 80446f8:	4620      	mov	r0, r4
 80446fa:	f000 fb64 	bl	8044dc6 <HAL_RTCEx_AlarmBEventCallback>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRBF);
 80446fe:	6822      	ldr	r2, [r4, #0]
 8044700:	68d3      	ldr	r3, [r2, #12]
 8044702:	b2db      	uxtb	r3, r3
 8044704:	f463 7320 	orn	r3, r3, #640	; 0x280
 8044708:	60d3      	str	r3, [r2, #12]
 804470a:	e7e5      	b.n	80446d8 <HAL_RTC_AlarmIRQHandler+0x28>
 804470c:	40013c00 	.word	0x40013c00

08044710 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8044710:	b538      	push	{r3, r4, r5, lr}
 8044712:	4604      	mov	r4, r0
  uint32_t tickstart = 0U;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8044714:	6802      	ldr	r2, [r0, #0]
 8044716:	68d3      	ldr	r3, [r2, #12]
 8044718:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 804471c:	60d3      	str	r3, [r2, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 804471e:	f7fc fcbf 	bl	80410a0 <HAL_GetTick>
 8044722:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8044724:	6823      	ldr	r3, [r4, #0]
 8044726:	68db      	ldr	r3, [r3, #12]
 8044728:	f013 0f20 	tst.w	r3, #32
 804472c:	d107      	bne.n	804473e <HAL_RTC_WaitForSynchro+0x2e>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 804472e:	f7fc fcb7 	bl	80410a0 <HAL_GetTick>
 8044732:	1b40      	subs	r0, r0, r5
 8044734:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8044738:	d9f4      	bls.n	8044724 <HAL_RTC_WaitForSynchro+0x14>
    {
      return HAL_TIMEOUT;
 804473a:	2003      	movs	r0, #3
 804473c:	e000      	b.n	8044740 <HAL_RTC_WaitForSynchro+0x30>
    }
  }

  return HAL_OK;
 804473e:	2000      	movs	r0, #0
}
 8044740:	bd38      	pop	{r3, r4, r5, pc}

08044742 <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8044742:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8044744:	6803      	ldr	r3, [r0, #0]
 8044746:	68da      	ldr	r2, [r3, #12]
 8044748:	f012 0f40 	tst.w	r2, #64	; 0x40
 804474c:	d001      	beq.n	8044752 <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 804474e:	2000      	movs	r0, #0
}
 8044750:	bd38      	pop	{r3, r4, r5, pc}
 8044752:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8044754:	f04f 32ff 	mov.w	r2, #4294967295
 8044758:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 804475a:	f7fc fca1 	bl	80410a0 <HAL_GetTick>
 804475e:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8044760:	6823      	ldr	r3, [r4, #0]
 8044762:	68db      	ldr	r3, [r3, #12]
 8044764:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044768:	d107      	bne.n	804477a <RTC_EnterInitMode+0x38>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 804476a:	f7fc fc99 	bl	80410a0 <HAL_GetTick>
 804476e:	1b43      	subs	r3, r0, r5
 8044770:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8044774:	d9f4      	bls.n	8044760 <RTC_EnterInitMode+0x1e>
        return HAL_TIMEOUT;
 8044776:	2003      	movs	r0, #3
 8044778:	e7ea      	b.n	8044750 <RTC_EnterInitMode+0xe>
  return HAL_OK;
 804477a:	2000      	movs	r0, #0
 804477c:	e7e8      	b.n	8044750 <RTC_EnterInitMode+0xe>

0804477e <HAL_RTC_Init>:
{
 804477e:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 8044780:	2800      	cmp	r0, #0
 8044782:	d05c      	beq.n	804483e <HAL_RTC_Init+0xc0>
 8044784:	4604      	mov	r4, r0
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8044786:	7f43      	ldrb	r3, [r0, #29]
 8044788:	2b00      	cmp	r3, #0
 804478a:	d041      	beq.n	8044810 <HAL_RTC_Init+0x92>
  hrtc->State = HAL_RTC_STATE_BUSY;
 804478c:	2302      	movs	r3, #2
 804478e:	7763      	strb	r3, [r4, #29]
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8044790:	6823      	ldr	r3, [r4, #0]
 8044792:	22ca      	movs	r2, #202	; 0xca
 8044794:	625a      	str	r2, [r3, #36]	; 0x24
 8044796:	6823      	ldr	r3, [r4, #0]
 8044798:	2253      	movs	r2, #83	; 0x53
 804479a:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 804479c:	4620      	mov	r0, r4
 804479e:	f7ff ffd0 	bl	8044742 <RTC_EnterInitMode>
 80447a2:	4605      	mov	r5, r0
 80447a4:	2800      	cmp	r0, #0
 80447a6:	d137      	bne.n	8044818 <HAL_RTC_Init+0x9a>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80447a8:	6822      	ldr	r2, [r4, #0]
 80447aa:	6893      	ldr	r3, [r2, #8]
 80447ac:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 80447b0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80447b4:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80447b6:	6821      	ldr	r1, [r4, #0]
 80447b8:	688a      	ldr	r2, [r1, #8]
 80447ba:	6863      	ldr	r3, [r4, #4]
 80447bc:	6920      	ldr	r0, [r4, #16]
 80447be:	4303      	orrs	r3, r0
 80447c0:	6960      	ldr	r0, [r4, #20]
 80447c2:	4303      	orrs	r3, r0
 80447c4:	4313      	orrs	r3, r2
 80447c6:	608b      	str	r3, [r1, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 80447c8:	6823      	ldr	r3, [r4, #0]
 80447ca:	68e2      	ldr	r2, [r4, #12]
 80447cc:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16U);
 80447ce:	6822      	ldr	r2, [r4, #0]
 80447d0:	6913      	ldr	r3, [r2, #16]
 80447d2:	68a1      	ldr	r1, [r4, #8]
 80447d4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80447d8:	6113      	str	r3, [r2, #16]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 80447da:	6822      	ldr	r2, [r4, #0]
 80447dc:	68d3      	ldr	r3, [r2, #12]
 80447de:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80447e2:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80447e4:	6823      	ldr	r3, [r4, #0]
 80447e6:	689b      	ldr	r3, [r3, #8]
 80447e8:	f013 0f20 	tst.w	r3, #32
 80447ec:	d01b      	beq.n	8044826 <HAL_RTC_Init+0xa8>
    hrtc->Instance->TAFCR &= (uint32_t)~RTC_TAFCR_ALARMOUTTYPE;
 80447ee:	6822      	ldr	r2, [r4, #0]
 80447f0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80447f2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80447f6:	6413      	str	r3, [r2, #64]	; 0x40
    hrtc->Instance->TAFCR |= (uint32_t)(hrtc->Init.OutPutType);
 80447f8:	6822      	ldr	r2, [r4, #0]
 80447fa:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80447fc:	69a1      	ldr	r1, [r4, #24]
 80447fe:	430b      	orrs	r3, r1
 8044800:	6413      	str	r3, [r2, #64]	; 0x40
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044802:	6823      	ldr	r3, [r4, #0]
 8044804:	22ff      	movs	r2, #255	; 0xff
 8044806:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8044808:	2301      	movs	r3, #1
 804480a:	7763      	strb	r3, [r4, #29]
}
 804480c:	4628      	mov	r0, r5
 804480e:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Lock = HAL_UNLOCKED;
 8044810:	7703      	strb	r3, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8044812:	f00b f93b 	bl	804fa8c <HAL_RTC_MspInit>
 8044816:	e7b9      	b.n	804478c <HAL_RTC_Init+0xe>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044818:	6823      	ldr	r3, [r4, #0]
 804481a:	22ff      	movs	r2, #255	; 0xff
 804481c:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 804481e:	2304      	movs	r3, #4
 8044820:	7763      	strb	r3, [r4, #29]
    return HAL_ERROR;
 8044822:	2501      	movs	r5, #1
 8044824:	e7f2      	b.n	804480c <HAL_RTC_Init+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8044826:	4620      	mov	r0, r4
 8044828:	f7ff ff72 	bl	8044710 <HAL_RTC_WaitForSynchro>
 804482c:	2800      	cmp	r0, #0
 804482e:	d0de      	beq.n	80447ee <HAL_RTC_Init+0x70>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044830:	6823      	ldr	r3, [r4, #0]
 8044832:	22ff      	movs	r2, #255	; 0xff
 8044834:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8044836:	2304      	movs	r3, #4
 8044838:	7763      	strb	r3, [r4, #29]
        return HAL_ERROR;
 804483a:	2501      	movs	r5, #1
 804483c:	e7e6      	b.n	804480c <HAL_RTC_Init+0x8e>
     return HAL_ERROR;
 804483e:	2501      	movs	r5, #1
 8044840:	e7e4      	b.n	804480c <HAL_RTC_Init+0x8e>

08044842 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8044842:	2300      	movs	r3, #0

  while(Value >= 10U)
 8044844:	2809      	cmp	r0, #9
 8044846:	d903      	bls.n	8044850 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
 8044848:	3301      	adds	r3, #1
    Value -= 10U;
 804484a:	380a      	subs	r0, #10
 804484c:	b2c0      	uxtb	r0, r0
 804484e:	e7f9      	b.n	8044844 <RTC_ByteToBcd2+0x2>
  }

  return  ((uint8_t)(bcdhigh << 4U) | Value);
 8044850:	011b      	lsls	r3, r3, #4
 8044852:	b2db      	uxtb	r3, r3
}
 8044854:	4318      	orrs	r0, r3
 8044856:	4770      	bx	lr

08044858 <HAL_RTC_SetTime>:
{
 8044858:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 804485a:	7f03      	ldrb	r3, [r0, #28]
 804485c:	2b01      	cmp	r3, #1
 804485e:	d078      	beq.n	8044952 <HAL_RTC_SetTime+0xfa>
 8044860:	4604      	mov	r4, r0
 8044862:	460e      	mov	r6, r1
 8044864:	2301      	movs	r3, #1
 8044866:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8044868:	2302      	movs	r3, #2
 804486a:	7743      	strb	r3, [r0, #29]
  if(Format == RTC_FORMAT_BIN)
 804486c:	2a00      	cmp	r2, #0
 804486e:	d147      	bne.n	8044900 <HAL_RTC_SetTime+0xa8>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044870:	6803      	ldr	r3, [r0, #0]
 8044872:	689b      	ldr	r3, [r3, #8]
 8044874:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044878:	d101      	bne.n	804487e <HAL_RTC_SetTime+0x26>
      sTime->TimeFormat = 0x00U;
 804487a:	2300      	movs	r3, #0
 804487c:	70cb      	strb	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 804487e:	7830      	ldrb	r0, [r6, #0]
 8044880:	f7ff ffdf 	bl	8044842 <RTC_ByteToBcd2>
 8044884:	0405      	lsls	r5, r0, #16
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8044886:	7870      	ldrb	r0, [r6, #1]
 8044888:	f7ff ffdb 	bl	8044842 <RTC_ByteToBcd2>
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 804488c:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8044890:	78b0      	ldrb	r0, [r6, #2]
 8044892:	f7ff ffd6 	bl	8044842 <RTC_ByteToBcd2>
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8U) | \
 8044896:	4305      	orrs	r5, r0
                        (((uint32_t)sTime->TimeFormat) << 16U));
 8044898:	78f0      	ldrb	r0, [r6, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16U) | \
 804489a:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 804489e:	6823      	ldr	r3, [r4, #0]
 80448a0:	22ca      	movs	r2, #202	; 0xca
 80448a2:	625a      	str	r2, [r3, #36]	; 0x24
 80448a4:	6823      	ldr	r3, [r4, #0]
 80448a6:	2253      	movs	r2, #83	; 0x53
 80448a8:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80448aa:	4620      	mov	r0, r4
 80448ac:	f7ff ff49 	bl	8044742 <RTC_EnterInitMode>
 80448b0:	4607      	mov	r7, r0
 80448b2:	2800      	cmp	r0, #0
 80448b4:	d136      	bne.n	8044924 <HAL_RTC_SetTime+0xcc>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80448b6:	6823      	ldr	r3, [r4, #0]
 80448b8:	f005 357f 	and.w	r5, r5, #2139062143	; 0x7f7f7f7f
 80448bc:	f025 45fe 	bic.w	r5, r5, #2130706432	; 0x7f000000
 80448c0:	601d      	str	r5, [r3, #0]
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BCK;
 80448c2:	6822      	ldr	r2, [r4, #0]
 80448c4:	6893      	ldr	r3, [r2, #8]
 80448c6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80448ca:	6093      	str	r3, [r2, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 80448cc:	6821      	ldr	r1, [r4, #0]
 80448ce:	688b      	ldr	r3, [r1, #8]
 80448d0:	68f2      	ldr	r2, [r6, #12]
 80448d2:	6930      	ldr	r0, [r6, #16]
 80448d4:	4302      	orrs	r2, r0
 80448d6:	4313      	orrs	r3, r2
 80448d8:	608b      	str	r3, [r1, #8]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 80448da:	6822      	ldr	r2, [r4, #0]
 80448dc:	68d3      	ldr	r3, [r2, #12]
 80448de:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80448e2:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80448e4:	6823      	ldr	r3, [r4, #0]
 80448e6:	689b      	ldr	r3, [r3, #8]
 80448e8:	f013 0f20 	tst.w	r3, #32
 80448ec:	d023      	beq.n	8044936 <HAL_RTC_SetTime+0xde>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80448ee:	6823      	ldr	r3, [r4, #0]
 80448f0:	22ff      	movs	r2, #255	; 0xff
 80448f2:	625a      	str	r2, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 80448f4:	2301      	movs	r3, #1
 80448f6:	7763      	strb	r3, [r4, #29]
   __HAL_UNLOCK(hrtc);
 80448f8:	2300      	movs	r3, #0
 80448fa:	7723      	strb	r3, [r4, #28]
}
 80448fc:	4638      	mov	r0, r7
 80448fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044900:	6803      	ldr	r3, [r0, #0]
 8044902:	689b      	ldr	r3, [r3, #8]
 8044904:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044908:	d101      	bne.n	804490e <HAL_RTC_SetTime+0xb6>
      sTime->TimeFormat = 0x00U;
 804490a:	2300      	movs	r3, #0
 804490c:	70cb      	strb	r3, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 804490e:	7835      	ldrb	r5, [r6, #0]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 8044910:	7870      	ldrb	r0, [r6, #1]
 8044912:	0200      	lsls	r0, r0, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 8044914:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
              ((uint32_t)sTime->Seconds) | \
 8044918:	78b5      	ldrb	r5, [r6, #2]
              ((uint32_t)(sTime->Minutes) << 8U) | \
 804491a:	4328      	orrs	r0, r5
              ((uint32_t)(sTime->TimeFormat) << 16U));
 804491c:	78f5      	ldrb	r5, [r6, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16U) | \
 804491e:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
 8044922:	e7bc      	b.n	804489e <HAL_RTC_SetTime+0x46>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044924:	6823      	ldr	r3, [r4, #0]
 8044926:	22ff      	movs	r2, #255	; 0xff
 8044928:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 804492a:	2304      	movs	r3, #4
 804492c:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 804492e:	2300      	movs	r3, #0
 8044930:	7723      	strb	r3, [r4, #28]
    return HAL_ERROR;
 8044932:	2701      	movs	r7, #1
 8044934:	e7e2      	b.n	80448fc <HAL_RTC_SetTime+0xa4>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8044936:	4620      	mov	r0, r4
 8044938:	f7ff feea 	bl	8044710 <HAL_RTC_WaitForSynchro>
 804493c:	2800      	cmp	r0, #0
 804493e:	d0d6      	beq.n	80448ee <HAL_RTC_SetTime+0x96>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044940:	6823      	ldr	r3, [r4, #0]
 8044942:	22ff      	movs	r2, #255	; 0xff
 8044944:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8044946:	2304      	movs	r3, #4
 8044948:	7763      	strb	r3, [r4, #29]
        __HAL_UNLOCK(hrtc);
 804494a:	2300      	movs	r3, #0
 804494c:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 804494e:	2701      	movs	r7, #1
 8044950:	e7d4      	b.n	80448fc <HAL_RTC_SetTime+0xa4>
  __HAL_LOCK(hrtc);
 8044952:	2702      	movs	r7, #2
 8044954:	e7d2      	b.n	80448fc <HAL_RTC_SetTime+0xa4>

08044956 <HAL_RTC_SetDate>:
{
 8044956:	b570      	push	{r4, r5, r6, lr}
 __HAL_LOCK(hrtc);
 8044958:	7f03      	ldrb	r3, [r0, #28]
 804495a:	2b01      	cmp	r3, #1
 804495c:	d066      	beq.n	8044a2c <HAL_RTC_SetDate+0xd6>
 804495e:	4604      	mov	r4, r0
 8044960:	460e      	mov	r6, r1
 8044962:	2301      	movs	r3, #1
 8044964:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8044966:	2302      	movs	r3, #2
 8044968:	7743      	strb	r3, [r0, #29]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 804496a:	b93a      	cbnz	r2, 804497c <HAL_RTC_SetDate+0x26>
 804496c:	784b      	ldrb	r3, [r1, #1]
 804496e:	f013 0f10 	tst.w	r3, #16
 8044972:	d003      	beq.n	804497c <HAL_RTC_SetDate+0x26>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8044974:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 8044978:	330a      	adds	r3, #10
 804497a:	704b      	strb	r3, [r1, #1]
  if(Format == RTC_FORMAT_BIN)
 804497c:	2a00      	cmp	r2, #0
 804497e:	d133      	bne.n	80449e8 <HAL_RTC_SetDate+0x92>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 8044980:	78f0      	ldrb	r0, [r6, #3]
 8044982:	f7ff ff5e 	bl	8044842 <RTC_ByteToBcd2>
 8044986:	0405      	lsls	r5, r0, #16
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8044988:	7870      	ldrb	r0, [r6, #1]
 804498a:	f7ff ff5a 	bl	8044842 <RTC_ByteToBcd2>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 804498e:	ea45 2500 	orr.w	r5, r5, r0, lsl #8
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8044992:	78b0      	ldrb	r0, [r6, #2]
 8044994:	f7ff ff55 	bl	8044842 <RTC_ByteToBcd2>
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8U) | \
 8044998:	4305      	orrs	r5, r0
                 ((uint32_t)sDate->WeekDay << 13U));
 804499a:	7830      	ldrb	r0, [r6, #0]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16U) | \
 804499c:	ea45 3540 	orr.w	r5, r5, r0, lsl #13
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80449a0:	6823      	ldr	r3, [r4, #0]
 80449a2:	22ca      	movs	r2, #202	; 0xca
 80449a4:	625a      	str	r2, [r3, #36]	; 0x24
 80449a6:	6823      	ldr	r3, [r4, #0]
 80449a8:	2253      	movs	r2, #83	; 0x53
 80449aa:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80449ac:	4620      	mov	r0, r4
 80449ae:	f7ff fec8 	bl	8044742 <RTC_EnterInitMode>
 80449b2:	4606      	mov	r6, r0
 80449b4:	bb18      	cbnz	r0, 80449fe <HAL_RTC_SetDate+0xa8>
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 80449b6:	6823      	ldr	r3, [r4, #0]
 80449b8:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
 80449bc:	f025 05c0 	bic.w	r5, r5, #192	; 0xc0
 80449c0:	605d      	str	r5, [r3, #4]
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 80449c2:	6822      	ldr	r2, [r4, #0]
 80449c4:	68d3      	ldr	r3, [r2, #12]
 80449c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80449ca:	60d3      	str	r3, [r2, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80449cc:	6823      	ldr	r3, [r4, #0]
 80449ce:	689b      	ldr	r3, [r3, #8]
 80449d0:	f013 0f20 	tst.w	r3, #32
 80449d4:	d01c      	beq.n	8044a10 <HAL_RTC_SetDate+0xba>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80449d6:	6823      	ldr	r3, [r4, #0]
 80449d8:	22ff      	movs	r2, #255	; 0xff
 80449da:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 80449dc:	2301      	movs	r3, #1
 80449de:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 80449e0:	2300      	movs	r3, #0
 80449e2:	7723      	strb	r3, [r4, #28]
}
 80449e4:	4630      	mov	r0, r6
 80449e6:	bd70      	pop	{r4, r5, r6, pc}
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 80449e8:	78f5      	ldrb	r5, [r6, #3]
                  (((uint32_t)sDate->Month) << 8U) | \
 80449ea:	7870      	ldrb	r0, [r6, #1]
 80449ec:	0200      	lsls	r0, r0, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 80449ee:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
                  ((uint32_t)sDate->Date) | \
 80449f2:	78b5      	ldrb	r5, [r6, #2]
                  (((uint32_t)sDate->Month) << 8U) | \
 80449f4:	4328      	orrs	r0, r5
                  (((uint32_t)sDate->WeekDay) << 13U));
 80449f6:	7835      	ldrb	r5, [r6, #0]
    datetmpreg = ((((uint32_t)sDate->Year) << 16U) | \
 80449f8:	ea40 3545 	orr.w	r5, r0, r5, lsl #13
 80449fc:	e7d0      	b.n	80449a0 <HAL_RTC_SetDate+0x4a>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80449fe:	6823      	ldr	r3, [r4, #0]
 8044a00:	22ff      	movs	r2, #255	; 0xff
 8044a02:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8044a04:	2304      	movs	r3, #4
 8044a06:	7763      	strb	r3, [r4, #29]
    __HAL_UNLOCK(hrtc);
 8044a08:	2300      	movs	r3, #0
 8044a0a:	7723      	strb	r3, [r4, #28]
    return HAL_ERROR;
 8044a0c:	2601      	movs	r6, #1
 8044a0e:	e7e9      	b.n	80449e4 <HAL_RTC_SetDate+0x8e>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8044a10:	4620      	mov	r0, r4
 8044a12:	f7ff fe7d 	bl	8044710 <HAL_RTC_WaitForSynchro>
 8044a16:	2800      	cmp	r0, #0
 8044a18:	d0dd      	beq.n	80449d6 <HAL_RTC_SetDate+0x80>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044a1a:	6823      	ldr	r3, [r4, #0]
 8044a1c:	22ff      	movs	r2, #255	; 0xff
 8044a1e:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8044a20:	2304      	movs	r3, #4
 8044a22:	7763      	strb	r3, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044a24:	2300      	movs	r3, #0
 8044a26:	7723      	strb	r3, [r4, #28]
        return HAL_ERROR;
 8044a28:	2601      	movs	r6, #1
 8044a2a:	e7db      	b.n	80449e4 <HAL_RTC_SetDate+0x8e>
 __HAL_LOCK(hrtc);
 8044a2c:	2602      	movs	r6, #2
 8044a2e:	e7d9      	b.n	80449e4 <HAL_RTC_SetDate+0x8e>

08044a30 <HAL_RTC_SetAlarm_IT>:
{
 8044a30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8044a32:	b083      	sub	sp, #12
 8044a34:	460d      	mov	r5, r1
  __IO uint32_t count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U) ;
 8044a36:	4b63      	ldr	r3, [pc, #396]	; (8044bc4 <HAL_RTC_SetAlarm_IT+0x194>)
 8044a38:	681b      	ldr	r3, [r3, #0]
 8044a3a:	4963      	ldr	r1, [pc, #396]	; (8044bc8 <HAL_RTC_SetAlarm_IT+0x198>)
 8044a3c:	fba1 1303 	umull	r1, r3, r1, r3
 8044a40:	0adb      	lsrs	r3, r3, #11
 8044a42:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8044a46:	fb01 f303 	mul.w	r3, r1, r3
 8044a4a:	9301      	str	r3, [sp, #4]
  __HAL_LOCK(hrtc);
 8044a4c:	7f03      	ldrb	r3, [r0, #28]
 8044a4e:	2b01      	cmp	r3, #1
 8044a50:	f000 80b5 	beq.w	8044bbe <HAL_RTC_SetAlarm_IT+0x18e>
 8044a54:	4604      	mov	r4, r0
 8044a56:	2301      	movs	r3, #1
 8044a58:	7703      	strb	r3, [r0, #28]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8044a5a:	2302      	movs	r3, #2
 8044a5c:	7743      	strb	r3, [r0, #29]
  if(Format == RTC_FORMAT_BIN)
 8044a5e:	2a00      	cmp	r2, #0
 8044a60:	d161      	bne.n	8044b26 <HAL_RTC_SetAlarm_IT+0xf6>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044a62:	6803      	ldr	r3, [r0, #0]
 8044a64:	689b      	ldr	r3, [r3, #8]
 8044a66:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044a6a:	d101      	bne.n	8044a70 <HAL_RTC_SetAlarm_IT+0x40>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 8044a6c:	2300      	movs	r3, #0
 8044a6e:	70eb      	strb	r3, [r5, #3]
    if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 8044a70:	69ef      	ldr	r7, [r5, #28]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044a72:	7828      	ldrb	r0, [r5, #0]
 8044a74:	f7ff fee5 	bl	8044842 <RTC_ByteToBcd2>
 8044a78:	0406      	lsls	r6, r0, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044a7a:	7868      	ldrb	r0, [r5, #1]
 8044a7c:	f7ff fee1 	bl	8044842 <RTC_ByteToBcd2>
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044a80:	ea46 2600 	orr.w	r6, r6, r0, lsl #8
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8044a84:	78a8      	ldrb	r0, [r5, #2]
 8044a86:	f7ff fedc 	bl	8044842 <RTC_ByteToBcd2>
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044a8a:	4306      	orrs	r6, r0
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044a8c:	78e8      	ldrb	r0, [r5, #3]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8044a8e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044a92:	f895 0020 	ldrb.w	r0, [r5, #32]
 8044a96:	f7ff fed4 	bl	8044842 <RTC_ByteToBcd2>
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044a9a:	ea46 6600 	orr.w	r6, r6, r0, lsl #24
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044a9e:	433e      	orrs	r6, r7
              ((uint32_t)sAlarm->AlarmMask));
 8044aa0:	696b      	ldr	r3, [r5, #20]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16U) | \
 8044aa2:	431e      	orrs	r6, r3
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8044aa4:	6868      	ldr	r0, [r5, #4]
 8044aa6:	69ab      	ldr	r3, [r5, #24]
 8044aa8:	4318      	orrs	r0, r3
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8044aaa:	6823      	ldr	r3, [r4, #0]
 8044aac:	22ca      	movs	r2, #202	; 0xca
 8044aae:	625a      	str	r2, [r3, #36]	; 0x24
 8044ab0:	6823      	ldr	r3, [r4, #0]
 8044ab2:	2253      	movs	r2, #83	; 0x53
 8044ab4:	625a      	str	r2, [r3, #36]	; 0x24
  if(sAlarm->Alarm == RTC_ALARM_A)
 8044ab6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8044ab8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8044abc:	d04d      	beq.n	8044b5a <HAL_RTC_SetAlarm_IT+0x12a>
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8044abe:	6822      	ldr	r2, [r4, #0]
 8044ac0:	6893      	ldr	r3, [r2, #8]
 8044ac2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8044ac6:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8044ac8:	6822      	ldr	r2, [r4, #0]
 8044aca:	68d3      	ldr	r3, [r2, #12]
 8044acc:	b2db      	uxtb	r3, r3
 8044ace:	f463 7320 	orn	r3, r3, #640	; 0x280
 8044ad2:	60d3      	str	r3, [r2, #12]
      if (count-- == 0U)
 8044ad4:	9b01      	ldr	r3, [sp, #4]
 8044ad6:	1e5a      	subs	r2, r3, #1
 8044ad8:	9201      	str	r2, [sp, #4]
 8044ada:	2b00      	cmp	r3, #0
 8044adc:	d067      	beq.n	8044bae <HAL_RTC_SetAlarm_IT+0x17e>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET);
 8044ade:	6823      	ldr	r3, [r4, #0]
 8044ae0:	68da      	ldr	r2, [r3, #12]
 8044ae2:	f012 0f02 	tst.w	r2, #2
 8044ae6:	d0f5      	beq.n	8044ad4 <HAL_RTC_SetAlarm_IT+0xa4>
    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8044ae8:	621e      	str	r6, [r3, #32]
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8044aea:	6823      	ldr	r3, [r4, #0]
 8044aec:	6498      	str	r0, [r3, #72]	; 0x48
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8044aee:	6822      	ldr	r2, [r4, #0]
 8044af0:	6893      	ldr	r3, [r2, #8]
 8044af2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8044af6:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8044af8:	6822      	ldr	r2, [r4, #0]
 8044afa:	6893      	ldr	r3, [r2, #8]
 8044afc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8044b00:	6093      	str	r3, [r2, #8]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8044b02:	4b32      	ldr	r3, [pc, #200]	; (8044bcc <HAL_RTC_SetAlarm_IT+0x19c>)
 8044b04:	681a      	ldr	r2, [r3, #0]
 8044b06:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8044b0a:	601a      	str	r2, [r3, #0]
  EXTI->RTSR |= RTC_EXTI_LINE_ALARM_EVENT;
 8044b0c:	689a      	ldr	r2, [r3, #8]
 8044b0e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8044b12:	609a      	str	r2, [r3, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044b14:	6823      	ldr	r3, [r4, #0]
 8044b16:	22ff      	movs	r2, #255	; 0xff
 8044b18:	625a      	str	r2, [r3, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8044b1a:	2301      	movs	r3, #1
 8044b1c:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hrtc);
 8044b1e:	2000      	movs	r0, #0
 8044b20:	7720      	strb	r0, [r4, #28]
}
 8044b22:	b003      	add	sp, #12
 8044b24:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8044b26:	6803      	ldr	r3, [r0, #0]
 8044b28:	689b      	ldr	r3, [r3, #8]
 8044b2a:	f013 0f40 	tst.w	r3, #64	; 0x40
 8044b2e:	d101      	bne.n	8044b34 <HAL_RTC_SetAlarm_IT+0x104>
      sAlarm->AlarmTime.TimeFormat = 0x00U;
 8044b30:	2300      	movs	r3, #0
 8044b32:	70eb      	strb	r3, [r5, #3]
    if(sAlarm->AlarmDateWeekDaySel == RTC_ALARMDATEWEEKDAYSEL_DATE)
 8044b34:	69ea      	ldr	r2, [r5, #28]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b36:	7829      	ldrb	r1, [r5, #0]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044b38:	786b      	ldrb	r3, [r5, #1]
 8044b3a:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b3c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8044b40:	78a9      	ldrb	r1, [r5, #2]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8U) | \
 8044b42:	430b      	orrs	r3, r1
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044b44:	78e9      	ldrb	r1, [r5, #3]
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8044b46:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044b4a:	f895 1020 	ldrb.w	r1, [r5, #32]
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16U) | \
 8044b4e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24U) | \
 8044b52:	4313      	orrs	r3, r2
              ((uint32_t)sAlarm->AlarmMask));
 8044b54:	696e      	ldr	r6, [r5, #20]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16U) | \
 8044b56:	431e      	orrs	r6, r3
 8044b58:	e7a4      	b.n	8044aa4 <HAL_RTC_SetAlarm_IT+0x74>
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8044b5a:	6822      	ldr	r2, [r4, #0]
 8044b5c:	6893      	ldr	r3, [r2, #8]
 8044b5e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8044b62:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8044b64:	6822      	ldr	r2, [r4, #0]
 8044b66:	68d3      	ldr	r3, [r2, #12]
 8044b68:	b2db      	uxtb	r3, r3
 8044b6a:	f463 73c0 	orn	r3, r3, #384	; 0x180
 8044b6e:	60d3      	str	r3, [r2, #12]
      if (count-- == 0U)
 8044b70:	9b01      	ldr	r3, [sp, #4]
 8044b72:	1e5a      	subs	r2, r3, #1
 8044b74:	9201      	str	r2, [sp, #4]
 8044b76:	b193      	cbz	r3, 8044b9e <HAL_RTC_SetAlarm_IT+0x16e>
    while (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET);
 8044b78:	6823      	ldr	r3, [r4, #0]
 8044b7a:	68d9      	ldr	r1, [r3, #12]
 8044b7c:	f011 0f01 	tst.w	r1, #1
 8044b80:	d0f6      	beq.n	8044b70 <HAL_RTC_SetAlarm_IT+0x140>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8044b82:	61de      	str	r6, [r3, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8044b84:	6823      	ldr	r3, [r4, #0]
 8044b86:	6458      	str	r0, [r3, #68]	; 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8044b88:	6822      	ldr	r2, [r4, #0]
 8044b8a:	6893      	ldr	r3, [r2, #8]
 8044b8c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8044b90:	6093      	str	r3, [r2, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
 8044b92:	6822      	ldr	r2, [r4, #0]
 8044b94:	6893      	ldr	r3, [r2, #8]
 8044b96:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8044b9a:	6093      	str	r3, [r2, #8]
 8044b9c:	e7b1      	b.n	8044b02 <HAL_RTC_SetAlarm_IT+0xd2>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044b9e:	6823      	ldr	r3, [r4, #0]
 8044ba0:	22ff      	movs	r2, #255	; 0xff
 8044ba2:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044ba4:	2003      	movs	r0, #3
 8044ba6:	7760      	strb	r0, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044ba8:	2300      	movs	r3, #0
 8044baa:	7723      	strb	r3, [r4, #28]
        return HAL_TIMEOUT;
 8044bac:	e7b9      	b.n	8044b22 <HAL_RTC_SetAlarm_IT+0xf2>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044bae:	6823      	ldr	r3, [r4, #0]
 8044bb0:	22ff      	movs	r2, #255	; 0xff
 8044bb2:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044bb4:	2003      	movs	r0, #3
 8044bb6:	7760      	strb	r0, [r4, #29]
        __HAL_UNLOCK(hrtc);
 8044bb8:	2300      	movs	r3, #0
 8044bba:	7723      	strb	r3, [r4, #28]
        return HAL_TIMEOUT;
 8044bbc:	e7b1      	b.n	8044b22 <HAL_RTC_SetAlarm_IT+0xf2>
  __HAL_LOCK(hrtc);
 8044bbe:	2002      	movs	r0, #2
 8044bc0:	e7af      	b.n	8044b22 <HAL_RTC_SetAlarm_IT+0xf2>
 8044bc2:	bf00      	nop
 8044bc4:	20003874 	.word	0x20003874
 8044bc8:	10624dd3 	.word	0x10624dd3
 8044bcc:	40013c00 	.word	0x40013c00

08044bd0 <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0U;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8044bd0:	0903      	lsrs	r3, r0, #4
 8044bd2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8044bd6:	f000 000f 	and.w	r0, r0, #15
 8044bda:	eb00 0043 	add.w	r0, r0, r3, lsl #1
}
 8044bde:	b2c0      	uxtb	r0, r0
 8044be0:	4770      	bx	lr

08044be2 <HAL_RTC_GetTime>:
{
 8044be2:	b570      	push	{r4, r5, r6, lr}
 8044be4:	460c      	mov	r4, r1
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8044be6:	6803      	ldr	r3, [r0, #0]
 8044be8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8044bea:	604b      	str	r3, [r1, #4]
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8044bec:	6803      	ldr	r3, [r0, #0]
 8044bee:	691b      	ldr	r3, [r3, #16]
 8044bf0:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8044bf4:	608b      	str	r3, [r1, #8]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8044bf6:	6803      	ldr	r3, [r0, #0]
 8044bf8:	681d      	ldr	r5, [r3, #0]
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
 8044bfa:	f3c5 4106 	ubfx	r1, r5, #16, #7
 8044bfe:	f3c5 4005 	ubfx	r0, r5, #16, #6
 8044c02:	7020      	strb	r0, [r4, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
 8044c04:	f3c5 2606 	ubfx	r6, r5, #8, #7
 8044c08:	7066      	strb	r6, [r4, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8044c0a:	f005 057f 	and.w	r5, r5, #127	; 0x7f
 8044c0e:	70a5      	strb	r5, [r4, #2]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16U);
 8044c10:	f001 0340 	and.w	r3, r1, #64	; 0x40
 8044c14:	70e3      	strb	r3, [r4, #3]
  if(Format == RTC_FORMAT_BIN)
 8044c16:	b952      	cbnz	r2, 8044c2e <HAL_RTC_GetTime+0x4c>
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8044c18:	f7ff ffda 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c1c:	7020      	strb	r0, [r4, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8044c1e:	4630      	mov	r0, r6
 8044c20:	f7ff ffd6 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c24:	7060      	strb	r0, [r4, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8044c26:	4628      	mov	r0, r5
 8044c28:	f7ff ffd2 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c2c:	70a0      	strb	r0, [r4, #2]
}
 8044c2e:	2000      	movs	r0, #0
 8044c30:	bd70      	pop	{r4, r5, r6, pc}

08044c32 <HAL_RTC_GetDate>:
{
 8044c32:	b570      	push	{r4, r5, r6, lr}
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8044c34:	6803      	ldr	r3, [r0, #0]
 8044c36:	685b      	ldr	r3, [r3, #4]
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16U);
 8044c38:	f3c3 4007 	ubfx	r0, r3, #16, #8
 8044c3c:	70c8      	strb	r0, [r1, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
 8044c3e:	f3c3 2604 	ubfx	r6, r3, #8, #5
 8044c42:	704e      	strb	r6, [r1, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8044c44:	f003 053f 	and.w	r5, r3, #63	; 0x3f
 8044c48:	708d      	strb	r5, [r1, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13U);
 8044c4a:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8044c4e:	700b      	strb	r3, [r1, #0]
  if(Format == RTC_FORMAT_BIN)
 8044c50:	b95a      	cbnz	r2, 8044c6a <HAL_RTC_GetDate+0x38>
 8044c52:	460c      	mov	r4, r1
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8044c54:	f7ff ffbc 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c58:	70e0      	strb	r0, [r4, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8044c5a:	4630      	mov	r0, r6
 8044c5c:	f7ff ffb8 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c60:	7060      	strb	r0, [r4, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8044c62:	4628      	mov	r0, r5
 8044c64:	f7ff ffb4 	bl	8044bd0 <RTC_Bcd2ToByte>
 8044c68:	70a0      	strb	r0, [r4, #2]
}
 8044c6a:	2000      	movs	r0, #0
 8044c6c:	bd70      	pop	{r4, r5, r6, pc}
	...

08044c70 <HAL_RTCEx_SetWakeUpTimer_IT>:
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
  assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8044c70:	7f03      	ldrb	r3, [r0, #28]
 8044c72:	2b01      	cmp	r3, #1
 8044c74:	d07c      	beq.n	8044d70 <HAL_RTCEx_SetWakeUpTimer_IT+0x100>
{
 8044c76:	b430      	push	{r4, r5}
 8044c78:	b082      	sub	sp, #8
  __HAL_LOCK(hrtc);
 8044c7a:	2301      	movs	r3, #1
 8044c7c:	7703      	strb	r3, [r0, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8044c7e:	2302      	movs	r3, #2
 8044c80:	7743      	strb	r3, [r0, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8044c82:	6803      	ldr	r3, [r0, #0]
 8044c84:	24ca      	movs	r4, #202	; 0xca
 8044c86:	625c      	str	r4, [r3, #36]	; 0x24
 8044c88:	6803      	ldr	r3, [r0, #0]
 8044c8a:	2453      	movs	r4, #83	; 0x53
 8044c8c:	625c      	str	r4, [r3, #36]	; 0x24

  /* Check RTC WUTWF flag is reset only when wake up timer enabled */
  if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET)
 8044c8e:	6805      	ldr	r5, [r0, #0]
 8044c90:	68ab      	ldr	r3, [r5, #8]
 8044c92:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8044c96:	d013      	beq.n	8044cc0 <HAL_RTCEx_SetWakeUpTimer_IT+0x50>
  {
    /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
    count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
 8044c98:	4b36      	ldr	r3, [pc, #216]	; (8044d74 <HAL_RTCEx_SetWakeUpTimer_IT+0x104>)
 8044c9a:	681b      	ldr	r3, [r3, #0]
 8044c9c:	4c36      	ldr	r4, [pc, #216]	; (8044d78 <HAL_RTCEx_SetWakeUpTimer_IT+0x108>)
 8044c9e:	fba4 4303 	umull	r4, r3, r4, r3
 8044ca2:	0adb      	lsrs	r3, r3, #11
 8044ca4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8044ca8:	fb04 f303 	mul.w	r3, r4, r3
 8044cac:	9301      	str	r3, [sp, #4]
    do
    {
      if(count-- == 0U)
 8044cae:	9b01      	ldr	r3, [sp, #4]
 8044cb0:	1e5c      	subs	r4, r3, #1
 8044cb2:	9401      	str	r4, [sp, #4]
 8044cb4:	2b00      	cmp	r3, #0
 8044cb6:	d048      	beq.n	8044d4a <HAL_RTCEx_SetWakeUpTimer_IT+0xda>
        __HAL_UNLOCK(hrtc);

        return HAL_TIMEOUT;
      }
    }
    while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET);
 8044cb8:	68eb      	ldr	r3, [r5, #12]
 8044cba:	f013 0f04 	tst.w	r3, #4
 8044cbe:	d1f6      	bne.n	8044cae <HAL_RTCEx_SetWakeUpTimer_IT+0x3e>
  }

  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8044cc0:	68ab      	ldr	r3, [r5, #8]
 8044cc2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8044cc6:	60ab      	str	r3, [r5, #8]

  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  count = RTC_TIMEOUT_VALUE  * (SystemCoreClock / 32U / 1000U);
 8044cc8:	4b2a      	ldr	r3, [pc, #168]	; (8044d74 <HAL_RTCEx_SetWakeUpTimer_IT+0x104>)
 8044cca:	681b      	ldr	r3, [r3, #0]
 8044ccc:	4c2a      	ldr	r4, [pc, #168]	; (8044d78 <HAL_RTCEx_SetWakeUpTimer_IT+0x108>)
 8044cce:	fba4 4303 	umull	r4, r3, r4, r3
 8044cd2:	0adb      	lsrs	r3, r3, #11
 8044cd4:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8044cd8:	fb04 f303 	mul.w	r3, r4, r3
 8044cdc:	9301      	str	r3, [sp, #4]
  do
  {
    if(count-- == 0U)
 8044cde:	9b01      	ldr	r3, [sp, #4]
 8044ce0:	1e5c      	subs	r4, r3, #1
 8044ce2:	9401      	str	r4, [sp, #4]
 8044ce4:	2b00      	cmp	r3, #0
 8044ce6:	d038      	beq.n	8044d5a <HAL_RTCEx_SetWakeUpTimer_IT+0xea>
      __HAL_UNLOCK(hrtc);

      return HAL_TIMEOUT;
    }
  }
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET);
 8044ce8:	6803      	ldr	r3, [r0, #0]
 8044cea:	68dc      	ldr	r4, [r3, #12]
 8044cec:	f014 0f04 	tst.w	r4, #4
 8044cf0:	d0f5      	beq.n	8044cde <HAL_RTCEx_SetWakeUpTimer_IT+0x6e>

  /* Configure the Wake-up Timer counter */
  hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
 8044cf2:	6159      	str	r1, [r3, #20]

  /* Clear the Wake-up Timer clock source bits in CR register */
  hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 8044cf4:	6801      	ldr	r1, [r0, #0]
 8044cf6:	688b      	ldr	r3, [r1, #8]
 8044cf8:	f023 0307 	bic.w	r3, r3, #7
 8044cfc:	608b      	str	r3, [r1, #8]

  /* Configure the clock source */
  hrtc->Instance->CR |= (uint32_t)WakeUpClock;
 8044cfe:	6801      	ldr	r1, [r0, #0]
 8044d00:	688b      	ldr	r3, [r1, #8]
 8044d02:	431a      	orrs	r2, r3
 8044d04:	608a      	str	r2, [r1, #8]

  /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
  __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
 8044d06:	4b1d      	ldr	r3, [pc, #116]	; (8044d7c <HAL_RTCEx_SetWakeUpTimer_IT+0x10c>)
 8044d08:	681a      	ldr	r2, [r3, #0]
 8044d0a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8044d0e:	601a      	str	r2, [r3, #0]

  EXTI->RTSR |= RTC_EXTI_LINE_WAKEUPTIMER_EVENT;
 8044d10:	689a      	ldr	r2, [r3, #8]
 8044d12:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8044d16:	609a      	str	r2, [r3, #8]

  /* Clear RTC Wake Up timer Flag */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8044d18:	6802      	ldr	r2, [r0, #0]
 8044d1a:	68d3      	ldr	r3, [r2, #12]
 8044d1c:	b2db      	uxtb	r3, r3
 8044d1e:	f463 6390 	orn	r3, r3, #1152	; 0x480
 8044d22:	60d3      	str	r3, [r2, #12]

  /* Configure the Interrupt in the RTC_CR register */
  __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
 8044d24:	6802      	ldr	r2, [r0, #0]
 8044d26:	6893      	ldr	r3, [r2, #8]
 8044d28:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8044d2c:	6093      	str	r3, [r2, #8]

  /* Enable the Wake-up Timer */
  __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
 8044d2e:	6802      	ldr	r2, [r0, #0]
 8044d30:	6893      	ldr	r3, [r2, #8]
 8044d32:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8044d36:	6093      	str	r3, [r2, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d38:	6803      	ldr	r3, [r0, #0]
 8044d3a:	22ff      	movs	r2, #255	; 0xff
 8044d3c:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8044d3e:	2301      	movs	r3, #1
 8044d40:	7743      	strb	r3, [r0, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8044d42:	2300      	movs	r3, #0
 8044d44:	7703      	strb	r3, [r0, #28]

  return HAL_OK;
 8044d46:	4618      	mov	r0, r3
 8044d48:	e00f      	b.n	8044d6a <HAL_RTCEx_SetWakeUpTimer_IT+0xfa>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d4a:	23ff      	movs	r3, #255	; 0xff
 8044d4c:	626b      	str	r3, [r5, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044d4e:	2303      	movs	r3, #3
 8044d50:	7743      	strb	r3, [r0, #29]
        __HAL_UNLOCK(hrtc);
 8044d52:	2200      	movs	r2, #0
 8044d54:	7702      	strb	r2, [r0, #28]
        return HAL_TIMEOUT;
 8044d56:	4618      	mov	r0, r3
 8044d58:	e007      	b.n	8044d6a <HAL_RTCEx_SetWakeUpTimer_IT+0xfa>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8044d5a:	6803      	ldr	r3, [r0, #0]
 8044d5c:	22ff      	movs	r2, #255	; 0xff
 8044d5e:	625a      	str	r2, [r3, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8044d60:	2303      	movs	r3, #3
 8044d62:	7743      	strb	r3, [r0, #29]
      __HAL_UNLOCK(hrtc);
 8044d64:	2200      	movs	r2, #0
 8044d66:	7702      	strb	r2, [r0, #28]
      return HAL_TIMEOUT;
 8044d68:	4618      	mov	r0, r3
}
 8044d6a:	b002      	add	sp, #8
 8044d6c:	bc30      	pop	{r4, r5}
 8044d6e:	4770      	bx	lr
  __HAL_LOCK(hrtc);
 8044d70:	2002      	movs	r0, #2
}
 8044d72:	4770      	bx	lr
 8044d74:	20003874 	.word	0x20003874
 8044d78:	10624dd3 	.word	0x10624dd3
 8044d7c:	40013c00 	.word	0x40013c00

08044d80 <HAL_RTCEx_WakeUpTimerIRQHandler>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval None
  */
void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8044d80:	b510      	push	{r4, lr}
 8044d82:	4604      	mov	r4, r0
  if(__HAL_RTC_WAKEUPTIMER_GET_IT(hrtc, RTC_IT_WUT))
 8044d84:	6803      	ldr	r3, [r0, #0]
 8044d86:	68da      	ldr	r2, [r3, #12]
 8044d88:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8044d8c:	d003      	beq.n	8044d96 <HAL_RTCEx_WakeUpTimerIRQHandler+0x16>
  {
    /* Get the status of the Interrupt */
    if((uint32_t)(hrtc->Instance->CR & RTC_IT_WUT) != (uint32_t)RESET)
 8044d8e:	689b      	ldr	r3, [r3, #8]
 8044d90:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 8044d94:	d106      	bne.n	8044da4 <HAL_RTCEx_WakeUpTimerIRQHandler+0x24>
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
    }
  }

  /* Clear the EXTI's line Flag for RTC WakeUpTimer */
  __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
 8044d96:	4b08      	ldr	r3, [pc, #32]	; (8044db8 <HAL_RTCEx_WakeUpTimerIRQHandler+0x38>)
 8044d98:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8044d9c:	615a      	str	r2, [r3, #20]

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8044d9e:	2301      	movs	r3, #1
 8044da0:	7763      	strb	r3, [r4, #29]
}
 8044da2:	bd10      	pop	{r4, pc}
      HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
 8044da4:	f00b fd9a 	bl	80508dc <HAL_RTCEx_WakeUpTimerEventCallback>
      __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
 8044da8:	6822      	ldr	r2, [r4, #0]
 8044daa:	68d3      	ldr	r3, [r2, #12]
 8044dac:	b2db      	uxtb	r3, r3
 8044dae:	f463 6390 	orn	r3, r3, #1152	; 0x480
 8044db2:	60d3      	str	r3, [r2, #12]
 8044db4:	e7ef      	b.n	8044d96 <HAL_RTCEx_WakeUpTimerIRQHandler+0x16>
 8044db6:	bf00      	nop
 8044db8:	40013c00 	.word	0x40013c00

08044dbc <HAL_RTCEx_BKUPRead>:
  uint32_t tmp = 0U;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t)&(hrtc->Instance->BKP0R);
 8044dbc:	6803      	ldr	r3, [r0, #0]
 8044dbe:	3350      	adds	r3, #80	; 0x50
  tmp += (BackupRegister * 4U);

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8044dc0:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
}
 8044dc4:	4770      	bx	lr

08044dc6 <HAL_RTCEx_AlarmBEventCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrtc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RTC_AlarmBEventCallback could be implemented in the user file
   */
}
 8044dc6:	4770      	bx	lr

08044dc8 <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8044dc8:	6802      	ldr	r2, [r0, #0]
 8044dca:	68d3      	ldr	r3, [r2, #12]
 8044dcc:	f043 0301 	orr.w	r3, r3, #1
 8044dd0:	60d3      	str	r3, [r2, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8044dd2:	6802      	ldr	r2, [r0, #0]
 8044dd4:	6893      	ldr	r3, [r2, #8]
 8044dd6:	f003 0307 	and.w	r3, r3, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8044dda:	2b06      	cmp	r3, #6
 8044ddc:	d003      	beq.n	8044de6 <HAL_TIM_Base_Start_IT+0x1e>
  {
    __HAL_TIM_ENABLE(htim);
 8044dde:	6813      	ldr	r3, [r2, #0]
 8044de0:	f043 0301 	orr.w	r3, r3, #1
 8044de4:	6013      	str	r3, [r2, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8044de6:	2000      	movs	r0, #0
 8044de8:	4770      	bx	lr

08044dea <HAL_TIM_OC_DelayElapsedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8044dea:	4770      	bx	lr

08044dec <HAL_TIM_IC_CaptureCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8044dec:	4770      	bx	lr

08044dee <HAL_TIM_PWM_PulseFinishedCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8044dee:	4770      	bx	lr

08044df0 <HAL_TIM_TriggerCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8044df0:	4770      	bx	lr

08044df2 <HAL_TIM_IRQHandler>:
{
 8044df2:	b510      	push	{r4, lr}
 8044df4:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8044df6:	6803      	ldr	r3, [r0, #0]
 8044df8:	691a      	ldr	r2, [r3, #16]
 8044dfa:	f012 0f02 	tst.w	r2, #2
 8044dfe:	d011      	beq.n	8044e24 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8044e00:	68da      	ldr	r2, [r3, #12]
 8044e02:	f012 0f02 	tst.w	r2, #2
 8044e06:	d00d      	beq.n	8044e24 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8044e08:	f06f 0202 	mvn.w	r2, #2
 8044e0c:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8044e0e:	2301      	movs	r3, #1
 8044e10:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8044e12:	6803      	ldr	r3, [r0, #0]
 8044e14:	699b      	ldr	r3, [r3, #24]
 8044e16:	f013 0f03 	tst.w	r3, #3
 8044e1a:	d070      	beq.n	8044efe <HAL_TIM_IRQHandler+0x10c>
          HAL_TIM_IC_CaptureCallback(htim);
 8044e1c:	f7ff ffe6 	bl	8044dec <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044e20:	2300      	movs	r3, #0
 8044e22:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8044e24:	6823      	ldr	r3, [r4, #0]
 8044e26:	691a      	ldr	r2, [r3, #16]
 8044e28:	f012 0f04 	tst.w	r2, #4
 8044e2c:	d012      	beq.n	8044e54 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8044e2e:	68da      	ldr	r2, [r3, #12]
 8044e30:	f012 0f04 	tst.w	r2, #4
 8044e34:	d00e      	beq.n	8044e54 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8044e36:	f06f 0204 	mvn.w	r2, #4
 8044e3a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8044e3c:	2302      	movs	r3, #2
 8044e3e:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8044e40:	6823      	ldr	r3, [r4, #0]
 8044e42:	699b      	ldr	r3, [r3, #24]
 8044e44:	f413 7f40 	tst.w	r3, #768	; 0x300
 8044e48:	d05f      	beq.n	8044f0a <HAL_TIM_IRQHandler+0x118>
        HAL_TIM_IC_CaptureCallback(htim);
 8044e4a:	4620      	mov	r0, r4
 8044e4c:	f7ff ffce 	bl	8044dec <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044e50:	2300      	movs	r3, #0
 8044e52:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8044e54:	6823      	ldr	r3, [r4, #0]
 8044e56:	691a      	ldr	r2, [r3, #16]
 8044e58:	f012 0f08 	tst.w	r2, #8
 8044e5c:	d012      	beq.n	8044e84 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8044e5e:	68da      	ldr	r2, [r3, #12]
 8044e60:	f012 0f08 	tst.w	r2, #8
 8044e64:	d00e      	beq.n	8044e84 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8044e66:	f06f 0208 	mvn.w	r2, #8
 8044e6a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8044e6c:	2304      	movs	r3, #4
 8044e6e:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8044e70:	6823      	ldr	r3, [r4, #0]
 8044e72:	69db      	ldr	r3, [r3, #28]
 8044e74:	f013 0f03 	tst.w	r3, #3
 8044e78:	d04e      	beq.n	8044f18 <HAL_TIM_IRQHandler+0x126>
        HAL_TIM_IC_CaptureCallback(htim);
 8044e7a:	4620      	mov	r0, r4
 8044e7c:	f7ff ffb6 	bl	8044dec <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044e80:	2300      	movs	r3, #0
 8044e82:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8044e84:	6823      	ldr	r3, [r4, #0]
 8044e86:	691a      	ldr	r2, [r3, #16]
 8044e88:	f012 0f10 	tst.w	r2, #16
 8044e8c:	d012      	beq.n	8044eb4 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8044e8e:	68da      	ldr	r2, [r3, #12]
 8044e90:	f012 0f10 	tst.w	r2, #16
 8044e94:	d00e      	beq.n	8044eb4 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8044e96:	f06f 0210 	mvn.w	r2, #16
 8044e9a:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8044e9c:	2308      	movs	r3, #8
 8044e9e:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8044ea0:	6823      	ldr	r3, [r4, #0]
 8044ea2:	69db      	ldr	r3, [r3, #28]
 8044ea4:	f413 7f40 	tst.w	r3, #768	; 0x300
 8044ea8:	d03d      	beq.n	8044f26 <HAL_TIM_IRQHandler+0x134>
        HAL_TIM_IC_CaptureCallback(htim);
 8044eaa:	4620      	mov	r0, r4
 8044eac:	f7ff ff9e 	bl	8044dec <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8044eb0:	2300      	movs	r3, #0
 8044eb2:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8044eb4:	6823      	ldr	r3, [r4, #0]
 8044eb6:	691a      	ldr	r2, [r3, #16]
 8044eb8:	f012 0f01 	tst.w	r2, #1
 8044ebc:	d003      	beq.n	8044ec6 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8044ebe:	68da      	ldr	r2, [r3, #12]
 8044ec0:	f012 0f01 	tst.w	r2, #1
 8044ec4:	d136      	bne.n	8044f34 <HAL_TIM_IRQHandler+0x142>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8044ec6:	6823      	ldr	r3, [r4, #0]
 8044ec8:	691a      	ldr	r2, [r3, #16]
 8044eca:	f012 0f80 	tst.w	r2, #128	; 0x80
 8044ece:	d003      	beq.n	8044ed8 <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8044ed0:	68da      	ldr	r2, [r3, #12]
 8044ed2:	f012 0f80 	tst.w	r2, #128	; 0x80
 8044ed6:	d134      	bne.n	8044f42 <HAL_TIM_IRQHandler+0x150>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8044ed8:	6823      	ldr	r3, [r4, #0]
 8044eda:	691a      	ldr	r2, [r3, #16]
 8044edc:	f012 0f40 	tst.w	r2, #64	; 0x40
 8044ee0:	d003      	beq.n	8044eea <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8044ee2:	68da      	ldr	r2, [r3, #12]
 8044ee4:	f012 0f40 	tst.w	r2, #64	; 0x40
 8044ee8:	d132      	bne.n	8044f50 <HAL_TIM_IRQHandler+0x15e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8044eea:	6823      	ldr	r3, [r4, #0]
 8044eec:	691a      	ldr	r2, [r3, #16]
 8044eee:	f012 0f20 	tst.w	r2, #32
 8044ef2:	d003      	beq.n	8044efc <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8044ef4:	68da      	ldr	r2, [r3, #12]
 8044ef6:	f012 0f20 	tst.w	r2, #32
 8044efa:	d130      	bne.n	8044f5e <HAL_TIM_IRQHandler+0x16c>
}
 8044efc:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8044efe:	f7ff ff74 	bl	8044dea <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f02:	4620      	mov	r0, r4
 8044f04:	f7ff ff73 	bl	8044dee <HAL_TIM_PWM_PulseFinishedCallback>
 8044f08:	e78a      	b.n	8044e20 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f0a:	4620      	mov	r0, r4
 8044f0c:	f7ff ff6d 	bl	8044dea <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f10:	4620      	mov	r0, r4
 8044f12:	f7ff ff6c 	bl	8044dee <HAL_TIM_PWM_PulseFinishedCallback>
 8044f16:	e79b      	b.n	8044e50 <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f18:	4620      	mov	r0, r4
 8044f1a:	f7ff ff66 	bl	8044dea <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f1e:	4620      	mov	r0, r4
 8044f20:	f7ff ff65 	bl	8044dee <HAL_TIM_PWM_PulseFinishedCallback>
 8044f24:	e7ac      	b.n	8044e80 <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8044f26:	4620      	mov	r0, r4
 8044f28:	f7ff ff5f 	bl	8044dea <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8044f2c:	4620      	mov	r0, r4
 8044f2e:	f7ff ff5e 	bl	8044dee <HAL_TIM_PWM_PulseFinishedCallback>
 8044f32:	e7bd      	b.n	8044eb0 <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8044f34:	f06f 0201 	mvn.w	r2, #1
 8044f38:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8044f3a:	4620      	mov	r0, r4
 8044f3c:	f00b fd8a 	bl	8050a54 <HAL_TIM_PeriodElapsedCallback>
 8044f40:	e7c1      	b.n	8044ec6 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8044f42:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8044f46:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8044f48:	4620      	mov	r0, r4
 8044f4a:	f000 f8b1 	bl	80450b0 <HAL_TIMEx_BreakCallback>
 8044f4e:	e7c3      	b.n	8044ed8 <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8044f50:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8044f54:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8044f56:	4620      	mov	r0, r4
 8044f58:	f7ff ff4a 	bl	8044df0 <HAL_TIM_TriggerCallback>
 8044f5c:	e7c5      	b.n	8044eea <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8044f5e:	f06f 0220 	mvn.w	r2, #32
 8044f62:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8044f64:	4620      	mov	r0, r4
 8044f66:	f000 f8a2 	bl	80450ae <HAL_TIMEx_CommutCallback>
}
 8044f6a:	e7c7      	b.n	8044efc <HAL_TIM_IRQHandler+0x10a>

08044f6c <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8044f6c:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8044f6e:	4a30      	ldr	r2, [pc, #192]	; (8045030 <TIM_Base_SetConfig+0xc4>)
 8044f70:	4290      	cmp	r0, r2
 8044f72:	d012      	beq.n	8044f9a <TIM_Base_SetConfig+0x2e>
 8044f74:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8044f78:	d00f      	beq.n	8044f9a <TIM_Base_SetConfig+0x2e>
 8044f7a:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8044f7e:	4290      	cmp	r0, r2
 8044f80:	d00b      	beq.n	8044f9a <TIM_Base_SetConfig+0x2e>
 8044f82:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044f86:	4290      	cmp	r0, r2
 8044f88:	d007      	beq.n	8044f9a <TIM_Base_SetConfig+0x2e>
 8044f8a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044f8e:	4290      	cmp	r0, r2
 8044f90:	d003      	beq.n	8044f9a <TIM_Base_SetConfig+0x2e>
 8044f92:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8044f96:	4290      	cmp	r0, r2
 8044f98:	d103      	bne.n	8044fa2 <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8044f9a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8044f9e:	684a      	ldr	r2, [r1, #4]
 8044fa0:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8044fa2:	4a23      	ldr	r2, [pc, #140]	; (8045030 <TIM_Base_SetConfig+0xc4>)
 8044fa4:	4290      	cmp	r0, r2
 8044fa6:	d02a      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fa8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8044fac:	d027      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fae:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8044fb2:	4290      	cmp	r0, r2
 8044fb4:	d023      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fb6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fba:	4290      	cmp	r0, r2
 8044fbc:	d01f      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fbe:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fc2:	4290      	cmp	r0, r2
 8044fc4:	d01b      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fc6:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 8044fca:	4290      	cmp	r0, r2
 8044fcc:	d017      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fce:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8044fd2:	4290      	cmp	r0, r2
 8044fd4:	d013      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fd6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fda:	4290      	cmp	r0, r2
 8044fdc:	d00f      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fde:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044fe2:	4290      	cmp	r0, r2
 8044fe4:	d00b      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fe6:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8044fea:	4290      	cmp	r0, r2
 8044fec:	d007      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044fee:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044ff2:	4290      	cmp	r0, r2
 8044ff4:	d003      	beq.n	8044ffe <TIM_Base_SetConfig+0x92>
 8044ff6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8044ffa:	4290      	cmp	r0, r2
 8044ffc:	d103      	bne.n	8045006 <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8044ffe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8045002:	68ca      	ldr	r2, [r1, #12]
 8045004:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8045006:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 804500a:	694a      	ldr	r2, [r1, #20]
 804500c:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 804500e:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8045010:	688b      	ldr	r3, [r1, #8]
 8045012:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8045014:	680b      	ldr	r3, [r1, #0]
 8045016:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8045018:	4b05      	ldr	r3, [pc, #20]	; (8045030 <TIM_Base_SetConfig+0xc4>)
 804501a:	4298      	cmp	r0, r3
 804501c:	d003      	beq.n	8045026 <TIM_Base_SetConfig+0xba>
 804501e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8045022:	4298      	cmp	r0, r3
 8045024:	d101      	bne.n	804502a <TIM_Base_SetConfig+0xbe>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8045026:	690b      	ldr	r3, [r1, #16]
 8045028:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 804502a:	2301      	movs	r3, #1
 804502c:	6143      	str	r3, [r0, #20]
}
 804502e:	4770      	bx	lr
 8045030:	40010000 	.word	0x40010000

08045034 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8045034:	b1b0      	cbz	r0, 8045064 <HAL_TIM_Base_Init+0x30>
{
 8045036:	b510      	push	{r4, lr}
 8045038:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 804503a:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 804503e:	b163      	cbz	r3, 804505a <HAL_TIM_Base_Init+0x26>
  htim->State = HAL_TIM_STATE_BUSY;
 8045040:	2302      	movs	r3, #2
 8045042:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8045046:	4621      	mov	r1, r4
 8045048:	f851 0b04 	ldr.w	r0, [r1], #4
 804504c:	f7ff ff8e 	bl	8044f6c <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8045050:	2301      	movs	r3, #1
 8045052:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8045056:	2000      	movs	r0, #0
}
 8045058:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 804505a:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 804505e:	f00a ff25 	bl	804feac <HAL_TIM_Base_MspInit>
 8045062:	e7ed      	b.n	8045040 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8045064:	2001      	movs	r0, #1
}
 8045066:	4770      	bx	lr

08045068 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8045068:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 804506c:	2b01      	cmp	r3, #1
 804506e:	d01c      	beq.n	80450aa <HAL_TIMEx_MasterConfigSynchronization+0x42>
{
 8045070:	b470      	push	{r4, r5, r6}
  __HAL_LOCK(htim);
 8045072:	2601      	movs	r6, #1
 8045074:	f880 603c 	strb.w	r6, [r0, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8045078:	2302      	movs	r3, #2
 804507a:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 804507e:	6802      	ldr	r2, [r0, #0]
 8045080:	6855      	ldr	r5, [r2, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8045082:	6893      	ldr	r3, [r2, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8045084:	f025 0570 	bic.w	r5, r5, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8045088:	680c      	ldr	r4, [r1, #0]
 804508a:	432c      	orrs	r4, r5

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 804508c:	f023 0580 	bic.w	r5, r3, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8045090:	684b      	ldr	r3, [r1, #4]
 8045092:	432b      	orrs	r3, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8045094:	6054      	str	r4, [r2, #4]

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 8045096:	6802      	ldr	r2, [r0, #0]
 8045098:	6093      	str	r3, [r2, #8]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 804509a:	f880 603d 	strb.w	r6, [r0, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 804509e:	2300      	movs	r3, #0
 80450a0:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c

  return HAL_OK;
 80450a4:	4618      	mov	r0, r3
}
 80450a6:	bc70      	pop	{r4, r5, r6}
 80450a8:	4770      	bx	lr
  __HAL_LOCK(htim);
 80450aa:	2002      	movs	r0, #2
}
 80450ac:	4770      	bx	lr

080450ae <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 80450ae:	4770      	bx	lr

080450b0 <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80450b0:	4770      	bx	lr

080450b2 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 80450b2:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 80450b4:	680c      	ldr	r4, [r1, #0]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80450b6:	fa94 f4a4 	rbit	r4, r4
 80450ba:	fab4 f484 	clz	r4, r4

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 80450be:	e02c      	b.n	804511a <LL_GPIO_Init+0x68>
      {
        /* Check Speed mode parameters */
        assert_param(IS_LL_GPIO_SPEED(GPIO_InitStruct->Speed));

        /* Speed mode configuration */
        LL_GPIO_SetPinSpeed(GPIOx, currentpin, GPIO_InitStruct->Speed);
 80450c0:	688e      	ldr	r6, [r1, #8]
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 80450c2:	6882      	ldr	r2, [r0, #8]
 80450c4:	fa93 f5a3 	rbit	r5, r3
 80450c8:	fab5 f585 	clz	r5, r5
 80450cc:	006d      	lsls	r5, r5, #1
 80450ce:	fa07 f505 	lsl.w	r5, r7, r5
 80450d2:	ea22 0205 	bic.w	r2, r2, r5
 80450d6:	fa93 f5a3 	rbit	r5, r3
 80450da:	fab5 f585 	clz	r5, r5
 80450de:	006d      	lsls	r5, r5, #1
 80450e0:	fa06 f505 	lsl.w	r5, r6, r5
 80450e4:	432a      	orrs	r2, r5
 80450e6:	6082      	str	r2, [r0, #8]
      }

      /* Pull-up Pull down resistor configuration*/
      LL_GPIO_SetPinPull(GPIOx, currentpin, GPIO_InitStruct->Pull);
 80450e8:	690e      	ldr	r6, [r1, #16]
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80450ea:	68c2      	ldr	r2, [r0, #12]
 80450ec:	fa93 f5a3 	rbit	r5, r3
 80450f0:	fab5 f585 	clz	r5, r5
 80450f4:	006d      	lsls	r5, r5, #1
 80450f6:	2703      	movs	r7, #3
 80450f8:	fa07 f505 	lsl.w	r5, r7, r5
 80450fc:	ea22 0205 	bic.w	r2, r2, r5
 8045100:	fa93 f5a3 	rbit	r5, r3
 8045104:	fab5 f585 	clz	r5, r5
 8045108:	006d      	lsls	r5, r5, #1
 804510a:	fa06 f505 	lsl.w	r5, r6, r5
 804510e:	432a      	orrs	r2, r5
 8045110:	60c2      	str	r2, [r0, #12]

      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8045112:	684a      	ldr	r2, [r1, #4]
 8045114:	2a02      	cmp	r2, #2
 8045116:	d022      	beq.n	804515e <LL_GPIO_Init+0xac>
        {
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
        }
      }
    }
    pinpos++;
 8045118:	3401      	adds	r4, #1
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 804511a:	680b      	ldr	r3, [r1, #0]
 804511c:	fa33 f204 	lsrs.w	r2, r3, r4
 8045120:	d050      	beq.n	80451c4 <LL_GPIO_Init+0x112>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8045122:	2201      	movs	r2, #1
 8045124:	40a2      	lsls	r2, r4
    if (currentpin)
 8045126:	4013      	ands	r3, r2
 8045128:	d0f6      	beq.n	8045118 <LL_GPIO_Init+0x66>
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 804512a:	684e      	ldr	r6, [r1, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 804512c:	6802      	ldr	r2, [r0, #0]
 804512e:	fa93 f5a3 	rbit	r5, r3
 8045132:	fab5 f585 	clz	r5, r5
 8045136:	006d      	lsls	r5, r5, #1
 8045138:	2703      	movs	r7, #3
 804513a:	fa07 f505 	lsl.w	r5, r7, r5
 804513e:	ea22 0205 	bic.w	r2, r2, r5
 8045142:	fa93 f5a3 	rbit	r5, r3
 8045146:	fab5 f585 	clz	r5, r5
 804514a:	006d      	lsls	r5, r5, #1
 804514c:	fa06 f505 	lsl.w	r5, r6, r5
 8045150:	432a      	orrs	r2, r5
 8045152:	6002      	str	r2, [r0, #0]
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8045154:	684a      	ldr	r2, [r1, #4]
 8045156:	3a01      	subs	r2, #1
 8045158:	2a01      	cmp	r2, #1
 804515a:	d8c5      	bhi.n	80450e8 <LL_GPIO_Init+0x36>
 804515c:	e7b0      	b.n	80450c0 <LL_GPIO_Init+0xe>
 804515e:	fa93 f2a3 	rbit	r2, r3
        if (POSITION_VAL(currentpin) < 0x00000008U)
 8045162:	fab2 f282 	clz	r2, r2
 8045166:	2a07      	cmp	r2, #7
 8045168:	d815      	bhi.n	8045196 <LL_GPIO_Init+0xe4>
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 804516a:	694d      	ldr	r5, [r1, #20]
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_0_7(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 804516c:	6a02      	ldr	r2, [r0, #32]
 804516e:	fa93 f6a3 	rbit	r6, r3
 8045172:	fab6 f686 	clz	r6, r6
 8045176:	00b6      	lsls	r6, r6, #2
 8045178:	270f      	movs	r7, #15
 804517a:	fa07 f606 	lsl.w	r6, r7, r6
 804517e:	ea22 0206 	bic.w	r2, r2, r6
 8045182:	fa93 f3a3 	rbit	r3, r3
 8045186:	fab3 f383 	clz	r3, r3
 804518a:	009b      	lsls	r3, r3, #2
 804518c:	fa05 f303 	lsl.w	r3, r5, r3
 8045190:	4313      	orrs	r3, r2
 8045192:	6203      	str	r3, [r0, #32]
             (Alternate << (POSITION_VAL(Pin) * 4U)));
}
 8045194:	e7c0      	b.n	8045118 <LL_GPIO_Init+0x66>
          LL_GPIO_SetAFPin_8_15(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8045196:	694a      	ldr	r2, [r1, #20]
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8045198:	6a45      	ldr	r5, [r0, #36]	; 0x24
 804519a:	0a1b      	lsrs	r3, r3, #8
 804519c:	fa93 f6a3 	rbit	r6, r3
 80451a0:	fab6 f686 	clz	r6, r6
 80451a4:	00b6      	lsls	r6, r6, #2
 80451a6:	270f      	movs	r7, #15
 80451a8:	fa07 f606 	lsl.w	r6, r7, r6
 80451ac:	ea25 0506 	bic.w	r5, r5, r6
 80451b0:	fa93 f3a3 	rbit	r3, r3
 80451b4:	fab3 f383 	clz	r3, r3
 80451b8:	009b      	lsls	r3, r3, #2
 80451ba:	fa02 f303 	lsl.w	r3, r2, r3
 80451be:	432b      	orrs	r3, r5
 80451c0:	6243      	str	r3, [r0, #36]	; 0x24
             (Alternate << (POSITION_VAL(Pin >> 8U) * 4U)));
}
 80451c2:	e7a9      	b.n	8045118 <LL_GPIO_Init+0x66>
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 80451c4:	684a      	ldr	r2, [r1, #4]
 80451c6:	3a01      	subs	r2, #1
 80451c8:	2a01      	cmp	r2, #1
 80451ca:	d902      	bls.n	80451d2 <LL_GPIO_Init+0x120>
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 80451cc:	2000      	movs	r0, #0
 80451ce:	bcf0      	pop	{r4, r5, r6, r7}
 80451d0:	4770      	bx	lr
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);
 80451d2:	68c9      	ldr	r1, [r1, #12]
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 80451d4:	6842      	ldr	r2, [r0, #4]
 80451d6:	ea22 0203 	bic.w	r2, r2, r3
 80451da:	fb01 f303 	mul.w	r3, r1, r3
 80451de:	4313      	orrs	r3, r2
 80451e0:	6043      	str	r3, [r0, #4]
}
 80451e2:	e7f3      	b.n	80451cc <LL_GPIO_Init+0x11a>

080451e4 <RCC_GetHCLKClockFreq>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80451e4:	4b03      	ldr	r3, [pc, #12]	; (80451f4 <RCC_GetHCLKClockFreq+0x10>)
 80451e6:	689b      	ldr	r3, [r3, #8]
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 80451e8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80451ec:	4a02      	ldr	r2, [pc, #8]	; (80451f8 <RCC_GetHCLKClockFreq+0x14>)
 80451ee:	5cd3      	ldrb	r3, [r2, r3]
}
 80451f0:	40d8      	lsrs	r0, r3
 80451f2:	4770      	bx	lr
 80451f4:	40023800 	.word	0x40023800
 80451f8:	080585e4 	.word	0x080585e4

080451fc <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 80451fc:	4b03      	ldr	r3, [pc, #12]	; (804520c <RCC_GetPCLK1ClockFreq+0x10>)
 80451fe:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8045200:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8045204:	4a02      	ldr	r2, [pc, #8]	; (8045210 <RCC_GetPCLK1ClockFreq+0x14>)
 8045206:	5cd3      	ldrb	r3, [r2, r3]
}
 8045208:	40d8      	lsrs	r0, r3
 804520a:	4770      	bx	lr
 804520c:	40023800 	.word	0x40023800
 8045210:	080585f4 	.word	0x080585f4

08045214 <RCC_GetPCLK2ClockFreq>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8045214:	4b03      	ldr	r3, [pc, #12]	; (8045224 <RCC_GetPCLK2ClockFreq+0x10>)
 8045216:	689b      	ldr	r3, [r3, #8]
  * @retval PCLK2 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK2 clock frequency */
  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 8045218:	f3c3 3342 	ubfx	r3, r3, #13, #3
 804521c:	4a02      	ldr	r2, [pc, #8]	; (8045228 <RCC_GetPCLK2ClockFreq+0x14>)
 804521e:	5cd3      	ldrb	r3, [r2, r3]
}
 8045220:	40d8      	lsrs	r0, r3
 8045222:	4770      	bx	lr
 8045224:	40023800 	.word	0x40023800
 8045228:	080585f4 	.word	0x080585f4

0804522c <RCC_PLL_GetFreqDomain_SYS>:
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 804522c:	4b0f      	ldr	r3, [pc, #60]	; (804526c <RCC_PLL_GetFreqDomain_SYS+0x40>)
 804522e:	685b      	ldr	r3, [r3, #4]
 8045230:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
     SYSCLK = PLL_VCO / (PLLP or PLLR)
  */
  pllsource = LL_RCC_PLL_GetMainSource();

  switch (pllsource)
 8045234:	b923      	cbnz	r3, 8045240 <RCC_PLL_GetFreqDomain_SYS+0x14>
  {
    case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
      pllinputfreq = HSI_VALUE;
 8045236:	4b0e      	ldr	r3, [pc, #56]	; (8045270 <RCC_PLL_GetFreqDomain_SYS+0x44>)
    default:
      pllinputfreq = HSI_VALUE;
      break;
  }

  if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 8045238:	2808      	cmp	r0, #8
 804523a:	d003      	beq.n	8045244 <RCC_PLL_GetFreqDomain_SYS+0x18>
  uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;
 804523c:	2000      	movs	r0, #0
                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }
#endif /* RCC_PLLR_SYSCLK_SUPPORT */

  return plloutputfreq;
}
 804523e:	4770      	bx	lr
      pllinputfreq = HSE_VALUE;
 8045240:	4b0c      	ldr	r3, [pc, #48]	; (8045274 <RCC_PLL_GetFreqDomain_SYS+0x48>)
 8045242:	e7f9      	b.n	8045238 <RCC_PLL_GetFreqDomain_SYS+0xc>
  *         @arg @ref LL_RCC_PLLM_DIV_62
  *         @arg @ref LL_RCC_PLLM_DIV_63
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8045244:	4a09      	ldr	r2, [pc, #36]	; (804526c <RCC_PLL_GetFreqDomain_SYS+0x40>)
 8045246:	6850      	ldr	r0, [r2, #4]
 8045248:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 804524c:	fbb3 f3f0 	udiv	r3, r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8045250:	6850      	ldr	r0, [r2, #4]
 8045252:	f3c0 1088 	ubfx	r0, r0, #6, #9
 8045256:	fb00 f003 	mul.w	r0, r0, r3
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLP));
 804525a:	6853      	ldr	r3, [r2, #4]
 804525c:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8045260:	3301      	adds	r3, #1
 8045262:	005b      	lsls	r3, r3, #1
 8045264:	fbb0 f0f3 	udiv	r0, r0, r3
 8045268:	4770      	bx	lr
 804526a:	bf00      	nop
 804526c:	40023800 	.word	0x40023800
 8045270:	00f42400 	.word	0x00f42400
 8045274:	017d7840 	.word	0x017d7840

08045278 <RCC_GetSystemClockFreq>:
{
 8045278:	b508      	push	{r3, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 804527a:	4b08      	ldr	r3, [pc, #32]	; (804529c <RCC_GetSystemClockFreq+0x24>)
 804527c:	689b      	ldr	r3, [r3, #8]
 804527e:	f003 030c 	and.w	r3, r3, #12
  switch (LL_RCC_GetSysClkSource())
 8045282:	2b04      	cmp	r3, #4
 8045284:	d005      	beq.n	8045292 <RCC_GetSystemClockFreq+0x1a>
 8045286:	2b08      	cmp	r3, #8
 8045288:	d105      	bne.n	8045296 <RCC_GetSystemClockFreq+0x1e>
      frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
 804528a:	2008      	movs	r0, #8
 804528c:	f7ff ffce 	bl	804522c <RCC_PLL_GetFreqDomain_SYS>
      break;
 8045290:	e002      	b.n	8045298 <RCC_GetSystemClockFreq+0x20>
      frequency = HSE_VALUE;
 8045292:	4803      	ldr	r0, [pc, #12]	; (80452a0 <RCC_GetSystemClockFreq+0x28>)
 8045294:	e000      	b.n	8045298 <RCC_GetSystemClockFreq+0x20>
  switch (LL_RCC_GetSysClkSource())
 8045296:	4803      	ldr	r0, [pc, #12]	; (80452a4 <RCC_GetSystemClockFreq+0x2c>)
}
 8045298:	bd08      	pop	{r3, pc}
 804529a:	bf00      	nop
 804529c:	40023800 	.word	0x40023800
 80452a0:	017d7840 	.word	0x017d7840
 80452a4:	00f42400 	.word	0x00f42400

080452a8 <LL_RCC_GetSystemClocksFreq>:
{
 80452a8:	b510      	push	{r4, lr}
 80452aa:	4604      	mov	r4, r0
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 80452ac:	f7ff ffe4 	bl	8045278 <RCC_GetSystemClockFreq>
 80452b0:	6020      	str	r0, [r4, #0]
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 80452b2:	f7ff ff97 	bl	80451e4 <RCC_GetHCLKClockFreq>
 80452b6:	6060      	str	r0, [r4, #4]
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 80452b8:	f7ff ffa0 	bl	80451fc <RCC_GetPCLK1ClockFreq>
 80452bc:	60a0      	str	r0, [r4, #8]
  RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
 80452be:	6860      	ldr	r0, [r4, #4]
 80452c0:	f7ff ffa8 	bl	8045214 <RCC_GetPCLK2ClockFreq>
 80452c4:	60e0      	str	r0, [r4, #12]
}
 80452c6:	bd10      	pop	{r4, pc}

080452c8 <LL_USART_Init>:
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 80452c8:	68c3      	ldr	r3, [r0, #12]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 80452ca:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 80452ce:	d001      	beq.n	80452d4 <LL_USART_Init+0xc>
  ErrorStatus status = ERROR;
 80452d0:	2001      	movs	r0, #1
    }
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 80452d2:	4770      	bx	lr
{
 80452d4:	b530      	push	{r4, r5, lr}
 80452d6:	b085      	sub	sp, #20
 80452d8:	4604      	mov	r4, r0
 80452da:	460d      	mov	r5, r1
    MODIFY_REG(USARTx->CR1,
 80452dc:	68c3      	ldr	r3, [r0, #12]
 80452de:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 80452e2:	f023 030c 	bic.w	r3, r3, #12
 80452e6:	684a      	ldr	r2, [r1, #4]
 80452e8:	68c9      	ldr	r1, [r1, #12]
 80452ea:	430a      	orrs	r2, r1
 80452ec:	6929      	ldr	r1, [r5, #16]
 80452ee:	430a      	orrs	r2, r1
 80452f0:	69a9      	ldr	r1, [r5, #24]
 80452f2:	430a      	orrs	r2, r1
 80452f4:	4313      	orrs	r3, r2
 80452f6:	60c3      	str	r3, [r0, #12]
    LL_USART_SetStopBitsLength(USARTx, USART_InitStruct->StopBits);
 80452f8:	68ab      	ldr	r3, [r5, #8]
  *         @arg @ref LL_USART_STOPBITS_2
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
{
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 80452fa:	6902      	ldr	r2, [r0, #16]
 80452fc:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8045300:	4313      	orrs	r3, r2
 8045302:	6103      	str	r3, [r0, #16]
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);
 8045304:	696b      	ldr	r3, [r5, #20]
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
{
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 8045306:	6942      	ldr	r2, [r0, #20]
 8045308:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 804530c:	4313      	orrs	r3, r2
 804530e:	6143      	str	r3, [r0, #20]
    LL_RCC_GetSystemClocksFreq(&rcc_clocks);
 8045310:	4668      	mov	r0, sp
 8045312:	f7ff ffc9 	bl	80452a8 <LL_RCC_GetSystemClocksFreq>
    if (USARTx == USART1)
 8045316:	4b3c      	ldr	r3, [pc, #240]	; (8045408 <LL_USART_Init+0x140>)
 8045318:	429c      	cmp	r4, r3
 804531a:	d016      	beq.n	804534a <LL_USART_Init+0x82>
    else if (USARTx == USART2)
 804531c:	4b3b      	ldr	r3, [pc, #236]	; (804540c <LL_USART_Init+0x144>)
 804531e:	429c      	cmp	r4, r3
 8045320:	d01a      	beq.n	8045358 <LL_USART_Init+0x90>
    else if (USARTx == USART3)
 8045322:	4b3b      	ldr	r3, [pc, #236]	; (8045410 <LL_USART_Init+0x148>)
 8045324:	429c      	cmp	r4, r3
 8045326:	d019      	beq.n	804535c <LL_USART_Init+0x94>
    else if (USARTx == USART6)
 8045328:	4b3a      	ldr	r3, [pc, #232]	; (8045414 <LL_USART_Init+0x14c>)
 804532a:	429c      	cmp	r4, r3
 804532c:	d018      	beq.n	8045360 <LL_USART_Init+0x98>
    else if (USARTx == UART4)
 804532e:	4b3a      	ldr	r3, [pc, #232]	; (8045418 <LL_USART_Init+0x150>)
 8045330:	429c      	cmp	r4, r3
 8045332:	d017      	beq.n	8045364 <LL_USART_Init+0x9c>
    else if (USARTx == UART5)
 8045334:	4b39      	ldr	r3, [pc, #228]	; (804541c <LL_USART_Init+0x154>)
 8045336:	429c      	cmp	r4, r3
 8045338:	d016      	beq.n	8045368 <LL_USART_Init+0xa0>
    else if (USARTx == UART7)
 804533a:	4b39      	ldr	r3, [pc, #228]	; (8045420 <LL_USART_Init+0x158>)
 804533c:	429c      	cmp	r4, r3
 804533e:	d015      	beq.n	804536c <LL_USART_Init+0xa4>
    else if (USARTx == UART8)
 8045340:	4b38      	ldr	r3, [pc, #224]	; (8045424 <LL_USART_Init+0x15c>)
 8045342:	429c      	cmp	r4, r3
 8045344:	d014      	beq.n	8045370 <LL_USART_Init+0xa8>
  ErrorStatus status = ERROR;
 8045346:	2001      	movs	r0, #1
 8045348:	e05b      	b.n	8045402 <LL_USART_Init+0x13a>
      periphclk = rcc_clocks.PCLK2_Frequency;
 804534a:	9b03      	ldr	r3, [sp, #12]
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 804534c:	2b00      	cmp	r3, #0
 804534e:	d057      	beq.n	8045400 <LL_USART_Init+0x138>
        && (USART_InitStruct->BaudRate != 0U))
 8045350:	682a      	ldr	r2, [r5, #0]
 8045352:	b97a      	cbnz	r2, 8045374 <LL_USART_Init+0xac>
  ErrorStatus status = ERROR;
 8045354:	2001      	movs	r0, #1
 8045356:	e054      	b.n	8045402 <LL_USART_Init+0x13a>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8045358:	9b02      	ldr	r3, [sp, #8]
 804535a:	e7f7      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 804535c:	9b02      	ldr	r3, [sp, #8]
 804535e:	e7f5      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK2_Frequency;
 8045360:	9b03      	ldr	r3, [sp, #12]
 8045362:	e7f3      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8045364:	9b02      	ldr	r3, [sp, #8]
 8045366:	e7f1      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8045368:	9b02      	ldr	r3, [sp, #8]
 804536a:	e7ef      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 804536c:	9b02      	ldr	r3, [sp, #8]
 804536e:	e7ed      	b.n	804534c <LL_USART_Init+0x84>
      periphclk = rcc_clocks.PCLK1_Frequency;
 8045370:	9b02      	ldr	r3, [sp, #8]
 8045372:	e7eb      	b.n	804534c <LL_USART_Init+0x84>
      LL_USART_SetBaudRate(USARTx,
 8045374:	69a9      	ldr	r1, [r5, #24]
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetBaudRate(USART_TypeDef *USARTx, uint32_t PeriphClk, uint32_t OverSampling,
                                          uint32_t BaudRate)
{
  if (OverSampling == LL_USART_OVERSAMPLING_8)
 8045376:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 804537a:	d020      	beq.n	80453be <LL_USART_Init+0xf6>
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
  }
  else
  {
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 804537c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8045380:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8045384:	0092      	lsls	r2, r2, #2
 8045386:	fbb3 f3f2 	udiv	r3, r3, r2
 804538a:	4827      	ldr	r0, [pc, #156]	; (8045428 <LL_USART_Init+0x160>)
 804538c:	fba0 1203 	umull	r1, r2, r0, r3
 8045390:	0952      	lsrs	r2, r2, #5
 8045392:	0111      	lsls	r1, r2, #4
 8045394:	b289      	uxth	r1, r1
 8045396:	2564      	movs	r5, #100	; 0x64
 8045398:	fb05 3312 	mls	r3, r5, r2, r3
 804539c:	011b      	lsls	r3, r3, #4
 804539e:	3332      	adds	r3, #50	; 0x32
 80453a0:	fba0 2303 	umull	r2, r3, r0, r3
 80453a4:	f3c3 134f 	ubfx	r3, r3, #5, #16
 80453a8:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80453ac:	440a      	add	r2, r1
 80453ae:	b292      	uxth	r2, r2
 80453b0:	f003 030f 	and.w	r3, r3, #15
 80453b4:	4413      	add	r3, r2
 80453b6:	b29b      	uxth	r3, r3
 80453b8:	60a3      	str	r3, [r4, #8]
      status = SUCCESS;
 80453ba:	2000      	movs	r0, #0
  }
}
 80453bc:	e021      	b.n	8045402 <LL_USART_Init+0x13a>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 80453be:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80453c2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80453c6:	0052      	lsls	r2, r2, #1
 80453c8:	fbb3 f3f2 	udiv	r3, r3, r2
 80453cc:	4816      	ldr	r0, [pc, #88]	; (8045428 <LL_USART_Init+0x160>)
 80453ce:	fba0 1203 	umull	r1, r2, r0, r3
 80453d2:	0952      	lsrs	r2, r2, #5
 80453d4:	0111      	lsls	r1, r2, #4
 80453d6:	b289      	uxth	r1, r1
 80453d8:	2564      	movs	r5, #100	; 0x64
 80453da:	fb05 3312 	mls	r3, r5, r2, r3
 80453de:	00db      	lsls	r3, r3, #3
 80453e0:	3332      	adds	r3, #50	; 0x32
 80453e2:	fba0 2303 	umull	r2, r3, r0, r3
 80453e6:	f3c3 134f 	ubfx	r3, r3, #5, #16
 80453ea:	005a      	lsls	r2, r3, #1
 80453ec:	f402 72f8 	and.w	r2, r2, #496	; 0x1f0
 80453f0:	440a      	add	r2, r1
 80453f2:	b292      	uxth	r2, r2
 80453f4:	f003 0307 	and.w	r3, r3, #7
 80453f8:	4413      	add	r3, r2
 80453fa:	b29b      	uxth	r3, r3
 80453fc:	60a3      	str	r3, [r4, #8]
 80453fe:	e7dc      	b.n	80453ba <LL_USART_Init+0xf2>
  ErrorStatus status = ERROR;
 8045400:	2001      	movs	r0, #1
}
 8045402:	b005      	add	sp, #20
 8045404:	bd30      	pop	{r4, r5, pc}
 8045406:	bf00      	nop
 8045408:	40011000 	.word	0x40011000
 804540c:	40004400 	.word	0x40004400
 8045410:	40004800 	.word	0x40004800
 8045414:	40011400 	.word	0x40011400
 8045418:	40004c00 	.word	0x40004c00
 804541c:	40005000 	.word	0x40005000
 8045420:	40007800 	.word	0x40007800
 8045424:	40007c00 	.word	0x40007c00
 8045428:	51eb851f 	.word	0x51eb851f

0804542c <lwip_htons>:
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
  return (u16_t)PP_HTONS(n);
 804542c:	ba40      	rev16	r0, r0
}
 804542e:	b280      	uxth	r0, r0
 8045430:	4770      	bx	lr

08045432 <lwip_htonl>:
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return (u32_t)PP_HTONL(n);
 8045432:	0203      	lsls	r3, r0, #8
 8045434:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8045438:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 804543c:	0a02      	lsrs	r2, r0, #8
 804543e:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 8045442:	4313      	orrs	r3, r2
}
 8045444:	ea43 6010 	orr.w	r0, r3, r0, lsr #24
 8045448:	4770      	bx	lr

0804544a <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
 804544a:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
 804544c:	f000 f878 	bl	8045540 <mem_init>
  memp_init();
 8045450:	f000 fa44 	bl	80458dc <memp_init>
  pbuf_init();
  netif_init();
 8045454:	f000 fa97 	bl	8045986 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 8045458:	f004 fbda 	bl	8049c10 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 804545c:	f001 f830 	bl	80464c0 <tcp_init>
#if PPP_SUPPORT
  ppp_init();
#endif
 
#if LWIP_TIMERS
  sys_timeouts_init();
 8045460:	f004 fb5a 	bl	8049b18 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 8045464:	bd08      	pop	{r3, pc}
	...

08045468 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 8045468:	b510      	push	{r4, lr}
 804546a:	4604      	mov	r4, r0
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 804546c:	4b2d      	ldr	r3, [pc, #180]	; (8045524 <plug_holes+0xbc>)
 804546e:	681b      	ldr	r3, [r3, #0]
 8045470:	4283      	cmp	r3, r0
 8045472:	d831      	bhi.n	80454d8 <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 8045474:	4b2b      	ldr	r3, [pc, #172]	; (8045524 <plug_holes+0xbc>)
 8045476:	685b      	ldr	r3, [r3, #4]
 8045478:	42a3      	cmp	r3, r4
 804547a:	d935      	bls.n	80454e8 <plug_holes+0x80>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 804547c:	7923      	ldrb	r3, [r4, #4]
 804547e:	2b00      	cmp	r3, #0
 8045480:	d13a      	bne.n	80454f8 <plug_holes+0x90>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8045482:	8823      	ldrh	r3, [r4, #0]
 8045484:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 8045488:	d83e      	bhi.n	8045508 <plug_holes+0xa0>

  nmem = (struct mem *)(void *)&ram[mem->next];
 804548a:	4b26      	ldr	r3, [pc, #152]	; (8045524 <plug_holes+0xbc>)
 804548c:	681b      	ldr	r3, [r3, #0]
 804548e:	8821      	ldrh	r1, [r4, #0]
 8045490:	185a      	adds	r2, r3, r1
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 8045492:	4294      	cmp	r4, r2
 8045494:	d00f      	beq.n	80454b6 <plug_holes+0x4e>
 8045496:	7910      	ldrb	r0, [r2, #4]
 8045498:	b968      	cbnz	r0, 80454b6 <plug_holes+0x4e>
 804549a:	4822      	ldr	r0, [pc, #136]	; (8045524 <plug_holes+0xbc>)
 804549c:	6840      	ldr	r0, [r0, #4]
 804549e:	4290      	cmp	r0, r2
 80454a0:	d009      	beq.n	80454b6 <plug_holes+0x4e>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 80454a2:	4820      	ldr	r0, [pc, #128]	; (8045524 <plug_holes+0xbc>)
 80454a4:	6880      	ldr	r0, [r0, #8]
 80454a6:	4290      	cmp	r0, r2
 80454a8:	d036      	beq.n	8045518 <plug_holes+0xb0>
      lfree = mem;
    }
    mem->next = nmem->next;
 80454aa:	5a5a      	ldrh	r2, [r3, r1]
 80454ac:	8022      	strh	r2, [r4, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 80454ae:	1ae0      	subs	r0, r4, r3
 80454b0:	5a5a      	ldrh	r2, [r3, r1]
 80454b2:	441a      	add	r2, r3
 80454b4:	8050      	strh	r0, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 80454b6:	8861      	ldrh	r1, [r4, #2]
 80454b8:	185a      	adds	r2, r3, r1
  if (pmem != mem && pmem->used == 0) {
 80454ba:	4294      	cmp	r4, r2
 80454bc:	d00b      	beq.n	80454d6 <plug_holes+0x6e>
 80454be:	7910      	ldrb	r0, [r2, #4]
 80454c0:	b948      	cbnz	r0, 80454d6 <plug_holes+0x6e>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 80454c2:	4818      	ldr	r0, [pc, #96]	; (8045524 <plug_holes+0xbc>)
 80454c4:	6880      	ldr	r0, [r0, #8]
 80454c6:	42a0      	cmp	r0, r4
 80454c8:	d029      	beq.n	804551e <plug_holes+0xb6>
      lfree = pmem;
    }
    pmem->next = mem->next;
 80454ca:	8820      	ldrh	r0, [r4, #0]
 80454cc:	5258      	strh	r0, [r3, r1]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 80454ce:	1ad2      	subs	r2, r2, r3
 80454d0:	8821      	ldrh	r1, [r4, #0]
 80454d2:	440b      	add	r3, r1
 80454d4:	805a      	strh	r2, [r3, #2]
  }
}
 80454d6:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 80454d8:	4b13      	ldr	r3, [pc, #76]	; (8045528 <plug_holes+0xc0>)
 80454da:	f240 125d 	movw	r2, #349	; 0x15d
 80454de:	4913      	ldr	r1, [pc, #76]	; (804552c <plug_holes+0xc4>)
 80454e0:	4813      	ldr	r0, [pc, #76]	; (8045530 <plug_holes+0xc8>)
 80454e2:	f00b fe83 	bl	80511ec <printf>
 80454e6:	e7c5      	b.n	8045474 <plug_holes+0xc>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 80454e8:	4b0f      	ldr	r3, [pc, #60]	; (8045528 <plug_holes+0xc0>)
 80454ea:	f44f 72af 	mov.w	r2, #350	; 0x15e
 80454ee:	4911      	ldr	r1, [pc, #68]	; (8045534 <plug_holes+0xcc>)
 80454f0:	480f      	ldr	r0, [pc, #60]	; (8045530 <plug_holes+0xc8>)
 80454f2:	f00b fe7b 	bl	80511ec <printf>
 80454f6:	e7c1      	b.n	804547c <plug_holes+0x14>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 80454f8:	4b0b      	ldr	r3, [pc, #44]	; (8045528 <plug_holes+0xc0>)
 80454fa:	f240 125f 	movw	r2, #351	; 0x15f
 80454fe:	490e      	ldr	r1, [pc, #56]	; (8045538 <plug_holes+0xd0>)
 8045500:	480b      	ldr	r0, [pc, #44]	; (8045530 <plug_holes+0xc8>)
 8045502:	f00b fe73 	bl	80511ec <printf>
 8045506:	e7bc      	b.n	8045482 <plug_holes+0x1a>
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 8045508:	4b07      	ldr	r3, [pc, #28]	; (8045528 <plug_holes+0xc0>)
 804550a:	f44f 72b1 	mov.w	r2, #354	; 0x162
 804550e:	490b      	ldr	r1, [pc, #44]	; (804553c <plug_holes+0xd4>)
 8045510:	4807      	ldr	r0, [pc, #28]	; (8045530 <plug_holes+0xc8>)
 8045512:	f00b fe6b 	bl	80511ec <printf>
 8045516:	e7b8      	b.n	804548a <plug_holes+0x22>
      lfree = mem;
 8045518:	4a02      	ldr	r2, [pc, #8]	; (8045524 <plug_holes+0xbc>)
 804551a:	6094      	str	r4, [r2, #8]
 804551c:	e7c5      	b.n	80454aa <plug_holes+0x42>
      lfree = pmem;
 804551e:	4801      	ldr	r0, [pc, #4]	; (8045524 <plug_holes+0xbc>)
 8045520:	6082      	str	r2, [r0, #8]
 8045522:	e7d2      	b.n	80454ca <plug_holes+0x62>
 8045524:	20004298 	.word	0x20004298
 8045528:	080585fc 	.word	0x080585fc
 804552c:	0805862c 	.word	0x0805862c
 8045530:	08058644 	.word	0x08058644
 8045534:	0805866c 	.word	0x0805866c
 8045538:	08058688 	.word	0x08058688
 804553c:	080586a4 	.word	0x080586a4

08045540 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 8045540:	b410      	push	{r4}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 8045542:	4b0b      	ldr	r3, [pc, #44]	; (8045570 <mem_init+0x30>)
 8045544:	f023 0303 	bic.w	r3, r3, #3
 8045548:	4a0a      	ldr	r2, [pc, #40]	; (8045574 <mem_init+0x34>)
 804554a:	6013      	str	r3, [r2, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 804554c:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 8045550:	8018      	strh	r0, [r3, #0]
  mem->prev = 0;
 8045552:	2100      	movs	r1, #0
 8045554:	8059      	strh	r1, [r3, #2]
  mem->used = 0;
 8045556:	7119      	strb	r1, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 8045558:	1819      	adds	r1, r3, r0
 804555a:	6051      	str	r1, [r2, #4]
  ram_end->used = 1;
 804555c:	2401      	movs	r4, #1
 804555e:	710c      	strb	r4, [r1, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 8045560:	f8a3 0640 	strh.w	r0, [r3, #1600]	; 0x640
  ram_end->prev = MEM_SIZE_ALIGNED;
 8045564:	8048      	strh	r0, [r1, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 8045566:	6093      	str	r3, [r2, #8]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 8045568:	f85d 4b04 	ldr.w	r4, [sp], #4
 804556c:	4770      	bx	lr
 804556e:	bf00      	nop
 8045570:	20005487 	.word	0x20005487
 8045574:	20004298 	.word	0x20004298

08045578 <mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 8045578:	2800      	cmp	r0, #0
 804557a:	d03d      	beq.n	80455f8 <mem_free+0x80>
{
 804557c:	b538      	push	{r3, r4, r5, lr}
 804557e:	4604      	mov	r4, r0
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 8045580:	f010 0f03 	tst.w	r0, #3
 8045584:	d128      	bne.n	80455d8 <mem_free+0x60>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8045586:	4b1d      	ldr	r3, [pc, #116]	; (80455fc <mem_free+0x84>)
 8045588:	681b      	ldr	r3, [r3, #0]
 804558a:	42a3      	cmp	r3, r4
 804558c:	d803      	bhi.n	8045596 <mem_free+0x1e>
 804558e:	4b1b      	ldr	r3, [pc, #108]	; (80455fc <mem_free+0x84>)
 8045590:	685b      	ldr	r3, [r3, #4]
 8045592:	42a3      	cmp	r3, r4
 8045594:	d806      	bhi.n	80455a4 <mem_free+0x2c>
 8045596:	4b1a      	ldr	r3, [pc, #104]	; (8045600 <mem_free+0x88>)
 8045598:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 804559c:	4919      	ldr	r1, [pc, #100]	; (8045604 <mem_free+0x8c>)
 804559e:	481a      	ldr	r0, [pc, #104]	; (8045608 <mem_free+0x90>)
 80455a0:	f00b fe24 	bl	80511ec <printf>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 80455a4:	4b15      	ldr	r3, [pc, #84]	; (80455fc <mem_free+0x84>)
 80455a6:	681b      	ldr	r3, [r3, #0]
 80455a8:	42a3      	cmp	r3, r4
 80455aa:	d814      	bhi.n	80455d6 <mem_free+0x5e>
 80455ac:	4b13      	ldr	r3, [pc, #76]	; (80455fc <mem_free+0x84>)
 80455ae:	685b      	ldr	r3, [r3, #4]
 80455b0:	42a3      	cmp	r3, r4
 80455b2:	d910      	bls.n	80455d6 <mem_free+0x5e>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 80455b4:	f1a4 0508 	sub.w	r5, r4, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 80455b8:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 80455bc:	b1a3      	cbz	r3, 80455e8 <mem_free+0x70>
  /* ... and is now unused. */
  mem->used = 0;
 80455be:	2300      	movs	r3, #0
 80455c0:	f804 3c04 	strb.w	r3, [r4, #-4]

  if (mem < lfree) {
 80455c4:	4b0d      	ldr	r3, [pc, #52]	; (80455fc <mem_free+0x84>)
 80455c6:	689b      	ldr	r3, [r3, #8]
 80455c8:	42ab      	cmp	r3, r5
 80455ca:	d901      	bls.n	80455d0 <mem_free+0x58>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 80455cc:	4b0b      	ldr	r3, [pc, #44]	; (80455fc <mem_free+0x84>)
 80455ce:	609d      	str	r5, [r3, #8]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 80455d0:	4628      	mov	r0, r5
 80455d2:	f7ff ff49 	bl	8045468 <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 80455d6:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 80455d8:	4b09      	ldr	r3, [pc, #36]	; (8045600 <mem_free+0x88>)
 80455da:	f44f 72d6 	mov.w	r2, #428	; 0x1ac
 80455de:	490b      	ldr	r1, [pc, #44]	; (804560c <mem_free+0x94>)
 80455e0:	4809      	ldr	r0, [pc, #36]	; (8045608 <mem_free+0x90>)
 80455e2:	f00b fe03 	bl	80511ec <printf>
 80455e6:	e7ce      	b.n	8045586 <mem_free+0xe>
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 80455e8:	4b05      	ldr	r3, [pc, #20]	; (8045600 <mem_free+0x88>)
 80455ea:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 80455ee:	4908      	ldr	r1, [pc, #32]	; (8045610 <mem_free+0x98>)
 80455f0:	4805      	ldr	r0, [pc, #20]	; (8045608 <mem_free+0x90>)
 80455f2:	f00b fdfb 	bl	80511ec <printf>
 80455f6:	e7e2      	b.n	80455be <mem_free+0x46>
 80455f8:	4770      	bx	lr
 80455fa:	bf00      	nop
 80455fc:	20004298 	.word	0x20004298
 8045600:	080585fc 	.word	0x080585fc
 8045604:	080586f4 	.word	0x080586f4
 8045608:	08058644 	.word	0x08058644
 804560c:	080586d0 	.word	0x080586d0
 8045610:	0805870c 	.word	0x0805870c

08045614 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 8045614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8045616:	4605      	mov	r5, r0
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 8045618:	1ccc      	adds	r4, r1, #3
 804561a:	b2a4      	uxth	r4, r4
 804561c:	f024 0403 	bic.w	r4, r4, #3
 8045620:	b2a4      	uxth	r4, r4

  if (newsize < MIN_SIZE_ALIGNED) {
 8045622:	2c0b      	cmp	r4, #11
 8045624:	d905      	bls.n	8045632 <mem_trim+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 8045626:	f5b4 6fc8 	cmp.w	r4, #1600	; 0x640
 804562a:	d903      	bls.n	8045634 <mem_trim+0x20>
    return NULL;
 804562c:	2500      	movs	r5, #0
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
 804562e:	4628      	mov	r0, r5
 8045630:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    newsize = MIN_SIZE_ALIGNED;
 8045632:	240c      	movs	r4, #12
  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 8045634:	4b37      	ldr	r3, [pc, #220]	; (8045714 <mem_trim+0x100>)
 8045636:	681b      	ldr	r3, [r3, #0]
 8045638:	42ab      	cmp	r3, r5
 804563a:	d803      	bhi.n	8045644 <mem_trim+0x30>
 804563c:	4b35      	ldr	r3, [pc, #212]	; (8045714 <mem_trim+0x100>)
 804563e:	685b      	ldr	r3, [r3, #4]
 8045640:	42ab      	cmp	r3, r5
 8045642:	d806      	bhi.n	8045652 <mem_trim+0x3e>
 8045644:	4b34      	ldr	r3, [pc, #208]	; (8045718 <mem_trim+0x104>)
 8045646:	f240 12f3 	movw	r2, #499	; 0x1f3
 804564a:	4934      	ldr	r1, [pc, #208]	; (804571c <mem_trim+0x108>)
 804564c:	4834      	ldr	r0, [pc, #208]	; (8045720 <mem_trim+0x10c>)
 804564e:	f00b fdcd 	bl	80511ec <printf>
  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 8045652:	4b30      	ldr	r3, [pc, #192]	; (8045714 <mem_trim+0x100>)
 8045654:	681b      	ldr	r3, [r3, #0]
 8045656:	42ab      	cmp	r3, r5
 8045658:	d8e9      	bhi.n	804562e <mem_trim+0x1a>
 804565a:	4a2e      	ldr	r2, [pc, #184]	; (8045714 <mem_trim+0x100>)
 804565c:	6852      	ldr	r2, [r2, #4]
 804565e:	42aa      	cmp	r2, r5
 8045660:	d9e5      	bls.n	804562e <mem_trim+0x1a>
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 8045662:	f1a5 0708 	sub.w	r7, r5, #8
  ptr = (mem_size_t)((u8_t *)mem - ram);
 8045666:	1aff      	subs	r7, r7, r3
 8045668:	b2bf      	uxth	r7, r7
  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 804566a:	f835 6c08 	ldrh.w	r6, [r5, #-8]
 804566e:	1bf6      	subs	r6, r6, r7
 8045670:	b2b6      	uxth	r6, r6
 8045672:	3e08      	subs	r6, #8
 8045674:	b2b6      	uxth	r6, r6
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 8045676:	42b4      	cmp	r4, r6
 8045678:	d820      	bhi.n	80456bc <mem_trim+0xa8>
  if (newsize > size) {
 804567a:	42b4      	cmp	r4, r6
 804567c:	d848      	bhi.n	8045710 <mem_trim+0xfc>
  if (newsize == size) {
 804567e:	d0d6      	beq.n	804562e <mem_trim+0x1a>
  mem2 = (struct mem *)(void *)&ram[mem->next];
 8045680:	4b24      	ldr	r3, [pc, #144]	; (8045714 <mem_trim+0x100>)
 8045682:	681a      	ldr	r2, [r3, #0]
 8045684:	f835 3c08 	ldrh.w	r3, [r5, #-8]
 8045688:	18d1      	adds	r1, r2, r3
  if (mem2->used == 0) {
 804568a:	7908      	ldrb	r0, [r1, #4]
 804568c:	bb10      	cbnz	r0, 80456d4 <mem_trim+0xc0>
    next = mem2->next;
 804568e:	5ad0      	ldrh	r0, [r2, r3]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 8045690:	19e3      	adds	r3, r4, r7
 8045692:	b29b      	uxth	r3, r3
 8045694:	3308      	adds	r3, #8
 8045696:	b29b      	uxth	r3, r3
    if (lfree == mem2) {
 8045698:	4c1e      	ldr	r4, [pc, #120]	; (8045714 <mem_trim+0x100>)
 804569a:	68a4      	ldr	r4, [r4, #8]
 804569c:	428c      	cmp	r4, r1
 804569e:	d015      	beq.n	80456cc <mem_trim+0xb8>
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80456a0:	18d1      	adds	r1, r2, r3
    mem2->used = 0;
 80456a2:	2400      	movs	r4, #0
 80456a4:	710c      	strb	r4, [r1, #4]
    mem2->next = next;
 80456a6:	52d0      	strh	r0, [r2, r3]
    mem2->prev = ptr;
 80456a8:	804f      	strh	r7, [r1, #2]
    mem->next = ptr2;
 80456aa:	f825 3c08 	strh.w	r3, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 80456ae:	5ad1      	ldrh	r1, [r2, r3]
 80456b0:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
 80456b4:	d0bb      	beq.n	804562e <mem_trim+0x1a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 80456b6:	440a      	add	r2, r1
 80456b8:	8053      	strh	r3, [r2, #2]
 80456ba:	e7b8      	b.n	804562e <mem_trim+0x1a>
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 80456bc:	4b16      	ldr	r3, [pc, #88]	; (8045718 <mem_trim+0x104>)
 80456be:	f240 2206 	movw	r2, #518	; 0x206
 80456c2:	4918      	ldr	r1, [pc, #96]	; (8045724 <mem_trim+0x110>)
 80456c4:	4816      	ldr	r0, [pc, #88]	; (8045720 <mem_trim+0x10c>)
 80456c6:	f00b fd91 	bl	80511ec <printf>
 80456ca:	e7d6      	b.n	804567a <mem_trim+0x66>
      lfree = (struct mem *)(void *)&ram[ptr2];
 80456cc:	18d1      	adds	r1, r2, r3
 80456ce:	4c11      	ldr	r4, [pc, #68]	; (8045714 <mem_trim+0x100>)
 80456d0:	60a1      	str	r1, [r4, #8]
 80456d2:	e7e5      	b.n	80456a0 <mem_trim+0x8c>
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 80456d4:	f104 0314 	add.w	r3, r4, #20
 80456d8:	42b3      	cmp	r3, r6
 80456da:	d8a8      	bhi.n	804562e <mem_trim+0x1a>
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 80456dc:	19e3      	adds	r3, r4, r7
 80456de:	b29b      	uxth	r3, r3
 80456e0:	3308      	adds	r3, #8
 80456e2:	b29b      	uxth	r3, r3
    mem2 = (struct mem *)(void *)&ram[ptr2];
 80456e4:	18d1      	adds	r1, r2, r3
    if (mem2 < lfree) {
 80456e6:	480b      	ldr	r0, [pc, #44]	; (8045714 <mem_trim+0x100>)
 80456e8:	6880      	ldr	r0, [r0, #8]
 80456ea:	4288      	cmp	r0, r1
 80456ec:	d901      	bls.n	80456f2 <mem_trim+0xde>
      lfree = mem2;
 80456ee:	4809      	ldr	r0, [pc, #36]	; (8045714 <mem_trim+0x100>)
 80456f0:	6081      	str	r1, [r0, #8]
    mem2->used = 0;
 80456f2:	2000      	movs	r0, #0
 80456f4:	7108      	strb	r0, [r1, #4]
    mem2->next = mem->next;
 80456f6:	f835 0c08 	ldrh.w	r0, [r5, #-8]
 80456fa:	52d0      	strh	r0, [r2, r3]
    mem2->prev = ptr;
 80456fc:	804f      	strh	r7, [r1, #2]
    mem->next = ptr2;
 80456fe:	f825 3c08 	strh.w	r3, [r5, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 8045702:	5ad1      	ldrh	r1, [r2, r3]
 8045704:	f5b1 6fc8 	cmp.w	r1, #1600	; 0x640
 8045708:	d091      	beq.n	804562e <mem_trim+0x1a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 804570a:	440a      	add	r2, r1
 804570c:	8053      	strh	r3, [r2, #2]
 804570e:	e78e      	b.n	804562e <mem_trim+0x1a>
    return NULL;
 8045710:	2500      	movs	r5, #0
 8045712:	e78c      	b.n	804562e <mem_trim+0x1a>
 8045714:	20004298 	.word	0x20004298
 8045718:	080585fc 	.word	0x080585fc
 804571c:	08058720 	.word	0x08058720
 8045720:	08058644 	.word	0x08058644
 8045724:	08058738 	.word	0x08058738

08045728 <mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 8045728:	2800      	cmp	r0, #0
 804572a:	d07e      	beq.n	804582a <mem_malloc+0x102>
{
 804572c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 804572e:	1cc2      	adds	r2, r0, #3
 8045730:	b292      	uxth	r2, r2
 8045732:	f022 0203 	bic.w	r2, r2, #3
 8045736:	b292      	uxth	r2, r2

  if (size < MIN_SIZE_ALIGNED) {
 8045738:	2a0b      	cmp	r2, #11
 804573a:	d904      	bls.n	8045746 <mem_malloc+0x1e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 804573c:	f5b2 6fc8 	cmp.w	r2, #1600	; 0x640
 8045740:	d902      	bls.n	8045748 <mem_malloc+0x20>
    return NULL;
 8045742:	2000      	movs	r0, #0
 8045744:	e070      	b.n	8045828 <mem_malloc+0x100>
    size = MIN_SIZE_ALIGNED;
 8045746:	220c      	movs	r2, #12
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 8045748:	4b39      	ldr	r3, [pc, #228]	; (8045830 <mem_malloc+0x108>)
 804574a:	689f      	ldr	r7, [r3, #8]
 804574c:	681e      	ldr	r6, [r3, #0]
 804574e:	1bbb      	subs	r3, r7, r6
 8045750:	b29b      	uxth	r3, r3
 8045752:	e040      	b.n	80457d6 <mem_malloc+0xae>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 8045754:	2301      	movs	r3, #1
 8045756:	7123      	strb	r3, [r4, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 8045758:	42a7      	cmp	r7, r4
 804575a:	d00e      	beq.n	804577a <mem_malloc+0x52>
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 804575c:	4425      	add	r5, r4
 804575e:	3508      	adds	r5, #8
 8045760:	4b33      	ldr	r3, [pc, #204]	; (8045830 <mem_malloc+0x108>)
 8045762:	685b      	ldr	r3, [r3, #4]
 8045764:	429d      	cmp	r5, r3
 8045766:	d81d      	bhi.n	80457a4 <mem_malloc+0x7c>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 8045768:	f014 0503 	ands.w	r5, r4, #3
 804576c:	d122      	bne.n	80457b4 <mem_malloc+0x8c>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 804576e:	bb4d      	cbnz	r5, 80457c4 <mem_malloc+0x9c>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 8045770:	f104 0008 	add.w	r0, r4, #8
 8045774:	e058      	b.n	8045828 <mem_malloc+0x100>
            cur = (struct mem *)(void *)&ram[cur->next];
 8045776:	883f      	ldrh	r7, [r7, #0]
 8045778:	4437      	add	r7, r6
          while (cur->used && cur != ram_end) {
 804577a:	793b      	ldrb	r3, [r7, #4]
 804577c:	b11b      	cbz	r3, 8045786 <mem_malloc+0x5e>
 804577e:	4a2c      	ldr	r2, [pc, #176]	; (8045830 <mem_malloc+0x108>)
 8045780:	6852      	ldr	r2, [r2, #4]
 8045782:	42ba      	cmp	r2, r7
 8045784:	d1f7      	bne.n	8045776 <mem_malloc+0x4e>
          lfree = cur;
 8045786:	4a2a      	ldr	r2, [pc, #168]	; (8045830 <mem_malloc+0x108>)
 8045788:	6097      	str	r7, [r2, #8]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 804578a:	6852      	ldr	r2, [r2, #4]
 804578c:	42ba      	cmp	r2, r7
 804578e:	d0e5      	beq.n	804575c <mem_malloc+0x34>
 8045790:	2b00      	cmp	r3, #0
 8045792:	d0e3      	beq.n	804575c <mem_malloc+0x34>
 8045794:	4b27      	ldr	r3, [pc, #156]	; (8045834 <mem_malloc+0x10c>)
 8045796:	f240 22cf 	movw	r2, #719	; 0x2cf
 804579a:	4927      	ldr	r1, [pc, #156]	; (8045838 <mem_malloc+0x110>)
 804579c:	4827      	ldr	r0, [pc, #156]	; (804583c <mem_malloc+0x114>)
 804579e:	f00b fd25 	bl	80511ec <printf>
 80457a2:	e7db      	b.n	804575c <mem_malloc+0x34>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 80457a4:	4b23      	ldr	r3, [pc, #140]	; (8045834 <mem_malloc+0x10c>)
 80457a6:	f240 22d3 	movw	r2, #723	; 0x2d3
 80457aa:	4925      	ldr	r1, [pc, #148]	; (8045840 <mem_malloc+0x118>)
 80457ac:	4823      	ldr	r0, [pc, #140]	; (804583c <mem_malloc+0x114>)
 80457ae:	f00b fd1d 	bl	80511ec <printf>
 80457b2:	e7d9      	b.n	8045768 <mem_malloc+0x40>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 80457b4:	4b1f      	ldr	r3, [pc, #124]	; (8045834 <mem_malloc+0x10c>)
 80457b6:	f240 22d5 	movw	r2, #725	; 0x2d5
 80457ba:	4922      	ldr	r1, [pc, #136]	; (8045844 <mem_malloc+0x11c>)
 80457bc:	481f      	ldr	r0, [pc, #124]	; (804583c <mem_malloc+0x114>)
 80457be:	f00b fd15 	bl	80511ec <printf>
 80457c2:	e7d4      	b.n	804576e <mem_malloc+0x46>
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 80457c4:	4b1b      	ldr	r3, [pc, #108]	; (8045834 <mem_malloc+0x10c>)
 80457c6:	f240 22d7 	movw	r2, #727	; 0x2d7
 80457ca:	491f      	ldr	r1, [pc, #124]	; (8045848 <mem_malloc+0x120>)
 80457cc:	481b      	ldr	r0, [pc, #108]	; (804583c <mem_malloc+0x114>)
 80457ce:	f00b fd0d 	bl	80511ec <printf>
 80457d2:	e7cd      	b.n	8045770 <mem_malloc+0x48>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 80457d4:	8823      	ldrh	r3, [r4, #0]
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 80457d6:	469c      	mov	ip, r3
 80457d8:	4615      	mov	r5, r2
 80457da:	f5c2 60c8 	rsb	r0, r2, #1600	; 0x640
 80457de:	4283      	cmp	r3, r0
 80457e0:	d221      	bcs.n	8045826 <mem_malloc+0xfe>
      mem = (struct mem *)(void *)&ram[ptr];
 80457e2:	18f4      	adds	r4, r6, r3
      if ((!mem->used) &&
 80457e4:	7920      	ldrb	r0, [r4, #4]
 80457e6:	2800      	cmp	r0, #0
 80457e8:	d1f4      	bne.n	80457d4 <mem_malloc+0xac>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 80457ea:	5af1      	ldrh	r1, [r6, r3]
 80457ec:	eba1 010c 	sub.w	r1, r1, ip
 80457f0:	3908      	subs	r1, #8
      if ((!mem->used) &&
 80457f2:	42a9      	cmp	r1, r5
 80457f4:	d3ee      	bcc.n	80457d4 <mem_malloc+0xac>
        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 80457f6:	f105 0014 	add.w	r0, r5, #20
 80457fa:	4281      	cmp	r1, r0
 80457fc:	d3aa      	bcc.n	8045754 <mem_malloc+0x2c>
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 80457fe:	441a      	add	r2, r3
 8045800:	b292      	uxth	r2, r2
 8045802:	3208      	adds	r2, #8
 8045804:	b292      	uxth	r2, r2
          mem2 = (struct mem *)(void *)&ram[ptr2];
 8045806:	18b1      	adds	r1, r6, r2
          mem2->used = 0;
 8045808:	2000      	movs	r0, #0
 804580a:	7108      	strb	r0, [r1, #4]
          mem2->next = mem->next;
 804580c:	8820      	ldrh	r0, [r4, #0]
 804580e:	52b0      	strh	r0, [r6, r2]
          mem2->prev = ptr;
 8045810:	804b      	strh	r3, [r1, #2]
          mem->next = ptr2;
 8045812:	8022      	strh	r2, [r4, #0]
          mem->used = 1;
 8045814:	2301      	movs	r3, #1
 8045816:	7123      	strb	r3, [r4, #4]
          if (mem2->next != MEM_SIZE_ALIGNED) {
 8045818:	5ab3      	ldrh	r3, [r6, r2]
 804581a:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 804581e:	d09b      	beq.n	8045758 <mem_malloc+0x30>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 8045820:	4433      	add	r3, r6
 8045822:	805a      	strh	r2, [r3, #2]
 8045824:	e798      	b.n	8045758 <mem_malloc+0x30>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
 8045826:	2000      	movs	r0, #0
}
 8045828:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return NULL;
 804582a:	2000      	movs	r0, #0
}
 804582c:	4770      	bx	lr
 804582e:	bf00      	nop
 8045830:	20004298 	.word	0x20004298
 8045834:	080585fc 	.word	0x080585fc
 8045838:	08058758 	.word	0x08058758
 804583c:	08058644 	.word	0x08058644
 8045840:	08058774 	.word	0x08058774
 8045844:	080587a4 	.word	0x080587a4
 8045848:	080587d4 	.word	0x080587d4

0804584c <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char* file, const int line)
#endif
{
 804584c:	b510      	push	{r4, lr}
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
 804584e:	6883      	ldr	r3, [r0, #8]
 8045850:	681c      	ldr	r4, [r3, #0]
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
 8045852:	b124      	cbz	r4, 804585e <do_memp_malloc_pool+0x12>
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element_overflow(memp, desc);
    memp_overflow_check_element_underflow(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
 8045854:	6822      	ldr	r2, [r4, #0]
 8045856:	601a      	str	r2, [r3, #0]
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8045858:	f014 0f03 	tst.w	r4, #3
 804585c:	d101      	bne.n	8045862 <do_memp_malloc_pool+0x16>
#endif
  }

  SYS_ARCH_UNPROTECT(old_level);
  return NULL;
}
 804585e:	4620      	mov	r0, r4
 8045860:	bd10      	pop	{r4, pc}
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 8045862:	4b04      	ldr	r3, [pc, #16]	; (8045874 <do_memp_malloc_pool+0x28>)
 8045864:	f44f 72a4 	mov.w	r2, #328	; 0x148
 8045868:	4903      	ldr	r1, [pc, #12]	; (8045878 <do_memp_malloc_pool+0x2c>)
 804586a:	4804      	ldr	r0, [pc, #16]	; (804587c <do_memp_malloc_pool+0x30>)
 804586c:	f00b fcbe 	bl	80511ec <printf>
    return ((u8_t*)memp + MEMP_SIZE);
 8045870:	e7f5      	b.n	804585e <do_memp_malloc_pool+0x12>
 8045872:	bf00      	nop
 8045874:	080587f8 	.word	0x080587f8
 8045878:	08058828 	.word	0x08058828
 804587c:	08058644 	.word	0x08058644

08045880 <do_memp_free_pool>:
  return memp;
}

static void
do_memp_free_pool(const struct memp_desc* desc, void *mem)
{
 8045880:	b538      	push	{r3, r4, r5, lr}
 8045882:	4605      	mov	r5, r0
 8045884:	460c      	mov	r4, r1
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
 8045886:	f011 0f03 	tst.w	r1, #3
 804588a:	d105      	bne.n	8045898 <do_memp_free_pool+0x18>
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
 804588c:	68ab      	ldr	r3, [r5, #8]
 804588e:	681b      	ldr	r3, [r3, #0]
 8045890:	6023      	str	r3, [r4, #0]
  *desc->tab = memp;
 8045892:	68ab      	ldr	r3, [r5, #8]
 8045894:	601c      	str	r4, [r3, #0]
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
 8045896:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("memp_free: mem properly aligned",
 8045898:	4b03      	ldr	r3, [pc, #12]	; (80458a8 <do_memp_free_pool+0x28>)
 804589a:	f44f 72ce 	mov.w	r2, #412	; 0x19c
 804589e:	4903      	ldr	r1, [pc, #12]	; (80458ac <do_memp_free_pool+0x2c>)
 80458a0:	4803      	ldr	r0, [pc, #12]	; (80458b0 <do_memp_free_pool+0x30>)
 80458a2:	f00b fca3 	bl	80511ec <printf>
 80458a6:	e7f1      	b.n	804588c <do_memp_free_pool+0xc>
 80458a8:	080587f8 	.word	0x080587f8
 80458ac:	0805884c 	.word	0x0805884c
 80458b0:	08058644 	.word	0x08058644

080458b4 <memp_init_pool>:
  *desc->tab = NULL;
 80458b4:	6883      	ldr	r3, [r0, #8]
 80458b6:	2200      	movs	r2, #0
 80458b8:	601a      	str	r2, [r3, #0]
  memp = (struct memp*)LWIP_MEM_ALIGN(desc->base);
 80458ba:	6843      	ldr	r3, [r0, #4]
 80458bc:	3303      	adds	r3, #3
 80458be:	f023 0303 	bic.w	r3, r3, #3
  for (i = 0; i < desc->num; ++i) {
 80458c2:	8841      	ldrh	r1, [r0, #2]
 80458c4:	4291      	cmp	r1, r2
 80458c6:	dd08      	ble.n	80458da <memp_init_pool+0x26>
    memp->next = *desc->tab;
 80458c8:	6881      	ldr	r1, [r0, #8]
 80458ca:	6809      	ldr	r1, [r1, #0]
 80458cc:	6019      	str	r1, [r3, #0]
    *desc->tab = memp;
 80458ce:	6881      	ldr	r1, [r0, #8]
 80458d0:	600b      	str	r3, [r1, #0]
   memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
 80458d2:	8801      	ldrh	r1, [r0, #0]
 80458d4:	440b      	add	r3, r1
  for (i = 0; i < desc->num; ++i) {
 80458d6:	3201      	adds	r2, #1
 80458d8:	e7f3      	b.n	80458c2 <memp_init_pool+0xe>
}
 80458da:	4770      	bx	lr

080458dc <memp_init>:
{
 80458dc:	b510      	push	{r4, lr}
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80458de:	2400      	movs	r4, #0
 80458e0:	e006      	b.n	80458f0 <memp_init+0x14>
    memp_init_pool(memp_pools[i]);
 80458e2:	4b05      	ldr	r3, [pc, #20]	; (80458f8 <memp_init+0x1c>)
 80458e4:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80458e8:	f7ff ffe4 	bl	80458b4 <memp_init_pool>
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
 80458ec:	3401      	adds	r4, #1
 80458ee:	b2a4      	uxth	r4, r4
 80458f0:	2c08      	cmp	r4, #8
 80458f2:	d9f6      	bls.n	80458e2 <memp_init+0x6>
}
 80458f4:	bd10      	pop	{r4, pc}
 80458f6:	bf00      	nop
 80458f8:	080584d0 	.word	0x080584d0

080458fc <memp_malloc>:
{
 80458fc:	b508      	push	{r3, lr}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 80458fe:	2808      	cmp	r0, #8
 8045900:	d805      	bhi.n	804590e <memp_malloc+0x12>
  memp = do_memp_malloc_pool(memp_pools[type]);
 8045902:	4b07      	ldr	r3, [pc, #28]	; (8045920 <memp_malloc+0x24>)
 8045904:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8045908:	f7ff ffa0 	bl	804584c <do_memp_malloc_pool>
}
 804590c:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 804590e:	4b05      	ldr	r3, [pc, #20]	; (8045924 <memp_malloc+0x28>)
 8045910:	f240 1287 	movw	r2, #391	; 0x187
 8045914:	4904      	ldr	r1, [pc, #16]	; (8045928 <memp_malloc+0x2c>)
 8045916:	4805      	ldr	r0, [pc, #20]	; (804592c <memp_malloc+0x30>)
 8045918:	f00b fc68 	bl	80511ec <printf>
 804591c:	2000      	movs	r0, #0
 804591e:	e7f5      	b.n	804590c <memp_malloc+0x10>
 8045920:	080584d0 	.word	0x080584d0
 8045924:	080587f8 	.word	0x080587f8
 8045928:	08058880 	.word	0x08058880
 804592c:	08058644 	.word	0x08058644

08045930 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 8045930:	b508      	push	{r3, lr}
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8045932:	2808      	cmp	r0, #8
 8045934:	d806      	bhi.n	8045944 <memp_free+0x14>

  if (mem == NULL) {
 8045936:	b121      	cbz	r1, 8045942 <memp_free+0x12>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
 8045938:	4b06      	ldr	r3, [pc, #24]	; (8045954 <memp_free+0x24>)
 804593a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 804593e:	f7ff ff9f 	bl	8045880 <do_memp_free_pool>
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
 8045942:	bd08      	pop	{r3, pc}
  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
 8045944:	4b04      	ldr	r3, [pc, #16]	; (8045958 <memp_free+0x28>)
 8045946:	f240 12db 	movw	r2, #475	; 0x1db
 804594a:	4904      	ldr	r1, [pc, #16]	; (804595c <memp_free+0x2c>)
 804594c:	4804      	ldr	r0, [pc, #16]	; (8045960 <memp_free+0x30>)
 804594e:	f00b fc4d 	bl	80511ec <printf>
 8045952:	e7f6      	b.n	8045942 <memp_free+0x12>
 8045954:	080584d0 	.word	0x080584d0
 8045958:	080587f8 	.word	0x080587f8
 804595c:	080588a0 	.word	0x080588a0
 8045960:	08058644 	.word	0x08058644

08045964 <netif_issue_reports>:
 */
static void
netif_issue_reports(struct netif* netif, u8_t report_type)
{
#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 8045964:	f011 0f01 	tst.w	r1, #1
 8045968:	d00c      	beq.n	8045984 <netif_issue_reports+0x20>
{
 804596a:	b508      	push	{r3, lr}
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 804596c:	6843      	ldr	r3, [r0, #4]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
 804596e:	b123      	cbz	r3, 804597a <netif_issue_reports+0x16>
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
 8045970:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8045974:	f013 0f08 	tst.w	r3, #8
 8045978:	d100      	bne.n	804597c <netif_issue_reports+0x18>
    /* Send Router Solicitation messages. */
    netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
  }
#endif /* LWIP_IPV6 */
}
 804597a:	bd08      	pop	{r3, pc}
      etharp_gratuitous(netif);
 804597c:	1d01      	adds	r1, r0, #4
 804597e:	f004 fc4b 	bl	804a218 <etharp_request>
}
 8045982:	e7fa      	b.n	804597a <netif_issue_reports+0x16>
 8045984:	4770      	bx	lr

08045986 <netif_init>:
}
 8045986:	4770      	bx	lr

08045988 <netif_set_ipaddr>:
{
 8045988:	b570      	push	{r4, r5, r6, lr}
 804598a:	b082      	sub	sp, #8
 804598c:	4604      	mov	r4, r0
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 804598e:	460d      	mov	r5, r1
 8045990:	b139      	cbz	r1, 80459a2 <netif_set_ipaddr+0x1a>
 8045992:	680b      	ldr	r3, [r1, #0]
 8045994:	9301      	str	r3, [sp, #4]
  if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
 8045996:	6863      	ldr	r3, [r4, #4]
 8045998:	9a01      	ldr	r2, [sp, #4]
 804599a:	429a      	cmp	r2, r3
 804599c:	d105      	bne.n	80459aa <netif_set_ipaddr+0x22>
}
 804599e:	b002      	add	sp, #8
 80459a0:	bd70      	pop	{r4, r5, r6, pc}
  *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
 80459a2:	4b0b      	ldr	r3, [pc, #44]	; (80459d0 <netif_set_ipaddr+0x48>)
 80459a4:	681b      	ldr	r3, [r3, #0]
 80459a6:	9301      	str	r3, [sp, #4]
 80459a8:	e7f5      	b.n	8045996 <netif_set_ipaddr+0xe>
    tcp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 80459aa:	1d26      	adds	r6, r4, #4
 80459ac:	a901      	add	r1, sp, #4
 80459ae:	4630      	mov	r0, r6
 80459b0:	f001 fcc6 	bl	8047340 <tcp_netif_ip_addr_changed>
    udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
 80459b4:	a901      	add	r1, sp, #4
 80459b6:	4630      	mov	r0, r6
 80459b8:	f004 f9c8 	bl	8049d4c <udp_netif_ip_addr_changed>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 80459bc:	b135      	cbz	r5, 80459cc <netif_set_ipaddr+0x44>
 80459be:	682b      	ldr	r3, [r5, #0]
 80459c0:	6063      	str	r3, [r4, #4]
    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
 80459c2:	2101      	movs	r1, #1
 80459c4:	4620      	mov	r0, r4
 80459c6:	f7ff ffcd 	bl	8045964 <netif_issue_reports>
}
 80459ca:	e7e8      	b.n	804599e <netif_set_ipaddr+0x16>
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
 80459cc:	2300      	movs	r3, #0
 80459ce:	e7f7      	b.n	80459c0 <netif_set_ipaddr+0x38>
 80459d0:	080585d0 	.word	0x080585d0

080459d4 <netif_set_gw>:
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 80459d4:	b111      	cbz	r1, 80459dc <netif_set_gw+0x8>
 80459d6:	680b      	ldr	r3, [r1, #0]
 80459d8:	60c3      	str	r3, [r0, #12]
}
 80459da:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->gw), gw);
 80459dc:	2300      	movs	r3, #0
 80459de:	e7fb      	b.n	80459d8 <netif_set_gw+0x4>

080459e0 <netif_set_netmask>:
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80459e0:	b111      	cbz	r1, 80459e8 <netif_set_netmask+0x8>
 80459e2:	680b      	ldr	r3, [r1, #0]
 80459e4:	6083      	str	r3, [r0, #8]
}
 80459e6:	4770      	bx	lr
  ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
 80459e8:	2300      	movs	r3, #0
 80459ea:	e7fb      	b.n	80459e4 <netif_set_netmask+0x4>

080459ec <netif_set_addr>:
{
 80459ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80459ee:	4604      	mov	r4, r0
 80459f0:	4616      	mov	r6, r2
 80459f2:	461d      	mov	r5, r3
  if (ip4_addr_isany(ipaddr)) {
 80459f4:	460f      	mov	r7, r1
 80459f6:	b109      	cbz	r1, 80459fc <netif_set_addr+0x10>
 80459f8:	680b      	ldr	r3, [r1, #0]
 80459fa:	b963      	cbnz	r3, 8045a16 <netif_set_addr+0x2a>
    netif_set_ipaddr(netif, ipaddr);
 80459fc:	4639      	mov	r1, r7
 80459fe:	4620      	mov	r0, r4
 8045a00:	f7ff ffc2 	bl	8045988 <netif_set_ipaddr>
    netif_set_netmask(netif, netmask);
 8045a04:	4631      	mov	r1, r6
 8045a06:	4620      	mov	r0, r4
 8045a08:	f7ff ffea 	bl	80459e0 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8045a0c:	4629      	mov	r1, r5
 8045a0e:	4620      	mov	r0, r4
 8045a10:	f7ff ffe0 	bl	80459d4 <netif_set_gw>
}
 8045a14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    netif_set_netmask(netif, netmask);
 8045a16:	4611      	mov	r1, r2
 8045a18:	f7ff ffe2 	bl	80459e0 <netif_set_netmask>
    netif_set_gw(netif, gw);
 8045a1c:	4629      	mov	r1, r5
 8045a1e:	4620      	mov	r0, r4
 8045a20:	f7ff ffd8 	bl	80459d4 <netif_set_gw>
    netif_set_ipaddr(netif, ipaddr);
 8045a24:	4639      	mov	r1, r7
 8045a26:	4620      	mov	r0, r4
 8045a28:	f7ff ffae 	bl	8045988 <netif_set_ipaddr>
}
 8045a2c:	e7f2      	b.n	8045a14 <netif_set_addr+0x28>
	...

08045a30 <netif_add>:
{
 8045a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8045a34:	4604      	mov	r4, r0
 8045a36:	460d      	mov	r5, r1
 8045a38:	4616      	mov	r6, r2
 8045a3a:	461f      	mov	r7, r3
 8045a3c:	f8dd 801c 	ldr.w	r8, [sp, #28]
  LWIP_ASSERT("No init function given", init != NULL);
 8045a40:	f1b8 0f00 	cmp.w	r8, #0
 8045a44:	d022      	beq.n	8045a8c <netif_add+0x5c>
  ip_addr_set_zero_ip4(&netif->ip_addr);
 8045a46:	2000      	movs	r0, #0
 8045a48:	6060      	str	r0, [r4, #4]
  ip_addr_set_zero_ip4(&netif->netmask);
 8045a4a:	60a0      	str	r0, [r4, #8]
  ip_addr_set_zero_ip4(&netif->gw);
 8045a4c:	60e0      	str	r0, [r4, #12]
  netif->flags = 0;
 8045a4e:	f884 002b 	strb.w	r0, [r4, #43]	; 0x2b
  netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
 8045a52:	2303      	movs	r3, #3
 8045a54:	f884 3020 	strb.w	r3, [r4, #32]
  netif->state = state;
 8045a58:	9b06      	ldr	r3, [sp, #24]
 8045a5a:	61e3      	str	r3, [r4, #28]
  netif->num = netif_num++;
 8045a5c:	4a10      	ldr	r2, [pc, #64]	; (8045aa0 <netif_add+0x70>)
 8045a5e:	7813      	ldrb	r3, [r2, #0]
 8045a60:	1c59      	adds	r1, r3, #1
 8045a62:	7011      	strb	r1, [r2, #0]
 8045a64:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
  netif->input = input;
 8045a68:	9b08      	ldr	r3, [sp, #32]
 8045a6a:	6123      	str	r3, [r4, #16]
  netif_set_addr(netif, ipaddr, netmask, gw);
 8045a6c:	463b      	mov	r3, r7
 8045a6e:	4632      	mov	r2, r6
 8045a70:	4629      	mov	r1, r5
 8045a72:	4620      	mov	r0, r4
 8045a74:	f7ff ffba 	bl	80459ec <netif_set_addr>
  if (init(netif) != ERR_OK) {
 8045a78:	4620      	mov	r0, r4
 8045a7a:	47c0      	blx	r8
 8045a7c:	b968      	cbnz	r0, 8045a9a <netif_add+0x6a>
  netif->next = netif_list;
 8045a7e:	4b09      	ldr	r3, [pc, #36]	; (8045aa4 <netif_add+0x74>)
 8045a80:	681a      	ldr	r2, [r3, #0]
 8045a82:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 8045a84:	601c      	str	r4, [r3, #0]
  return netif;
 8045a86:	4620      	mov	r0, r4
}
 8045a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("No init function given", init != NULL);
 8045a8c:	4b06      	ldr	r3, [pc, #24]	; (8045aa8 <netif_add+0x78>)
 8045a8e:	22fb      	movs	r2, #251	; 0xfb
 8045a90:	4906      	ldr	r1, [pc, #24]	; (8045aac <netif_add+0x7c>)
 8045a92:	4807      	ldr	r0, [pc, #28]	; (8045ab0 <netif_add+0x80>)
 8045a94:	f00b fbaa 	bl	80511ec <printf>
 8045a98:	e7d5      	b.n	8045a46 <netif_add+0x16>
    return NULL;
 8045a9a:	2000      	movs	r0, #0
 8045a9c:	e7f4      	b.n	8045a88 <netif_add+0x58>
 8045a9e:	bf00      	nop
 8045aa0:	200042c8 	.word	0x200042c8
 8045aa4:	2000898c 	.word	0x2000898c
 8045aa8:	080588bc 	.word	0x080588bc
 8045aac:	080588f0 	.word	0x080588f0
 8045ab0:	08058644 	.word	0x08058644

08045ab4 <netif_set_default>:
  netif_default = netif;
 8045ab4:	4b01      	ldr	r3, [pc, #4]	; (8045abc <netif_set_default+0x8>)
 8045ab6:	6018      	str	r0, [r3, #0]
}
 8045ab8:	4770      	bx	lr
 8045aba:	bf00      	nop
 8045abc:	20008990 	.word	0x20008990

08045ac0 <netif_set_up>:
{
 8045ac0:	b508      	push	{r3, lr}
  if (!(netif->flags & NETIF_FLAG_UP)) {
 8045ac2:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8045ac6:	f013 0f01 	tst.w	r3, #1
 8045aca:	d106      	bne.n	8045ada <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 8045acc:	f043 0301 	orr.w	r3, r3, #1
 8045ad0:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    if (netif->flags & NETIF_FLAG_LINK_UP) {
 8045ad4:	f013 0f04 	tst.w	r3, #4
 8045ad8:	d100      	bne.n	8045adc <netif_set_up+0x1c>
}
 8045ada:	bd08      	pop	{r3, pc}
      netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
 8045adc:	2103      	movs	r1, #3
 8045ade:	f7ff ff41 	bl	8045964 <netif_issue_reports>
}
 8045ae2:	e7fa      	b.n	8045ada <netif_set_up+0x1a>

08045ae4 <netif_set_down>:
 * @ingroup netif
 * Bring an interface down, disabling any traffic processing.
 */
void
netif_set_down(struct netif *netif)
{
 8045ae4:	b508      	push	{r3, lr}
  if (netif->flags & NETIF_FLAG_UP) {
 8045ae6:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 8045aea:	f013 0f01 	tst.w	r3, #1
 8045aee:	d006      	beq.n	8045afe <netif_set_down+0x1a>
    netif->flags &= ~NETIF_FLAG_UP;
 8045af0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8045af4:	f880 302b 	strb.w	r3, [r0, #43]	; 0x2b
    MIB2_COPY_SYSUPTIME_TO(&netif->ts);

#if LWIP_IPV4 && LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8045af8:	f013 0f08 	tst.w	r3, #8
 8045afc:	d100      	bne.n	8045b00 <netif_set_down+0x1c>
    nd6_cleanup_netif(netif);
#endif /* LWIP_IPV6 */

    NETIF_STATUS_CALLBACK(netif);
  }
}
 8045afe:	bd08      	pop	{r3, pc}
      etharp_cleanup_netif(netif);
 8045b00:	f004 fb10 	bl	804a124 <etharp_cleanup_netif>
}
 8045b04:	e7fb      	b.n	8045afe <netif_set_down+0x1a>
	...

08045b08 <pbuf_pool_is_empty>:
/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
 8045b08:	4b01      	ldr	r3, [pc, #4]	; (8045b10 <pbuf_pool_is_empty+0x8>)
 8045b0a:	2201      	movs	r2, #1
 8045b0c:	701a      	strb	r2, [r3, #0]
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 8045b0e:	4770      	bx	lr
 8045b10:	20008994 	.word	0x20008994

08045b14 <pbuf_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
 8045b14:	b570      	push	{r4, r5, r6, lr}
 8045b16:	460c      	mov	r4, r1
 8045b18:	4616      	mov	r6, r2
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 8045b1a:	4605      	mov	r5, r0
 8045b1c:	b1c0      	cbz	r0, 8045b50 <pbuf_header_impl+0x3c>
  if ((header_size_increment == 0) || (p == NULL)) {
 8045b1e:	2c00      	cmp	r4, #0
 8045b20:	d04e      	beq.n	8045bc0 <pbuf_header_impl+0xac>
 8045b22:	2d00      	cmp	r5, #0
 8045b24:	d04e      	beq.n	8045bc4 <pbuf_header_impl+0xb0>
    return 0;
  }

  if (header_size_increment < 0) {
 8045b26:	2c00      	cmp	r4, #0
 8045b28:	db1a      	blt.n	8045b60 <pbuf_header_impl+0x4c>
    increment_magnitude = (u16_t)-header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = (u16_t)header_size_increment;
 8045b2a:	b2a2      	uxth	r2, r4
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 8045b2c:	7b2b      	ldrb	r3, [r5, #12]
  /* remember current payload pointer */
  payload = p->payload;
 8045b2e:	6869      	ldr	r1, [r5, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 8045b30:	b32b      	cbz	r3, 8045b7e <pbuf_header_impl+0x6a>
 8045b32:	2b03      	cmp	r3, #3
 8045b34:	d023      	beq.n	8045b7e <pbuf_header_impl+0x6a>
      p->payload = payload;
      /* bail out unsuccessfully */
      return 1;
    }
  /* pbuf types referring to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 8045b36:	3b01      	subs	r3, #1
 8045b38:	b29b      	uxth	r3, r3
 8045b3a:	2b01      	cmp	r3, #1
 8045b3c:	d837      	bhi.n	8045bae <pbuf_header_impl+0x9a>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8045b3e:	2c00      	cmp	r4, #0
 8045b40:	db2f      	blt.n	8045ba2 <pbuf_header_impl+0x8e>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else if ((header_size_increment > 0) && force) {
 8045b42:	2c00      	cmp	r4, #0
 8045b44:	dd40      	ble.n	8045bc8 <pbuf_header_impl+0xb4>
 8045b46:	2e00      	cmp	r6, #0
 8045b48:	d040      	beq.n	8045bcc <pbuf_header_impl+0xb8>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8045b4a:	1b09      	subs	r1, r1, r4
 8045b4c:	6069      	str	r1, [r5, #4]
 8045b4e:	e01c      	b.n	8045b8a <pbuf_header_impl+0x76>
  LWIP_ASSERT("p != NULL", p != NULL);
 8045b50:	4b1f      	ldr	r3, [pc, #124]	; (8045bd0 <pbuf_header_impl+0xbc>)
 8045b52:	f240 223f 	movw	r2, #575	; 0x23f
 8045b56:	491f      	ldr	r1, [pc, #124]	; (8045bd4 <pbuf_header_impl+0xc0>)
 8045b58:	481f      	ldr	r0, [pc, #124]	; (8045bd8 <pbuf_header_impl+0xc4>)
 8045b5a:	f00b fb47 	bl	80511ec <printf>
 8045b5e:	e7de      	b.n	8045b1e <pbuf_header_impl+0xa>
    increment_magnitude = (u16_t)-header_size_increment;
 8045b60:	b2a2      	uxth	r2, r4
 8045b62:	4252      	negs	r2, r2
 8045b64:	b292      	uxth	r2, r2
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 8045b66:	896b      	ldrh	r3, [r5, #10]
 8045b68:	4293      	cmp	r3, r2
 8045b6a:	d2df      	bcs.n	8045b2c <pbuf_header_impl+0x18>
 8045b6c:	4b18      	ldr	r3, [pc, #96]	; (8045bd0 <pbuf_header_impl+0xbc>)
 8045b6e:	f240 2247 	movw	r2, #583	; 0x247
 8045b72:	491a      	ldr	r1, [pc, #104]	; (8045bdc <pbuf_header_impl+0xc8>)
 8045b74:	4818      	ldr	r0, [pc, #96]	; (8045bd8 <pbuf_header_impl+0xc4>)
 8045b76:	f00b fb39 	bl	80511ec <printf>
 8045b7a:	2001      	movs	r0, #1
 8045b7c:	e021      	b.n	8045bc2 <pbuf_header_impl+0xae>
    p->payload = (u8_t *)p->payload - header_size_increment;
 8045b7e:	1b0b      	subs	r3, r1, r4
 8045b80:	606b      	str	r3, [r5, #4]
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 8045b82:	f105 0210 	add.w	r2, r5, #16
 8045b86:	4293      	cmp	r3, r2
 8045b88:	d308      	bcc.n	8045b9c <pbuf_header_impl+0x88>
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 8045b8a:	b2a4      	uxth	r4, r4
 8045b8c:	896b      	ldrh	r3, [r5, #10]
 8045b8e:	4423      	add	r3, r4
 8045b90:	816b      	strh	r3, [r5, #10]
  p->tot_len += header_size_increment;
 8045b92:	8929      	ldrh	r1, [r5, #8]
 8045b94:	440c      	add	r4, r1
 8045b96:	812c      	strh	r4, [r5, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 8045b98:	2000      	movs	r0, #0
 8045b9a:	e012      	b.n	8045bc2 <pbuf_header_impl+0xae>
      p->payload = payload;
 8045b9c:	6069      	str	r1, [r5, #4]
      return 1;
 8045b9e:	2001      	movs	r0, #1
 8045ba0:	e00f      	b.n	8045bc2 <pbuf_header_impl+0xae>
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8045ba2:	896b      	ldrh	r3, [r5, #10]
 8045ba4:	4293      	cmp	r3, r2
 8045ba6:	d3cc      	bcc.n	8045b42 <pbuf_header_impl+0x2e>
      p->payload = (u8_t *)p->payload - header_size_increment;
 8045ba8:	1b09      	subs	r1, r1, r4
 8045baa:	6069      	str	r1, [r5, #4]
 8045bac:	e7ed      	b.n	8045b8a <pbuf_header_impl+0x76>
    LWIP_ASSERT("bad pbuf type", 0);
 8045bae:	4b08      	ldr	r3, [pc, #32]	; (8045bd0 <pbuf_header_impl+0xbc>)
 8045bb0:	f240 2277 	movw	r2, #631	; 0x277
 8045bb4:	490a      	ldr	r1, [pc, #40]	; (8045be0 <pbuf_header_impl+0xcc>)
 8045bb6:	4808      	ldr	r0, [pc, #32]	; (8045bd8 <pbuf_header_impl+0xc4>)
 8045bb8:	f00b fb18 	bl	80511ec <printf>
    return 1;
 8045bbc:	2001      	movs	r0, #1
 8045bbe:	e000      	b.n	8045bc2 <pbuf_header_impl+0xae>
    return 0;
 8045bc0:	2000      	movs	r0, #0
}
 8045bc2:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
 8045bc4:	2000      	movs	r0, #0
 8045bc6:	e7fc      	b.n	8045bc2 <pbuf_header_impl+0xae>
      return 1;
 8045bc8:	2001      	movs	r0, #1
 8045bca:	e7fa      	b.n	8045bc2 <pbuf_header_impl+0xae>
 8045bcc:	2001      	movs	r0, #1
 8045bce:	e7f8      	b.n	8045bc2 <pbuf_header_impl+0xae>
 8045bd0:	08058908 	.word	0x08058908
 8045bd4:	08058938 	.word	0x08058938
 8045bd8:	08058644 	.word	0x08058644
 8045bdc:	08058944 	.word	0x08058944
 8045be0:	08058964 	.word	0x08058964

08045be4 <pbuf_free_ooseq>:
{
 8045be4:	b510      	push	{r4, lr}
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
 8045be6:	4b07      	ldr	r3, [pc, #28]	; (8045c04 <pbuf_free_ooseq+0x20>)
 8045be8:	2200      	movs	r2, #0
 8045bea:	701a      	strb	r2, [r3, #0]
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8045bec:	4b06      	ldr	r3, [pc, #24]	; (8045c08 <pbuf_free_ooseq+0x24>)
 8045bee:	681c      	ldr	r4, [r3, #0]
 8045bf0:	b13c      	cbz	r4, 8045c02 <pbuf_free_ooseq+0x1e>
    if (NULL != pcb->ooseq) {
 8045bf2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8045bf4:	b908      	cbnz	r0, 8045bfa <pbuf_free_ooseq+0x16>
  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 8045bf6:	68e4      	ldr	r4, [r4, #12]
 8045bf8:	e7fa      	b.n	8045bf0 <pbuf_free_ooseq+0xc>
      tcp_segs_free(pcb->ooseq);
 8045bfa:	f000 fd3e 	bl	804667a <tcp_segs_free>
      pcb->ooseq = NULL;
 8045bfe:	2300      	movs	r3, #0
 8045c00:	6723      	str	r3, [r4, #112]	; 0x70
}
 8045c02:	bd10      	pop	{r4, pc}
 8045c04:	20008994 	.word	0x20008994
 8045c08:	2000899c 	.word	0x2000899c

08045c0c <pbuf_alloced_custom>:
{
 8045c0c:	b570      	push	{r4, r5, r6, lr}
 8045c0e:	9c04      	ldr	r4, [sp, #16]
  switch (l) {
 8045c10:	2804      	cmp	r0, #4
 8045c12:	d80a      	bhi.n	8045c2a <pbuf_alloced_custom+0x1e>
 8045c14:	e8df f000 	tbb	[pc, r0]
 8045c18:	05032912 	.word	0x05032912
 8045c1c:	07          	.byte	0x07
 8045c1d:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8045c1e:	200e      	movs	r0, #14
    break;
 8045c20:	e00d      	b.n	8045c3e <pbuf_alloced_custom+0x32>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045c22:	2000      	movs	r0, #0
    break;
 8045c24:	e00b      	b.n	8045c3e <pbuf_alloced_custom+0x32>
    offset = 0;
 8045c26:	2000      	movs	r0, #0
    break;
 8045c28:	e009      	b.n	8045c3e <pbuf_alloced_custom+0x32>
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
 8045c2a:	4b13      	ldr	r3, [pc, #76]	; (8045c78 <pbuf_alloced_custom+0x6c>)
 8045c2c:	f240 12c5 	movw	r2, #453	; 0x1c5
 8045c30:	4912      	ldr	r1, [pc, #72]	; (8045c7c <pbuf_alloced_custom+0x70>)
 8045c32:	4813      	ldr	r0, [pc, #76]	; (8045c80 <pbuf_alloced_custom+0x74>)
 8045c34:	f00b fada 	bl	80511ec <printf>
    return NULL;
 8045c38:	2000      	movs	r0, #0
 8045c3a:	e015      	b.n	8045c68 <pbuf_alloced_custom+0x5c>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045c3c:	2036      	movs	r0, #54	; 0x36
  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 8045c3e:	3003      	adds	r0, #3
 8045c40:	f020 0003 	bic.w	r0, r0, #3
 8045c44:	180e      	adds	r6, r1, r0
 8045c46:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 8045c4a:	42ae      	cmp	r6, r5
 8045c4c:	d812      	bhi.n	8045c74 <pbuf_alloced_custom+0x68>
  p->pbuf.next = NULL;
 8045c4e:	2500      	movs	r5, #0
 8045c50:	601d      	str	r5, [r3, #0]
  if (payload_mem != NULL) {
 8045c52:	b164      	cbz	r4, 8045c6e <pbuf_alloced_custom+0x62>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 8045c54:	4420      	add	r0, r4
 8045c56:	6058      	str	r0, [r3, #4]
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 8045c58:	2002      	movs	r0, #2
 8045c5a:	7358      	strb	r0, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
 8045c5c:	8119      	strh	r1, [r3, #8]
 8045c5e:	8159      	strh	r1, [r3, #10]
  p->pbuf.type = type;
 8045c60:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
 8045c62:	2201      	movs	r2, #1
 8045c64:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
 8045c66:	4618      	mov	r0, r3
}
 8045c68:	bd70      	pop	{r4, r5, r6, pc}
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8045c6a:	2022      	movs	r0, #34	; 0x22
 8045c6c:	e7e7      	b.n	8045c3e <pbuf_alloced_custom+0x32>
    p->pbuf.payload = NULL;
 8045c6e:	2000      	movs	r0, #0
 8045c70:	6058      	str	r0, [r3, #4]
 8045c72:	e7f1      	b.n	8045c58 <pbuf_alloced_custom+0x4c>
    return NULL;
 8045c74:	2000      	movs	r0, #0
 8045c76:	e7f7      	b.n	8045c68 <pbuf_alloced_custom+0x5c>
 8045c78:	08058908 	.word	0x08058908
 8045c7c:	08058974 	.word	0x08058974
 8045c80:	08058644 	.word	0x08058644

08045c84 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 8045c84:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 0);
 8045c86:	2200      	movs	r2, #0
 8045c88:	f7ff ff44 	bl	8045b14 <pbuf_header_impl>
}
 8045c8c:	bd08      	pop	{r3, pc}

08045c8e <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
 8045c8e:	b508      	push	{r3, lr}
   return pbuf_header_impl(p, header_size_increment, 1);
 8045c90:	2201      	movs	r2, #1
 8045c92:	f7ff ff3f 	bl	8045b14 <pbuf_header_impl>
}
 8045c96:	bd08      	pop	{r3, pc}

08045c98 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8045c98:	b570      	push	{r4, r5, r6, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 8045c9a:	b128      	cbz	r0, 8045ca8 <pbuf_free+0x10>
 8045c9c:	4604      	mov	r4, r0
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 8045c9e:	7b03      	ldrb	r3, [r0, #12]
 8045ca0:	2b03      	cmp	r3, #3
 8045ca2:	d80b      	bhi.n	8045cbc <pbuf_free+0x24>
{
 8045ca4:	2500      	movs	r5, #0
 8045ca6:	e01f      	b.n	8045ce8 <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
 8045ca8:	4b27      	ldr	r3, [pc, #156]	; (8045d48 <pbuf_free+0xb0>)
 8045caa:	f240 22d2 	movw	r2, #722	; 0x2d2
 8045cae:	4927      	ldr	r1, [pc, #156]	; (8045d4c <pbuf_free+0xb4>)
 8045cb0:	4827      	ldr	r0, [pc, #156]	; (8045d50 <pbuf_free+0xb8>)
 8045cb2:	f00b fa9b 	bl	80511ec <printf>
    return 0;
 8045cb6:	2500      	movs	r5, #0
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 8045cb8:	4628      	mov	r0, r5
 8045cba:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("pbuf_free: sane type",
 8045cbc:	4b22      	ldr	r3, [pc, #136]	; (8045d48 <pbuf_free+0xb0>)
 8045cbe:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 8045cc2:	4924      	ldr	r1, [pc, #144]	; (8045d54 <pbuf_free+0xbc>)
 8045cc4:	4822      	ldr	r0, [pc, #136]	; (8045d50 <pbuf_free+0xb8>)
 8045cc6:	f00b fa91 	bl	80511ec <printf>
 8045cca:	e7eb      	b.n	8045ca4 <pbuf_free+0xc>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8045ccc:	4b1e      	ldr	r3, [pc, #120]	; (8045d48 <pbuf_free+0xb0>)
 8045cce:	f240 22eb 	movw	r2, #747	; 0x2eb
 8045cd2:	4921      	ldr	r1, [pc, #132]	; (8045d58 <pbuf_free+0xc0>)
 8045cd4:	481e      	ldr	r0, [pc, #120]	; (8045d50 <pbuf_free+0xb8>)
 8045cd6:	f00b fa89 	bl	80511ec <printf>
 8045cda:	e00a      	b.n	8045cf2 <pbuf_free+0x5a>
        pc->custom_free_function(p);
 8045cdc:	6923      	ldr	r3, [r4, #16]
 8045cde:	4620      	mov	r0, r4
 8045ce0:	4798      	blx	r3
      count++;
 8045ce2:	3501      	adds	r5, #1
 8045ce4:	b2ed      	uxtb	r5, r5
      p = q;
 8045ce6:	4634      	mov	r4, r6
  while (p != NULL) {
 8045ce8:	2c00      	cmp	r4, #0
 8045cea:	d0e5      	beq.n	8045cb8 <pbuf_free+0x20>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 8045cec:	89e3      	ldrh	r3, [r4, #14]
 8045cee:	2b00      	cmp	r3, #0
 8045cf0:	d0ec      	beq.n	8045ccc <pbuf_free+0x34>
    ref = --(p->ref);
 8045cf2:	89e3      	ldrh	r3, [r4, #14]
 8045cf4:	3b01      	subs	r3, #1
 8045cf6:	b29b      	uxth	r3, r3
 8045cf8:	81e3      	strh	r3, [r4, #14]
    if (ref == 0) {
 8045cfa:	2b00      	cmp	r3, #0
 8045cfc:	d1dc      	bne.n	8045cb8 <pbuf_free+0x20>
      q = p->next;
 8045cfe:	6826      	ldr	r6, [r4, #0]
      type = p->type;
 8045d00:	7b23      	ldrb	r3, [r4, #12]
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 8045d02:	7b62      	ldrb	r2, [r4, #13]
 8045d04:	f012 0f02 	tst.w	r2, #2
 8045d08:	d00a      	beq.n	8045d20 <pbuf_free+0x88>
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
 8045d0a:	6923      	ldr	r3, [r4, #16]
 8045d0c:	2b00      	cmp	r3, #0
 8045d0e:	d1e5      	bne.n	8045cdc <pbuf_free+0x44>
 8045d10:	4b0d      	ldr	r3, [pc, #52]	; (8045d48 <pbuf_free+0xb0>)
 8045d12:	f240 22f9 	movw	r2, #761	; 0x2f9
 8045d16:	4911      	ldr	r1, [pc, #68]	; (8045d5c <pbuf_free+0xc4>)
 8045d18:	480d      	ldr	r0, [pc, #52]	; (8045d50 <pbuf_free+0xb8>)
 8045d1a:	f00b fa67 	bl	80511ec <printf>
 8045d1e:	e7dd      	b.n	8045cdc <pbuf_free+0x44>
        if (type == PBUF_POOL) {
 8045d20:	2b03      	cmp	r3, #3
 8045d22:	d007      	beq.n	8045d34 <pbuf_free+0x9c>
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8045d24:	3b01      	subs	r3, #1
 8045d26:	b29b      	uxth	r3, r3
 8045d28:	2b01      	cmp	r3, #1
 8045d2a:	d908      	bls.n	8045d3e <pbuf_free+0xa6>
          mem_free(p);
 8045d2c:	4620      	mov	r0, r4
 8045d2e:	f7ff fc23 	bl	8045578 <mem_free>
 8045d32:	e7d6      	b.n	8045ce2 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF_POOL, p);
 8045d34:	4621      	mov	r1, r4
 8045d36:	2008      	movs	r0, #8
 8045d38:	f7ff fdfa 	bl	8045930 <memp_free>
 8045d3c:	e7d1      	b.n	8045ce2 <pbuf_free+0x4a>
          memp_free(MEMP_PBUF, p);
 8045d3e:	4621      	mov	r1, r4
 8045d40:	2007      	movs	r0, #7
 8045d42:	f7ff fdf5 	bl	8045930 <memp_free>
 8045d46:	e7cc      	b.n	8045ce2 <pbuf_free+0x4a>
 8045d48:	08058908 	.word	0x08058908
 8045d4c:	08058938 	.word	0x08058938
 8045d50:	08058644 	.word	0x08058644
 8045d54:	08058998 	.word	0x08058998
 8045d58:	080589b0 	.word	0x080589b0
 8045d5c:	080589c8 	.word	0x080589c8

08045d60 <pbuf_alloc>:
{
 8045d60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8045d64:	460d      	mov	r5, r1
 8045d66:	4617      	mov	r7, r2
  switch (layer) {
 8045d68:	2804      	cmp	r0, #4
 8045d6a:	d80a      	bhi.n	8045d82 <pbuf_alloc+0x22>
 8045d6c:	e8df f000 	tbb	[pc, r0]
 8045d70:	05033f12 	.word	0x05033f12
 8045d74:	07          	.byte	0x07
 8045d75:	00          	.byte	0x00
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
 8045d76:	240e      	movs	r4, #14
    break;
 8045d78:	e00d      	b.n	8045d96 <pbuf_alloc+0x36>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045d7a:	2400      	movs	r4, #0
    break;
 8045d7c:	e00b      	b.n	8045d96 <pbuf_alloc+0x36>
    offset = 0;
 8045d7e:	2400      	movs	r4, #0
    break;
 8045d80:	e009      	b.n	8045d96 <pbuf_alloc+0x36>
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 8045d82:	4b68      	ldr	r3, [pc, #416]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045d84:	f44f 728b 	mov.w	r2, #278	; 0x116
 8045d88:	4967      	ldr	r1, [pc, #412]	; (8045f28 <pbuf_alloc+0x1c8>)
 8045d8a:	4868      	ldr	r0, [pc, #416]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045d8c:	f00b fa2e 	bl	80511ec <printf>
    return NULL;
 8045d90:	2600      	movs	r6, #0
 8045d92:	e0b9      	b.n	8045f08 <pbuf_alloc+0x1a8>
    offset = PBUF_LINK_ENCAPSULATION_HLEN;
 8045d94:	2436      	movs	r4, #54	; 0x36
  switch (type) {
 8045d96:	2f02      	cmp	r7, #2
 8045d98:	d82b      	bhi.n	8045df2 <pbuf_alloc+0x92>
 8045d9a:	b27b      	sxtb	r3, r7
 8045d9c:	2b00      	cmp	r3, #0
 8045d9e:	f040 80a4 	bne.w	8045eea <pbuf_alloc+0x18a>
 8045da2:	2f00      	cmp	r7, #0
 8045da4:	f040 80b3 	bne.w	8045f0e <pbuf_alloc+0x1ae>
      mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
 8045da8:	f104 0013 	add.w	r0, r4, #19
 8045dac:	f020 0003 	bic.w	r0, r0, #3
 8045db0:	b283      	uxth	r3, r0
 8045db2:	1cea      	adds	r2, r5, #3
 8045db4:	b290      	uxth	r0, r2
 8045db6:	f020 0003 	bic.w	r0, r0, #3
 8045dba:	4418      	add	r0, r3
 8045dbc:	b280      	uxth	r0, r0
      if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
 8045dbe:	f022 0203 	bic.w	r2, r2, #3
 8045dc2:	4290      	cmp	r0, r2
 8045dc4:	f0c0 80ac 	bcc.w	8045f20 <pbuf_alloc+0x1c0>
      p = (struct pbuf*)mem_malloc(alloc_len);
 8045dc8:	f7ff fcae 	bl	8045728 <mem_malloc>
    if (p == NULL) {
 8045dcc:	4606      	mov	r6, r0
 8045dce:	2800      	cmp	r0, #0
 8045dd0:	f000 809a 	beq.w	8045f08 <pbuf_alloc+0x1a8>
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 8045dd4:	f104 0310 	add.w	r3, r4, #16
 8045dd8:	4403      	add	r3, r0
 8045dda:	3303      	adds	r3, #3
 8045ddc:	f023 0303 	bic.w	r3, r3, #3
 8045de0:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 8045de2:	8105      	strh	r5, [r0, #8]
 8045de4:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8045de6:	2300      	movs	r3, #0
 8045de8:	6003      	str	r3, [r0, #0]
    p->type = type;
 8045dea:	7307      	strb	r7, [r0, #12]
    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
 8045dec:	e088      	b.n	8045f00 <pbuf_alloc+0x1a0>
    offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
 8045dee:	2422      	movs	r4, #34	; 0x22
 8045df0:	e7d1      	b.n	8045d96 <pbuf_alloc+0x36>
  switch (type) {
 8045df2:	2f03      	cmp	r7, #3
 8045df4:	f040 808b 	bne.w	8045f0e <pbuf_alloc+0x1ae>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8045df8:	2008      	movs	r0, #8
 8045dfa:	f7ff fd7f 	bl	80458fc <memp_malloc>
    if (p == NULL) {
 8045dfe:	4606      	mov	r6, r0
 8045e00:	b1f8      	cbz	r0, 8045e42 <pbuf_alloc+0xe2>
    p->type = type;
 8045e02:	7307      	strb	r7, [r0, #12]
    p->next = NULL;
 8045e04:	2300      	movs	r3, #0
 8045e06:	6003      	str	r3, [r0, #0]
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8045e08:	f104 0310 	add.w	r3, r4, #16
 8045e0c:	4403      	add	r3, r0
 8045e0e:	3303      	adds	r3, #3
 8045e10:	f023 0303 	bic.w	r3, r3, #3
 8045e14:	6043      	str	r3, [r0, #4]
    p->tot_len = length;
 8045e16:	8105      	strh	r5, [r0, #8]
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8045e18:	1ce2      	adds	r2, r4, #3
 8045e1a:	f022 0203 	bic.w	r2, r2, #3
 8045e1e:	f5c2 7214 	rsb	r2, r2, #592	; 0x250
 8045e22:	42aa      	cmp	r2, r5
 8045e24:	bf28      	it	cs
 8045e26:	462a      	movcs	r2, r5
 8045e28:	b292      	uxth	r2, r2
 8045e2a:	8142      	strh	r2, [r0, #10]
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045e2c:	4413      	add	r3, r2
 8045e2e:	f500 7818 	add.w	r8, r0, #608	; 0x260
 8045e32:	4543      	cmp	r3, r8
 8045e34:	d808      	bhi.n	8045e48 <pbuf_alloc+0xe8>
    p->ref = 1;
 8045e36:	2301      	movs	r3, #1
 8045e38:	81f3      	strh	r3, [r6, #14]
    rem_len = length - p->len;
 8045e3a:	8971      	ldrh	r1, [r6, #10]
 8045e3c:	1a6d      	subs	r5, r5, r1
    r = p;
 8045e3e:	46b1      	mov	r9, r6
    while (rem_len > 0) {
 8045e40:	e02d      	b.n	8045e9e <pbuf_alloc+0x13e>
      PBUF_POOL_IS_EMPTY();
 8045e42:	f7ff fe61 	bl	8045b08 <pbuf_pool_is_empty>
      return NULL;
 8045e46:	e05f      	b.n	8045f08 <pbuf_alloc+0x1a8>
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045e48:	4b36      	ldr	r3, [pc, #216]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045e4a:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8045e4e:	4938      	ldr	r1, [pc, #224]	; (8045f30 <pbuf_alloc+0x1d0>)
 8045e50:	4836      	ldr	r0, [pc, #216]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045e52:	f00b f9cb 	bl	80511ec <printf>
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
 8045e56:	e7ee      	b.n	8045e36 <pbuf_alloc+0xd6>
        PBUF_POOL_IS_EMPTY();
 8045e58:	f7ff fe56 	bl	8045b08 <pbuf_pool_is_empty>
        pbuf_free(p);
 8045e5c:	4630      	mov	r0, r6
 8045e5e:	f7ff ff1b 	bl	8045c98 <pbuf_free>
        return NULL;
 8045e62:	4626      	mov	r6, r4
 8045e64:	e050      	b.n	8045f08 <pbuf_alloc+0x1a8>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8045e66:	4b2f      	ldr	r3, [pc, #188]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045e68:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 8045e6c:	4931      	ldr	r1, [pc, #196]	; (8045f34 <pbuf_alloc+0x1d4>)
 8045e6e:	482f      	ldr	r0, [pc, #188]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045e70:	f00b f9bc 	bl	80511ec <printf>
 8045e74:	e025      	b.n	8045ec2 <pbuf_alloc+0x162>
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8045e76:	4b2b      	ldr	r3, [pc, #172]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045e78:	f240 1251 	movw	r2, #337	; 0x151
 8045e7c:	492e      	ldr	r1, [pc, #184]	; (8045f38 <pbuf_alloc+0x1d8>)
 8045e7e:	482b      	ldr	r0, [pc, #172]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045e80:	f00b f9b4 	bl	80511ec <printf>
 8045e84:	e02b      	b.n	8045ede <pbuf_alloc+0x17e>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045e86:	4b27      	ldr	r3, [pc, #156]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045e88:	f240 1253 	movw	r2, #339	; 0x153
 8045e8c:	4928      	ldr	r1, [pc, #160]	; (8045f30 <pbuf_alloc+0x1d0>)
 8045e8e:	4827      	ldr	r0, [pc, #156]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045e90:	f00b f9ac 	bl	80511ec <printf>
      q->ref = 1;
 8045e94:	2301      	movs	r3, #1
 8045e96:	81e3      	strh	r3, [r4, #14]
      rem_len -= q->len;
 8045e98:	8963      	ldrh	r3, [r4, #10]
 8045e9a:	1aed      	subs	r5, r5, r3
      r = q;
 8045e9c:	46a1      	mov	r9, r4
    while (rem_len > 0) {
 8045e9e:	2d00      	cmp	r5, #0
 8045ea0:	dd2e      	ble.n	8045f00 <pbuf_alloc+0x1a0>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8045ea2:	2008      	movs	r0, #8
 8045ea4:	f7ff fd2a 	bl	80458fc <memp_malloc>
      if (q == NULL) {
 8045ea8:	4604      	mov	r4, r0
 8045eaa:	2800      	cmp	r0, #0
 8045eac:	d0d4      	beq.n	8045e58 <pbuf_alloc+0xf8>
      q->type = type;
 8045eae:	7307      	strb	r7, [r0, #12]
      q->flags = 0;
 8045eb0:	2300      	movs	r3, #0
 8045eb2:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 8045eb4:	6003      	str	r3, [r0, #0]
      r->next = q;
 8045eb6:	f8c9 0000 	str.w	r0, [r9]
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8045eba:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8045ebe:	429d      	cmp	r5, r3
 8045ec0:	dcd1      	bgt.n	8045e66 <pbuf_alloc+0x106>
      q->tot_len = (u16_t)rem_len;
 8045ec2:	b2ab      	uxth	r3, r5
 8045ec4:	8123      	strh	r3, [r4, #8]
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8045ec6:	f5b3 7f14 	cmp.w	r3, #592	; 0x250
 8045eca:	bf28      	it	cs
 8045ecc:	f44f 7314 	movcs.w	r3, #592	; 0x250
 8045ed0:	8163      	strh	r3, [r4, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8045ed2:	f104 0310 	add.w	r3, r4, #16
 8045ed6:	6063      	str	r3, [r4, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8045ed8:	f013 0f03 	tst.w	r3, #3
 8045edc:	d1cb      	bne.n	8045e76 <pbuf_alloc+0x116>
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8045ede:	6873      	ldr	r3, [r6, #4]
 8045ee0:	8972      	ldrh	r2, [r6, #10]
 8045ee2:	4413      	add	r3, r2
 8045ee4:	4598      	cmp	r8, r3
 8045ee6:	d2d5      	bcs.n	8045e94 <pbuf_alloc+0x134>
 8045ee8:	e7cd      	b.n	8045e86 <pbuf_alloc+0x126>
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 8045eea:	2007      	movs	r0, #7
 8045eec:	f7ff fd06 	bl	80458fc <memp_malloc>
    if (p == NULL) {
 8045ef0:	4606      	mov	r6, r0
 8045ef2:	b148      	cbz	r0, 8045f08 <pbuf_alloc+0x1a8>
    p->payload = NULL;
 8045ef4:	2300      	movs	r3, #0
 8045ef6:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
 8045ef8:	8105      	strh	r5, [r0, #8]
 8045efa:	8145      	strh	r5, [r0, #10]
    p->next = NULL;
 8045efc:	6003      	str	r3, [r0, #0]
    p->type = type;
 8045efe:	7307      	strb	r7, [r0, #12]
  p->ref = 1;
 8045f00:	2301      	movs	r3, #1
 8045f02:	81f3      	strh	r3, [r6, #14]
  p->flags = 0;
 8045f04:	2300      	movs	r3, #0
 8045f06:	7373      	strb	r3, [r6, #13]
}
 8045f08:	4630      	mov	r0, r6
 8045f0a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8045f0e:	4b05      	ldr	r3, [pc, #20]	; (8045f24 <pbuf_alloc+0x1c4>)
 8045f10:	f44f 72c6 	mov.w	r2, #396	; 0x18c
 8045f14:	4909      	ldr	r1, [pc, #36]	; (8045f3c <pbuf_alloc+0x1dc>)
 8045f16:	4805      	ldr	r0, [pc, #20]	; (8045f2c <pbuf_alloc+0x1cc>)
 8045f18:	f00b f968 	bl	80511ec <printf>
    return NULL;
 8045f1c:	2600      	movs	r6, #0
 8045f1e:	e7f3      	b.n	8045f08 <pbuf_alloc+0x1a8>
        return NULL;
 8045f20:	2600      	movs	r6, #0
 8045f22:	e7f1      	b.n	8045f08 <pbuf_alloc+0x1a8>
 8045f24:	08058908 	.word	0x08058908
 8045f28:	080589ec 	.word	0x080589ec
 8045f2c:	08058644 	.word	0x08058644
 8045f30:	08058a08 	.word	0x08058a08
 8045f34:	08058a70 	.word	0x08058a70
 8045f38:	08058a84 	.word	0x08058a84
 8045f3c:	08058ab4 	.word	0x08058ab4

08045f40 <pbuf_realloc>:
{
 8045f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8045f44:	460e      	mov	r6, r1
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8045f46:	4604      	mov	r4, r0
 8045f48:	b170      	cbz	r0, 8045f68 <pbuf_realloc+0x28>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8045f4a:	7b23      	ldrb	r3, [r4, #12]
 8045f4c:	2b03      	cmp	r3, #3
 8045f4e:	d004      	beq.n	8045f5a <pbuf_realloc+0x1a>
 8045f50:	2b01      	cmp	r3, #1
 8045f52:	d002      	beq.n	8045f5a <pbuf_realloc+0x1a>
 8045f54:	b10b      	cbz	r3, 8045f5a <pbuf_realloc+0x1a>
 8045f56:	2b02      	cmp	r3, #2
 8045f58:	d10e      	bne.n	8045f78 <pbuf_realloc+0x38>
  if (new_len >= p->tot_len) {
 8045f5a:	8927      	ldrh	r7, [r4, #8]
 8045f5c:	42b7      	cmp	r7, r6
 8045f5e:	d943      	bls.n	8045fe8 <pbuf_realloc+0xa8>
  grow = new_len - p->tot_len;
 8045f60:	eba6 0807 	sub.w	r8, r6, r7
  rem_len = new_len;
 8045f64:	4635      	mov	r5, r6
  while (rem_len > q->len) {
 8045f66:	e01d      	b.n	8045fa4 <pbuf_realloc+0x64>
  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8045f68:	4b2a      	ldr	r3, [pc, #168]	; (8046014 <pbuf_realloc+0xd4>)
 8045f6a:	f240 12f3 	movw	r2, #499	; 0x1f3
 8045f6e:	492a      	ldr	r1, [pc, #168]	; (8046018 <pbuf_realloc+0xd8>)
 8045f70:	482a      	ldr	r0, [pc, #168]	; (804601c <pbuf_realloc+0xdc>)
 8045f72:	f00b f93b 	bl	80511ec <printf>
 8045f76:	e7e8      	b.n	8045f4a <pbuf_realloc+0xa>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 8045f78:	4b26      	ldr	r3, [pc, #152]	; (8046014 <pbuf_realloc+0xd4>)
 8045f7a:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8045f7e:	4928      	ldr	r1, [pc, #160]	; (8046020 <pbuf_realloc+0xe0>)
 8045f80:	4826      	ldr	r0, [pc, #152]	; (804601c <pbuf_realloc+0xdc>)
 8045f82:	f00b f933 	bl	80511ec <printf>
 8045f86:	e7e8      	b.n	8045f5a <pbuf_realloc+0x1a>
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8045f88:	4b22      	ldr	r3, [pc, #136]	; (8046014 <pbuf_realloc+0xd4>)
 8045f8a:	f240 220b 	movw	r2, #523	; 0x20b
 8045f8e:	4925      	ldr	r1, [pc, #148]	; (8046024 <pbuf_realloc+0xe4>)
 8045f90:	4822      	ldr	r0, [pc, #136]	; (804601c <pbuf_realloc+0xdc>)
 8045f92:	f00b f92b 	bl	80511ec <printf>
    q->tot_len += (u16_t)grow;
 8045f96:	1bf3      	subs	r3, r6, r7
 8045f98:	8922      	ldrh	r2, [r4, #8]
 8045f9a:	fa12 f383 	uxtah	r3, r2, r3
 8045f9e:	8123      	strh	r3, [r4, #8]
    q = q->next;
 8045fa0:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8045fa2:	b14c      	cbz	r4, 8045fb8 <pbuf_realloc+0x78>
  while (rem_len > q->len) {
 8045fa4:	8963      	ldrh	r3, [r4, #10]
 8045fa6:	42ab      	cmp	r3, r5
 8045fa8:	d20e      	bcs.n	8045fc8 <pbuf_realloc+0x88>
    rem_len -= q->len;
 8045faa:	1aed      	subs	r5, r5, r3
 8045fac:	b2ad      	uxth	r5, r5
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 8045fae:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8045fb2:	4598      	cmp	r8, r3
 8045fb4:	ddef      	ble.n	8045f96 <pbuf_realloc+0x56>
 8045fb6:	e7e7      	b.n	8045f88 <pbuf_realloc+0x48>
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8045fb8:	4b16      	ldr	r3, [pc, #88]	; (8046014 <pbuf_realloc+0xd4>)
 8045fba:	f240 220f 	movw	r2, #527	; 0x20f
 8045fbe:	491a      	ldr	r1, [pc, #104]	; (8046028 <pbuf_realloc+0xe8>)
 8045fc0:	4816      	ldr	r0, [pc, #88]	; (804601c <pbuf_realloc+0xdc>)
 8045fc2:	f00b f913 	bl	80511ec <printf>
 8045fc6:	e7ed      	b.n	8045fa4 <pbuf_realloc+0x64>
  if ((q->type == PBUF_RAM) && (rem_len != q->len)
 8045fc8:	7b22      	ldrb	r2, [r4, #12]
 8045fca:	b92a      	cbnz	r2, 8045fd8 <pbuf_realloc+0x98>
 8045fcc:	42ab      	cmp	r3, r5
 8045fce:	d003      	beq.n	8045fd8 <pbuf_realloc+0x98>
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
 8045fd0:	7b63      	ldrb	r3, [r4, #13]
 8045fd2:	f013 0f02 	tst.w	r3, #2
 8045fd6:	d009      	beq.n	8045fec <pbuf_realloc+0xac>
  q->len = rem_len;
 8045fd8:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8045fda:	8125      	strh	r5, [r4, #8]
  if (q->next != NULL) {
 8045fdc:	6820      	ldr	r0, [r4, #0]
 8045fde:	b108      	cbz	r0, 8045fe4 <pbuf_realloc+0xa4>
    pbuf_free(q->next);
 8045fe0:	f7ff fe5a 	bl	8045c98 <pbuf_free>
  q->next = NULL;
 8045fe4:	2300      	movs	r3, #0
 8045fe6:	6023      	str	r3, [r4, #0]
}
 8045fe8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8045fec:	6863      	ldr	r3, [r4, #4]
 8045fee:	1b1b      	subs	r3, r3, r4
 8045ff0:	fa15 f183 	uxtah	r1, r5, r3
 8045ff4:	b289      	uxth	r1, r1
 8045ff6:	4620      	mov	r0, r4
 8045ff8:	f7ff fb0c 	bl	8045614 <mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 8045ffc:	4604      	mov	r4, r0
 8045ffe:	2800      	cmp	r0, #0
 8046000:	d1ea      	bne.n	8045fd8 <pbuf_realloc+0x98>
 8046002:	4b04      	ldr	r3, [pc, #16]	; (8046014 <pbuf_realloc+0xd4>)
 8046004:	f240 221d 	movw	r2, #541	; 0x21d
 8046008:	4908      	ldr	r1, [pc, #32]	; (804602c <pbuf_realloc+0xec>)
 804600a:	4804      	ldr	r0, [pc, #16]	; (804601c <pbuf_realloc+0xdc>)
 804600c:	f00b f8ee 	bl	80511ec <printf>
 8046010:	e7e2      	b.n	8045fd8 <pbuf_realloc+0x98>
 8046012:	bf00      	nop
 8046014:	08058908 	.word	0x08058908
 8046018:	08058ad0 	.word	0x08058ad0
 804601c:	08058644 	.word	0x08058644
 8046020:	08058ae8 	.word	0x08058ae8
 8046024:	08058b04 	.word	0x08058b04
 8046028:	08058b18 	.word	0x08058b18
 804602c:	08058b30 	.word	0x08058b30

08046030 <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
 8046030:	4603      	mov	r3, r0
  u16_t len;

  len = 0;
 8046032:	2000      	movs	r0, #0
  while (p != NULL) {
 8046034:	b11b      	cbz	r3, 804603e <pbuf_clen+0xe>
    ++len;
 8046036:	3001      	adds	r0, #1
 8046038:	b280      	uxth	r0, r0
    p = p->next;
 804603a:	681b      	ldr	r3, [r3, #0]
 804603c:	e7fa      	b.n	8046034 <pbuf_clen+0x4>
  }
  return len;
}
 804603e:	4770      	bx	lr

08046040 <pbuf_ref>:
 */
void
pbuf_ref(struct pbuf *p)
{
  /* pbuf given? */
  if (p != NULL) {
 8046040:	b170      	cbz	r0, 8046060 <pbuf_ref+0x20>
{
 8046042:	b508      	push	{r3, lr}
    SYS_ARCH_INC(p->ref, 1);
 8046044:	89c3      	ldrh	r3, [r0, #14]
 8046046:	3301      	adds	r3, #1
 8046048:	b29b      	uxth	r3, r3
 804604a:	81c3      	strh	r3, [r0, #14]
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 804604c:	b103      	cbz	r3, 8046050 <pbuf_ref+0x10>
  }
}
 804604e:	bd08      	pop	{r3, pc}
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
 8046050:	4b04      	ldr	r3, [pc, #16]	; (8046064 <pbuf_ref+0x24>)
 8046052:	f240 3239 	movw	r2, #825	; 0x339
 8046056:	4904      	ldr	r1, [pc, #16]	; (8046068 <pbuf_ref+0x28>)
 8046058:	4804      	ldr	r0, [pc, #16]	; (804606c <pbuf_ref+0x2c>)
 804605a:	f00b f8c7 	bl	80511ec <printf>
}
 804605e:	e7f6      	b.n	804604e <pbuf_ref+0xe>
 8046060:	4770      	bx	lr
 8046062:	bf00      	nop
 8046064:	08058908 	.word	0x08058908
 8046068:	08058b4c 	.word	0x08058b4c
 804606c:	08058644 	.word	0x08058644

08046070 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 8046070:	b538      	push	{r3, r4, r5, lr}
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8046072:	b110      	cbz	r0, 804607a <pbuf_cat+0xa>
 8046074:	460d      	mov	r5, r1
 8046076:	4604      	mov	r4, r0
 8046078:	b961      	cbnz	r1, 8046094 <pbuf_cat+0x24>
 804607a:	4b15      	ldr	r3, [pc, #84]	; (80460d0 <pbuf_cat+0x60>)
 804607c:	f44f 7253 	mov.w	r2, #844	; 0x34c
 8046080:	4914      	ldr	r1, [pc, #80]	; (80460d4 <pbuf_cat+0x64>)
 8046082:	4815      	ldr	r0, [pc, #84]	; (80460d8 <pbuf_cat+0x68>)
 8046084:	f00b f8b2 	bl	80511ec <printf>
 8046088:	e019      	b.n	80460be <pbuf_cat+0x4e>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 804608a:	892b      	ldrh	r3, [r5, #8]
 804608c:	8920      	ldrh	r0, [r4, #8]
 804608e:	4403      	add	r3, r0
 8046090:	8123      	strh	r3, [r4, #8]
  for (p = h; p->next != NULL; p = p->next) {
 8046092:	4614      	mov	r4, r2
 8046094:	6822      	ldr	r2, [r4, #0]
 8046096:	2a00      	cmp	r2, #0
 8046098:	d1f7      	bne.n	804608a <pbuf_cat+0x1a>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 804609a:	8922      	ldrh	r2, [r4, #8]
 804609c:	8963      	ldrh	r3, [r4, #10]
 804609e:	429a      	cmp	r2, r3
 80460a0:	d10e      	bne.n	80460c0 <pbuf_cat+0x50>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80460a2:	6823      	ldr	r3, [r4, #0]
 80460a4:	b133      	cbz	r3, 80460b4 <pbuf_cat+0x44>
 80460a6:	4b0a      	ldr	r3, [pc, #40]	; (80460d0 <pbuf_cat+0x60>)
 80460a8:	f240 3256 	movw	r2, #854	; 0x356
 80460ac:	490b      	ldr	r1, [pc, #44]	; (80460dc <pbuf_cat+0x6c>)
 80460ae:	480a      	ldr	r0, [pc, #40]	; (80460d8 <pbuf_cat+0x68>)
 80460b0:	f00b f89c 	bl	80511ec <printf>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80460b4:	892b      	ldrh	r3, [r5, #8]
 80460b6:	8922      	ldrh	r2, [r4, #8]
 80460b8:	4413      	add	r3, r2
 80460ba:	8123      	strh	r3, [r4, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80460bc:	6025      	str	r5, [r4, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80460be:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80460c0:	4b03      	ldr	r3, [pc, #12]	; (80460d0 <pbuf_cat+0x60>)
 80460c2:	f240 3255 	movw	r2, #853	; 0x355
 80460c6:	4906      	ldr	r1, [pc, #24]	; (80460e0 <pbuf_cat+0x70>)
 80460c8:	4803      	ldr	r0, [pc, #12]	; (80460d8 <pbuf_cat+0x68>)
 80460ca:	f00b f88f 	bl	80511ec <printf>
 80460ce:	e7e8      	b.n	80460a2 <pbuf_cat+0x32>
 80460d0:	08058908 	.word	0x08058908
 80460d4:	08058b60 	.word	0x08058b60
 80460d8:	08058644 	.word	0x08058644
 80460dc:	08058bc8 	.word	0x08058bc8
 80460e0:	08058b98 	.word	0x08058b98

080460e4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
 80460e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (const void*)p_to, (const void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80460e8:	b150      	cbz	r0, 8046100 <pbuf_copy+0x1c>
 80460ea:	460d      	mov	r5, r1
 80460ec:	4607      	mov	r7, r0
 80460ee:	b139      	cbz	r1, 8046100 <pbuf_copy+0x1c>
 80460f0:	8902      	ldrh	r2, [r0, #8]
 80460f2:	890b      	ldrh	r3, [r1, #8]
 80460f4:	429a      	cmp	r2, r3
 80460f6:	d303      	bcc.n	8046100 <pbuf_copy+0x1c>
  u16_t offset_to=0, offset_from=0, len;
 80460f8:	f04f 0800 	mov.w	r8, #0
 80460fc:	4646      	mov	r6, r8
 80460fe:	e03c      	b.n	804617a <pbuf_copy+0x96>
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 8046100:	4b3d      	ldr	r3, [pc, #244]	; (80461f8 <pbuf_copy+0x114>)
 8046102:	f44f 726f 	mov.w	r2, #956	; 0x3bc
 8046106:	493d      	ldr	r1, [pc, #244]	; (80461fc <pbuf_copy+0x118>)
 8046108:	483d      	ldr	r0, [pc, #244]	; (8046200 <pbuf_copy+0x11c>)
 804610a:	f00b f86f 	bl	80511ec <printf>
 804610e:	f06f 000f 	mvn.w	r0, #15
 8046112:	e06e      	b.n	80461f2 <pbuf_copy+0x10e>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 8046114:	1b9b      	subs	r3, r3, r6
 8046116:	b29c      	uxth	r4, r3
 8046118:	e037      	b.n	804618a <pbuf_copy+0xa6>
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 804611a:	4b37      	ldr	r3, [pc, #220]	; (80461f8 <pbuf_copy+0x114>)
 804611c:	f240 32cd 	movw	r2, #973	; 0x3cd
 8046120:	4938      	ldr	r1, [pc, #224]	; (8046204 <pbuf_copy+0x120>)
 8046122:	4837      	ldr	r0, [pc, #220]	; (8046200 <pbuf_copy+0x11c>)
 8046124:	f00b f862 	bl	80511ec <printf>
 8046128:	e03e      	b.n	80461a8 <pbuf_copy+0xc4>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 804612a:	4b33      	ldr	r3, [pc, #204]	; (80461f8 <pbuf_copy+0x114>)
 804612c:	f240 32ce 	movw	r2, #974	; 0x3ce
 8046130:	4935      	ldr	r1, [pc, #212]	; (8046208 <pbuf_copy+0x124>)
 8046132:	4833      	ldr	r0, [pc, #204]	; (8046200 <pbuf_copy+0x11c>)
 8046134:	f00b f85a 	bl	80511ec <printf>
 8046138:	e039      	b.n	80461ae <pbuf_copy+0xca>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 804613a:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 804613c:	b10f      	cbz	r7, 8046142 <pbuf_copy+0x5e>
      offset_to = 0;
 804613e:	2600      	movs	r6, #0
 8046140:	e03e      	b.n	80461c0 <pbuf_copy+0xdc>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8046142:	b90d      	cbnz	r5, 8046148 <pbuf_copy+0x64>
      offset_to = 0;
 8046144:	2600      	movs	r6, #0
 8046146:	e03b      	b.n	80461c0 <pbuf_copy+0xdc>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 8046148:	4b2b      	ldr	r3, [pc, #172]	; (80461f8 <pbuf_copy+0x114>)
 804614a:	f44f 7276 	mov.w	r2, #984	; 0x3d8
 804614e:	492f      	ldr	r1, [pc, #188]	; (804620c <pbuf_copy+0x128>)
 8046150:	482b      	ldr	r0, [pc, #172]	; (8046200 <pbuf_copy+0x11c>)
 8046152:	f00b f84b 	bl	80511ec <printf>
 8046156:	f06f 000f 	mvn.w	r0, #15
 804615a:	e04a      	b.n	80461f2 <pbuf_copy+0x10e>
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 804615c:	682b      	ldr	r3, [r5, #0]
 804615e:	2b00      	cmp	r3, #0
 8046160:	d033      	beq.n	80461ca <pbuf_copy+0xe6>
 8046162:	4b25      	ldr	r3, [pc, #148]	; (80461f8 <pbuf_copy+0x114>)
 8046164:	f240 32dd 	movw	r2, #989	; 0x3dd
 8046168:	4929      	ldr	r1, [pc, #164]	; (8046210 <pbuf_copy+0x12c>)
 804616a:	4825      	ldr	r0, [pc, #148]	; (8046200 <pbuf_copy+0x11c>)
 804616c:	f00b f83e 	bl	80511ec <printf>
 8046170:	f06f 0005 	mvn.w	r0, #5
 8046174:	e03d      	b.n	80461f2 <pbuf_copy+0x10e>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 8046176:	2d00      	cmp	r5, #0
 8046178:	d03a      	beq.n	80461f0 <pbuf_copy+0x10c>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 804617a:	897b      	ldrh	r3, [r7, #10]
 804617c:	1b99      	subs	r1, r3, r6
 804617e:	896c      	ldrh	r4, [r5, #10]
 8046180:	eba4 0208 	sub.w	r2, r4, r8
 8046184:	4291      	cmp	r1, r2
 8046186:	dbc5      	blt.n	8046114 <pbuf_copy+0x30>
      len = p_from->len - offset_from;
 8046188:	b294      	uxth	r4, r2
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 804618a:	6878      	ldr	r0, [r7, #4]
 804618c:	6869      	ldr	r1, [r5, #4]
 804618e:	4622      	mov	r2, r4
 8046190:	4441      	add	r1, r8
 8046192:	4430      	add	r0, r6
 8046194:	f00b f808 	bl	80511a8 <memcpy>
    offset_to += len;
 8046198:	4426      	add	r6, r4
 804619a:	b2b6      	uxth	r6, r6
    offset_from += len;
 804619c:	4444      	add	r4, r8
 804619e:	fa1f f884 	uxth.w	r8, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80461a2:	897b      	ldrh	r3, [r7, #10]
 80461a4:	42b3      	cmp	r3, r6
 80461a6:	d3b8      	bcc.n	804611a <pbuf_copy+0x36>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 80461a8:	896b      	ldrh	r3, [r5, #10]
 80461aa:	4543      	cmp	r3, r8
 80461ac:	d3bd      	bcc.n	804612a <pbuf_copy+0x46>
    if (offset_from >= p_from->len) {
 80461ae:	896b      	ldrh	r3, [r5, #10]
 80461b0:	4543      	cmp	r3, r8
 80461b2:	d802      	bhi.n	80461ba <pbuf_copy+0xd6>
      p_from = p_from->next;
 80461b4:	682d      	ldr	r5, [r5, #0]
      offset_from = 0;
 80461b6:	f04f 0800 	mov.w	r8, #0
    if (offset_to == p_to->len) {
 80461ba:	897b      	ldrh	r3, [r7, #10]
 80461bc:	42b3      	cmp	r3, r6
 80461be:	d0bc      	beq.n	804613a <pbuf_copy+0x56>
    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 80461c0:	b11d      	cbz	r5, 80461ca <pbuf_copy+0xe6>
 80461c2:	896a      	ldrh	r2, [r5, #10]
 80461c4:	892b      	ldrh	r3, [r5, #8]
 80461c6:	429a      	cmp	r2, r3
 80461c8:	d0c8      	beq.n	804615c <pbuf_copy+0x78>
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 80461ca:	2f00      	cmp	r7, #0
 80461cc:	d0d3      	beq.n	8046176 <pbuf_copy+0x92>
 80461ce:	897a      	ldrh	r2, [r7, #10]
 80461d0:	893b      	ldrh	r3, [r7, #8]
 80461d2:	429a      	cmp	r2, r3
 80461d4:	d1cf      	bne.n	8046176 <pbuf_copy+0x92>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
 80461d6:	683b      	ldr	r3, [r7, #0]
 80461d8:	2b00      	cmp	r3, #0
 80461da:	d0cc      	beq.n	8046176 <pbuf_copy+0x92>
 80461dc:	4b06      	ldr	r3, [pc, #24]	; (80461f8 <pbuf_copy+0x114>)
 80461de:	f240 32e2 	movw	r2, #994	; 0x3e2
 80461e2:	490b      	ldr	r1, [pc, #44]	; (8046210 <pbuf_copy+0x12c>)
 80461e4:	4806      	ldr	r0, [pc, #24]	; (8046200 <pbuf_copy+0x11c>)
 80461e6:	f00b f801 	bl	80511ec <printf>
 80461ea:	f06f 0005 	mvn.w	r0, #5
 80461ee:	e000      	b.n	80461f2 <pbuf_copy+0x10e>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 80461f0:	2000      	movs	r0, #0
}
 80461f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80461f6:	bf00      	nop
 80461f8:	08058908 	.word	0x08058908
 80461fc:	08058c14 	.word	0x08058c14
 8046200:	08058644 	.word	0x08058644
 8046204:	08058c44 	.word	0x08058c44
 8046208:	08058c5c 	.word	0x08058c5c
 804620c:	08058c78 	.word	0x08058c78
 8046210:	08058c88 	.word	0x08058c88

08046214 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 8046214:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8046218:	b130      	cbz	r0, 8046228 <pbuf_copy_partial+0x14>
 804621a:	4688      	mov	r8, r1
 804621c:	4691      	mov	r9, r2
 804621e:	4605      	mov	r5, r0
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8046220:	b169      	cbz	r1, 804623e <pbuf_copy_partial+0x2a>
  u16_t copied_total = 0;
 8046222:	2700      	movs	r7, #0

  left = 0;
 8046224:	463e      	mov	r6, r7
 8046226:	e02a      	b.n	804627e <pbuf_copy_partial+0x6a>
  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8046228:	4b1b      	ldr	r3, [pc, #108]	; (8046298 <pbuf_copy_partial+0x84>)
 804622a:	f240 32fe 	movw	r2, #1022	; 0x3fe
 804622e:	491b      	ldr	r1, [pc, #108]	; (804629c <pbuf_copy_partial+0x88>)
 8046230:	481b      	ldr	r0, [pc, #108]	; (80462a0 <pbuf_copy_partial+0x8c>)
 8046232:	f00a ffdb 	bl	80511ec <printf>
 8046236:	2700      	movs	r7, #0
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
 8046238:	4638      	mov	r0, r7
 804623a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 804623e:	4b16      	ldr	r3, [pc, #88]	; (8046298 <pbuf_copy_partial+0x84>)
 8046240:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8046244:	4917      	ldr	r1, [pc, #92]	; (80462a4 <pbuf_copy_partial+0x90>)
 8046246:	4816      	ldr	r0, [pc, #88]	; (80462a0 <pbuf_copy_partial+0x8c>)
 8046248:	f00a ffd0 	bl	80511ec <printf>
 804624c:	2700      	movs	r7, #0
 804624e:	e7f3      	b.n	8046238 <pbuf_copy_partial+0x24>
      buf_copy_len = p->len - offset;
 8046250:	896c      	ldrh	r4, [r5, #10]
 8046252:	1ae4      	subs	r4, r4, r3
 8046254:	b2a4      	uxth	r4, r4
      if (buf_copy_len > len) {
 8046256:	45a1      	cmp	r9, r4
 8046258:	d200      	bcs.n	804625c <pbuf_copy_partial+0x48>
        buf_copy_len = len;
 804625a:	464c      	mov	r4, r9
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 804625c:	6869      	ldr	r1, [r5, #4]
 804625e:	4622      	mov	r2, r4
 8046260:	4419      	add	r1, r3
 8046262:	eb08 0006 	add.w	r0, r8, r6
 8046266:	f00a ff9f 	bl	80511a8 <memcpy>
      copied_total += buf_copy_len;
 804626a:	4427      	add	r7, r4
 804626c:	b2bf      	uxth	r7, r7
      left += buf_copy_len;
 804626e:	4426      	add	r6, r4
 8046270:	b2b6      	uxth	r6, r6
      len -= buf_copy_len;
 8046272:	eba9 0404 	sub.w	r4, r9, r4
 8046276:	fa1f f984 	uxth.w	r9, r4
      offset = 0;
 804627a:	2300      	movs	r3, #0
  for (p = buf; len != 0 && p != NULL; p = p->next) {
 804627c:	682d      	ldr	r5, [r5, #0]
 804627e:	f1b9 0f00 	cmp.w	r9, #0
 8046282:	d0d9      	beq.n	8046238 <pbuf_copy_partial+0x24>
 8046284:	2d00      	cmp	r5, #0
 8046286:	d0d7      	beq.n	8046238 <pbuf_copy_partial+0x24>
    if ((offset != 0) && (offset >= p->len)) {
 8046288:	2b00      	cmp	r3, #0
 804628a:	d0e1      	beq.n	8046250 <pbuf_copy_partial+0x3c>
 804628c:	8969      	ldrh	r1, [r5, #10]
 804628e:	4299      	cmp	r1, r3
 8046290:	d8de      	bhi.n	8046250 <pbuf_copy_partial+0x3c>
      offset -= p->len;
 8046292:	1a5b      	subs	r3, r3, r1
 8046294:	b29b      	uxth	r3, r3
 8046296:	e7f1      	b.n	804627c <pbuf_copy_partial+0x68>
 8046298:	08058908 	.word	0x08058908
 804629c:	08058cb4 	.word	0x08058cb4
 80462a0:	08058644 	.word	0x08058644
 80462a4:	08058cd4 	.word	0x08058cd4

080462a8 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 80462a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 80462ac:	b148      	cbz	r0, 80462c2 <pbuf_take+0x1a>
 80462ae:	4688      	mov	r8, r1
 80462b0:	4691      	mov	r9, r2
 80462b2:	4606      	mov	r6, r0
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 80462b4:	b179      	cbz	r1, 80462d6 <pbuf_take+0x2e>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 80462b6:	8903      	ldrh	r3, [r0, #8]
 80462b8:	4293      	cmp	r3, r2
 80462ba:	d316      	bcc.n	80462ea <pbuf_take+0x42>
  u16_t total_copy_len = len;
 80462bc:	4614      	mov	r4, r2
  u16_t copied_total = 0;
 80462be:	2700      	movs	r7, #0
 80462c0:	e030      	b.n	8046324 <pbuf_take+0x7c>
  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
 80462c2:	4b23      	ldr	r3, [pc, #140]	; (8046350 <pbuf_take+0xa8>)
 80462c4:	f240 4284 	movw	r2, #1156	; 0x484
 80462c8:	4922      	ldr	r1, [pc, #136]	; (8046354 <pbuf_take+0xac>)
 80462ca:	4823      	ldr	r0, [pc, #140]	; (8046358 <pbuf_take+0xb0>)
 80462cc:	f00a ff8e 	bl	80511ec <printf>
 80462d0:	f06f 000f 	mvn.w	r0, #15
 80462d4:	e031      	b.n	804633a <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 80462d6:	4b1e      	ldr	r3, [pc, #120]	; (8046350 <pbuf_take+0xa8>)
 80462d8:	f240 4285 	movw	r2, #1157	; 0x485
 80462dc:	491f      	ldr	r1, [pc, #124]	; (804635c <pbuf_take+0xb4>)
 80462de:	481e      	ldr	r0, [pc, #120]	; (8046358 <pbuf_take+0xb0>)
 80462e0:	f00a ff84 	bl	80511ec <printf>
 80462e4:	f06f 000f 	mvn.w	r0, #15
 80462e8:	e027      	b.n	804633a <pbuf_take+0x92>
  LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
 80462ea:	4b19      	ldr	r3, [pc, #100]	; (8046350 <pbuf_take+0xa8>)
 80462ec:	f240 4286 	movw	r2, #1158	; 0x486
 80462f0:	491b      	ldr	r1, [pc, #108]	; (8046360 <pbuf_take+0xb8>)
 80462f2:	4819      	ldr	r0, [pc, #100]	; (8046358 <pbuf_take+0xb0>)
 80462f4:	f00a ff7a 	bl	80511ec <printf>
 80462f8:	f04f 30ff 	mov.w	r0, #4294967295
 80462fc:	e01d      	b.n	804633a <pbuf_take+0x92>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; total_copy_len != 0; p = p->next) {
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 80462fe:	4b14      	ldr	r3, [pc, #80]	; (8046350 <pbuf_take+0xa8>)
 8046300:	f240 428e 	movw	r2, #1166	; 0x48e
 8046304:	4917      	ldr	r1, [pc, #92]	; (8046364 <pbuf_take+0xbc>)
 8046306:	4814      	ldr	r0, [pc, #80]	; (8046358 <pbuf_take+0xb0>)
 8046308:	f00a ff70 	bl	80511ec <printf>
 804630c:	e00d      	b.n	804632a <pbuf_take+0x82>
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
 804630e:	462a      	mov	r2, r5
 8046310:	eb08 0107 	add.w	r1, r8, r7
 8046314:	6870      	ldr	r0, [r6, #4]
 8046316:	f00a ff47 	bl	80511a8 <memcpy>
    total_copy_len -= buf_copy_len;
 804631a:	1b64      	subs	r4, r4, r5
 804631c:	b2a4      	uxth	r4, r4
    copied_total += buf_copy_len;
 804631e:	442f      	add	r7, r5
 8046320:	b2bf      	uxth	r7, r7
  for (p = buf; total_copy_len != 0; p = p->next) {
 8046322:	6836      	ldr	r6, [r6, #0]
 8046324:	b134      	cbz	r4, 8046334 <pbuf_take+0x8c>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 8046326:	2e00      	cmp	r6, #0
 8046328:	d0e9      	beq.n	80462fe <pbuf_take+0x56>
    if (buf_copy_len > p->len) {
 804632a:	8975      	ldrh	r5, [r6, #10]
 804632c:	42a5      	cmp	r5, r4
 804632e:	d3ee      	bcc.n	804630e <pbuf_take+0x66>
    buf_copy_len = total_copy_len;
 8046330:	4625      	mov	r5, r4
 8046332:	e7ec      	b.n	804630e <pbuf_take+0x66>
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 8046334:	454f      	cmp	r7, r9
 8046336:	d102      	bne.n	804633e <pbuf_take+0x96>
  return ERR_OK;
 8046338:	2000      	movs	r0, #0
}
 804633a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 804633e:	4b04      	ldr	r3, [pc, #16]	; (8046350 <pbuf_take+0xa8>)
 8046340:	f240 4299 	movw	r2, #1177	; 0x499
 8046344:	4908      	ldr	r1, [pc, #32]	; (8046368 <pbuf_take+0xc0>)
 8046346:	4804      	ldr	r0, [pc, #16]	; (8046358 <pbuf_take+0xb0>)
 8046348:	f00a ff50 	bl	80511ec <printf>
  return ERR_OK;
 804634c:	2000      	movs	r0, #0
 804634e:	e7f4      	b.n	804633a <pbuf_take+0x92>
 8046350:	08058908 	.word	0x08058908
 8046354:	08058cf8 	.word	0x08058cf8
 8046358:	08058644 	.word	0x08058644
 804635c:	08058d10 	.word	0x08058d10
 8046360:	08058d2c 	.word	0x08058d2c
 8046364:	08058d4c 	.word	0x08058d4c
 8046368:	08058d64 	.word	0x08058d64

0804636c <tcp_remove_listener>:
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
   struct tcp_pcb *pcb;
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 804636c:	e002      	b.n	8046374 <tcp_remove_listener+0x8>
      if (pcb->listener == lpcb) {
         pcb->listener = NULL;
 804636e:	2300      	movs	r3, #0
 8046370:	6783      	str	r3, [r0, #120]	; 0x78
   for (pcb = list; pcb != NULL; pcb = pcb->next) {
 8046372:	68c0      	ldr	r0, [r0, #12]
 8046374:	b118      	cbz	r0, 804637e <tcp_remove_listener+0x12>
      if (pcb->listener == lpcb) {
 8046376:	6f83      	ldr	r3, [r0, #120]	; 0x78
 8046378:	428b      	cmp	r3, r1
 804637a:	d1fa      	bne.n	8046372 <tcp_remove_listener+0x6>
 804637c:	e7f7      	b.n	804636e <tcp_remove_listener+0x2>
      }
   }
}
 804637e:	4770      	bx	lr

08046380 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 8046380:	b410      	push	{r4}
  u8_t i;
  u16_t n = 0;
 8046382:	2400      	movs	r4, #0
 8046384:	e009      	b.n	804639a <tcp_new_port+0x1a>
  struct tcp_pcb *pcb;

again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 8046386:	4b15      	ldr	r3, [pc, #84]	; (80463dc <tcp_new_port+0x5c>)
 8046388:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 804638c:	801a      	strh	r2, [r3, #0]
 804638e:	e00c      	b.n	80463aa <tcp_new_port+0x2a>
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 8046390:	3401      	adds	r4, #1
 8046392:	b2a4      	uxth	r4, r4
 8046394:	f5b4 4f80 	cmp.w	r4, #16384	; 0x4000
 8046398:	d21e      	bcs.n	80463d8 <tcp_new_port+0x58>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 804639a:	4a10      	ldr	r2, [pc, #64]	; (80463dc <tcp_new_port+0x5c>)
 804639c:	8813      	ldrh	r3, [r2, #0]
 804639e:	1c59      	adds	r1, r3, #1
 80463a0:	8011      	strh	r1, [r2, #0]
 80463a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80463a6:	4293      	cmp	r3, r2
 80463a8:	d0ed      	beq.n	8046386 <tcp_new_port+0x6>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 80463aa:	2000      	movs	r0, #0
 80463ac:	2803      	cmp	r0, #3
 80463ae:	d80e      	bhi.n	80463ce <tcp_new_port+0x4e>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 80463b0:	4b0b      	ldr	r3, [pc, #44]	; (80463e0 <tcp_new_port+0x60>)
 80463b2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80463b6:	681b      	ldr	r3, [r3, #0]
 80463b8:	b133      	cbz	r3, 80463c8 <tcp_new_port+0x48>
      if (pcb->local_port == tcp_port) {
 80463ba:	8ad9      	ldrh	r1, [r3, #22]
 80463bc:	4a07      	ldr	r2, [pc, #28]	; (80463dc <tcp_new_port+0x5c>)
 80463be:	8812      	ldrh	r2, [r2, #0]
 80463c0:	4291      	cmp	r1, r2
 80463c2:	d0e5      	beq.n	8046390 <tcp_new_port+0x10>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 80463c4:	68db      	ldr	r3, [r3, #12]
 80463c6:	e7f7      	b.n	80463b8 <tcp_new_port+0x38>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 80463c8:	3001      	adds	r0, #1
 80463ca:	b2c0      	uxtb	r0, r0
 80463cc:	e7ee      	b.n	80463ac <tcp_new_port+0x2c>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 80463ce:	4b03      	ldr	r3, [pc, #12]	; (80463dc <tcp_new_port+0x5c>)
 80463d0:	8818      	ldrh	r0, [r3, #0]
}
 80463d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80463d6:	4770      	bx	lr
          return 0;
 80463d8:	2000      	movs	r0, #0
 80463da:	e7fa      	b.n	80463d2 <tcp_new_port+0x52>
 80463dc:	20000008 	.word	0x20000008
 80463e0:	08058560 	.word	0x08058560

080463e4 <tcp_listen_closed>:
{
 80463e4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 80463e6:	4605      	mov	r5, r0
 80463e8:	b120      	cbz	r0, 80463f4 <tcp_listen_closed+0x10>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 80463ea:	7d2b      	ldrb	r3, [r5, #20]
 80463ec:	2b01      	cmp	r3, #1
 80463ee:	d108      	bne.n	8046402 <tcp_listen_closed+0x1e>
{
 80463f0:	2401      	movs	r4, #1
 80463f2:	e015      	b.n	8046420 <tcp_listen_closed+0x3c>
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 80463f4:	4b0c      	ldr	r3, [pc, #48]	; (8046428 <tcp_listen_closed+0x44>)
 80463f6:	22c0      	movs	r2, #192	; 0xc0
 80463f8:	490c      	ldr	r1, [pc, #48]	; (804642c <tcp_listen_closed+0x48>)
 80463fa:	480d      	ldr	r0, [pc, #52]	; (8046430 <tcp_listen_closed+0x4c>)
 80463fc:	f00a fef6 	bl	80511ec <printf>
 8046400:	e7f3      	b.n	80463ea <tcp_listen_closed+0x6>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
 8046402:	4b09      	ldr	r3, [pc, #36]	; (8046428 <tcp_listen_closed+0x44>)
 8046404:	22c1      	movs	r2, #193	; 0xc1
 8046406:	490b      	ldr	r1, [pc, #44]	; (8046434 <tcp_listen_closed+0x50>)
 8046408:	4809      	ldr	r0, [pc, #36]	; (8046430 <tcp_listen_closed+0x4c>)
 804640a:	f00a feef 	bl	80511ec <printf>
 804640e:	e7ef      	b.n	80463f0 <tcp_listen_closed+0xc>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
 8046410:	4b09      	ldr	r3, [pc, #36]	; (8046438 <tcp_listen_closed+0x54>)
 8046412:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8046416:	4629      	mov	r1, r5
 8046418:	6818      	ldr	r0, [r3, #0]
 804641a:	f7ff ffa7 	bl	804636c <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
 804641e:	3401      	adds	r4, #1
 8046420:	2c03      	cmp	r4, #3
 8046422:	d9f5      	bls.n	8046410 <tcp_listen_closed+0x2c>
}
 8046424:	bd38      	pop	{r3, r4, r5, pc}
 8046426:	bf00      	nop
 8046428:	08058d90 	.word	0x08058d90
 804642c:	08058dc0 	.word	0x08058dc0
 8046430:	08058644 	.word	0x08058644
 8046434:	08058dcc 	.word	0x08058dcc
 8046438:	08058560 	.word	0x08058560

0804643c <tcp_close_shutdown_fin>:
{
 804643c:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 804643e:	4605      	mov	r5, r0
 8046440:	b148      	cbz	r0, 8046456 <tcp_close_shutdown_fin+0x1a>
  switch (pcb->state) {
 8046442:	7d2b      	ldrb	r3, [r5, #20]
 8046444:	2b04      	cmp	r3, #4
 8046446:	d01f      	beq.n	8046488 <tcp_close_shutdown_fin+0x4c>
 8046448:	2b07      	cmp	r3, #7
 804644a:	d026      	beq.n	804649a <tcp_close_shutdown_fin+0x5e>
 804644c:	2b03      	cmp	r3, #3
 804644e:	d00a      	beq.n	8046466 <tcp_close_shutdown_fin+0x2a>
 8046450:	2400      	movs	r4, #0
}
 8046452:	4620      	mov	r0, r4
 8046454:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
 8046456:	4b17      	ldr	r3, [pc, #92]	; (80464b4 <tcp_close_shutdown_fin+0x78>)
 8046458:	f240 124d 	movw	r2, #333	; 0x14d
 804645c:	4916      	ldr	r1, [pc, #88]	; (80464b8 <tcp_close_shutdown_fin+0x7c>)
 804645e:	4817      	ldr	r0, [pc, #92]	; (80464bc <tcp_close_shutdown_fin+0x80>)
 8046460:	f00a fec4 	bl	80511ec <printf>
 8046464:	e7ed      	b.n	8046442 <tcp_close_shutdown_fin+0x6>
    err = tcp_send_fin(pcb);
 8046466:	4628      	mov	r0, r5
 8046468:	f002 ffc8 	bl	80493fc <tcp_send_fin>
    if (err == ERR_OK) {
 804646c:	4604      	mov	r4, r0
 804646e:	b908      	cbnz	r0, 8046474 <tcp_close_shutdown_fin+0x38>
      pcb->state = FIN_WAIT_1;
 8046470:	2305      	movs	r3, #5
 8046472:	752b      	strb	r3, [r5, #20]
  if (err == ERR_OK) {
 8046474:	b1d4      	cbz	r4, 80464ac <tcp_close_shutdown_fin+0x70>
  } else if (err == ERR_MEM) {
 8046476:	f1b4 3fff 	cmp.w	r4, #4294967295
 804647a:	d1ea      	bne.n	8046452 <tcp_close_shutdown_fin+0x16>
    pcb->flags |= TF_CLOSEPEND;
 804647c:	7eab      	ldrb	r3, [r5, #26]
 804647e:	f043 0308 	orr.w	r3, r3, #8
 8046482:	76ab      	strb	r3, [r5, #26]
    return ERR_OK;
 8046484:	2400      	movs	r4, #0
 8046486:	e7e4      	b.n	8046452 <tcp_close_shutdown_fin+0x16>
    err = tcp_send_fin(pcb);
 8046488:	4628      	mov	r0, r5
 804648a:	f002 ffb7 	bl	80493fc <tcp_send_fin>
    if (err == ERR_OK) {
 804648e:	4604      	mov	r4, r0
 8046490:	2800      	cmp	r0, #0
 8046492:	d1ef      	bne.n	8046474 <tcp_close_shutdown_fin+0x38>
      pcb->state = FIN_WAIT_1;
 8046494:	2305      	movs	r3, #5
 8046496:	752b      	strb	r3, [r5, #20]
 8046498:	e7ec      	b.n	8046474 <tcp_close_shutdown_fin+0x38>
    err = tcp_send_fin(pcb);
 804649a:	4628      	mov	r0, r5
 804649c:	f002 ffae 	bl	80493fc <tcp_send_fin>
    if (err == ERR_OK) {
 80464a0:	4604      	mov	r4, r0
 80464a2:	2800      	cmp	r0, #0
 80464a4:	d1e6      	bne.n	8046474 <tcp_close_shutdown_fin+0x38>
      pcb->state = LAST_ACK;
 80464a6:	2309      	movs	r3, #9
 80464a8:	752b      	strb	r3, [r5, #20]
 80464aa:	e7e3      	b.n	8046474 <tcp_close_shutdown_fin+0x38>
    tcp_output(pcb);
 80464ac:	4628      	mov	r0, r5
 80464ae:	f003 f801 	bl	80494b4 <tcp_output>
 80464b2:	e7ce      	b.n	8046452 <tcp_close_shutdown_fin+0x16>
 80464b4:	08058d90 	.word	0x08058d90
 80464b8:	08058dc0 	.word	0x08058dc0
 80464bc:	08058644 	.word	0x08058644

080464c0 <tcp_init>:
}
 80464c0:	4770      	bx	lr
	...

080464c4 <tcp_bind>:
{
 80464c4:	b570      	push	{r4, r5, r6, lr}
 80464c6:	4606      	mov	r6, r0
  if (ipaddr == NULL) {
 80464c8:	460d      	mov	r5, r1
 80464ca:	b171      	cbz	r1, 80464ea <tcp_bind+0x26>
  if ((pcb == NULL) || (ipaddr == NULL)) {
 80464cc:	2e00      	cmp	r6, #0
 80464ce:	d039      	beq.n	8046544 <tcp_bind+0x80>
 80464d0:	2d00      	cmp	r5, #0
 80464d2:	d03a      	beq.n	804654a <tcp_bind+0x86>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 80464d4:	7d33      	ldrb	r3, [r6, #20]
 80464d6:	b953      	cbnz	r3, 80464ee <tcp_bind+0x2a>
  if (port == 0) {
 80464d8:	b19a      	cbz	r2, 8046502 <tcp_bind+0x3e>
    for (i = 0; i < max_pcb_list; i++) {
 80464da:	2000      	movs	r0, #0
 80464dc:	2803      	cmp	r0, #3
 80464de:	dc14      	bgt.n	804650a <tcp_bind+0x46>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 80464e0:	4b21      	ldr	r3, [pc, #132]	; (8046568 <tcp_bind+0xa4>)
 80464e2:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80464e6:	681b      	ldr	r3, [r3, #0]
 80464e8:	e01c      	b.n	8046524 <tcp_bind+0x60>
    ipaddr = IP4_ADDR_ANY;
 80464ea:	4d20      	ldr	r5, [pc, #128]	; (804656c <tcp_bind+0xa8>)
 80464ec:	e7ee      	b.n	80464cc <tcp_bind+0x8>
  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 80464ee:	4b20      	ldr	r3, [pc, #128]	; (8046570 <tcp_bind+0xac>)
 80464f0:	f44f 7211 	mov.w	r2, #580	; 0x244
 80464f4:	491f      	ldr	r1, [pc, #124]	; (8046574 <tcp_bind+0xb0>)
 80464f6:	4820      	ldr	r0, [pc, #128]	; (8046578 <tcp_bind+0xb4>)
 80464f8:	f00a fe78 	bl	80511ec <printf>
 80464fc:	f06f 0005 	mvn.w	r0, #5
 8046500:	e00e      	b.n	8046520 <tcp_bind+0x5c>
    port = tcp_new_port();
 8046502:	f7ff ff3d 	bl	8046380 <tcp_new_port>
    if (port == 0) {
 8046506:	4602      	mov	r2, r0
 8046508:	b310      	cbz	r0, 8046550 <tcp_bind+0x8c>
  if (!ip_addr_isany(ipaddr)) {
 804650a:	682b      	ldr	r3, [r5, #0]
 804650c:	b103      	cbz	r3, 8046510 <tcp_bind+0x4c>
    ip_addr_set(&pcb->local_ip, ipaddr);
 804650e:	6033      	str	r3, [r6, #0]
  pcb->local_port = port;
 8046510:	82f2      	strh	r2, [r6, #22]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8046512:	4b1a      	ldr	r3, [pc, #104]	; (804657c <tcp_bind+0xb8>)
 8046514:	681a      	ldr	r2, [r3, #0]
 8046516:	60f2      	str	r2, [r6, #12]
 8046518:	601e      	str	r6, [r3, #0]
 804651a:	f003 fac3 	bl	8049aa4 <tcp_timer_needed>
  return ERR_OK;
 804651e:	2000      	movs	r0, #0
}
 8046520:	bd70      	pop	{r4, r5, r6, pc}
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 8046522:	68db      	ldr	r3, [r3, #12]
 8046524:	b163      	cbz	r3, 8046540 <tcp_bind+0x7c>
        if (cpcb->local_port == port) {
 8046526:	8ad9      	ldrh	r1, [r3, #22]
 8046528:	4291      	cmp	r1, r2
 804652a:	d1fa      	bne.n	8046522 <tcp_bind+0x5e>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 804652c:	b19b      	cbz	r3, 8046556 <tcp_bind+0x92>
                (ip_addr_isany(&cpcb->local_ip) ||
 804652e:	6819      	ldr	r1, [r3, #0]
 8046530:	b1a1      	cbz	r1, 804655c <tcp_bind+0x98>
                ip_addr_isany(ipaddr) ||
 8046532:	682c      	ldr	r4, [r5, #0]
 8046534:	b1ac      	cbz	r4, 8046562 <tcp_bind+0x9e>
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
 8046536:	42a1      	cmp	r1, r4
 8046538:	d1f3      	bne.n	8046522 <tcp_bind+0x5e>
              return ERR_USE;
 804653a:	f06f 0007 	mvn.w	r0, #7
 804653e:	e7ef      	b.n	8046520 <tcp_bind+0x5c>
    for (i = 0; i < max_pcb_list; i++) {
 8046540:	3001      	adds	r0, #1
 8046542:	e7cb      	b.n	80464dc <tcp_bind+0x18>
    return ERR_VAL;
 8046544:	f06f 0005 	mvn.w	r0, #5
 8046548:	e7ea      	b.n	8046520 <tcp_bind+0x5c>
 804654a:	f06f 0005 	mvn.w	r0, #5
 804654e:	e7e7      	b.n	8046520 <tcp_bind+0x5c>
      return ERR_BUF;
 8046550:	f06f 0001 	mvn.w	r0, #1
 8046554:	e7e4      	b.n	8046520 <tcp_bind+0x5c>
              return ERR_USE;
 8046556:	f06f 0007 	mvn.w	r0, #7
 804655a:	e7e1      	b.n	8046520 <tcp_bind+0x5c>
 804655c:	f06f 0007 	mvn.w	r0, #7
 8046560:	e7de      	b.n	8046520 <tcp_bind+0x5c>
 8046562:	f06f 0007 	mvn.w	r0, #7
 8046566:	e7db      	b.n	8046520 <tcp_bind+0x5c>
 8046568:	08058560 	.word	0x08058560
 804656c:	080585d0 	.word	0x080585d0
 8046570:	08058d90 	.word	0x08058d90
 8046574:	08058de4 	.word	0x08058de4
 8046578:	08058644 	.word	0x08058644
 804657c:	200089a8 	.word	0x200089a8

08046580 <tcp_update_rcv_ann_wnd>:
{
 8046580:	b538      	push	{r3, r4, r5, lr}
 8046582:	4604      	mov	r4, r0
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8046584:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8046586:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 8046588:	1868      	adds	r0, r5, r1
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 804658a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 804658c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 804658e:	f5b3 6f86 	cmp.w	r3, #1072	; 0x430
 8046592:	bf94      	ite	ls
 8046594:	18d3      	addls	r3, r2, r3
 8046596:	f502 6386 	addhi.w	r3, r2, #1072	; 0x430
 804659a:	1ac3      	subs	r3, r0, r3
 804659c:	2b00      	cmp	r3, #0
 804659e:	db02      	blt.n	80465a6 <tcp_update_rcv_ann_wnd+0x26>
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 80465a0:	8561      	strh	r1, [r4, #42]	; 0x2a
    return new_right_edge - pcb->rcv_ann_right_edge;
 80465a2:	1a80      	subs	r0, r0, r2
}
 80465a4:	bd38      	pop	{r3, r4, r5, pc}
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 80465a6:	1aab      	subs	r3, r5, r2
 80465a8:	2b00      	cmp	r3, #0
 80465aa:	dd03      	ble.n	80465b4 <tcp_update_rcv_ann_wnd+0x34>
      pcb->rcv_ann_wnd = 0;
 80465ac:	2300      	movs	r3, #0
 80465ae:	8563      	strh	r3, [r4, #42]	; 0x2a
    return 0;
 80465b0:	2000      	movs	r0, #0
 80465b2:	e7f7      	b.n	80465a4 <tcp_update_rcv_ann_wnd+0x24>
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 80465b4:	1b55      	subs	r5, r2, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 80465b6:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 80465ba:	d201      	bcs.n	80465c0 <tcp_update_rcv_ann_wnd+0x40>
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
 80465bc:	8565      	strh	r5, [r4, #42]	; 0x2a
 80465be:	e7f7      	b.n	80465b0 <tcp_update_rcv_ann_wnd+0x30>
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 80465c0:	4b03      	ldr	r3, [pc, #12]	; (80465d0 <tcp_update_rcv_ann_wnd+0x50>)
 80465c2:	f44f 7242 	mov.w	r2, #776	; 0x308
 80465c6:	4903      	ldr	r1, [pc, #12]	; (80465d4 <tcp_update_rcv_ann_wnd+0x54>)
 80465c8:	4803      	ldr	r0, [pc, #12]	; (80465d8 <tcp_update_rcv_ann_wnd+0x58>)
 80465ca:	f00a fe0f 	bl	80511ec <printf>
 80465ce:	e7f5      	b.n	80465bc <tcp_update_rcv_ann_wnd+0x3c>
 80465d0:	08058d90 	.word	0x08058d90
 80465d4:	08058e30 	.word	0x08058e30
 80465d8:	08058644 	.word	0x08058644

080465dc <tcp_recved>:
{
 80465dc:	b538      	push	{r3, r4, r5, lr}
 80465de:	4605      	mov	r5, r0
 80465e0:	460c      	mov	r4, r1
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 80465e2:	7d03      	ldrb	r3, [r0, #20]
 80465e4:	2b01      	cmp	r3, #1
 80465e6:	d010      	beq.n	804660a <tcp_recved+0x2e>
  pcb->rcv_wnd += len;
 80465e8:	8d29      	ldrh	r1, [r5, #40]	; 0x28
 80465ea:	4421      	add	r1, r4
 80465ec:	b289      	uxth	r1, r1
 80465ee:	8529      	strh	r1, [r5, #40]	; 0x28
  if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
 80465f0:	f5b1 6f06 	cmp.w	r1, #2144	; 0x860
 80465f4:	d911      	bls.n	804661a <tcp_recved+0x3e>
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
 80465f6:	f44f 6306 	mov.w	r3, #2144	; 0x860
 80465fa:	852b      	strh	r3, [r5, #40]	; 0x28
  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 80465fc:	4628      	mov	r0, r5
 80465fe:	f7ff ffbf 	bl	8046580 <tcp_update_rcv_ann_wnd>
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 8046602:	f5b0 7f06 	cmp.w	r0, #536	; 0x218
 8046606:	da1b      	bge.n	8046640 <tcp_recved+0x64>
}
 8046608:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 804660a:	4b11      	ldr	r3, [pc, #68]	; (8046650 <tcp_recved+0x74>)
 804660c:	f240 321f 	movw	r2, #799	; 0x31f
 8046610:	4910      	ldr	r1, [pc, #64]	; (8046654 <tcp_recved+0x78>)
 8046612:	4811      	ldr	r0, [pc, #68]	; (8046658 <tcp_recved+0x7c>)
 8046614:	f00a fdea 	bl	80511ec <printf>
 8046618:	e7e6      	b.n	80465e8 <tcp_recved+0xc>
  } else if (pcb->rcv_wnd == 0) {
 804661a:	2900      	cmp	r1, #0
 804661c:	d1ee      	bne.n	80465fc <tcp_recved+0x20>
    if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
 804661e:	7d2b      	ldrb	r3, [r5, #20]
 8046620:	2b07      	cmp	r3, #7
 8046622:	d001      	beq.n	8046628 <tcp_recved+0x4c>
 8046624:	2b09      	cmp	r3, #9
 8046626:	d103      	bne.n	8046630 <tcp_recved+0x54>
      pcb->rcv_wnd = TCP_WND_MAX(pcb);
 8046628:	f44f 6306 	mov.w	r3, #2144	; 0x860
 804662c:	852b      	strh	r3, [r5, #40]	; 0x28
 804662e:	e7e5      	b.n	80465fc <tcp_recved+0x20>
      LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
 8046630:	4b07      	ldr	r3, [pc, #28]	; (8046650 <tcp_recved+0x74>)
 8046632:	f240 322d 	movw	r2, #813	; 0x32d
 8046636:	4909      	ldr	r1, [pc, #36]	; (804665c <tcp_recved+0x80>)
 8046638:	4807      	ldr	r0, [pc, #28]	; (8046658 <tcp_recved+0x7c>)
 804663a:	f00a fdd7 	bl	80511ec <printf>
 804663e:	e7dd      	b.n	80465fc <tcp_recved+0x20>
    tcp_ack_now(pcb);
 8046640:	7eab      	ldrb	r3, [r5, #26]
 8046642:	f043 0302 	orr.w	r3, r3, #2
 8046646:	76ab      	strb	r3, [r5, #26]
    tcp_output(pcb);
 8046648:	4628      	mov	r0, r5
 804664a:	f002 ff33 	bl	80494b4 <tcp_output>
}
 804664e:	e7db      	b.n	8046608 <tcp_recved+0x2c>
 8046650:	08058d90 	.word	0x08058d90
 8046654:	08058e4c 	.word	0x08058e4c
 8046658:	08058644 	.word	0x08058644
 804665c:	08058e74 	.word	0x08058e74

08046660 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8046660:	b150      	cbz	r0, 8046678 <tcp_seg_free+0x18>
{
 8046662:	b510      	push	{r4, lr}
 8046664:	4604      	mov	r4, r0
    if (seg->p != NULL) {
 8046666:	6840      	ldr	r0, [r0, #4]
 8046668:	b108      	cbz	r0, 804666e <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 804666a:	f7ff fb15 	bl	8045c98 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 804666e:	4621      	mov	r1, r4
 8046670:	2003      	movs	r0, #3
 8046672:	f7ff f95d 	bl	8045930 <memp_free>
  }
}
 8046676:	bd10      	pop	{r4, pc}
 8046678:	4770      	bx	lr

0804667a <tcp_segs_free>:
  while (seg != NULL) {
 804667a:	b138      	cbz	r0, 804668c <tcp_segs_free+0x12>
{
 804667c:	b510      	push	{r4, lr}
    struct tcp_seg *next = seg->next;
 804667e:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 8046680:	f7ff ffee 	bl	8046660 <tcp_seg_free>
    seg = next;
 8046684:	4620      	mov	r0, r4
  while (seg != NULL) {
 8046686:	2c00      	cmp	r4, #0
 8046688:	d1f9      	bne.n	804667e <tcp_segs_free+0x4>
}
 804668a:	bd10      	pop	{r4, pc}
 804668c:	4770      	bx	lr

0804668e <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 804668e:	b538      	push	{r3, r4, r5, lr}
 8046690:	4604      	mov	r4, r0
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 8046692:	2003      	movs	r0, #3
 8046694:	f7ff f932 	bl	80458fc <memp_malloc>
  if (cseg == NULL) {
 8046698:	4605      	mov	r5, r0
 804669a:	b150      	cbz	r0, 80466b2 <tcp_seg_copy+0x24>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
 804669c:	6820      	ldr	r0, [r4, #0]
 804669e:	6861      	ldr	r1, [r4, #4]
 80466a0:	68a2      	ldr	r2, [r4, #8]
 80466a2:	68e3      	ldr	r3, [r4, #12]
 80466a4:	6028      	str	r0, [r5, #0]
 80466a6:	6069      	str	r1, [r5, #4]
 80466a8:	60aa      	str	r2, [r5, #8]
 80466aa:	60eb      	str	r3, [r5, #12]
  pbuf_ref(cseg->p);
 80466ac:	6868      	ldr	r0, [r5, #4]
 80466ae:	f7ff fcc7 	bl	8046040 <pbuf_ref>
  return cseg;
}
 80466b2:	4628      	mov	r0, r5
 80466b4:	bd38      	pop	{r3, r4, r5, pc}

080466b6 <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
 80466b6:	b100      	cbz	r0, 80466ba <tcp_arg+0x4>
    pcb->callback_arg = arg;
 80466b8:	6101      	str	r1, [r0, #16]
  }
}
 80466ba:	4770      	bx	lr

080466bc <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  if (pcb != NULL) {
 80466bc:	b180      	cbz	r0, 80466e0 <tcp_recv+0x24>
{
 80466be:	b538      	push	{r3, r4, r5, lr}
 80466c0:	460c      	mov	r4, r1
 80466c2:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 80466c4:	7d03      	ldrb	r3, [r0, #20]
 80466c6:	2b01      	cmp	r3, #1
 80466c8:	d002      	beq.n	80466d0 <tcp_recv+0x14>
    pcb->recv = recv;
 80466ca:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
  }
}
 80466ce:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 80466d0:	4b04      	ldr	r3, [pc, #16]	; (80466e4 <tcp_recv+0x28>)
 80466d2:	f240 62bb 	movw	r2, #1723	; 0x6bb
 80466d6:	4904      	ldr	r1, [pc, #16]	; (80466e8 <tcp_recv+0x2c>)
 80466d8:	4804      	ldr	r0, [pc, #16]	; (80466ec <tcp_recv+0x30>)
 80466da:	f00a fd87 	bl	80511ec <printf>
 80466de:	e7f4      	b.n	80466ca <tcp_recv+0xe>
 80466e0:	4770      	bx	lr
 80466e2:	bf00      	nop
 80466e4:	08058d90 	.word	0x08058d90
 80466e8:	08058e98 	.word	0x08058e98
 80466ec:	08058644 	.word	0x08058644

080466f0 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  if (pcb != NULL) {
 80466f0:	b178      	cbz	r0, 8046712 <tcp_sent+0x22>
{
 80466f2:	b538      	push	{r3, r4, r5, lr}
 80466f4:	460c      	mov	r4, r1
 80466f6:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 80466f8:	7d03      	ldrb	r3, [r0, #20]
 80466fa:	2b01      	cmp	r3, #1
 80466fc:	d001      	beq.n	8046702 <tcp_sent+0x12>
    pcb->sent = sent;
 80466fe:	67ec      	str	r4, [r5, #124]	; 0x7c
  }
}
 8046700:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8046702:	4b04      	ldr	r3, [pc, #16]	; (8046714 <tcp_sent+0x24>)
 8046704:	f240 62cc 	movw	r2, #1740	; 0x6cc
 8046708:	4903      	ldr	r1, [pc, #12]	; (8046718 <tcp_sent+0x28>)
 804670a:	4804      	ldr	r0, [pc, #16]	; (804671c <tcp_sent+0x2c>)
 804670c:	f00a fd6e 	bl	80511ec <printf>
 8046710:	e7f5      	b.n	80466fe <tcp_sent+0xe>
 8046712:	4770      	bx	lr
 8046714:	08058d90 	.word	0x08058d90
 8046718:	08058ec0 	.word	0x08058ec0
 804671c:	08058644 	.word	0x08058644

08046720 <tcp_err>:
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  if (pcb != NULL) {
 8046720:	b180      	cbz	r0, 8046744 <tcp_err+0x24>
{
 8046722:	b538      	push	{r3, r4, r5, lr}
 8046724:	460c      	mov	r4, r1
 8046726:	4605      	mov	r5, r0
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8046728:	7d03      	ldrb	r3, [r0, #20]
 804672a:	2b01      	cmp	r3, #1
 804672c:	d002      	beq.n	8046734 <tcp_err+0x14>
    pcb->errf = err;
 804672e:	f8c5 408c 	str.w	r4, [r5, #140]	; 0x8c
  }
}
 8046732:	bd38      	pop	{r3, r4, r5, pc}
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8046734:	4b04      	ldr	r3, [pc, #16]	; (8046748 <tcp_err+0x28>)
 8046736:	f44f 62dc 	mov.w	r2, #1760	; 0x6e0
 804673a:	4904      	ldr	r1, [pc, #16]	; (804674c <tcp_err+0x2c>)
 804673c:	4804      	ldr	r0, [pc, #16]	; (8046750 <tcp_err+0x30>)
 804673e:	f00a fd55 	bl	80511ec <printf>
 8046742:	e7f4      	b.n	804672e <tcp_err+0xe>
 8046744:	4770      	bx	lr
 8046746:	bf00      	nop
 8046748:	08058d90 	.word	0x08058d90
 804674c:	08058ee8 	.word	0x08058ee8
 8046750:	08058644 	.word	0x08058644

08046754 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 8046754:	b570      	push	{r4, r5, r6, lr}
 8046756:	4604      	mov	r4, r0
 8046758:	460e      	mov	r6, r1
 804675a:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 804675c:	7d03      	ldrb	r3, [r0, #20]
 804675e:	2b01      	cmp	r3, #1
 8046760:	d003      	beq.n	804676a <tcp_poll+0x16>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8046762:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
 8046766:	7725      	strb	r5, [r4, #28]
}
 8046768:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 804676a:	4b04      	ldr	r3, [pc, #16]	; (804677c <tcp_poll+0x28>)
 804676c:	f240 7203 	movw	r2, #1795	; 0x703
 8046770:	4903      	ldr	r1, [pc, #12]	; (8046780 <tcp_poll+0x2c>)
 8046772:	4804      	ldr	r0, [pc, #16]	; (8046784 <tcp_poll+0x30>)
 8046774:	f00a fd3a 	bl	80511ec <printf>
 8046778:	e7f3      	b.n	8046762 <tcp_poll+0xe>
 804677a:	bf00      	nop
 804677c:	08058d90 	.word	0x08058d90
 8046780:	08058f10 	.word	0x08058f10
 8046784:	08058644 	.word	0x08058644

08046788 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 8046788:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state != CLOSED &&
 804678a:	7d03      	ldrb	r3, [r0, #20]
 804678c:	b1e3      	cbz	r3, 80467c8 <tcp_pcb_purge+0x40>
 804678e:	4604      	mov	r4, r0
 8046790:	2b0a      	cmp	r3, #10
 8046792:	d019      	beq.n	80467c8 <tcp_pcb_purge+0x40>
     pcb->state != TIME_WAIT &&
 8046794:	2b01      	cmp	r3, #1
 8046796:	d017      	beq.n	80467c8 <tcp_pcb_purge+0x40>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
 8046798:	6f40      	ldr	r0, [r0, #116]	; 0x74
 804679a:	b118      	cbz	r0, 80467a4 <tcp_pcb_purge+0x1c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 804679c:	f7ff fa7c 	bl	8045c98 <pbuf_free>
      pcb->refused_data = NULL;
 80467a0:	2300      	movs	r3, #0
 80467a2:	6763      	str	r3, [r4, #116]	; 0x74
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 80467a4:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80467a6:	f7ff ff68 	bl	804667a <tcp_segs_free>
    pcb->ooseq = NULL;
 80467aa:	2500      	movs	r5, #0
 80467ac:	6725      	str	r5, [r4, #112]	; 0x70
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 80467ae:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80467b2:	8623      	strh	r3, [r4, #48]	; 0x30

    tcp_segs_free(pcb->unsent);
 80467b4:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 80467b6:	f7ff ff60 	bl	804667a <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 80467ba:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80467bc:	f7ff ff5d 	bl	804667a <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 80467c0:	66a5      	str	r5, [r4, #104]	; 0x68
 80467c2:	66e5      	str	r5, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 80467c4:	f8a4 5064 	strh.w	r5, [r4, #100]	; 0x64
#endif /* TCP_OVERSIZE */
  }
}
 80467c8:	bd38      	pop	{r3, r4, r5, pc}
	...

080467cc <tcp_slowtmr>:
{
 80467cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80467d0:	b082      	sub	sp, #8
  ++tcp_ticks;
 80467d2:	4aae      	ldr	r2, [pc, #696]	; (8046a8c <tcp_slowtmr+0x2c0>)
 80467d4:	6813      	ldr	r3, [r2, #0]
 80467d6:	3301      	adds	r3, #1
 80467d8:	6013      	str	r3, [r2, #0]
  ++tcp_timer_ctr;
 80467da:	4aad      	ldr	r2, [pc, #692]	; (8046a90 <tcp_slowtmr+0x2c4>)
 80467dc:	7813      	ldrb	r3, [r2, #0]
 80467de:	3301      	adds	r3, #1
 80467e0:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 80467e2:	4bac      	ldr	r3, [pc, #688]	; (8046a94 <tcp_slowtmr+0x2c8>)
 80467e4:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 80467e6:	2600      	movs	r6, #0
  while (pcb != NULL) {
 80467e8:	e16e      	b.n	8046ac8 <tcp_slowtmr+0x2fc>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 80467ea:	4bab      	ldr	r3, [pc, #684]	; (8046a98 <tcp_slowtmr+0x2cc>)
 80467ec:	f44f 727c 	mov.w	r2, #1008	; 0x3f0
 80467f0:	49aa      	ldr	r1, [pc, #680]	; (8046a9c <tcp_slowtmr+0x2d0>)
 80467f2:	48ab      	ldr	r0, [pc, #684]	; (8046aa0 <tcp_slowtmr+0x2d4>)
 80467f4:	f00a fcfa 	bl	80511ec <printf>
 80467f8:	e16b      	b.n	8046ad2 <tcp_slowtmr+0x306>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 80467fa:	4ba7      	ldr	r3, [pc, #668]	; (8046a98 <tcp_slowtmr+0x2cc>)
 80467fc:	f240 32f1 	movw	r2, #1009	; 0x3f1
 8046800:	49a8      	ldr	r1, [pc, #672]	; (8046aa4 <tcp_slowtmr+0x2d8>)
 8046802:	48a7      	ldr	r0, [pc, #668]	; (8046aa0 <tcp_slowtmr+0x2d4>)
 8046804:	f00a fcf2 	bl	80511ec <printf>
 8046808:	e167      	b.n	8046ada <tcp_slowtmr+0x30e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 804680a:	4ba3      	ldr	r3, [pc, #652]	; (8046a98 <tcp_slowtmr+0x2cc>)
 804680c:	f240 32f2 	movw	r2, #1010	; 0x3f2
 8046810:	49a5      	ldr	r1, [pc, #660]	; (8046aa8 <tcp_slowtmr+0x2dc>)
 8046812:	48a3      	ldr	r0, [pc, #652]	; (8046aa0 <tcp_slowtmr+0x2d4>)
 8046814:	f00a fcea 	bl	80511ec <printf>
 8046818:	e163      	b.n	8046ae2 <tcp_slowtmr+0x316>
      pcb = pcb->next;
 804681a:	68e4      	ldr	r4, [r4, #12]
      continue;
 804681c:	e154      	b.n	8046ac8 <tcp_slowtmr+0x2fc>
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 804681e:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8046822:	2a05      	cmp	r2, #5
 8046824:	f240 8168 	bls.w	8046af8 <tcp_slowtmr+0x32c>
      ++pcb_remove;
 8046828:	2501      	movs	r5, #1
 804682a:	e04c      	b.n	80468c6 <tcp_slowtmr+0xfa>
          if (tcp_zero_window_probe(pcb) == ERR_OK) {
 804682c:	4620      	mov	r0, r4
 804682e:	f003 f879 	bl	8049924 <tcp_zero_window_probe>
 8046832:	2800      	cmp	r0, #0
 8046834:	f040 8087 	bne.w	8046946 <tcp_slowtmr+0x17a>
            pcb->persist_cnt = 0;
 8046838:	2300      	movs	r3, #0
 804683a:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
            if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 804683e:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 8046842:	2b06      	cmp	r3, #6
 8046844:	f200 8081 	bhi.w	804694a <tcp_slowtmr+0x17e>
              pcb->persist_backoff++;
 8046848:	3301      	adds	r3, #1
 804684a:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
    pcb_remove = 0;
 804684e:	2500      	movs	r5, #0
 8046850:	e039      	b.n	80468c6 <tcp_slowtmr+0xfa>
        if (pcb->rtime >= 0) {
 8046852:	f9b4 1030 	ldrsh.w	r1, [r4, #48]	; 0x30
 8046856:	2900      	cmp	r1, #0
 8046858:	db01      	blt.n	804685e <tcp_slowtmr+0x92>
          ++pcb->rtime;
 804685a:	3101      	adds	r1, #1
 804685c:	8621      	strh	r1, [r4, #48]	; 0x30
        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 804685e:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8046860:	b389      	cbz	r1, 80468c6 <tcp_slowtmr+0xfa>
 8046862:	f9b4 0030 	ldrsh.w	r0, [r4, #48]	; 0x30
 8046866:	f9b4 1040 	ldrsh.w	r1, [r4, #64]	; 0x40
 804686a:	4288      	cmp	r0, r1
 804686c:	db2b      	blt.n	80468c6 <tcp_slowtmr+0xfa>
          if (pcb->state != SYN_SENT) {
 804686e:	2b02      	cmp	r3, #2
 8046870:	d00f      	beq.n	8046892 <tcp_slowtmr+0xc6>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
 8046872:	f9b4 103c 	ldrsh.w	r1, [r4, #60]	; 0x3c
 8046876:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	; 0x3e
 804687a:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 804687e:	498b      	ldr	r1, [pc, #556]	; (8046aac <tcp_slowtmr+0x2e0>)
 8046880:	2a0c      	cmp	r2, #12
 8046882:	bf94      	ite	ls
 8046884:	188a      	addls	r2, r1, r2
 8046886:	f101 020c 	addhi.w	r2, r1, #12
 804688a:	7e12      	ldrb	r2, [r2, #24]
 804688c:	4093      	lsls	r3, r2
 804688e:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
          pcb->rtime = 0;
 8046892:	2300      	movs	r3, #0
 8046894:	8623      	strh	r3, [r4, #48]	; 0x30
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 8046896:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 804689a:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 804689e:	4293      	cmp	r3, r2
 80468a0:	bf28      	it	cs
 80468a2:	4613      	movcs	r3, r2
          pcb->ssthresh = eff_wnd >> 1;
 80468a4:	085b      	lsrs	r3, r3, #1
 80468a6:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
          if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
 80468aa:	8e61      	ldrh	r1, [r4, #50]	; 0x32
 80468ac:	004a      	lsls	r2, r1, #1
 80468ae:	b292      	uxth	r2, r2
 80468b0:	4293      	cmp	r3, r2
 80468b2:	d201      	bcs.n	80468b8 <tcp_slowtmr+0xec>
            pcb->ssthresh = (pcb->mss << 1);
 80468b4:	f8a4 204a 	strh.w	r2, [r4, #74]	; 0x4a
          pcb->cwnd = pcb->mss;
 80468b8:	f8a4 1048 	strh.w	r1, [r4, #72]	; 0x48
          tcp_rexmit_rto(pcb);
 80468bc:	4620      	mov	r0, r4
 80468be:	f002 ff97 	bl	80497f0 <tcp_rexmit_rto>
 80468c2:	e000      	b.n	80468c6 <tcp_slowtmr+0xfa>
      ++pcb_remove;
 80468c4:	2501      	movs	r5, #1
    if (pcb->state == FIN_WAIT_2) {
 80468c6:	7d22      	ldrb	r2, [r4, #20]
 80468c8:	2a06      	cmp	r2, #6
 80468ca:	d040      	beq.n	804694e <tcp_slowtmr+0x182>
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
 80468cc:	7a23      	ldrb	r3, [r4, #8]
 80468ce:	f013 0708 	ands.w	r7, r3, #8
 80468d2:	d004      	beq.n	80468de <tcp_slowtmr+0x112>
 80468d4:	2a04      	cmp	r2, #4
 80468d6:	d047      	beq.n	8046968 <tcp_slowtmr+0x19c>
       ((pcb->state == ESTABLISHED) ||
 80468d8:	2a07      	cmp	r2, #7
 80468da:	d045      	beq.n	8046968 <tcp_slowtmr+0x19c>
    pcb_reset = 0;
 80468dc:	2700      	movs	r7, #0
    if (pcb->ooseq != NULL &&
 80468de:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80468e0:	b150      	cbz	r0, 80468f8 <tcp_slowtmr+0x12c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 80468e2:	4b6a      	ldr	r3, [pc, #424]	; (8046a8c <tcp_slowtmr+0x2c0>)
 80468e4:	681a      	ldr	r2, [r3, #0]
 80468e6:	6a23      	ldr	r3, [r4, #32]
 80468e8:	1ad2      	subs	r2, r2, r3
 80468ea:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
 80468ee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if (pcb->ooseq != NULL &&
 80468f2:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 80468f6:	d265      	bcs.n	80469c4 <tcp_slowtmr+0x1f8>
    if (pcb->state == SYN_RCVD) {
 80468f8:	7d23      	ldrb	r3, [r4, #20]
 80468fa:	2b03      	cmp	r3, #3
 80468fc:	d067      	beq.n	80469ce <tcp_slowtmr+0x202>
    if (pcb->state == LAST_ACK) {
 80468fe:	2b09      	cmp	r3, #9
 8046900:	d06e      	beq.n	80469e0 <tcp_slowtmr+0x214>
    if (pcb_remove) {
 8046902:	2d00      	cmp	r5, #0
 8046904:	d175      	bne.n	80469f2 <tcp_slowtmr+0x226>
      pcb = pcb->next;
 8046906:	68e5      	ldr	r5, [r4, #12]
      ++prev->polltmr;
 8046908:	7ee3      	ldrb	r3, [r4, #27]
 804690a:	3301      	adds	r3, #1
 804690c:	b2db      	uxtb	r3, r3
 804690e:	76e3      	strb	r3, [r4, #27]
      if (prev->polltmr >= prev->pollinterval) {
 8046910:	7f22      	ldrb	r2, [r4, #28]
 8046912:	4293      	cmp	r3, r2
 8046914:	f0c0 80d6 	bcc.w	8046ac4 <tcp_slowtmr+0x2f8>
        prev->polltmr = 0;
 8046918:	2300      	movs	r3, #0
 804691a:	76e3      	strb	r3, [r4, #27]
        tcp_active_pcbs_changed = 0;
 804691c:	4a64      	ldr	r2, [pc, #400]	; (8046ab0 <tcp_slowtmr+0x2e4>)
 804691e:	7013      	strb	r3, [r2, #0]
        TCP_EVENT_POLL(prev, err);
 8046920:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 8046924:	2b00      	cmp	r3, #0
 8046926:	f000 80a9 	beq.w	8046a7c <tcp_slowtmr+0x2b0>
 804692a:	4621      	mov	r1, r4
 804692c:	6920      	ldr	r0, [r4, #16]
 804692e:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
 8046930:	4b5f      	ldr	r3, [pc, #380]	; (8046ab0 <tcp_slowtmr+0x2e4>)
 8046932:	781b      	ldrb	r3, [r3, #0]
 8046934:	2b00      	cmp	r3, #0
 8046936:	f47f af54 	bne.w	80467e2 <tcp_slowtmr+0x16>
        if (err == ERR_OK) {
 804693a:	2800      	cmp	r0, #0
 804693c:	f000 80a0 	beq.w	8046a80 <tcp_slowtmr+0x2b4>
      prev = pcb;
 8046940:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046942:	462c      	mov	r4, r5
 8046944:	e0c0      	b.n	8046ac8 <tcp_slowtmr+0x2fc>
    pcb_remove = 0;
 8046946:	2500      	movs	r5, #0
 8046948:	e7bd      	b.n	80468c6 <tcp_slowtmr+0xfa>
 804694a:	2500      	movs	r5, #0
 804694c:	e7bb      	b.n	80468c6 <tcp_slowtmr+0xfa>
      if (pcb->flags & TF_RXCLOSED) {
 804694e:	7ea3      	ldrb	r3, [r4, #26]
 8046950:	f013 0f10 	tst.w	r3, #16
 8046954:	d0ba      	beq.n	80468cc <tcp_slowtmr+0x100>
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8046956:	6a21      	ldr	r1, [r4, #32]
 8046958:	4b4c      	ldr	r3, [pc, #304]	; (8046a8c <tcp_slowtmr+0x2c0>)
 804695a:	681b      	ldr	r3, [r3, #0]
 804695c:	1a5b      	subs	r3, r3, r1
 804695e:	2b28      	cmp	r3, #40	; 0x28
 8046960:	d9b4      	bls.n	80468cc <tcp_slowtmr+0x100>
          ++pcb_remove;
 8046962:	3501      	adds	r5, #1
 8046964:	b2ed      	uxtb	r5, r5
 8046966:	e7b1      	b.n	80468cc <tcp_slowtmr+0x100>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8046968:	4b48      	ldr	r3, [pc, #288]	; (8046a8c <tcp_slowtmr+0x2c0>)
 804696a:	681a      	ldr	r2, [r3, #0]
 804696c:	6a23      	ldr	r3, [r4, #32]
 804696e:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 8046970:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 8046974:	f501 2324 	add.w	r3, r1, #671744	; 0xa4000
 8046978:	f603 43b8 	addw	r3, r3, #3256	; 0xcb8
 804697c:	484d      	ldr	r0, [pc, #308]	; (8046ab4 <tcp_slowtmr+0x2e8>)
 804697e:	fba0 0303 	umull	r0, r3, r0, r3
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8046982:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 8046986:	d903      	bls.n	8046990 <tcp_slowtmr+0x1c4>
        ++pcb_remove;
 8046988:	3501      	adds	r5, #1
 804698a:	b2ed      	uxtb	r5, r5
        ++pcb_reset;
 804698c:	2701      	movs	r7, #1
 804698e:	e7a6      	b.n	80468de <tcp_slowtmr+0x112>
                (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 8046990:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 8046994:	4848      	ldr	r0, [pc, #288]	; (8046ab8 <tcp_slowtmr+0x2ec>)
 8046996:	fb00 1303 	mla	r3, r0, r3, r1
                / TCP_SLOW_INTERVAL)
 804699a:	4946      	ldr	r1, [pc, #280]	; (8046ab4 <tcp_slowtmr+0x2e8>)
 804699c:	fba1 1303 	umull	r1, r3, r1, r3
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
 80469a0:	ebb2 1f53 	cmp.w	r2, r3, lsr #5
 80469a4:	d801      	bhi.n	80469aa <tcp_slowtmr+0x1de>
    pcb_reset = 0;
 80469a6:	2700      	movs	r7, #0
 80469a8:	e799      	b.n	80468de <tcp_slowtmr+0x112>
        err = tcp_keepalive(pcb);
 80469aa:	4620      	mov	r0, r4
 80469ac:	f002 ff8e 	bl	80498cc <tcp_keepalive>
        if (err == ERR_OK) {
 80469b0:	b930      	cbnz	r0, 80469c0 <tcp_slowtmr+0x1f4>
          pcb->keep_cnt_sent++;
 80469b2:	f894 3096 	ldrb.w	r3, [r4, #150]	; 0x96
 80469b6:	3301      	adds	r3, #1
 80469b8:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
    pcb_reset = 0;
 80469bc:	2700      	movs	r7, #0
 80469be:	e78e      	b.n	80468de <tcp_slowtmr+0x112>
 80469c0:	2700      	movs	r7, #0
 80469c2:	e78c      	b.n	80468de <tcp_slowtmr+0x112>
      tcp_segs_free(pcb->ooseq);
 80469c4:	f7ff fe59 	bl	804667a <tcp_segs_free>
      pcb->ooseq = NULL;
 80469c8:	2300      	movs	r3, #0
 80469ca:	6723      	str	r3, [r4, #112]	; 0x70
 80469cc:	e794      	b.n	80468f8 <tcp_slowtmr+0x12c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 80469ce:	6a21      	ldr	r1, [r4, #32]
 80469d0:	4a2e      	ldr	r2, [pc, #184]	; (8046a8c <tcp_slowtmr+0x2c0>)
 80469d2:	6812      	ldr	r2, [r2, #0]
 80469d4:	1a52      	subs	r2, r2, r1
 80469d6:	2a28      	cmp	r2, #40	; 0x28
 80469d8:	d991      	bls.n	80468fe <tcp_slowtmr+0x132>
        ++pcb_remove;
 80469da:	3501      	adds	r5, #1
 80469dc:	b2ed      	uxtb	r5, r5
 80469de:	e78e      	b.n	80468fe <tcp_slowtmr+0x132>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80469e0:	6a22      	ldr	r2, [r4, #32]
 80469e2:	4b2a      	ldr	r3, [pc, #168]	; (8046a8c <tcp_slowtmr+0x2c0>)
 80469e4:	681b      	ldr	r3, [r3, #0]
 80469e6:	1a9b      	subs	r3, r3, r2
 80469e8:	2bf0      	cmp	r3, #240	; 0xf0
 80469ea:	d98a      	bls.n	8046902 <tcp_slowtmr+0x136>
        ++pcb_remove;
 80469ec:	3501      	adds	r5, #1
 80469ee:	b2ed      	uxtb	r5, r5
 80469f0:	e787      	b.n	8046902 <tcp_slowtmr+0x136>
      tcp_err_fn err_fn = pcb->errf;
 80469f2:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      tcp_pcb_purge(pcb);
 80469f6:	4620      	mov	r0, r4
 80469f8:	f7ff fec6 	bl	8046788 <tcp_pcb_purge>
      if (prev != NULL) {
 80469fc:	b326      	cbz	r6, 8046a48 <tcp_slowtmr+0x27c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 80469fe:	4b25      	ldr	r3, [pc, #148]	; (8046a94 <tcp_slowtmr+0x2c8>)
 8046a00:	681b      	ldr	r3, [r3, #0]
 8046a02:	42a3      	cmp	r3, r4
 8046a04:	d018      	beq.n	8046a38 <tcp_slowtmr+0x26c>
        prev->next = pcb->next;
 8046a06:	68e3      	ldr	r3, [r4, #12]
 8046a08:	60f3      	str	r3, [r6, #12]
      if (pcb_reset) {
 8046a0a:	bb67      	cbnz	r7, 8046a66 <tcp_slowtmr+0x29a>
      err_arg = pcb->callback_arg;
 8046a0c:	f8d4 8010 	ldr.w	r8, [r4, #16]
      pcb = pcb->next;
 8046a10:	68e7      	ldr	r7, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8046a12:	4621      	mov	r1, r4
 8046a14:	2001      	movs	r0, #1
 8046a16:	f7fe ff8b 	bl	8045930 <memp_free>
      tcp_active_pcbs_changed = 0;
 8046a1a:	4b25      	ldr	r3, [pc, #148]	; (8046ab0 <tcp_slowtmr+0x2e4>)
 8046a1c:	2200      	movs	r2, #0
 8046a1e:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
 8046a20:	b11d      	cbz	r5, 8046a2a <tcp_slowtmr+0x25e>
 8046a22:	f06f 010c 	mvn.w	r1, #12
 8046a26:	4640      	mov	r0, r8
 8046a28:	47a8      	blx	r5
      if (tcp_active_pcbs_changed) {
 8046a2a:	4b21      	ldr	r3, [pc, #132]	; (8046ab0 <tcp_slowtmr+0x2e4>)
 8046a2c:	781b      	ldrb	r3, [r3, #0]
 8046a2e:	2b00      	cmp	r3, #0
 8046a30:	f47f aed7 	bne.w	80467e2 <tcp_slowtmr+0x16>
      pcb = pcb->next;
 8046a34:	463c      	mov	r4, r7
 8046a36:	e047      	b.n	8046ac8 <tcp_slowtmr+0x2fc>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 8046a38:	4b17      	ldr	r3, [pc, #92]	; (8046a98 <tcp_slowtmr+0x2cc>)
 8046a3a:	f240 4289 	movw	r2, #1161	; 0x489
 8046a3e:	491f      	ldr	r1, [pc, #124]	; (8046abc <tcp_slowtmr+0x2f0>)
 8046a40:	4817      	ldr	r0, [pc, #92]	; (8046aa0 <tcp_slowtmr+0x2d4>)
 8046a42:	f00a fbd3 	bl	80511ec <printf>
 8046a46:	e7de      	b.n	8046a06 <tcp_slowtmr+0x23a>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 8046a48:	4b12      	ldr	r3, [pc, #72]	; (8046a94 <tcp_slowtmr+0x2c8>)
 8046a4a:	681b      	ldr	r3, [r3, #0]
 8046a4c:	42a3      	cmp	r3, r4
 8046a4e:	d006      	beq.n	8046a5e <tcp_slowtmr+0x292>
 8046a50:	4b11      	ldr	r3, [pc, #68]	; (8046a98 <tcp_slowtmr+0x2cc>)
 8046a52:	f240 428d 	movw	r2, #1165	; 0x48d
 8046a56:	491a      	ldr	r1, [pc, #104]	; (8046ac0 <tcp_slowtmr+0x2f4>)
 8046a58:	4811      	ldr	r0, [pc, #68]	; (8046aa0 <tcp_slowtmr+0x2d4>)
 8046a5a:	f00a fbc7 	bl	80511ec <printf>
        tcp_active_pcbs = pcb->next;
 8046a5e:	68e2      	ldr	r2, [r4, #12]
 8046a60:	4b0c      	ldr	r3, [pc, #48]	; (8046a94 <tcp_slowtmr+0x2c8>)
 8046a62:	601a      	str	r2, [r3, #0]
 8046a64:	e7d1      	b.n	8046a0a <tcp_slowtmr+0x23e>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8046a66:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8046a68:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8046a6a:	8b23      	ldrh	r3, [r4, #24]
 8046a6c:	9301      	str	r3, [sp, #4]
 8046a6e:	8ae3      	ldrh	r3, [r4, #22]
 8046a70:	9300      	str	r3, [sp, #0]
 8046a72:	1d23      	adds	r3, r4, #4
 8046a74:	4622      	mov	r2, r4
 8046a76:	f002 fe65 	bl	8049744 <tcp_rst>
 8046a7a:	e7c7      	b.n	8046a0c <tcp_slowtmr+0x240>
        TCP_EVENT_POLL(prev, err);
 8046a7c:	2000      	movs	r0, #0
 8046a7e:	e757      	b.n	8046930 <tcp_slowtmr+0x164>
          tcp_output(prev);
 8046a80:	4620      	mov	r0, r4
 8046a82:	f002 fd17 	bl	80494b4 <tcp_output>
      prev = pcb;
 8046a86:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046a88:	462c      	mov	r4, r5
 8046a8a:	e01d      	b.n	8046ac8 <tcp_slowtmr+0x2fc>
 8046a8c:	200089a0 	.word	0x200089a0
 8046a90:	200042c9 	.word	0x200042c9
 8046a94:	2000899c 	.word	0x2000899c
 8046a98:	08058d90 	.word	0x08058d90
 8046a9c:	08058f30 	.word	0x08058f30
 8046aa0:	08058644 	.word	0x08058644
 8046aa4:	08058f5c 	.word	0x08058f5c
 8046aa8:	08058f88 	.word	0x08058f88
 8046aac:	08058560 	.word	0x08058560
 8046ab0:	20008998 	.word	0x20008998
 8046ab4:	10624dd3 	.word	0x10624dd3
 8046ab8:	000124f8 	.word	0x000124f8
 8046abc:	08058fb8 	.word	0x08058fb8
 8046ac0:	08058fe4 	.word	0x08058fe4
      prev = pcb;
 8046ac4:	4626      	mov	r6, r4
      pcb = pcb->next;
 8046ac6:	462c      	mov	r4, r5
  while (pcb != NULL) {
 8046ac8:	b394      	cbz	r4, 8046b30 <tcp_slowtmr+0x364>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8046aca:	7d23      	ldrb	r3, [r4, #20]
 8046acc:	2b00      	cmp	r3, #0
 8046ace:	f43f ae8c 	beq.w	80467ea <tcp_slowtmr+0x1e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 8046ad2:	7d23      	ldrb	r3, [r4, #20]
 8046ad4:	2b01      	cmp	r3, #1
 8046ad6:	f43f ae90 	beq.w	80467fa <tcp_slowtmr+0x2e>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 8046ada:	7d23      	ldrb	r3, [r4, #20]
 8046adc:	2b0a      	cmp	r3, #10
 8046ade:	f43f ae94 	beq.w	804680a <tcp_slowtmr+0x3e>
    if (pcb->last_timer == tcp_timer_ctr) {
 8046ae2:	7f62      	ldrb	r2, [r4, #29]
 8046ae4:	4b33      	ldr	r3, [pc, #204]	; (8046bb4 <tcp_slowtmr+0x3e8>)
 8046ae6:	781b      	ldrb	r3, [r3, #0]
 8046ae8:	429a      	cmp	r2, r3
 8046aea:	f43f ae96 	beq.w	804681a <tcp_slowtmr+0x4e>
    pcb->last_timer = tcp_timer_ctr;
 8046aee:	7763      	strb	r3, [r4, #29]
    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
 8046af0:	7d23      	ldrb	r3, [r4, #20]
 8046af2:	2b02      	cmp	r3, #2
 8046af4:	f43f ae93 	beq.w	804681e <tcp_slowtmr+0x52>
    else if (pcb->nrtx >= TCP_MAXRTX) {
 8046af8:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
 8046afc:	2a0b      	cmp	r2, #11
 8046afe:	f63f aee1 	bhi.w	80468c4 <tcp_slowtmr+0xf8>
      if (pcb->persist_backoff > 0) {
 8046b02:	f894 5095 	ldrb.w	r5, [r4, #149]	; 0x95
 8046b06:	2d00      	cmp	r5, #0
 8046b08:	f43f aea3 	beq.w	8046852 <tcp_slowtmr+0x86>
        u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
 8046b0c:	3d01      	subs	r5, #1
 8046b0e:	4b2a      	ldr	r3, [pc, #168]	; (8046bb8 <tcp_slowtmr+0x3ec>)
 8046b10:	441d      	add	r5, r3
 8046b12:	7c2a      	ldrb	r2, [r5, #16]
        if (pcb->persist_cnt < backoff_cnt) {
 8046b14:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8046b18:	4293      	cmp	r3, r2
 8046b1a:	d202      	bcs.n	8046b22 <tcp_slowtmr+0x356>
          pcb->persist_cnt++;
 8046b1c:	3301      	adds	r3, #1
 8046b1e:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
        if (pcb->persist_cnt >= backoff_cnt) {
 8046b22:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
 8046b26:	4293      	cmp	r3, r2
 8046b28:	f4bf ae80 	bcs.w	804682c <tcp_slowtmr+0x60>
    pcb_remove = 0;
 8046b2c:	2500      	movs	r5, #0
 8046b2e:	e6ca      	b.n	80468c6 <tcp_slowtmr+0xfa>
  pcb = tcp_tw_pcbs;
 8046b30:	4b22      	ldr	r3, [pc, #136]	; (8046bbc <tcp_slowtmr+0x3f0>)
 8046b32:	681d      	ldr	r5, [r3, #0]
  while (pcb != NULL) {
 8046b34:	e00e      	b.n	8046b54 <tcp_slowtmr+0x388>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8046b36:	4b22      	ldr	r3, [pc, #136]	; (8046bc0 <tcp_slowtmr+0x3f4>)
 8046b38:	f240 42bd 	movw	r2, #1213	; 0x4bd
 8046b3c:	4921      	ldr	r1, [pc, #132]	; (8046bc4 <tcp_slowtmr+0x3f8>)
 8046b3e:	4822      	ldr	r0, [pc, #136]	; (8046bc8 <tcp_slowtmr+0x3fc>)
 8046b40:	f00a fb54 	bl	80511ec <printf>
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8046b44:	6a2a      	ldr	r2, [r5, #32]
 8046b46:	4b21      	ldr	r3, [pc, #132]	; (8046bcc <tcp_slowtmr+0x400>)
 8046b48:	681b      	ldr	r3, [r3, #0]
 8046b4a:	1a9b      	subs	r3, r3, r2
 8046b4c:	2bf0      	cmp	r3, #240	; 0xf0
 8046b4e:	d806      	bhi.n	8046b5e <tcp_slowtmr+0x392>
      prev = pcb;
 8046b50:	462c      	mov	r4, r5
      pcb = pcb->next;
 8046b52:	68ed      	ldr	r5, [r5, #12]
  while (pcb != NULL) {
 8046b54:	b35d      	cbz	r5, 8046bae <tcp_slowtmr+0x3e2>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8046b56:	7d2b      	ldrb	r3, [r5, #20]
 8046b58:	2b0a      	cmp	r3, #10
 8046b5a:	d0f3      	beq.n	8046b44 <tcp_slowtmr+0x378>
 8046b5c:	e7eb      	b.n	8046b36 <tcp_slowtmr+0x36a>
      tcp_pcb_purge(pcb);
 8046b5e:	4628      	mov	r0, r5
 8046b60:	f7ff fe12 	bl	8046788 <tcp_pcb_purge>
      if (prev != NULL) {
 8046b64:	b1a4      	cbz	r4, 8046b90 <tcp_slowtmr+0x3c4>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8046b66:	4b15      	ldr	r3, [pc, #84]	; (8046bbc <tcp_slowtmr+0x3f0>)
 8046b68:	681b      	ldr	r3, [r3, #0]
 8046b6a:	42ab      	cmp	r3, r5
 8046b6c:	d008      	beq.n	8046b80 <tcp_slowtmr+0x3b4>
        prev->next = pcb->next;
 8046b6e:	68eb      	ldr	r3, [r5, #12]
 8046b70:	60e3      	str	r3, [r4, #12]
      pcb = pcb->next;
 8046b72:	68ee      	ldr	r6, [r5, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 8046b74:	4629      	mov	r1, r5
 8046b76:	2001      	movs	r0, #1
 8046b78:	f7fe feda 	bl	8045930 <memp_free>
      pcb = pcb->next;
 8046b7c:	4635      	mov	r5, r6
 8046b7e:	e7e9      	b.n	8046b54 <tcp_slowtmr+0x388>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8046b80:	4b0f      	ldr	r3, [pc, #60]	; (8046bc0 <tcp_slowtmr+0x3f4>)
 8046b82:	f240 42cb 	movw	r2, #1227	; 0x4cb
 8046b86:	4912      	ldr	r1, [pc, #72]	; (8046bd0 <tcp_slowtmr+0x404>)
 8046b88:	480f      	ldr	r0, [pc, #60]	; (8046bc8 <tcp_slowtmr+0x3fc>)
 8046b8a:	f00a fb2f 	bl	80511ec <printf>
 8046b8e:	e7ee      	b.n	8046b6e <tcp_slowtmr+0x3a2>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 8046b90:	4b0a      	ldr	r3, [pc, #40]	; (8046bbc <tcp_slowtmr+0x3f0>)
 8046b92:	681b      	ldr	r3, [r3, #0]
 8046b94:	42ab      	cmp	r3, r5
 8046b96:	d006      	beq.n	8046ba6 <tcp_slowtmr+0x3da>
 8046b98:	4b09      	ldr	r3, [pc, #36]	; (8046bc0 <tcp_slowtmr+0x3f4>)
 8046b9a:	f240 42cf 	movw	r2, #1231	; 0x4cf
 8046b9e:	490d      	ldr	r1, [pc, #52]	; (8046bd4 <tcp_slowtmr+0x408>)
 8046ba0:	4809      	ldr	r0, [pc, #36]	; (8046bc8 <tcp_slowtmr+0x3fc>)
 8046ba2:	f00a fb23 	bl	80511ec <printf>
        tcp_tw_pcbs = pcb->next;
 8046ba6:	68ea      	ldr	r2, [r5, #12]
 8046ba8:	4b04      	ldr	r3, [pc, #16]	; (8046bbc <tcp_slowtmr+0x3f0>)
 8046baa:	601a      	str	r2, [r3, #0]
 8046bac:	e7e1      	b.n	8046b72 <tcp_slowtmr+0x3a6>
}
 8046bae:	b002      	add	sp, #8
 8046bb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8046bb4:	200042c9 	.word	0x200042c9
 8046bb8:	08058560 	.word	0x08058560
 8046bbc:	200089ac 	.word	0x200089ac
 8046bc0:	08058d90 	.word	0x08058d90
 8046bc4:	08059010 	.word	0x08059010
 8046bc8:	08058644 	.word	0x08058644
 8046bcc:	200089a0 	.word	0x200089a0
 8046bd0:	08059040 	.word	0x08059040
 8046bd4:	08059068 	.word	0x08059068

08046bd8 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8046bd8:	b510      	push	{r4, lr}
 8046bda:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8046bdc:	6803      	ldr	r3, [r0, #0]
 8046bde:	428b      	cmp	r3, r1
 8046be0:	d005      	beq.n	8046bee <tcp_pcb_remove+0x16>
 8046be2:	b14b      	cbz	r3, 8046bf8 <tcp_pcb_remove+0x20>
 8046be4:	68da      	ldr	r2, [r3, #12]
 8046be6:	42a2      	cmp	r2, r4
 8046be8:	d004      	beq.n	8046bf4 <tcp_pcb_remove+0x1c>
 8046bea:	4613      	mov	r3, r2
 8046bec:	e7f9      	b.n	8046be2 <tcp_pcb_remove+0xa>
 8046bee:	68db      	ldr	r3, [r3, #12]
 8046bf0:	6003      	str	r3, [r0, #0]
 8046bf2:	e001      	b.n	8046bf8 <tcp_pcb_remove+0x20>
 8046bf4:	68e2      	ldr	r2, [r4, #12]
 8046bf6:	60da      	str	r2, [r3, #12]
 8046bf8:	2300      	movs	r3, #0
 8046bfa:	60e3      	str	r3, [r4, #12]

  tcp_pcb_purge(pcb);
 8046bfc:	4620      	mov	r0, r4
 8046bfe:	f7ff fdc3 	bl	8046788 <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8046c02:	7d23      	ldrb	r3, [r4, #20]
 8046c04:	2b0a      	cmp	r3, #10
 8046c06:	d005      	beq.n	8046c14 <tcp_pcb_remove+0x3c>
 8046c08:	2b01      	cmp	r3, #1
 8046c0a:	d003      	beq.n	8046c14 <tcp_pcb_remove+0x3c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8046c0c:	7ea3      	ldrb	r3, [r4, #26]
     pcb->state != LISTEN &&
 8046c0e:	f013 0f01 	tst.w	r3, #1
 8046c12:	d121      	bne.n	8046c58 <tcp_pcb_remove+0x80>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
 8046c14:	7d23      	ldrb	r3, [r4, #20]
 8046c16:	2b01      	cmp	r3, #1
 8046c18:	d01a      	beq.n	8046c50 <tcp_pcb_remove+0x78>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 8046c1a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8046c1c:	b133      	cbz	r3, 8046c2c <tcp_pcb_remove+0x54>
 8046c1e:	4b12      	ldr	r3, [pc, #72]	; (8046c68 <tcp_pcb_remove+0x90>)
 8046c20:	f240 7253 	movw	r2, #1875	; 0x753
 8046c24:	4911      	ldr	r1, [pc, #68]	; (8046c6c <tcp_pcb_remove+0x94>)
 8046c26:	4812      	ldr	r0, [pc, #72]	; (8046c70 <tcp_pcb_remove+0x98>)
 8046c28:	f00a fae0 	bl	80511ec <printf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 8046c2c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8046c2e:	b133      	cbz	r3, 8046c3e <tcp_pcb_remove+0x66>
 8046c30:	4b0d      	ldr	r3, [pc, #52]	; (8046c68 <tcp_pcb_remove+0x90>)
 8046c32:	f240 7254 	movw	r2, #1876	; 0x754
 8046c36:	490f      	ldr	r1, [pc, #60]	; (8046c74 <tcp_pcb_remove+0x9c>)
 8046c38:	480d      	ldr	r0, [pc, #52]	; (8046c70 <tcp_pcb_remove+0x98>)
 8046c3a:	f00a fad7 	bl	80511ec <printf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
 8046c3e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8046c40:	b133      	cbz	r3, 8046c50 <tcp_pcb_remove+0x78>
 8046c42:	4b09      	ldr	r3, [pc, #36]	; (8046c68 <tcp_pcb_remove+0x90>)
 8046c44:	f240 7256 	movw	r2, #1878	; 0x756
 8046c48:	490b      	ldr	r1, [pc, #44]	; (8046c78 <tcp_pcb_remove+0xa0>)
 8046c4a:	4809      	ldr	r0, [pc, #36]	; (8046c70 <tcp_pcb_remove+0x98>)
 8046c4c:	f00a face 	bl	80511ec <printf>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8046c50:	2300      	movs	r3, #0
 8046c52:	7523      	strb	r3, [r4, #20]
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
 8046c54:	82e3      	strh	r3, [r4, #22]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 8046c56:	bd10      	pop	{r4, pc}
    pcb->flags |= TF_ACK_NOW;
 8046c58:	f043 0302 	orr.w	r3, r3, #2
 8046c5c:	76a3      	strb	r3, [r4, #26]
    tcp_output(pcb);
 8046c5e:	4620      	mov	r0, r4
 8046c60:	f002 fc28 	bl	80494b4 <tcp_output>
 8046c64:	e7d6      	b.n	8046c14 <tcp_pcb_remove+0x3c>
 8046c66:	bf00      	nop
 8046c68:	08058d90 	.word	0x08058d90
 8046c6c:	08059090 	.word	0x08059090
 8046c70:	08058644 	.word	0x08058644
 8046c74:	080590a8 	.word	0x080590a8
 8046c78:	080590c4 	.word	0x080590c4

08046c7c <tcp_close_shutdown>:
{
 8046c7c:	b510      	push	{r4, lr}
 8046c7e:	b082      	sub	sp, #8
 8046c80:	4604      	mov	r4, r0
  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8046c82:	b121      	cbz	r1, 8046c8e <tcp_close_shutdown+0x12>
 8046c84:	7d03      	ldrb	r3, [r0, #20]
 8046c86:	2b04      	cmp	r3, #4
 8046c88:	d00c      	beq.n	8046ca4 <tcp_close_shutdown+0x28>
 8046c8a:	2b07      	cmp	r3, #7
 8046c8c:	d00a      	beq.n	8046ca4 <tcp_close_shutdown+0x28>
  switch (pcb->state) {
 8046c8e:	7d23      	ldrb	r3, [r4, #20]
 8046c90:	2b01      	cmp	r3, #1
 8046c92:	d070      	beq.n	8046d76 <tcp_close_shutdown+0xfa>
 8046c94:	2b02      	cmp	r3, #2
 8046c96:	d07b      	beq.n	8046d90 <tcp_close_shutdown+0x114>
 8046c98:	2b00      	cmp	r3, #0
 8046c9a:	d052      	beq.n	8046d42 <tcp_close_shutdown+0xc6>
    return tcp_close_shutdown_fin(pcb);
 8046c9c:	4620      	mov	r0, r4
 8046c9e:	f7ff fbcd 	bl	804643c <tcp_close_shutdown_fin>
 8046ca2:	e040      	b.n	8046d26 <tcp_close_shutdown+0xaa>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 8046ca4:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8046ca6:	b1d3      	cbz	r3, 8046cde <tcp_close_shutdown+0x62>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8046ca8:	7ea3      	ldrb	r3, [r4, #26]
 8046caa:	f013 0f10 	tst.w	r3, #16
 8046cae:	d01b      	beq.n	8046ce8 <tcp_close_shutdown+0x6c>
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8046cb0:	8b23      	ldrh	r3, [r4, #24]
 8046cb2:	9301      	str	r3, [sp, #4]
 8046cb4:	8ae3      	ldrh	r3, [r4, #22]
 8046cb6:	9300      	str	r3, [sp, #0]
 8046cb8:	1d23      	adds	r3, r4, #4
 8046cba:	4622      	mov	r2, r4
 8046cbc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8046cbe:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8046cc0:	f002 fd40 	bl	8049744 <tcp_rst>
      tcp_pcb_purge(pcb);
 8046cc4:	4620      	mov	r0, r4
 8046cc6:	f7ff fd5f 	bl	8046788 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8046cca:	4b37      	ldr	r3, [pc, #220]	; (8046da8 <tcp_close_shutdown+0x12c>)
 8046ccc:	681b      	ldr	r3, [r3, #0]
 8046cce:	42a3      	cmp	r3, r4
 8046cd0:	d012      	beq.n	8046cf8 <tcp_close_shutdown+0x7c>
 8046cd2:	b1bb      	cbz	r3, 8046d04 <tcp_close_shutdown+0x88>
 8046cd4:	68da      	ldr	r2, [r3, #12]
 8046cd6:	42a2      	cmp	r2, r4
 8046cd8:	d012      	beq.n	8046d00 <tcp_close_shutdown+0x84>
 8046cda:	4613      	mov	r3, r2
 8046cdc:	e7f9      	b.n	8046cd2 <tcp_close_shutdown+0x56>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
 8046cde:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8046ce0:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8046ce4:	d0d3      	beq.n	8046c8e <tcp_close_shutdown+0x12>
 8046ce6:	e7df      	b.n	8046ca8 <tcp_close_shutdown+0x2c>
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8046ce8:	4b30      	ldr	r3, [pc, #192]	; (8046dac <tcp_close_shutdown+0x130>)
 8046cea:	f240 120f 	movw	r2, #271	; 0x10f
 8046cee:	4930      	ldr	r1, [pc, #192]	; (8046db0 <tcp_close_shutdown+0x134>)
 8046cf0:	4830      	ldr	r0, [pc, #192]	; (8046db4 <tcp_close_shutdown+0x138>)
 8046cf2:	f00a fa7b 	bl	80511ec <printf>
 8046cf6:	e7db      	b.n	8046cb0 <tcp_close_shutdown+0x34>
      TCP_RMV_ACTIVE(pcb);
 8046cf8:	68da      	ldr	r2, [r3, #12]
 8046cfa:	4b2b      	ldr	r3, [pc, #172]	; (8046da8 <tcp_close_shutdown+0x12c>)
 8046cfc:	601a      	str	r2, [r3, #0]
 8046cfe:	e001      	b.n	8046d04 <tcp_close_shutdown+0x88>
 8046d00:	68e2      	ldr	r2, [r4, #12]
 8046d02:	60da      	str	r2, [r3, #12]
 8046d04:	2300      	movs	r3, #0
 8046d06:	60e3      	str	r3, [r4, #12]
 8046d08:	4b2b      	ldr	r3, [pc, #172]	; (8046db8 <tcp_close_shutdown+0x13c>)
 8046d0a:	2201      	movs	r2, #1
 8046d0c:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
 8046d0e:	7d23      	ldrb	r3, [r4, #20]
 8046d10:	2b04      	cmp	r3, #4
 8046d12:	d00a      	beq.n	8046d2a <tcp_close_shutdown+0xae>
        if (tcp_input_pcb == pcb) {
 8046d14:	4b29      	ldr	r3, [pc, #164]	; (8046dbc <tcp_close_shutdown+0x140>)
 8046d16:	681b      	ldr	r3, [r3, #0]
 8046d18:	42a3      	cmp	r3, r4
 8046d1a:	d00f      	beq.n	8046d3c <tcp_close_shutdown+0xc0>
          memp_free(MEMP_TCP_PCB, pcb);
 8046d1c:	4621      	mov	r1, r4
 8046d1e:	2001      	movs	r0, #1
 8046d20:	f7fe fe06 	bl	8045930 <memp_free>
      return ERR_OK;
 8046d24:	2000      	movs	r0, #0
}
 8046d26:	b002      	add	sp, #8
 8046d28:	bd10      	pop	{r4, pc}
        pcb->state = TIME_WAIT;
 8046d2a:	230a      	movs	r3, #10
 8046d2c:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 8046d2e:	4b24      	ldr	r3, [pc, #144]	; (8046dc0 <tcp_close_shutdown+0x144>)
 8046d30:	681a      	ldr	r2, [r3, #0]
 8046d32:	60e2      	str	r2, [r4, #12]
 8046d34:	601c      	str	r4, [r3, #0]
 8046d36:	f002 feb5 	bl	8049aa4 <tcp_timer_needed>
 8046d3a:	e7f3      	b.n	8046d24 <tcp_close_shutdown+0xa8>
          tcp_trigger_input_pcb_close();
 8046d3c:	f001 fe64 	bl	8048a08 <tcp_trigger_input_pcb_close>
 8046d40:	e7f0      	b.n	8046d24 <tcp_close_shutdown+0xa8>
    if (pcb->local_port != 0) {
 8046d42:	8ae3      	ldrh	r3, [r4, #22]
 8046d44:	b18b      	cbz	r3, 8046d6a <tcp_close_shutdown+0xee>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8046d46:	4b1f      	ldr	r3, [pc, #124]	; (8046dc4 <tcp_close_shutdown+0x148>)
 8046d48:	681b      	ldr	r3, [r3, #0]
 8046d4a:	42a3      	cmp	r3, r4
 8046d4c:	d005      	beq.n	8046d5a <tcp_close_shutdown+0xde>
 8046d4e:	b153      	cbz	r3, 8046d66 <tcp_close_shutdown+0xea>
 8046d50:	68da      	ldr	r2, [r3, #12]
 8046d52:	42a2      	cmp	r2, r4
 8046d54:	d005      	beq.n	8046d62 <tcp_close_shutdown+0xe6>
 8046d56:	4613      	mov	r3, r2
 8046d58:	e7f9      	b.n	8046d4e <tcp_close_shutdown+0xd2>
 8046d5a:	68da      	ldr	r2, [r3, #12]
 8046d5c:	4b19      	ldr	r3, [pc, #100]	; (8046dc4 <tcp_close_shutdown+0x148>)
 8046d5e:	601a      	str	r2, [r3, #0]
 8046d60:	e001      	b.n	8046d66 <tcp_close_shutdown+0xea>
 8046d62:	68e2      	ldr	r2, [r4, #12]
 8046d64:	60da      	str	r2, [r3, #12]
 8046d66:	2300      	movs	r3, #0
 8046d68:	60e3      	str	r3, [r4, #12]
    memp_free(MEMP_TCP_PCB, pcb);
 8046d6a:	4621      	mov	r1, r4
 8046d6c:	2001      	movs	r0, #1
 8046d6e:	f7fe fddf 	bl	8045930 <memp_free>
  return ERR_OK;
 8046d72:	2000      	movs	r0, #0
    break;
 8046d74:	e7d7      	b.n	8046d26 <tcp_close_shutdown+0xaa>
    tcp_listen_closed(pcb);
 8046d76:	4620      	mov	r0, r4
 8046d78:	f7ff fb34 	bl	80463e4 <tcp_listen_closed>
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8046d7c:	4621      	mov	r1, r4
 8046d7e:	4812      	ldr	r0, [pc, #72]	; (8046dc8 <tcp_close_shutdown+0x14c>)
 8046d80:	f7ff ff2a 	bl	8046bd8 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8046d84:	4621      	mov	r1, r4
 8046d86:	2002      	movs	r0, #2
 8046d88:	f7fe fdd2 	bl	8045930 <memp_free>
  return ERR_OK;
 8046d8c:	2000      	movs	r0, #0
    break;
 8046d8e:	e7ca      	b.n	8046d26 <tcp_close_shutdown+0xaa>
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8046d90:	4621      	mov	r1, r4
 8046d92:	4805      	ldr	r0, [pc, #20]	; (8046da8 <tcp_close_shutdown+0x12c>)
 8046d94:	f7ff ff20 	bl	8046bd8 <tcp_pcb_remove>
 8046d98:	2001      	movs	r0, #1
 8046d9a:	4b07      	ldr	r3, [pc, #28]	; (8046db8 <tcp_close_shutdown+0x13c>)
 8046d9c:	7018      	strb	r0, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 8046d9e:	4621      	mov	r1, r4
 8046da0:	f7fe fdc6 	bl	8045930 <memp_free>
  return ERR_OK;
 8046da4:	2000      	movs	r0, #0
    break;
 8046da6:	e7be      	b.n	8046d26 <tcp_close_shutdown+0xaa>
 8046da8:	2000899c 	.word	0x2000899c
 8046dac:	08058d90 	.word	0x08058d90
 8046db0:	080590dc 	.word	0x080590dc
 8046db4:	08058644 	.word	0x08058644
 8046db8:	20008998 	.word	0x20008998
 8046dbc:	200089b0 	.word	0x200089b0
 8046dc0:	200089ac 	.word	0x200089ac
 8046dc4:	200089a8 	.word	0x200089a8
 8046dc8:	200089a4 	.word	0x200089a4

08046dcc <tcp_close>:
{
 8046dcc:	b508      	push	{r3, lr}
  if (pcb->state != LISTEN) {
 8046dce:	7d03      	ldrb	r3, [r0, #20]
 8046dd0:	2b01      	cmp	r3, #1
 8046dd2:	d003      	beq.n	8046ddc <tcp_close+0x10>
    pcb->flags |= TF_RXCLOSED;
 8046dd4:	7e83      	ldrb	r3, [r0, #26]
 8046dd6:	f043 0310 	orr.w	r3, r3, #16
 8046dda:	7683      	strb	r3, [r0, #26]
  return tcp_close_shutdown(pcb, 1);
 8046ddc:	2101      	movs	r1, #1
 8046dde:	f7ff ff4d 	bl	8046c7c <tcp_close_shutdown>
}
 8046de2:	bd08      	pop	{r3, pc}

08046de4 <tcp_recv_null>:
{
 8046de4:	b510      	push	{r4, lr}
 8046de6:	4608      	mov	r0, r1
  if (p != NULL) {
 8046de8:	b142      	cbz	r2, 8046dfc <tcp_recv_null+0x18>
 8046dea:	4614      	mov	r4, r2
    tcp_recved(pcb, p->tot_len);
 8046dec:	8911      	ldrh	r1, [r2, #8]
 8046dee:	f7ff fbf5 	bl	80465dc <tcp_recved>
    pbuf_free(p);
 8046df2:	4620      	mov	r0, r4
 8046df4:	f7fe ff50 	bl	8045c98 <pbuf_free>
  return ERR_OK;
 8046df8:	2000      	movs	r0, #0
}
 8046dfa:	bd10      	pop	{r4, pc}
  } else if (err == ERR_OK) {
 8046dfc:	b10b      	cbz	r3, 8046e02 <tcp_recv_null+0x1e>
  return ERR_OK;
 8046dfe:	2000      	movs	r0, #0
 8046e00:	e7fb      	b.n	8046dfa <tcp_recv_null+0x16>
    return tcp_close(pcb);
 8046e02:	f7ff ffe3 	bl	8046dcc <tcp_close>
 8046e06:	e7f8      	b.n	8046dfa <tcp_recv_null+0x16>

08046e08 <tcp_process_refused_data>:
{
 8046e08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8046e0a:	4604      	mov	r4, r0
    u8_t refused_flags = pcb->refused_data->flags;
 8046e0c:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8046e0e:	7b77      	ldrb	r7, [r6, #13]
    pcb->refused_data = NULL;
 8046e10:	2300      	movs	r3, #0
 8046e12:	6743      	str	r3, [r0, #116]	; 0x74
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8046e14:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
 8046e18:	b1dd      	cbz	r5, 8046e52 <tcp_process_refused_data+0x4a>
 8046e1a:	4632      	mov	r2, r6
 8046e1c:	4601      	mov	r1, r0
 8046e1e:	6900      	ldr	r0, [r0, #16]
 8046e20:	47a8      	blx	r5
 8046e22:	4605      	mov	r5, r0
    if (err == ERR_OK) {
 8046e24:	b9ed      	cbnz	r5, 8046e62 <tcp_process_refused_data+0x5a>
      if (refused_flags & PBUF_FLAG_TCP_FIN
 8046e26:	f017 0f20 	tst.w	r7, #32
 8046e2a:	d020      	beq.n	8046e6e <tcp_process_refused_data+0x66>
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 8046e2c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8046e2e:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 8046e32:	d001      	beq.n	8046e38 <tcp_process_refused_data+0x30>
          pcb->rcv_wnd++;
 8046e34:	3301      	adds	r3, #1
 8046e36:	8523      	strh	r3, [r4, #40]	; 0x28
        TCP_EVENT_CLOSED(pcb, err);
 8046e38:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
 8046e3c:	b1be      	cbz	r6, 8046e6e <tcp_process_refused_data+0x66>
 8046e3e:	2300      	movs	r3, #0
 8046e40:	461a      	mov	r2, r3
 8046e42:	4621      	mov	r1, r4
 8046e44:	6920      	ldr	r0, [r4, #16]
 8046e46:	47b0      	blx	r6
        if (err == ERR_ABRT) {
 8046e48:	f110 0f0d 	cmn.w	r0, #13
 8046e4c:	d10f      	bne.n	8046e6e <tcp_process_refused_data+0x66>
          return ERR_ABRT;
 8046e4e:	4605      	mov	r5, r0
 8046e50:	e00d      	b.n	8046e6e <tcp_process_refused_data+0x66>
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 8046e52:	2300      	movs	r3, #0
 8046e54:	4632      	mov	r2, r6
 8046e56:	4601      	mov	r1, r0
 8046e58:	4618      	mov	r0, r3
 8046e5a:	f7ff ffc3 	bl	8046de4 <tcp_recv_null>
 8046e5e:	4605      	mov	r5, r0
 8046e60:	e7e0      	b.n	8046e24 <tcp_process_refused_data+0x1c>
    } else if (err == ERR_ABRT) {
 8046e62:	f115 0f0d 	cmn.w	r5, #13
 8046e66:	d002      	beq.n	8046e6e <tcp_process_refused_data+0x66>
      pcb->refused_data = refused_data;
 8046e68:	6766      	str	r6, [r4, #116]	; 0x74
      return ERR_INPROGRESS;
 8046e6a:	f06f 0504 	mvn.w	r5, #4
}
 8046e6e:	4628      	mov	r0, r5
 8046e70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08046e74 <tcp_fasttmr>:
{
 8046e74:	b570      	push	{r4, r5, r6, lr}
  ++tcp_timer_ctr;
 8046e76:	4a1c      	ldr	r2, [pc, #112]	; (8046ee8 <tcp_fasttmr+0x74>)
 8046e78:	7813      	ldrb	r3, [r2, #0]
 8046e7a:	3301      	adds	r3, #1
 8046e7c:	7013      	strb	r3, [r2, #0]
  pcb = tcp_active_pcbs;
 8046e7e:	4b1b      	ldr	r3, [pc, #108]	; (8046eec <tcp_fasttmr+0x78>)
 8046e80:	681c      	ldr	r4, [r3, #0]
  while (pcb != NULL) {
 8046e82:	e013      	b.n	8046eac <tcp_fasttmr+0x38>
        tcp_ack_now(pcb);
 8046e84:	f043 0302 	orr.w	r3, r3, #2
 8046e88:	76a3      	strb	r3, [r4, #26]
        tcp_output(pcb);
 8046e8a:	4620      	mov	r0, r4
 8046e8c:	f002 fb12 	bl	80494b4 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 8046e90:	7ea3      	ldrb	r3, [r4, #26]
 8046e92:	f023 0303 	bic.w	r3, r3, #3
 8046e96:	76a3      	strb	r3, [r4, #26]
 8046e98:	e013      	b.n	8046ec2 <tcp_fasttmr+0x4e>
        pcb->flags &= ~(TF_CLOSEPEND);
 8046e9a:	f023 0308 	bic.w	r3, r3, #8
 8046e9e:	76a3      	strb	r3, [r4, #26]
        tcp_close_shutdown_fin(pcb);
 8046ea0:	4620      	mov	r0, r4
 8046ea2:	f7ff facb 	bl	804643c <tcp_close_shutdown_fin>
 8046ea6:	e010      	b.n	8046eca <tcp_fasttmr+0x56>
      pcb = pcb->next;
 8046ea8:	68e5      	ldr	r5, [r4, #12]
{
 8046eaa:	462c      	mov	r4, r5
  while (pcb != NULL) {
 8046eac:	b1dc      	cbz	r4, 8046ee6 <tcp_fasttmr+0x72>
    if (pcb->last_timer != tcp_timer_ctr) {
 8046eae:	7f62      	ldrb	r2, [r4, #29]
 8046eb0:	4b0d      	ldr	r3, [pc, #52]	; (8046ee8 <tcp_fasttmr+0x74>)
 8046eb2:	781b      	ldrb	r3, [r3, #0]
 8046eb4:	429a      	cmp	r2, r3
 8046eb6:	d0f7      	beq.n	8046ea8 <tcp_fasttmr+0x34>
      pcb->last_timer = tcp_timer_ctr;
 8046eb8:	7763      	strb	r3, [r4, #29]
      if (pcb->flags & TF_ACK_DELAY) {
 8046eba:	7ea3      	ldrb	r3, [r4, #26]
 8046ebc:	f013 0f01 	tst.w	r3, #1
 8046ec0:	d1e0      	bne.n	8046e84 <tcp_fasttmr+0x10>
      if (pcb->flags & TF_CLOSEPEND) {
 8046ec2:	7ea3      	ldrb	r3, [r4, #26]
 8046ec4:	f013 0f08 	tst.w	r3, #8
 8046ec8:	d1e7      	bne.n	8046e9a <tcp_fasttmr+0x26>
      next = pcb->next;
 8046eca:	68e5      	ldr	r5, [r4, #12]
      if (pcb->refused_data != NULL) {
 8046ecc:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8046ece:	2b00      	cmp	r3, #0
 8046ed0:	d0eb      	beq.n	8046eaa <tcp_fasttmr+0x36>
        tcp_active_pcbs_changed = 0;
 8046ed2:	4e07      	ldr	r6, [pc, #28]	; (8046ef0 <tcp_fasttmr+0x7c>)
 8046ed4:	2300      	movs	r3, #0
 8046ed6:	7033      	strb	r3, [r6, #0]
        tcp_process_refused_data(pcb);
 8046ed8:	4620      	mov	r0, r4
 8046eda:	f7ff ff95 	bl	8046e08 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 8046ede:	7833      	ldrb	r3, [r6, #0]
 8046ee0:	2b00      	cmp	r3, #0
 8046ee2:	d0e2      	beq.n	8046eaa <tcp_fasttmr+0x36>
 8046ee4:	e7cb      	b.n	8046e7e <tcp_fasttmr+0xa>
}
 8046ee6:	bd70      	pop	{r4, r5, r6, pc}
 8046ee8:	200042c9 	.word	0x200042c9
 8046eec:	2000899c 	.word	0x2000899c
 8046ef0:	20008998 	.word	0x20008998

08046ef4 <tcp_tmr>:
{
 8046ef4:	b508      	push	{r3, lr}
  tcp_fasttmr();
 8046ef6:	f7ff ffbd 	bl	8046e74 <tcp_fasttmr>
  if (++tcp_timer & 1) {
 8046efa:	4a06      	ldr	r2, [pc, #24]	; (8046f14 <tcp_tmr+0x20>)
 8046efc:	7853      	ldrb	r3, [r2, #1]
 8046efe:	3301      	adds	r3, #1
 8046f00:	b2db      	uxtb	r3, r3
 8046f02:	7053      	strb	r3, [r2, #1]
 8046f04:	f013 0f01 	tst.w	r3, #1
 8046f08:	d100      	bne.n	8046f0c <tcp_tmr+0x18>
}
 8046f0a:	bd08      	pop	{r3, pc}
    tcp_slowtmr();
 8046f0c:	f7ff fc5e 	bl	80467cc <tcp_slowtmr>
}
 8046f10:	e7fb      	b.n	8046f0a <tcp_tmr+0x16>
 8046f12:	bf00      	nop
 8046f14:	200042c9 	.word	0x200042c9

08046f18 <tcp_abandon>:
{
 8046f18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8046f1c:	b082      	sub	sp, #8
 8046f1e:	4604      	mov	r4, r0
 8046f20:	460d      	mov	r5, r1
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 8046f22:	7d03      	ldrb	r3, [r0, #20]
 8046f24:	2b01      	cmp	r3, #1
 8046f26:	d01a      	beq.n	8046f5e <tcp_abandon+0x46>
  if (pcb->state == TIME_WAIT) {
 8046f28:	7d23      	ldrb	r3, [r4, #20]
 8046f2a:	2b0a      	cmp	r3, #10
 8046f2c:	d01f      	beq.n	8046f6e <tcp_abandon+0x56>
    seqno = pcb->snd_nxt;
 8046f2e:	f8d4 804c 	ldr.w	r8, [r4, #76]	; 0x4c
    ackno = pcb->rcv_nxt;
 8046f32:	f8d4 9024 	ldr.w	r9, [r4, #36]	; 0x24
    errf = pcb->errf;
 8046f36:	f8d4 608c 	ldr.w	r6, [r4, #140]	; 0x8c
    errf_arg = pcb->callback_arg;
 8046f3a:	6927      	ldr	r7, [r4, #16]
    if (pcb->state == CLOSED) {
 8046f3c:	2b00      	cmp	r3, #0
 8046f3e:	d141      	bne.n	8046fc4 <tcp_abandon+0xac>
      if (pcb->local_port != 0) {
 8046f40:	f8b4 a016 	ldrh.w	sl, [r4, #22]
 8046f44:	f1ba 0f00 	cmp.w	sl, #0
 8046f48:	d046      	beq.n	8046fd8 <tcp_abandon+0xc0>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 8046f4a:	4b2a      	ldr	r3, [pc, #168]	; (8046ff4 <tcp_abandon+0xdc>)
 8046f4c:	681b      	ldr	r3, [r3, #0]
 8046f4e:	42a3      	cmp	r3, r4
 8046f50:	d016      	beq.n	8046f80 <tcp_abandon+0x68>
 8046f52:	b1db      	cbz	r3, 8046f8c <tcp_abandon+0x74>
 8046f54:	68da      	ldr	r2, [r3, #12]
 8046f56:	42a2      	cmp	r2, r4
 8046f58:	d016      	beq.n	8046f88 <tcp_abandon+0x70>
 8046f5a:	4613      	mov	r3, r2
 8046f5c:	e7f9      	b.n	8046f52 <tcp_abandon+0x3a>
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 8046f5e:	4b26      	ldr	r3, [pc, #152]	; (8046ff8 <tcp_abandon+0xe0>)
 8046f60:	f240 12df 	movw	r2, #479	; 0x1df
 8046f64:	4925      	ldr	r1, [pc, #148]	; (8046ffc <tcp_abandon+0xe4>)
 8046f66:	4826      	ldr	r0, [pc, #152]	; (8047000 <tcp_abandon+0xe8>)
 8046f68:	f00a f940 	bl	80511ec <printf>
 8046f6c:	e7dc      	b.n	8046f28 <tcp_abandon+0x10>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 8046f6e:	4621      	mov	r1, r4
 8046f70:	4824      	ldr	r0, [pc, #144]	; (8047004 <tcp_abandon+0xec>)
 8046f72:	f7ff fe31 	bl	8046bd8 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8046f76:	4621      	mov	r1, r4
 8046f78:	2001      	movs	r0, #1
 8046f7a:	f7fe fcd9 	bl	8045930 <memp_free>
 8046f7e:	e01e      	b.n	8046fbe <tcp_abandon+0xa6>
        TCP_RMV(&tcp_bound_pcbs, pcb);
 8046f80:	68da      	ldr	r2, [r3, #12]
 8046f82:	4b1c      	ldr	r3, [pc, #112]	; (8046ff4 <tcp_abandon+0xdc>)
 8046f84:	601a      	str	r2, [r3, #0]
 8046f86:	e001      	b.n	8046f8c <tcp_abandon+0x74>
 8046f88:	68e2      	ldr	r2, [r4, #12]
 8046f8a:	60da      	str	r2, [r3, #12]
 8046f8c:	2500      	movs	r5, #0
 8046f8e:	60e5      	str	r5, [r4, #12]
    u16_t local_port = 0;
 8046f90:	46aa      	mov	sl, r5
    if (pcb->unacked != NULL) {
 8046f92:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8046f94:	b108      	cbz	r0, 8046f9a <tcp_abandon+0x82>
      tcp_segs_free(pcb->unacked);
 8046f96:	f7ff fb70 	bl	804667a <tcp_segs_free>
    if (pcb->unsent != NULL) {
 8046f9a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8046f9c:	b108      	cbz	r0, 8046fa2 <tcp_abandon+0x8a>
      tcp_segs_free(pcb->unsent);
 8046f9e:	f7ff fb6c 	bl	804667a <tcp_segs_free>
    if (pcb->ooseq != NULL) {
 8046fa2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8046fa4:	b108      	cbz	r0, 8046faa <tcp_abandon+0x92>
      tcp_segs_free(pcb->ooseq);
 8046fa6:	f7ff fb68 	bl	804667a <tcp_segs_free>
    if (send_rst) {
 8046faa:	b9bd      	cbnz	r5, 8046fdc <tcp_abandon+0xc4>
    memp_free(MEMP_TCP_PCB, pcb);
 8046fac:	4621      	mov	r1, r4
 8046fae:	2001      	movs	r0, #1
 8046fb0:	f7fe fcbe 	bl	8045930 <memp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
 8046fb4:	b11e      	cbz	r6, 8046fbe <tcp_abandon+0xa6>
 8046fb6:	f06f 010c 	mvn.w	r1, #12
 8046fba:	4638      	mov	r0, r7
 8046fbc:	47b0      	blx	r6
}
 8046fbe:	b002      	add	sp, #8
 8046fc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      local_port = pcb->local_port;
 8046fc4:	f8b4 a016 	ldrh.w	sl, [r4, #22]
      TCP_PCB_REMOVE_ACTIVE(pcb);
 8046fc8:	4621      	mov	r1, r4
 8046fca:	480f      	ldr	r0, [pc, #60]	; (8047008 <tcp_abandon+0xf0>)
 8046fcc:	f7ff fe04 	bl	8046bd8 <tcp_pcb_remove>
 8046fd0:	4b0e      	ldr	r3, [pc, #56]	; (804700c <tcp_abandon+0xf4>)
 8046fd2:	2201      	movs	r2, #1
 8046fd4:	701a      	strb	r2, [r3, #0]
 8046fd6:	e7dc      	b.n	8046f92 <tcp_abandon+0x7a>
    int send_rst = 0;
 8046fd8:	2500      	movs	r5, #0
 8046fda:	e7da      	b.n	8046f92 <tcp_abandon+0x7a>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
 8046fdc:	8b23      	ldrh	r3, [r4, #24]
 8046fde:	9301      	str	r3, [sp, #4]
 8046fe0:	f8cd a000 	str.w	sl, [sp]
 8046fe4:	1d23      	adds	r3, r4, #4
 8046fe6:	4622      	mov	r2, r4
 8046fe8:	4649      	mov	r1, r9
 8046fea:	4640      	mov	r0, r8
 8046fec:	f002 fbaa 	bl	8049744 <tcp_rst>
 8046ff0:	e7dc      	b.n	8046fac <tcp_abandon+0x94>
 8046ff2:	bf00      	nop
 8046ff4:	200089a8 	.word	0x200089a8
 8046ff8:	08058d90 	.word	0x08058d90
 8046ffc:	080590f8 	.word	0x080590f8
 8047000:	08058644 	.word	0x08058644
 8047004:	200089ac 	.word	0x200089ac
 8047008:	2000899c 	.word	0x2000899c
 804700c:	20008998 	.word	0x20008998

08047010 <tcp_abort>:
{
 8047010:	b508      	push	{r3, lr}
  tcp_abandon(pcb, 1);
 8047012:	2101      	movs	r1, #1
 8047014:	f7ff ff80 	bl	8046f18 <tcp_abandon>
}
 8047018:	bd08      	pop	{r3, pc}
	...

0804701c <tcp_kill_timewait>:
{
 804701c:	b510      	push	{r4, lr}
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 804701e:	4b0a      	ldr	r3, [pc, #40]	; (8047048 <tcp_kill_timewait+0x2c>)
 8047020:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 8047022:	2400      	movs	r4, #0
  inactive = NULL;
 8047024:	4620      	mov	r0, r4
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8047026:	e000      	b.n	804702a <tcp_kill_timewait+0xe>
 8047028:	68db      	ldr	r3, [r3, #12]
 804702a:	b143      	cbz	r3, 804703e <tcp_kill_timewait+0x22>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 804702c:	6a19      	ldr	r1, [r3, #32]
 804702e:	4a07      	ldr	r2, [pc, #28]	; (804704c <tcp_kill_timewait+0x30>)
 8047030:	6812      	ldr	r2, [r2, #0]
 8047032:	1a52      	subs	r2, r2, r1
 8047034:	42a2      	cmp	r2, r4
 8047036:	d3f7      	bcc.n	8047028 <tcp_kill_timewait+0xc>
      inactivity = tcp_ticks - pcb->tmr;
 8047038:	4614      	mov	r4, r2
      inactive = pcb;
 804703a:	4618      	mov	r0, r3
 804703c:	e7f4      	b.n	8047028 <tcp_kill_timewait+0xc>
  if (inactive != NULL) {
 804703e:	b108      	cbz	r0, 8047044 <tcp_kill_timewait+0x28>
    tcp_abort(inactive);
 8047040:	f7ff ffe6 	bl	8047010 <tcp_abort>
}
 8047044:	bd10      	pop	{r4, pc}
 8047046:	bf00      	nop
 8047048:	200089ac 	.word	0x200089ac
 804704c:	200089a0 	.word	0x200089a0

08047050 <tcp_kill_prio>:
{
 8047050:	b570      	push	{r4, r5, r6, lr}
 8047052:	4604      	mov	r4, r0
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 8047054:	f010 0f80 	tst.w	r0, #128	; 0x80
 8047058:	d104      	bne.n	8047064 <tcp_kill_prio+0x14>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 804705a:	4b0d      	ldr	r3, [pc, #52]	; (8047090 <tcp_kill_prio+0x40>)
 804705c:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 804705e:	2600      	movs	r6, #0
  inactive = NULL;
 8047060:	4630      	mov	r0, r6
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8047062:	e002      	b.n	804706a <tcp_kill_prio+0x1a>
  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
 8047064:	247f      	movs	r4, #127	; 0x7f
 8047066:	e7f8      	b.n	804705a <tcp_kill_prio+0xa>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8047068:	68db      	ldr	r3, [r3, #12]
 804706a:	b163      	cbz	r3, 8047086 <tcp_kill_prio+0x36>
    if (pcb->prio <= mprio &&
 804706c:	7d59      	ldrb	r1, [r3, #21]
 804706e:	42a1      	cmp	r1, r4
 8047070:	d8fa      	bhi.n	8047068 <tcp_kill_prio+0x18>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 8047072:	6a1d      	ldr	r5, [r3, #32]
 8047074:	4a07      	ldr	r2, [pc, #28]	; (8047094 <tcp_kill_prio+0x44>)
 8047076:	6812      	ldr	r2, [r2, #0]
 8047078:	1b52      	subs	r2, r2, r5
    if (pcb->prio <= mprio &&
 804707a:	42b2      	cmp	r2, r6
 804707c:	d3f4      	bcc.n	8047068 <tcp_kill_prio+0x18>
      mprio = pcb->prio;
 804707e:	460c      	mov	r4, r1
      inactivity = tcp_ticks - pcb->tmr;
 8047080:	4616      	mov	r6, r2
      inactive = pcb;
 8047082:	4618      	mov	r0, r3
 8047084:	e7f0      	b.n	8047068 <tcp_kill_prio+0x18>
  if (inactive != NULL) {
 8047086:	b108      	cbz	r0, 804708c <tcp_kill_prio+0x3c>
    tcp_abort(inactive);
 8047088:	f7ff ffc2 	bl	8047010 <tcp_abort>
}
 804708c:	bd70      	pop	{r4, r5, r6, pc}
 804708e:	bf00      	nop
 8047090:	2000899c 	.word	0x2000899c
 8047094:	200089a0 	.word	0x200089a0

08047098 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t* old_addr, struct tcp_pcb* pcb_list)
{
 8047098:	b538      	push	{r3, r4, r5, lr}
 804709a:	4604      	mov	r4, r0
 804709c:	4608      	mov	r0, r1
  struct tcp_pcb *pcb;
  pcb = pcb_list;
  while (pcb != NULL) {
 804709e:	e003      	b.n	80470a8 <tcp_netif_ip_addr_changed_pcblist+0x10>
      /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
      && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
      ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
 80470a0:	68c5      	ldr	r5, [r0, #12]
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
      tcp_abort(pcb);
 80470a2:	f7ff ffb5 	bl	8047010 <tcp_abort>
      pcb = next;
 80470a6:	4628      	mov	r0, r5
  while (pcb != NULL) {
 80470a8:	b128      	cbz	r0, 80470b6 <tcp_netif_ip_addr_changed_pcblist+0x1e>
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
 80470aa:	6802      	ldr	r2, [r0, #0]
 80470ac:	6823      	ldr	r3, [r4, #0]
 80470ae:	429a      	cmp	r2, r3
 80470b0:	d0f6      	beq.n	80470a0 <tcp_netif_ip_addr_changed_pcblist+0x8>
    } else {
      pcb = pcb->next;
 80470b2:	68c0      	ldr	r0, [r0, #12]
 80470b4:	e7f8      	b.n	80470a8 <tcp_netif_ip_addr_changed_pcblist+0x10>
    }
  }
}
 80470b6:	bd38      	pop	{r3, r4, r5, pc}

080470b8 <tcp_kill_state>:
{
 80470b8:	b538      	push	{r3, r4, r5, lr}
 80470ba:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 80470bc:	f1a0 0308 	sub.w	r3, r0, #8
 80470c0:	b2db      	uxtb	r3, r3
 80470c2:	2b01      	cmp	r3, #1
 80470c4:	d804      	bhi.n	80470d0 <tcp_kill_state+0x18>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80470c6:	4b10      	ldr	r3, [pc, #64]	; (8047108 <tcp_kill_state+0x50>)
 80470c8:	681b      	ldr	r3, [r3, #0]
  inactivity = 0;
 80470ca:	2100      	movs	r1, #0
  inactive = NULL;
 80470cc:	4608      	mov	r0, r1
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80470ce:	e008      	b.n	80470e2 <tcp_kill_state+0x2a>
  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
 80470d0:	4b0e      	ldr	r3, [pc, #56]	; (804710c <tcp_kill_state+0x54>)
 80470d2:	f240 52dc 	movw	r2, #1500	; 0x5dc
 80470d6:	490e      	ldr	r1, [pc, #56]	; (8047110 <tcp_kill_state+0x58>)
 80470d8:	480e      	ldr	r0, [pc, #56]	; (8047114 <tcp_kill_state+0x5c>)
 80470da:	f00a f887 	bl	80511ec <printf>
 80470de:	e7f2      	b.n	80470c6 <tcp_kill_state+0xe>
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 80470e0:	68db      	ldr	r3, [r3, #12]
 80470e2:	b15b      	cbz	r3, 80470fc <tcp_kill_state+0x44>
    if (pcb->state == state) {
 80470e4:	7d1a      	ldrb	r2, [r3, #20]
 80470e6:	42a2      	cmp	r2, r4
 80470e8:	d1fa      	bne.n	80470e0 <tcp_kill_state+0x28>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 80470ea:	6a1d      	ldr	r5, [r3, #32]
 80470ec:	4a0a      	ldr	r2, [pc, #40]	; (8047118 <tcp_kill_state+0x60>)
 80470ee:	6812      	ldr	r2, [r2, #0]
 80470f0:	1b52      	subs	r2, r2, r5
 80470f2:	428a      	cmp	r2, r1
 80470f4:	d3f4      	bcc.n	80470e0 <tcp_kill_state+0x28>
        inactivity = tcp_ticks - pcb->tmr;
 80470f6:	4611      	mov	r1, r2
        inactive = pcb;
 80470f8:	4618      	mov	r0, r3
 80470fa:	e7f1      	b.n	80470e0 <tcp_kill_state+0x28>
  if (inactive != NULL) {
 80470fc:	b110      	cbz	r0, 8047104 <tcp_kill_state+0x4c>
    tcp_abandon(inactive, 0);
 80470fe:	2100      	movs	r1, #0
 8047100:	f7ff ff0a 	bl	8046f18 <tcp_abandon>
}
 8047104:	bd38      	pop	{r3, r4, r5, pc}
 8047106:	bf00      	nop
 8047108:	2000899c 	.word	0x2000899c
 804710c:	08058d90 	.word	0x08058d90
 8047110:	0805912c 	.word	0x0805912c
 8047114:	08058644 	.word	0x08058644
 8047118:	200089a0 	.word	0x200089a0

0804711c <tcp_alloc>:
{
 804711c:	b538      	push	{r3, r4, r5, lr}
 804711e:	4605      	mov	r5, r0
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 8047120:	2001      	movs	r0, #1
 8047122:	f7fe fbeb 	bl	80458fc <memp_malloc>
  if (pcb == NULL) {
 8047126:	4604      	mov	r4, r0
 8047128:	b368      	cbz	r0, 8047186 <tcp_alloc+0x6a>
  if (pcb != NULL) {
 804712a:	b354      	cbz	r4, 8047182 <tcp_alloc+0x66>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 804712c:	2298      	movs	r2, #152	; 0x98
 804712e:	2100      	movs	r1, #0
 8047130:	4620      	mov	r0, r4
 8047132:	f00a f847 	bl	80511c4 <memset>
    pcb->prio = prio;
 8047136:	7565      	strb	r5, [r4, #21]
    pcb->snd_buf = TCP_SND_BUF;
 8047138:	f44f 6386 	mov.w	r3, #1072	; 0x430
 804713c:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 8047140:	f44f 6206 	mov.w	r2, #2144	; 0x860
 8047144:	8562      	strh	r2, [r4, #42]	; 0x2a
 8047146:	8522      	strh	r2, [r4, #40]	; 0x28
    pcb->ttl = TCP_TTL;
 8047148:	22ff      	movs	r2, #255	; 0xff
 804714a:	72a2      	strb	r2, [r4, #10]
    pcb->mss = INITIAL_MSS;
 804714c:	f44f 7206 	mov.w	r2, #536	; 0x218
 8047150:	8662      	strh	r2, [r4, #50]	; 0x32
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 8047152:	2206      	movs	r2, #6
 8047154:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 8047158:	87e2      	strh	r2, [r4, #62]	; 0x3e
    pcb->rtime = -1;
 804715a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 804715e:	8622      	strh	r2, [r4, #48]	; 0x30
    pcb->cwnd = 1;
 8047160:	2201      	movs	r2, #1
 8047162:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
    pcb->tmr = tcp_ticks;
 8047166:	4a19      	ldr	r2, [pc, #100]	; (80471cc <tcp_alloc+0xb0>)
 8047168:	6812      	ldr	r2, [r2, #0]
 804716a:	6222      	str	r2, [r4, #32]
    pcb->last_timer = tcp_timer_ctr;
 804716c:	4a18      	ldr	r2, [pc, #96]	; (80471d0 <tcp_alloc+0xb4>)
 804716e:	7812      	ldrb	r2, [r2, #0]
 8047170:	7762      	strb	r2, [r4, #29]
    pcb->ssthresh = TCP_SND_BUF;
 8047172:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    pcb->recv = tcp_recv_null;
 8047176:	4b17      	ldr	r3, [pc, #92]	; (80471d4 <tcp_alloc+0xb8>)
 8047178:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 804717c:	4b16      	ldr	r3, [pc, #88]	; (80471d8 <tcp_alloc+0xbc>)
 804717e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
}
 8047182:	4620      	mov	r0, r4
 8047184:	bd38      	pop	{r3, r4, r5, pc}
    tcp_kill_timewait();
 8047186:	f7ff ff49 	bl	804701c <tcp_kill_timewait>
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 804718a:	2001      	movs	r0, #1
 804718c:	f7fe fbb6 	bl	80458fc <memp_malloc>
    if (pcb == NULL) {
 8047190:	4604      	mov	r4, r0
 8047192:	2800      	cmp	r0, #0
 8047194:	d1c9      	bne.n	804712a <tcp_alloc+0xe>
      tcp_kill_state(LAST_ACK);
 8047196:	2009      	movs	r0, #9
 8047198:	f7ff ff8e 	bl	80470b8 <tcp_kill_state>
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 804719c:	2001      	movs	r0, #1
 804719e:	f7fe fbad 	bl	80458fc <memp_malloc>
      if (pcb == NULL) {
 80471a2:	4604      	mov	r4, r0
 80471a4:	2800      	cmp	r0, #0
 80471a6:	d1c0      	bne.n	804712a <tcp_alloc+0xe>
        tcp_kill_state(CLOSING);
 80471a8:	2008      	movs	r0, #8
 80471aa:	f7ff ff85 	bl	80470b8 <tcp_kill_state>
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80471ae:	2001      	movs	r0, #1
 80471b0:	f7fe fba4 	bl	80458fc <memp_malloc>
        if (pcb == NULL) {
 80471b4:	4604      	mov	r4, r0
 80471b6:	2800      	cmp	r0, #0
 80471b8:	d1b7      	bne.n	804712a <tcp_alloc+0xe>
          tcp_kill_prio(prio);
 80471ba:	4628      	mov	r0, r5
 80471bc:	f7ff ff48 	bl	8047050 <tcp_kill_prio>
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 80471c0:	2001      	movs	r0, #1
 80471c2:	f7fe fb9b 	bl	80458fc <memp_malloc>
 80471c6:	4604      	mov	r4, r0
          if (pcb != NULL) {
 80471c8:	e7af      	b.n	804712a <tcp_alloc+0xe>
 80471ca:	bf00      	nop
 80471cc:	200089a0 	.word	0x200089a0
 80471d0:	200042c9 	.word	0x200042c9
 80471d4:	08046de5 	.word	0x08046de5
 80471d8:	006ddd00 	.word	0x006ddd00

080471dc <tcp_new>:
{
 80471dc:	b508      	push	{r3, lr}
  return tcp_alloc(TCP_PRIO_NORMAL);
 80471de:	2040      	movs	r0, #64	; 0x40
 80471e0:	f7ff ff9c 	bl	804711c <tcp_alloc>
}
 80471e4:	bd08      	pop	{r3, pc}
	...

080471e8 <tcp_next_iss>:
  iss += tcp_ticks;       /* XXX */
 80471e8:	4b03      	ldr	r3, [pc, #12]	; (80471f8 <tcp_next_iss+0x10>)
 80471ea:	6858      	ldr	r0, [r3, #4]
 80471ec:	4a03      	ldr	r2, [pc, #12]	; (80471fc <tcp_next_iss+0x14>)
 80471ee:	6812      	ldr	r2, [r2, #0]
 80471f0:	4410      	add	r0, r2
 80471f2:	6058      	str	r0, [r3, #4]
}
 80471f4:	4770      	bx	lr
 80471f6:	bf00      	nop
 80471f8:	20000008 	.word	0x20000008
 80471fc:	200089a0 	.word	0x200089a0

08047200 <tcp_eff_send_mss_impl>:
{
 8047200:	b510      	push	{r4, lr}
 8047202:	4604      	mov	r4, r0
  outif = ip_route(src, dest);
 8047204:	4608      	mov	r0, r1
 8047206:	f003 fb51 	bl	804a8ac <ip4_route>
    if (outif == NULL) {
 804720a:	b130      	cbz	r0, 804721a <tcp_eff_send_mss_impl+0x1a>
    mtu = outif->mtu;
 804720c:	8c43      	ldrh	r3, [r0, #34]	; 0x22
  if (mtu != 0) {
 804720e:	b123      	cbz	r3, 804721a <tcp_eff_send_mss_impl+0x1a>
      mss_s = mtu - IP_HLEN - TCP_HLEN;
 8047210:	3b28      	subs	r3, #40	; 0x28
 8047212:	b29b      	uxth	r3, r3
    sendmss = LWIP_MIN(sendmss, mss_s);
 8047214:	429c      	cmp	r4, r3
 8047216:	bf28      	it	cs
 8047218:	461c      	movcs	r4, r3
}
 804721a:	4620      	mov	r0, r4
 804721c:	bd10      	pop	{r4, pc}
	...

08047220 <tcp_connect>:
{
 8047220:	b570      	push	{r4, r5, r6, lr}
  if ((pcb == NULL) || (ipaddr == NULL)) {
 8047222:	2800      	cmp	r0, #0
 8047224:	d070      	beq.n	8047308 <tcp_connect+0xe8>
 8047226:	461d      	mov	r5, r3
 8047228:	4604      	mov	r4, r0
 804722a:	2900      	cmp	r1, #0
 804722c:	d06f      	beq.n	804730e <tcp_connect+0xee>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 804722e:	7d03      	ldrb	r3, [r0, #20]
 8047230:	2b00      	cmp	r3, #0
 8047232:	d149      	bne.n	80472c8 <tcp_connect+0xa8>
  ip_addr_set(&pcb->remote_ip, ipaddr);
 8047234:	680b      	ldr	r3, [r1, #0]
 8047236:	6043      	str	r3, [r0, #4]
  pcb->remote_port = port;
 8047238:	8302      	strh	r2, [r0, #24]
  if (ip_addr_isany(&pcb->local_ip)) {
 804723a:	b108      	cbz	r0, 8047240 <tcp_connect+0x20>
 804723c:	6803      	ldr	r3, [r0, #0]
 804723e:	b963      	cbnz	r3, 804725a <tcp_connect+0x3a>
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 8047240:	1d20      	adds	r0, r4, #4
 8047242:	f003 fb33 	bl	804a8ac <ip4_route>
 8047246:	4603      	mov	r3, r0
 8047248:	2800      	cmp	r0, #0
 804724a:	d047      	beq.n	80472dc <tcp_connect+0xbc>
 804724c:	1d02      	adds	r2, r0, #4
    if ((netif == NULL) || (local_ip == NULL)) {
 804724e:	2b00      	cmp	r3, #0
 8047250:	d060      	beq.n	8047314 <tcp_connect+0xf4>
 8047252:	2a00      	cmp	r2, #0
 8047254:	d061      	beq.n	804731a <tcp_connect+0xfa>
    ip_addr_copy(pcb->local_ip, *local_ip);
 8047256:	6813      	ldr	r3, [r2, #0]
 8047258:	6023      	str	r3, [r4, #0]
  old_local_port = pcb->local_port;
 804725a:	8ae6      	ldrh	r6, [r4, #22]
  if (pcb->local_port == 0) {
 804725c:	b926      	cbnz	r6, 8047268 <tcp_connect+0x48>
    pcb->local_port = tcp_new_port();
 804725e:	f7ff f88f 	bl	8046380 <tcp_new_port>
 8047262:	82e0      	strh	r0, [r4, #22]
    if (pcb->local_port == 0) {
 8047264:	2800      	cmp	r0, #0
 8047266:	d05b      	beq.n	8047320 <tcp_connect+0x100>
  iss = tcp_next_iss(pcb);
 8047268:	4620      	mov	r0, r4
 804726a:	f7ff ffbd 	bl	80471e8 <tcp_next_iss>
  pcb->rcv_nxt = 0;
 804726e:	2200      	movs	r2, #0
 8047270:	6262      	str	r2, [r4, #36]	; 0x24
  pcb->snd_nxt = iss;
 8047272:	64e0      	str	r0, [r4, #76]	; 0x4c
  pcb->lastack = iss - 1;
 8047274:	3801      	subs	r0, #1
 8047276:	6460      	str	r0, [r4, #68]	; 0x44
  pcb->snd_wl2 = iss - 1;
 8047278:	6560      	str	r0, [r4, #84]	; 0x54
  pcb->snd_lbb = iss - 1;
 804727a:	65a0      	str	r0, [r4, #88]	; 0x58
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
 804727c:	f44f 6306 	mov.w	r3, #2144	; 0x860
 8047280:	8563      	strh	r3, [r4, #42]	; 0x2a
 8047282:	8523      	strh	r3, [r4, #40]	; 0x28
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8047284:	62e2      	str	r2, [r4, #44]	; 0x2c
  pcb->snd_wnd = TCP_WND;
 8047286:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
  pcb->mss = INITIAL_MSS;
 804728a:	f44f 7006 	mov.w	r0, #536	; 0x218
 804728e:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 8047290:	1d21      	adds	r1, r4, #4
 8047292:	f7ff ffb5 	bl	8047200 <tcp_eff_send_mss_impl>
 8047296:	8660      	strh	r0, [r4, #50]	; 0x32
  pcb->cwnd = 1;
 8047298:	2301      	movs	r3, #1
 804729a:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
  pcb->connected = connected;
 804729e:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 80472a2:	2102      	movs	r1, #2
 80472a4:	4620      	mov	r0, r4
 80472a6:	f001 fff7 	bl	8049298 <tcp_enqueue_flags>
  if (ret == ERR_OK) {
 80472aa:	4605      	mov	r5, r0
 80472ac:	bb50      	cbnz	r0, 8047304 <tcp_connect+0xe4>
    pcb->state = SYN_SENT;
 80472ae:	2302      	movs	r3, #2
 80472b0:	7523      	strb	r3, [r4, #20]
    if (old_local_port != 0) {
 80472b2:	b1de      	cbz	r6, 80472ec <tcp_connect+0xcc>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80472b4:	4b1c      	ldr	r3, [pc, #112]	; (8047328 <tcp_connect+0x108>)
 80472b6:	681b      	ldr	r3, [r3, #0]
 80472b8:	42a3      	cmp	r3, r4
 80472ba:	d011      	beq.n	80472e0 <tcp_connect+0xc0>
 80472bc:	b1b3      	cbz	r3, 80472ec <tcp_connect+0xcc>
 80472be:	68da      	ldr	r2, [r3, #12]
 80472c0:	42a2      	cmp	r2, r4
 80472c2:	d011      	beq.n	80472e8 <tcp_connect+0xc8>
 80472c4:	4613      	mov	r3, r2
 80472c6:	e7f9      	b.n	80472bc <tcp_connect+0x9c>
  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 80472c8:	4b18      	ldr	r3, [pc, #96]	; (804732c <tcp_connect+0x10c>)
 80472ca:	f44f 725e 	mov.w	r2, #888	; 0x378
 80472ce:	4918      	ldr	r1, [pc, #96]	; (8047330 <tcp_connect+0x110>)
 80472d0:	4818      	ldr	r0, [pc, #96]	; (8047334 <tcp_connect+0x114>)
 80472d2:	f009 ff8b 	bl	80511ec <printf>
 80472d6:	f06f 0509 	mvn.w	r5, #9
 80472da:	e013      	b.n	8047304 <tcp_connect+0xe4>
    ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
 80472dc:	4602      	mov	r2, r0
 80472de:	e7b6      	b.n	804724e <tcp_connect+0x2e>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80472e0:	68da      	ldr	r2, [r3, #12]
 80472e2:	4b11      	ldr	r3, [pc, #68]	; (8047328 <tcp_connect+0x108>)
 80472e4:	601a      	str	r2, [r3, #0]
 80472e6:	e001      	b.n	80472ec <tcp_connect+0xcc>
 80472e8:	68e2      	ldr	r2, [r4, #12]
 80472ea:	60da      	str	r2, [r3, #12]
    TCP_REG_ACTIVE(pcb);
 80472ec:	4b12      	ldr	r3, [pc, #72]	; (8047338 <tcp_connect+0x118>)
 80472ee:	681a      	ldr	r2, [r3, #0]
 80472f0:	60e2      	str	r2, [r4, #12]
 80472f2:	601c      	str	r4, [r3, #0]
 80472f4:	f002 fbd6 	bl	8049aa4 <tcp_timer_needed>
 80472f8:	4b10      	ldr	r3, [pc, #64]	; (804733c <tcp_connect+0x11c>)
 80472fa:	2201      	movs	r2, #1
 80472fc:	701a      	strb	r2, [r3, #0]
    tcp_output(pcb);
 80472fe:	4620      	mov	r0, r4
 8047300:	f002 f8d8 	bl	80494b4 <tcp_output>
}
 8047304:	4628      	mov	r0, r5
 8047306:	bd70      	pop	{r4, r5, r6, pc}
    return ERR_VAL;
 8047308:	f06f 0505 	mvn.w	r5, #5
 804730c:	e7fa      	b.n	8047304 <tcp_connect+0xe4>
 804730e:	f06f 0505 	mvn.w	r5, #5
 8047312:	e7f7      	b.n	8047304 <tcp_connect+0xe4>
      return ERR_RTE;
 8047314:	f06f 0503 	mvn.w	r5, #3
 8047318:	e7f4      	b.n	8047304 <tcp_connect+0xe4>
 804731a:	f06f 0503 	mvn.w	r5, #3
 804731e:	e7f1      	b.n	8047304 <tcp_connect+0xe4>
      return ERR_BUF;
 8047320:	f06f 0501 	mvn.w	r5, #1
 8047324:	e7ee      	b.n	8047304 <tcp_connect+0xe4>
 8047326:	bf00      	nop
 8047328:	200089a8 	.word	0x200089a8
 804732c:	08058d90 	.word	0x08058d90
 8047330:	0805913c 	.word	0x0805913c
 8047334:	08058644 	.word	0x08058644
 8047338:	2000899c 	.word	0x2000899c
 804733c:	20008998 	.word	0x20008998

08047340 <tcp_netif_ip_addr_changed>:
void
tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  struct tcp_pcb_listen *lpcb, *next;

  if (!ip_addr_isany(old_addr)) {
 8047340:	b308      	cbz	r0, 8047386 <tcp_netif_ip_addr_changed+0x46>
{
 8047342:	b538      	push	{r3, r4, r5, lr}
 8047344:	460d      	mov	r5, r1
 8047346:	4604      	mov	r4, r0
  if (!ip_addr_isany(old_addr)) {
 8047348:	6803      	ldr	r3, [r0, #0]
 804734a:	b903      	cbnz	r3, 804734e <tcp_netif_ip_addr_changed+0xe>
          ip_addr_copy(lpcb->local_ip, *new_addr);
        }
      }
    }
  }
}
 804734c:	bd38      	pop	{r3, r4, r5, pc}
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
 804734e:	4b0e      	ldr	r3, [pc, #56]	; (8047388 <tcp_netif_ip_addr_changed+0x48>)
 8047350:	6819      	ldr	r1, [r3, #0]
 8047352:	f7ff fea1 	bl	8047098 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
 8047356:	4b0d      	ldr	r3, [pc, #52]	; (804738c <tcp_netif_ip_addr_changed+0x4c>)
 8047358:	6819      	ldr	r1, [r3, #0]
 804735a:	4620      	mov	r0, r4
 804735c:	f7ff fe9c 	bl	8047098 <tcp_netif_ip_addr_changed_pcblist>
    if (!ip_addr_isany(new_addr)) {
 8047360:	2d00      	cmp	r5, #0
 8047362:	d0f3      	beq.n	804734c <tcp_netif_ip_addr_changed+0xc>
 8047364:	682b      	ldr	r3, [r5, #0]
 8047366:	2b00      	cmp	r3, #0
 8047368:	d0f0      	beq.n	804734c <tcp_netif_ip_addr_changed+0xc>
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 804736a:	4b09      	ldr	r3, [pc, #36]	; (8047390 <tcp_netif_ip_addr_changed+0x50>)
 804736c:	681b      	ldr	r3, [r3, #0]
 804736e:	e000      	b.n	8047372 <tcp_netif_ip_addr_changed+0x32>
{
 8047370:	4613      	mov	r3, r2
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
 8047372:	2b00      	cmp	r3, #0
 8047374:	d0ea      	beq.n	804734c <tcp_netif_ip_addr_changed+0xc>
        next = lpcb->next;
 8047376:	68da      	ldr	r2, [r3, #12]
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
 8047378:	6818      	ldr	r0, [r3, #0]
 804737a:	6821      	ldr	r1, [r4, #0]
 804737c:	4288      	cmp	r0, r1
 804737e:	d1f7      	bne.n	8047370 <tcp_netif_ip_addr_changed+0x30>
          ip_addr_copy(lpcb->local_ip, *new_addr);
 8047380:	6829      	ldr	r1, [r5, #0]
 8047382:	6019      	str	r1, [r3, #0]
 8047384:	e7f4      	b.n	8047370 <tcp_netif_ip_addr_changed+0x30>
 8047386:	4770      	bx	lr
 8047388:	2000899c 	.word	0x2000899c
 804738c:	200089a8 	.word	0x200089a8
 8047390:	200089a4 	.word	0x200089a4

08047394 <tcp_getoptbyte>:
}

static u8_t
tcp_getoptbyte(void)
{
  if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
 8047394:	4b0d      	ldr	r3, [pc, #52]	; (80473cc <tcp_getoptbyte+0x38>)
 8047396:	6819      	ldr	r1, [r3, #0]
 8047398:	b121      	cbz	r1, 80473a4 <tcp_getoptbyte+0x10>
 804739a:	461a      	mov	r2, r3
 804739c:	889b      	ldrh	r3, [r3, #4]
 804739e:	88d2      	ldrh	r2, [r2, #6]
 80473a0:	4293      	cmp	r3, r2
 80473a2:	d207      	bcs.n	80473b4 <tcp_getoptbyte+0x20>
    u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
 80473a4:	4a09      	ldr	r2, [pc, #36]	; (80473cc <tcp_getoptbyte+0x38>)
 80473a6:	6893      	ldr	r3, [r2, #8]
    return opts[tcp_optidx++];
 80473a8:	8891      	ldrh	r1, [r2, #4]
 80473aa:	1c48      	adds	r0, r1, #1
 80473ac:	8090      	strh	r0, [r2, #4]
 80473ae:	440b      	add	r3, r1
 80473b0:	7d18      	ldrb	r0, [r3, #20]
  } else {
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
    return tcphdr_opt2[idx];
  }
}
 80473b2:	4770      	bx	lr
{
 80473b4:	b410      	push	{r4}
    u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
 80473b6:	1c5c      	adds	r4, r3, #1
 80473b8:	4804      	ldr	r0, [pc, #16]	; (80473cc <tcp_getoptbyte+0x38>)
 80473ba:	8084      	strh	r4, [r0, #4]
 80473bc:	b2db      	uxtb	r3, r3
 80473be:	b2d2      	uxtb	r2, r2
 80473c0:	1a9b      	subs	r3, r3, r2
 80473c2:	b2db      	uxtb	r3, r3
    return tcphdr_opt2[idx];
 80473c4:	5cc8      	ldrb	r0, [r1, r3]
}
 80473c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80473ca:	4770      	bx	lr
 80473cc:	200042cc 	.word	0x200042cc

080473d0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 80473d0:	b538      	push	{r3, r4, r5, lr}
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
 80473d2:	4b1e      	ldr	r3, [pc, #120]	; (804744c <tcp_parseopt+0x7c>)
 80473d4:	899b      	ldrh	r3, [r3, #12]
 80473d6:	2b00      	cmp	r3, #0
 80473d8:	d036      	beq.n	8047448 <tcp_parseopt+0x78>
 80473da:	4604      	mov	r4, r0
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
 80473dc:	4b1b      	ldr	r3, [pc, #108]	; (804744c <tcp_parseopt+0x7c>)
 80473de:	2200      	movs	r2, #0
 80473e0:	809a      	strh	r2, [r3, #4]
 80473e2:	4b1a      	ldr	r3, [pc, #104]	; (804744c <tcp_parseopt+0x7c>)
 80473e4:	889a      	ldrh	r2, [r3, #4]
 80473e6:	899b      	ldrh	r3, [r3, #12]
 80473e8:	429a      	cmp	r2, r3
 80473ea:	d22d      	bcs.n	8047448 <tcp_parseopt+0x78>
      u8_t opt = tcp_getoptbyte();
 80473ec:	f7ff ffd2 	bl	8047394 <tcp_getoptbyte>
      switch (opt) {
 80473f0:	2801      	cmp	r0, #1
 80473f2:	d0f6      	beq.n	80473e2 <tcp_parseopt+0x12>
 80473f4:	2802      	cmp	r0, #2
 80473f6:	d00b      	beq.n	8047410 <tcp_parseopt+0x40>
 80473f8:	b330      	cbz	r0, 8047448 <tcp_parseopt+0x78>
        tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        data = tcp_getoptbyte();
 80473fa:	f7ff ffcb 	bl	8047394 <tcp_getoptbyte>
 80473fe:	4603      	mov	r3, r0
        if (data < 2) {
 8047400:	2801      	cmp	r0, #1
 8047402:	d921      	bls.n	8047448 <tcp_parseopt+0x78>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        tcp_optidx += data - 2;
 8047404:	4a11      	ldr	r2, [pc, #68]	; (804744c <tcp_parseopt+0x7c>)
 8047406:	8890      	ldrh	r0, [r2, #4]
 8047408:	4403      	add	r3, r0
 804740a:	3b02      	subs	r3, #2
 804740c:	8093      	strh	r3, [r2, #4]
 804740e:	e7e8      	b.n	80473e2 <tcp_parseopt+0x12>
        if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
 8047410:	f7ff ffc0 	bl	8047394 <tcp_getoptbyte>
 8047414:	2804      	cmp	r0, #4
 8047416:	d117      	bne.n	8047448 <tcp_parseopt+0x78>
 8047418:	4a0c      	ldr	r2, [pc, #48]	; (804744c <tcp_parseopt+0x7c>)
 804741a:	8893      	ldrh	r3, [r2, #4]
 804741c:	3301      	adds	r3, #1
 804741e:	8992      	ldrh	r2, [r2, #12]
 8047420:	4293      	cmp	r3, r2
 8047422:	da11      	bge.n	8047448 <tcp_parseopt+0x78>
        mss = (tcp_getoptbyte() << 8);
 8047424:	f7ff ffb6 	bl	8047394 <tcp_getoptbyte>
 8047428:	b285      	uxth	r5, r0
 804742a:	022d      	lsls	r5, r5, #8
 804742c:	b2ad      	uxth	r5, r5
        mss |= tcp_getoptbyte();
 804742e:	f7ff ffb1 	bl	8047394 <tcp_getoptbyte>
 8047432:	b280      	uxth	r0, r0
 8047434:	4305      	orrs	r5, r0
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8047436:	1e6b      	subs	r3, r5, #1
 8047438:	b29b      	uxth	r3, r3
 804743a:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 804743e:	d301      	bcc.n	8047444 <tcp_parseopt+0x74>
 8047440:	f44f 7506 	mov.w	r5, #536	; 0x218
 8047444:	8665      	strh	r5, [r4, #50]	; 0x32
        break;
 8047446:	e7cc      	b.n	80473e2 <tcp_parseopt+0x12>
      }
    }
  }
}
 8047448:	bd38      	pop	{r3, r4, r5, pc}
 804744a:	bf00      	nop
 804744c:	200042cc 	.word	0x200042cc

08047450 <tcp_input_delayed_close>:
  if (recv_flags & TF_CLOSED) {
 8047450:	4b0e      	ldr	r3, [pc, #56]	; (804748c <tcp_input_delayed_close+0x3c>)
 8047452:	7b9b      	ldrb	r3, [r3, #14]
 8047454:	f013 0f10 	tst.w	r3, #16
 8047458:	d101      	bne.n	804745e <tcp_input_delayed_close+0xe>
  return 0;
 804745a:	2000      	movs	r0, #0
}
 804745c:	4770      	bx	lr
{
 804745e:	b510      	push	{r4, lr}
 8047460:	4604      	mov	r4, r0
    if (!(pcb->flags & TF_RXCLOSED)) {
 8047462:	7e83      	ldrb	r3, [r0, #26]
 8047464:	f013 0f10 	tst.w	r3, #16
 8047468:	d106      	bne.n	8047478 <tcp_input_delayed_close+0x28>
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
 804746a:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 804746e:	b11b      	cbz	r3, 8047478 <tcp_input_delayed_close+0x28>
 8047470:	f06f 010e 	mvn.w	r1, #14
 8047474:	6900      	ldr	r0, [r0, #16]
 8047476:	4798      	blx	r3
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8047478:	4621      	mov	r1, r4
 804747a:	4805      	ldr	r0, [pc, #20]	; (8047490 <tcp_input_delayed_close+0x40>)
 804747c:	f7ff fbac 	bl	8046bd8 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 8047480:	4621      	mov	r1, r4
 8047482:	2001      	movs	r0, #1
 8047484:	f7fe fa54 	bl	8045930 <memp_free>
    return 1;
 8047488:	2001      	movs	r0, #1
}
 804748a:	bd10      	pop	{r4, pc}
 804748c:	200042cc 	.word	0x200042cc
 8047490:	2000899c 	.word	0x2000899c

08047494 <tcp_timewait_input>:
  if (flags & TCP_RST) {
 8047494:	4b1b      	ldr	r3, [pc, #108]	; (8047504 <tcp_timewait_input+0x70>)
 8047496:	7bdb      	ldrb	r3, [r3, #15]
 8047498:	f013 0f04 	tst.w	r3, #4
 804749c:	d130      	bne.n	8047500 <tcp_timewait_input+0x6c>
{
 804749e:	b530      	push	{r4, r5, lr}
 80474a0:	b083      	sub	sp, #12
  if (flags & TCP_SYN) {
 80474a2:	f013 0f02 	tst.w	r3, #2
 80474a6:	d01d      	beq.n	80474e4 <tcp_timewait_input+0x50>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
 80474a8:	4b16      	ldr	r3, [pc, #88]	; (8047504 <tcp_timewait_input+0x70>)
 80474aa:	6919      	ldr	r1, [r3, #16]
 80474ac:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80474ae:	1aca      	subs	r2, r1, r3
 80474b0:	2a00      	cmp	r2, #0
 80474b2:	db04      	blt.n	80474be <tcp_timewait_input+0x2a>
 80474b4:	8d02      	ldrh	r2, [r0, #40]	; 0x28
 80474b6:	4413      	add	r3, r2
 80474b8:	1acb      	subs	r3, r1, r3
 80474ba:	2b00      	cmp	r3, #0
 80474bc:	dd04      	ble.n	80474c8 <tcp_timewait_input+0x34>
  if ((tcplen > 0)) {
 80474be:	4b11      	ldr	r3, [pc, #68]	; (8047504 <tcp_timewait_input+0x70>)
 80474c0:	8a9b      	ldrh	r3, [r3, #20]
 80474c2:	b9b3      	cbnz	r3, 80474f2 <tcp_timewait_input+0x5e>
}
 80474c4:	b003      	add	sp, #12
 80474c6:	bd30      	pop	{r4, r5, pc}
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 80474c8:	480e      	ldr	r0, [pc, #56]	; (8047504 <tcp_timewait_input+0x70>)
 80474ca:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80474cc:	4b0e      	ldr	r3, [pc, #56]	; (8047508 <tcp_timewait_input+0x74>)
 80474ce:	8a84      	ldrh	r4, [r0, #20]
 80474d0:	8815      	ldrh	r5, [r2, #0]
 80474d2:	9501      	str	r5, [sp, #4]
 80474d4:	8852      	ldrh	r2, [r2, #2]
 80474d6:	9200      	str	r2, [sp, #0]
 80474d8:	1d1a      	adds	r2, r3, #4
 80474da:	4421      	add	r1, r4
 80474dc:	6980      	ldr	r0, [r0, #24]
 80474de:	f002 f931 	bl	8049744 <tcp_rst>
      return;
 80474e2:	e7ef      	b.n	80474c4 <tcp_timewait_input+0x30>
  } else if (flags & TCP_FIN) {
 80474e4:	f013 0f01 	tst.w	r3, #1
 80474e8:	d0e9      	beq.n	80474be <tcp_timewait_input+0x2a>
    pcb->tmr = tcp_ticks;
 80474ea:	4b08      	ldr	r3, [pc, #32]	; (804750c <tcp_timewait_input+0x78>)
 80474ec:	681b      	ldr	r3, [r3, #0]
 80474ee:	6203      	str	r3, [r0, #32]
 80474f0:	e7e5      	b.n	80474be <tcp_timewait_input+0x2a>
    pcb->flags |= TF_ACK_NOW;
 80474f2:	7e83      	ldrb	r3, [r0, #26]
 80474f4:	f043 0302 	orr.w	r3, r3, #2
 80474f8:	7683      	strb	r3, [r0, #26]
    tcp_output(pcb);
 80474fa:	f001 ffdb 	bl	80494b4 <tcp_output>
 80474fe:	e7e1      	b.n	80474c4 <tcp_timewait_input+0x30>
 8047500:	4770      	bx	lr
 8047502:	bf00      	nop
 8047504:	200042cc 	.word	0x200042cc
 8047508:	2000547c 	.word	0x2000547c
 804750c:	200089a0 	.word	0x200089a0

08047510 <tcp_listen_input>:
  if (flags & TCP_RST) {
 8047510:	4b3a      	ldr	r3, [pc, #232]	; (80475fc <tcp_listen_input+0xec>)
 8047512:	7bdb      	ldrb	r3, [r3, #15]
 8047514:	f013 0f04 	tst.w	r3, #4
 8047518:	d16e      	bne.n	80475f8 <tcp_listen_input+0xe8>
{
 804751a:	b570      	push	{r4, r5, r6, lr}
 804751c:	b082      	sub	sp, #8
 804751e:	4605      	mov	r5, r0
  if (flags & TCP_ACK) {
 8047520:	f013 0f10 	tst.w	r3, #16
 8047524:	d104      	bne.n	8047530 <tcp_listen_input+0x20>
  } else if (flags & TCP_SYN) {
 8047526:	f013 0f02 	tst.w	r3, #2
 804752a:	d110      	bne.n	804754e <tcp_listen_input+0x3e>
}
 804752c:	b002      	add	sp, #8
 804752e:	bd70      	pop	{r4, r5, r6, pc}
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8047530:	4832      	ldr	r0, [pc, #200]	; (80475fc <tcp_listen_input+0xec>)
 8047532:	6882      	ldr	r2, [r0, #8]
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8047534:	4b32      	ldr	r3, [pc, #200]	; (8047600 <tcp_listen_input+0xf0>)
 8047536:	8a84      	ldrh	r4, [r0, #20]
 8047538:	6901      	ldr	r1, [r0, #16]
 804753a:	8815      	ldrh	r5, [r2, #0]
 804753c:	9501      	str	r5, [sp, #4]
 804753e:	8852      	ldrh	r2, [r2, #2]
 8047540:	9200      	str	r2, [sp, #0]
 8047542:	1d1a      	adds	r2, r3, #4
 8047544:	4421      	add	r1, r4
 8047546:	6980      	ldr	r0, [r0, #24]
 8047548:	f002 f8fc 	bl	8049744 <tcp_rst>
 804754c:	e7ee      	b.n	804752c <tcp_listen_input+0x1c>
    npcb = tcp_alloc(pcb->prio);
 804754e:	7d40      	ldrb	r0, [r0, #21]
 8047550:	f7ff fde4 	bl	804711c <tcp_alloc>
    if (npcb == NULL) {
 8047554:	4604      	mov	r4, r0
 8047556:	2800      	cmp	r0, #0
 8047558:	d040      	beq.n	80475dc <tcp_listen_input+0xcc>
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
 804755a:	4b2a      	ldr	r3, [pc, #168]	; (8047604 <tcp_listen_input+0xf4>)
 804755c:	695a      	ldr	r2, [r3, #20]
 804755e:	6002      	str	r2, [r0, #0]
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
 8047560:	691b      	ldr	r3, [r3, #16]
 8047562:	6043      	str	r3, [r0, #4]
    npcb->local_port = pcb->local_port;
 8047564:	8aeb      	ldrh	r3, [r5, #22]
 8047566:	82c3      	strh	r3, [r0, #22]
    npcb->remote_port = tcphdr->src;
 8047568:	4e24      	ldr	r6, [pc, #144]	; (80475fc <tcp_listen_input+0xec>)
 804756a:	68b3      	ldr	r3, [r6, #8]
 804756c:	881b      	ldrh	r3, [r3, #0]
 804756e:	8303      	strh	r3, [r0, #24]
    npcb->state = SYN_RCVD;
 8047570:	2303      	movs	r3, #3
 8047572:	7503      	strb	r3, [r0, #20]
    npcb->rcv_nxt = seqno + 1;
 8047574:	6933      	ldr	r3, [r6, #16]
 8047576:	3301      	adds	r3, #1
 8047578:	6243      	str	r3, [r0, #36]	; 0x24
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 804757a:	62c3      	str	r3, [r0, #44]	; 0x2c
    iss = tcp_next_iss(npcb);
 804757c:	f7ff fe34 	bl	80471e8 <tcp_next_iss>
    npcb->snd_wl2 = iss;
 8047580:	6560      	str	r0, [r4, #84]	; 0x54
    npcb->snd_nxt = iss;
 8047582:	64e0      	str	r0, [r4, #76]	; 0x4c
    npcb->lastack = iss;
 8047584:	6460      	str	r0, [r4, #68]	; 0x44
    npcb->snd_lbb = iss;
 8047586:	65a0      	str	r0, [r4, #88]	; 0x58
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8047588:	6933      	ldr	r3, [r6, #16]
 804758a:	3b01      	subs	r3, #1
 804758c:	6523      	str	r3, [r4, #80]	; 0x50
    npcb->callback_arg = pcb->callback_arg;
 804758e:	692b      	ldr	r3, [r5, #16]
 8047590:	6123      	str	r3, [r4, #16]
    npcb->listener = pcb;
 8047592:	67a5      	str	r5, [r4, #120]	; 0x78
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8047594:	7a2b      	ldrb	r3, [r5, #8]
 8047596:	f003 030c 	and.w	r3, r3, #12
 804759a:	7223      	strb	r3, [r4, #8]
    TCP_REG_ACTIVE(npcb);
 804759c:	4b1a      	ldr	r3, [pc, #104]	; (8047608 <tcp_listen_input+0xf8>)
 804759e:	681a      	ldr	r2, [r3, #0]
 80475a0:	60e2      	str	r2, [r4, #12]
 80475a2:	601c      	str	r4, [r3, #0]
 80475a4:	f002 fa7e 	bl	8049aa4 <tcp_timer_needed>
 80475a8:	4b18      	ldr	r3, [pc, #96]	; (804760c <tcp_listen_input+0xfc>)
 80475aa:	2201      	movs	r2, #1
 80475ac:	701a      	strb	r2, [r3, #0]
    tcp_parseopt(npcb);
 80475ae:	4620      	mov	r0, r4
 80475b0:	f7ff ff0e 	bl	80473d0 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
 80475b4:	68b3      	ldr	r3, [r6, #8]
 80475b6:	89db      	ldrh	r3, [r3, #14]
 80475b8:	f8a4 305c 	strh.w	r3, [r4, #92]	; 0x5c
    npcb->snd_wnd_max = npcb->snd_wnd;
 80475bc:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
 80475c0:	1d21      	adds	r1, r4, #4
 80475c2:	8e60      	ldrh	r0, [r4, #50]	; 0x32
 80475c4:	f7ff fe1c 	bl	8047200 <tcp_eff_send_mss_impl>
 80475c8:	8660      	strh	r0, [r4, #50]	; 0x32
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 80475ca:	2112      	movs	r1, #18
 80475cc:	4620      	mov	r0, r4
 80475ce:	f001 fe63 	bl	8049298 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 80475d2:	b960      	cbnz	r0, 80475ee <tcp_listen_input+0xde>
    tcp_output(npcb);
 80475d4:	4620      	mov	r0, r4
 80475d6:	f001 ff6d 	bl	80494b4 <tcp_output>
 80475da:	e7a7      	b.n	804752c <tcp_listen_input+0x1c>
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
 80475dc:	69ab      	ldr	r3, [r5, #24]
 80475de:	2b00      	cmp	r3, #0
 80475e0:	d0a4      	beq.n	804752c <tcp_listen_input+0x1c>
 80475e2:	f04f 32ff 	mov.w	r2, #4294967295
 80475e6:	2100      	movs	r1, #0
 80475e8:	6928      	ldr	r0, [r5, #16]
 80475ea:	4798      	blx	r3
      return;
 80475ec:	e79e      	b.n	804752c <tcp_listen_input+0x1c>
      tcp_abandon(npcb, 0);
 80475ee:	2100      	movs	r1, #0
 80475f0:	4620      	mov	r0, r4
 80475f2:	f7ff fc91 	bl	8046f18 <tcp_abandon>
      return;
 80475f6:	e799      	b.n	804752c <tcp_listen_input+0x1c>
 80475f8:	4770      	bx	lr
 80475fa:	bf00      	nop
 80475fc:	200042cc 	.word	0x200042cc
 8047600:	2000547c 	.word	0x2000547c
 8047604:	2000546c 	.word	0x2000546c
 8047608:	2000899c 	.word	0x2000899c
 804760c:	20008998 	.word	0x20008998

08047610 <tcp_oos_insert_segment>:
{
 8047610:	b570      	push	{r4, r5, r6, lr}
 8047612:	4605      	mov	r5, r0
 8047614:	460c      	mov	r4, r1
  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8047616:	68c3      	ldr	r3, [r0, #12]
 8047618:	8998      	ldrh	r0, [r3, #12]
 804761a:	f7fd ff07 	bl	804542c <lwip_htons>
 804761e:	f010 0f01 	tst.w	r0, #1
 8047622:	d012      	beq.n	804764a <tcp_oos_insert_segment+0x3a>
    tcp_segs_free(next);
 8047624:	4620      	mov	r0, r4
 8047626:	f7ff f828 	bl	804667a <tcp_segs_free>
    next = NULL;
 804762a:	2400      	movs	r4, #0
  cseg->next = next;
 804762c:	602c      	str	r4, [r5, #0]
}
 804762e:	bd70      	pop	{r4, r5, r6, pc}
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 8047630:	68eb      	ldr	r3, [r5, #12]
 8047632:	899e      	ldrh	r6, [r3, #12]
 8047634:	2001      	movs	r0, #1
 8047636:	f7fd fef9 	bl	804542c <lwip_htons>
 804763a:	68eb      	ldr	r3, [r5, #12]
 804763c:	4306      	orrs	r6, r0
 804763e:	819e      	strh	r6, [r3, #12]
      next = next->next;
 8047640:	6826      	ldr	r6, [r4, #0]
      tcp_seg_free(old_seg);
 8047642:	4620      	mov	r0, r4
 8047644:	f7ff f80c 	bl	8046660 <tcp_seg_free>
      next = next->next;
 8047648:	4634      	mov	r4, r6
    while (next &&
 804764a:	b18c      	cbz	r4, 8047670 <tcp_oos_insert_segment+0x60>
           TCP_SEQ_GEQ((seqno + cseg->len),
 804764c:	892b      	ldrh	r3, [r5, #8]
 804764e:	4a11      	ldr	r2, [pc, #68]	; (8047694 <tcp_oos_insert_segment+0x84>)
 8047650:	6912      	ldr	r2, [r2, #16]
 8047652:	4413      	add	r3, r2
 8047654:	68e1      	ldr	r1, [r4, #12]
 8047656:	684a      	ldr	r2, [r1, #4]
 8047658:	8920      	ldrh	r0, [r4, #8]
 804765a:	4402      	add	r2, r0
 804765c:	1a9b      	subs	r3, r3, r2
    while (next &&
 804765e:	2b00      	cmp	r3, #0
 8047660:	db06      	blt.n	8047670 <tcp_oos_insert_segment+0x60>
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8047662:	8988      	ldrh	r0, [r1, #12]
 8047664:	f7fd fee2 	bl	804542c <lwip_htons>
 8047668:	f010 0f01 	tst.w	r0, #1
 804766c:	d0e8      	beq.n	8047640 <tcp_oos_insert_segment+0x30>
 804766e:	e7df      	b.n	8047630 <tcp_oos_insert_segment+0x20>
    if (next &&
 8047670:	2c00      	cmp	r4, #0
 8047672:	d0db      	beq.n	804762c <tcp_oos_insert_segment+0x1c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 8047674:	892b      	ldrh	r3, [r5, #8]
 8047676:	4a07      	ldr	r2, [pc, #28]	; (8047694 <tcp_oos_insert_segment+0x84>)
 8047678:	6911      	ldr	r1, [r2, #16]
 804767a:	440b      	add	r3, r1
 804767c:	68e2      	ldr	r2, [r4, #12]
 804767e:	6852      	ldr	r2, [r2, #4]
 8047680:	1a9b      	subs	r3, r3, r2
    if (next &&
 8047682:	2b00      	cmp	r3, #0
 8047684:	ddd2      	ble.n	804762c <tcp_oos_insert_segment+0x1c>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 8047686:	1a52      	subs	r2, r2, r1
 8047688:	b291      	uxth	r1, r2
 804768a:	8129      	strh	r1, [r5, #8]
      pbuf_realloc(cseg->p, cseg->len);
 804768c:	6868      	ldr	r0, [r5, #4]
 804768e:	f7fe fc57 	bl	8045f40 <pbuf_realloc>
 8047692:	e7cb      	b.n	804762c <tcp_oos_insert_segment+0x1c>
 8047694:	200042cc 	.word	0x200042cc

08047698 <tcp_receive>:
{
 8047698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804769a:	4604      	mov	r4, r0
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 804769c:	7d03      	ldrb	r3, [r0, #20]
 804769e:	2b03      	cmp	r3, #3
 80476a0:	d979      	bls.n	8047796 <tcp_receive+0xfe>
  if (flags & TCP_ACK) {
 80476a2:	4bb3      	ldr	r3, [pc, #716]	; (8047970 <tcp_receive+0x2d8>)
 80476a4:	7bdb      	ldrb	r3, [r3, #15]
 80476a6:	f013 0f10 	tst.w	r3, #16
 80476aa:	f000 8194 	beq.w	80479d6 <tcp_receive+0x33e>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80476ae:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 80476b2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80476b4:	1886      	adds	r6, r0, r2
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80476b6:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80476b8:	4bad      	ldr	r3, [pc, #692]	; (8047970 <tcp_receive+0x2d8>)
 80476ba:	691b      	ldr	r3, [r3, #16]
 80476bc:	1acd      	subs	r5, r1, r3
 80476be:	2d00      	cmp	r5, #0
 80476c0:	db7c      	blt.n	80477bc <tcp_receive+0x124>
 80476c2:	4299      	cmp	r1, r3
 80476c4:	d06f      	beq.n	80477a6 <tcp_receive+0x10e>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 80476c6:	49aa      	ldr	r1, [pc, #680]	; (8047970 <tcp_receive+0x2d8>)
 80476c8:	6989      	ldr	r1, [r1, #24]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80476ca:	428a      	cmp	r2, r1
 80476cc:	d071      	beq.n	80477b2 <tcp_receive+0x11a>
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 80476ce:	4ba8      	ldr	r3, [pc, #672]	; (8047970 <tcp_receive+0x2d8>)
 80476d0:	699b      	ldr	r3, [r3, #24]
 80476d2:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80476d4:	1a5a      	subs	r2, r3, r1
 80476d6:	2a00      	cmp	r2, #0
 80476d8:	f340 8095 	ble.w	8047806 <tcp_receive+0x16e>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 80476dc:	2a01      	cmp	r2, #1
 80476de:	d404      	bmi.n	80476ea <tcp_receive+0x52>
 80476e0:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 80476e2:	1a9a      	subs	r2, r3, r2
 80476e4:	2a00      	cmp	r2, #0
 80476e6:	f340 80be 	ble.w	8047866 <tcp_receive+0x1ce>
      tcp_send_empty_ack(pcb);
 80476ea:	4620      	mov	r0, r4
 80476ec:	f001 fea8 	bl	8049440 <tcp_send_empty_ack>
    while (pcb->unsent != NULL &&
 80476f0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80476f2:	2b00      	cmp	r3, #0
 80476f4:	f000 8160 	beq.w	80479b8 <tcp_receive+0x320>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 80476f8:	4a9d      	ldr	r2, [pc, #628]	; (8047970 <tcp_receive+0x2d8>)
 80476fa:	6996      	ldr	r6, [r2, #24]
 80476fc:	68db      	ldr	r3, [r3, #12]
 80476fe:	6858      	ldr	r0, [r3, #4]
 8047700:	f7fd fe97 	bl	8045432 <lwip_htonl>
 8047704:	4605      	mov	r5, r0
 8047706:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8047708:	891f      	ldrh	r7, [r3, #8]
 804770a:	68db      	ldr	r3, [r3, #12]
 804770c:	8998      	ldrh	r0, [r3, #12]
 804770e:	f7fd fe8d 	bl	804542c <lwip_htons>
 8047712:	f010 0f03 	tst.w	r0, #3
 8047716:	f000 814d 	beq.w	80479b4 <tcp_receive+0x31c>
 804771a:	2001      	movs	r0, #1
 804771c:	4407      	add	r7, r0
 804771e:	443d      	add	r5, r7
 8047720:	1b75      	subs	r5, r6, r5
    while (pcb->unsent != NULL &&
 8047722:	2d00      	cmp	r5, #0
 8047724:	f2c0 8148 	blt.w	80479b8 <tcp_receive+0x320>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 8047728:	4b91      	ldr	r3, [pc, #580]	; (8047970 <tcp_receive+0x2d8>)
 804772a:	699b      	ldr	r3, [r3, #24]
 804772c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 804772e:	1a9b      	subs	r3, r3, r2
 8047730:	2b00      	cmp	r3, #0
 8047732:	f300 8141 	bgt.w	80479b8 <tcp_receive+0x320>
      next = pcb->unsent;
 8047736:	6ea5      	ldr	r5, [r4, #104]	; 0x68
      pcb->unsent = pcb->unsent->next;
 8047738:	682b      	ldr	r3, [r5, #0]
 804773a:	66a3      	str	r3, [r4, #104]	; 0x68
      if (pcb->unsent == NULL) {
 804773c:	2b00      	cmp	r3, #0
 804773e:	f000 812e 	beq.w	804799e <tcp_receive+0x306>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8047742:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
 8047746:	6868      	ldr	r0, [r5, #4]
 8047748:	f7fe fc72 	bl	8046030 <pbuf_clen>
 804774c:	4286      	cmp	r6, r0
 804774e:	f0c0 8129 	bcc.w	80479a4 <tcp_receive+0x30c>
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8047752:	6868      	ldr	r0, [r5, #4]
 8047754:	f7fe fc6c 	bl	8046030 <pbuf_clen>
 8047758:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 804775c:	1a1b      	subs	r3, r3, r0
 804775e:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      recv_acked += next->len;
 8047762:	892b      	ldrh	r3, [r5, #8]
 8047764:	4a82      	ldr	r2, [pc, #520]	; (8047970 <tcp_receive+0x2d8>)
 8047766:	8b91      	ldrh	r1, [r2, #28]
 8047768:	440b      	add	r3, r1
 804776a:	8393      	strh	r3, [r2, #28]
      tcp_seg_free(next);
 804776c:	4628      	mov	r0, r5
 804776e:	f7fe ff77 	bl	8046660 <tcp_seg_free>
      if (pcb->snd_queuelen != 0) {
 8047772:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8047776:	2b00      	cmp	r3, #0
 8047778:	d0ba      	beq.n	80476f0 <tcp_receive+0x58>
        LWIP_ASSERT("tcp_receive: valid queue length",
 804777a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 804777c:	2b00      	cmp	r3, #0
 804777e:	d1b7      	bne.n	80476f0 <tcp_receive+0x58>
 8047780:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8047782:	2b00      	cmp	r3, #0
 8047784:	d1b4      	bne.n	80476f0 <tcp_receive+0x58>
 8047786:	4b7b      	ldr	r3, [pc, #492]	; (8047974 <tcp_receive+0x2dc>)
 8047788:	f240 42dc 	movw	r2, #1244	; 0x4dc
 804778c:	497a      	ldr	r1, [pc, #488]	; (8047978 <tcp_receive+0x2e0>)
 804778e:	487b      	ldr	r0, [pc, #492]	; (804797c <tcp_receive+0x2e4>)
 8047790:	f009 fd2c 	bl	80511ec <printf>
 8047794:	e7ac      	b.n	80476f0 <tcp_receive+0x58>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 8047796:	4b77      	ldr	r3, [pc, #476]	; (8047974 <tcp_receive+0x2dc>)
 8047798:	f44f 6281 	mov.w	r2, #1032	; 0x408
 804779c:	4978      	ldr	r1, [pc, #480]	; (8047980 <tcp_receive+0x2e8>)
 804779e:	4877      	ldr	r0, [pc, #476]	; (804797c <tcp_receive+0x2e4>)
 80477a0:	f009 fd24 	bl	80511ec <printf>
 80477a4:	e77d      	b.n	80476a2 <tcp_receive+0xa>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80477a6:	4972      	ldr	r1, [pc, #456]	; (8047970 <tcp_receive+0x2d8>)
 80477a8:	6989      	ldr	r1, [r1, #24]
 80477aa:	1a51      	subs	r1, r2, r1
 80477ac:	2900      	cmp	r1, #0
 80477ae:	da8a      	bge.n	80476c6 <tcp_receive+0x2e>
 80477b0:	e004      	b.n	80477bc <tcp_receive+0x124>
       (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
 80477b2:	4a6f      	ldr	r2, [pc, #444]	; (8047970 <tcp_receive+0x2d8>)
 80477b4:	6892      	ldr	r2, [r2, #8]
 80477b6:	89d2      	ldrh	r2, [r2, #14]
 80477b8:	4290      	cmp	r0, r2
 80477ba:	d288      	bcs.n	80476ce <tcp_receive+0x36>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
 80477bc:	4a6c      	ldr	r2, [pc, #432]	; (8047970 <tcp_receive+0x2d8>)
 80477be:	6892      	ldr	r2, [r2, #8]
 80477c0:	89d2      	ldrh	r2, [r2, #14]
 80477c2:	b291      	uxth	r1, r2
 80477c4:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
 80477c8:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 80477cc:	4281      	cmp	r1, r0
 80477ce:	d901      	bls.n	80477d4 <tcp_receive+0x13c>
        pcb->snd_wnd_max = pcb->snd_wnd;
 80477d0:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      pcb->snd_wl1 = seqno;
 80477d4:	6523      	str	r3, [r4, #80]	; 0x50
      pcb->snd_wl2 = ackno;
 80477d6:	4b66      	ldr	r3, [pc, #408]	; (8047970 <tcp_receive+0x2d8>)
 80477d8:	699b      	ldr	r3, [r3, #24]
 80477da:	6563      	str	r3, [r4, #84]	; 0x54
      if (pcb->snd_wnd == 0) {
 80477dc:	b951      	cbnz	r1, 80477f4 <tcp_receive+0x15c>
        if (pcb->persist_backoff == 0) {
 80477de:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 80477e2:	2b00      	cmp	r3, #0
 80477e4:	f47f af73 	bne.w	80476ce <tcp_receive+0x36>
          pcb->persist_cnt = 0;
 80477e8:	f884 3094 	strb.w	r3, [r4, #148]	; 0x94
          pcb->persist_backoff = 1;
 80477ec:	2301      	movs	r3, #1
 80477ee:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 80477f2:	e76c      	b.n	80476ce <tcp_receive+0x36>
      } else if (pcb->persist_backoff > 0) {
 80477f4:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
 80477f8:	2b00      	cmp	r3, #0
 80477fa:	f43f af68 	beq.w	80476ce <tcp_receive+0x36>
          pcb->persist_backoff = 0;
 80477fe:	2300      	movs	r3, #0
 8047800:	f884 3095 	strb.w	r3, [r4, #149]	; 0x95
 8047804:	e763      	b.n	80476ce <tcp_receive+0x36>
      if (tcplen == 0) {
 8047806:	4a5a      	ldr	r2, [pc, #360]	; (8047970 <tcp_receive+0x2d8>)
 8047808:	8a92      	ldrh	r2, [r2, #20]
 804780a:	b92a      	cbnz	r2, 8047818 <tcp_receive+0x180>
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
 804780c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 804780e:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 8047812:	4402      	add	r2, r0
 8047814:	42b2      	cmp	r2, r6
 8047816:	d003      	beq.n	8047820 <tcp_receive+0x188>
        pcb->dupacks = 0;
 8047818:	2300      	movs	r3, #0
 804781a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 804781e:	e767      	b.n	80476f0 <tcp_receive+0x58>
          if (pcb->rtime >= 0) {
 8047820:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
 8047824:	2a00      	cmp	r2, #0
 8047826:	dbf7      	blt.n	8047818 <tcp_receive+0x180>
            if (pcb->lastack == ackno) {
 8047828:	428b      	cmp	r3, r1
 804782a:	d1f5      	bne.n	8047818 <tcp_receive+0x180>
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 804782c:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8047830:	2bff      	cmp	r3, #255	; 0xff
 8047832:	d002      	beq.n	804783a <tcp_receive+0x1a2>
                ++pcb->dupacks;
 8047834:	3301      	adds	r3, #1
 8047836:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
              if (pcb->dupacks > 3) {
 804783a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 804783e:	2b03      	cmp	r3, #3
 8047840:	d90a      	bls.n	8047858 <tcp_receive+0x1c0>
                if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8047842:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 8047846:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 8047848:	4413      	add	r3, r2
 804784a:	b29b      	uxth	r3, r3
 804784c:	429a      	cmp	r2, r3
 804784e:	f4bf af4f 	bcs.w	80476f0 <tcp_receive+0x58>
                  pcb->cwnd += pcb->mss;
 8047852:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      if (!found_dupack) {
 8047856:	e74b      	b.n	80476f0 <tcp_receive+0x58>
              } else if (pcb->dupacks == 3) {
 8047858:	2b03      	cmp	r3, #3
 804785a:	f47f af49 	bne.w	80476f0 <tcp_receive+0x58>
                tcp_rexmit_fast(pcb);
 804785e:	4620      	mov	r0, r4
 8047860:	f002 f809 	bl	8049876 <tcp_rexmit_fast>
      if (!found_dupack) {
 8047864:	e744      	b.n	80476f0 <tcp_receive+0x58>
      if (pcb->flags & TF_INFR) {
 8047866:	7ea2      	ldrb	r2, [r4, #26]
 8047868:	f012 0f04 	tst.w	r2, #4
 804786c:	d006      	beq.n	804787c <tcp_receive+0x1e4>
        pcb->flags &= ~TF_INFR;
 804786e:	f022 0204 	bic.w	r2, r2, #4
 8047872:	76a2      	strb	r2, [r4, #26]
        pcb->cwnd = pcb->ssthresh;
 8047874:	f8b4 204a 	ldrh.w	r2, [r4, #74]	; 0x4a
 8047878:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
      pcb->nrtx = 0;
 804787c:	2100      	movs	r1, #0
 804787e:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8047882:	f9b4 003c 	ldrsh.w	r0, [r4, #60]	; 0x3c
 8047886:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8047888:	eb02 02e0 	add.w	r2, r2, r0, asr #3
 804788c:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
      pcb->dupacks = 0;
 8047890:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
      pcb->lastack = ackno;
 8047894:	6463      	str	r3, [r4, #68]	; 0x44
      if (pcb->state >= ESTABLISHED) {
 8047896:	7d23      	ldrb	r3, [r4, #20]
 8047898:	2b03      	cmp	r3, #3
 804789a:	d90c      	bls.n	80478b6 <tcp_receive+0x21e>
        if (pcb->cwnd < pcb->ssthresh) {
 804789c:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 80478a0:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80478a4:	429a      	cmp	r2, r3
 80478a6:	d24b      	bcs.n	8047940 <tcp_receive+0x2a8>
          if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 80478a8:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 80478aa:	4413      	add	r3, r2
 80478ac:	b29b      	uxth	r3, r3
 80478ae:	429a      	cmp	r2, r3
 80478b0:	d201      	bcs.n	80478b6 <tcp_receive+0x21e>
            pcb->cwnd += pcb->mss;
 80478b2:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
      while (pcb->unacked != NULL &&
 80478b6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80478b8:	2b00      	cmp	r3, #0
 80478ba:	d065      	beq.n	8047988 <tcp_receive+0x2f0>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
 80478bc:	68db      	ldr	r3, [r3, #12]
 80478be:	6858      	ldr	r0, [r3, #4]
 80478c0:	f7fd fdb7 	bl	8045432 <lwip_htonl>
 80478c4:	4605      	mov	r5, r0
 80478c6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80478c8:	891e      	ldrh	r6, [r3, #8]
 80478ca:	68db      	ldr	r3, [r3, #12]
 80478cc:	8998      	ldrh	r0, [r3, #12]
 80478ce:	f7fd fdad 	bl	804542c <lwip_htons>
 80478d2:	f010 0f03 	tst.w	r0, #3
 80478d6:	d048      	beq.n	804796a <tcp_receive+0x2d2>
 80478d8:	2301      	movs	r3, #1
 80478da:	441e      	add	r6, r3
 80478dc:	4435      	add	r5, r6
 80478de:	4b24      	ldr	r3, [pc, #144]	; (8047970 <tcp_receive+0x2d8>)
 80478e0:	699b      	ldr	r3, [r3, #24]
 80478e2:	1aed      	subs	r5, r5, r3
      while (pcb->unacked != NULL &&
 80478e4:	2d00      	cmp	r5, #0
 80478e6:	dc4f      	bgt.n	8047988 <tcp_receive+0x2f0>
        next = pcb->unacked;
 80478e8:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
        pcb->unacked = pcb->unacked->next;
 80478ea:	682b      	ldr	r3, [r5, #0]
 80478ec:	66e3      	str	r3, [r4, #108]	; 0x6c
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80478ee:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
 80478f2:	6868      	ldr	r0, [r5, #4]
 80478f4:	f7fe fb9c 	bl	8046030 <pbuf_clen>
 80478f8:	4286      	cmp	r6, r0
 80478fa:	d32e      	bcc.n	804795a <tcp_receive+0x2c2>
        pcb->snd_queuelen -= pbuf_clen(next->p);
 80478fc:	6868      	ldr	r0, [r5, #4]
 80478fe:	f7fe fb97 	bl	8046030 <pbuf_clen>
 8047902:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8047906:	1a1b      	subs	r3, r3, r0
 8047908:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
        recv_acked += next->len;
 804790c:	892b      	ldrh	r3, [r5, #8]
 804790e:	4a18      	ldr	r2, [pc, #96]	; (8047970 <tcp_receive+0x2d8>)
 8047910:	8b91      	ldrh	r1, [r2, #28]
 8047912:	440b      	add	r3, r1
 8047914:	8393      	strh	r3, [r2, #28]
        tcp_seg_free(next);
 8047916:	4628      	mov	r0, r5
 8047918:	f7fe fea2 	bl	8046660 <tcp_seg_free>
        if (pcb->snd_queuelen != 0) {
 804791c:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8047920:	2b00      	cmp	r3, #0
 8047922:	d0c8      	beq.n	80478b6 <tcp_receive+0x21e>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 8047924:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8047926:	2b00      	cmp	r3, #0
 8047928:	d1c5      	bne.n	80478b6 <tcp_receive+0x21e>
 804792a:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 804792c:	2b00      	cmp	r3, #0
 804792e:	d1c2      	bne.n	80478b6 <tcp_receive+0x21e>
 8047930:	4b10      	ldr	r3, [pc, #64]	; (8047974 <tcp_receive+0x2dc>)
 8047932:	f240 42a6 	movw	r2, #1190	; 0x4a6
 8047936:	4910      	ldr	r1, [pc, #64]	; (8047978 <tcp_receive+0x2e0>)
 8047938:	4810      	ldr	r0, [pc, #64]	; (804797c <tcp_receive+0x2e4>)
 804793a:	f009 fc57 	bl	80511ec <printf>
 804793e:	e7ba      	b.n	80478b6 <tcp_receive+0x21e>
          tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8047940:	8e63      	ldrh	r3, [r4, #50]	; 0x32
 8047942:	fb03 f303 	mul.w	r3, r3, r3
 8047946:	fb93 f3f2 	sdiv	r3, r3, r2
 804794a:	fa12 f383 	uxtah	r3, r2, r3
 804794e:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 8047950:	429a      	cmp	r2, r3
 8047952:	d2b0      	bcs.n	80478b6 <tcp_receive+0x21e>
            pcb->cwnd = new_cwnd;
 8047954:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
 8047958:	e7ad      	b.n	80478b6 <tcp_receive+0x21e>
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 804795a:	4b06      	ldr	r3, [pc, #24]	; (8047974 <tcp_receive+0x2dc>)
 804795c:	f240 429e 	movw	r2, #1182	; 0x49e
 8047960:	4908      	ldr	r1, [pc, #32]	; (8047984 <tcp_receive+0x2ec>)
 8047962:	4806      	ldr	r0, [pc, #24]	; (804797c <tcp_receive+0x2e4>)
 8047964:	f009 fc42 	bl	80511ec <printf>
 8047968:	e7c8      	b.n	80478fc <tcp_receive+0x264>
             TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
 804796a:	2300      	movs	r3, #0
 804796c:	e7b5      	b.n	80478da <tcp_receive+0x242>
 804796e:	bf00      	nop
 8047970:	200042cc 	.word	0x200042cc
 8047974:	080591d4 	.word	0x080591d4
 8047978:	0805924c 	.word	0x0805924c
 804797c:	08058644 	.word	0x08058644
 8047980:	08059208 	.word	0x08059208
 8047984:	08059224 	.word	0x08059224
      if (pcb->unacked == NULL) {
 8047988:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 804798a:	b123      	cbz	r3, 8047996 <tcp_receive+0x2fe>
        pcb->rtime = 0;
 804798c:	2300      	movs	r3, #0
 804798e:	8623      	strh	r3, [r4, #48]	; 0x30
      pcb->polltmr = 0;
 8047990:	2300      	movs	r3, #0
 8047992:	76e3      	strb	r3, [r4, #27]
 8047994:	e6ac      	b.n	80476f0 <tcp_receive+0x58>
        pcb->rtime = -1;
 8047996:	f64f 73ff 	movw	r3, #65535	; 0xffff
 804799a:	8623      	strh	r3, [r4, #48]	; 0x30
 804799c:	e7f8      	b.n	8047990 <tcp_receive+0x2f8>
        pcb->unsent_oversize = 0;
 804799e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 80479a2:	e6ce      	b.n	8047742 <tcp_receive+0xaa>
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 80479a4:	4b9c      	ldr	r3, [pc, #624]	; (8047c18 <tcp_receive+0x580>)
 80479a6:	f240 42d5 	movw	r2, #1237	; 0x4d5
 80479aa:	499c      	ldr	r1, [pc, #624]	; (8047c1c <tcp_receive+0x584>)
 80479ac:	489c      	ldr	r0, [pc, #624]	; (8047c20 <tcp_receive+0x588>)
 80479ae:	f009 fc1d 	bl	80511ec <printf>
 80479b2:	e6ce      	b.n	8047752 <tcp_receive+0xba>
           TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
 80479b4:	2000      	movs	r0, #0
 80479b6:	e6b1      	b.n	804771c <tcp_receive+0x84>
    pcb->snd_buf += recv_acked;
 80479b8:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 80479bc:	4a99      	ldr	r2, [pc, #612]	; (8047c24 <tcp_receive+0x58c>)
 80479be:	8b92      	ldrh	r2, [r2, #28]
 80479c0:	4413      	add	r3, r2
 80479c2:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 80479c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80479c8:	b12b      	cbz	r3, 80479d6 <tcp_receive+0x33e>
 80479ca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80479cc:	4995      	ldr	r1, [pc, #596]	; (8047c24 <tcp_receive+0x58c>)
 80479ce:	6989      	ldr	r1, [r1, #24]
 80479d0:	1a52      	subs	r2, r2, r1
 80479d2:	2a00      	cmp	r2, #0
 80479d4:	db28      	blt.n	8047a28 <tcp_receive+0x390>
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 80479d6:	4b93      	ldr	r3, [pc, #588]	; (8047c24 <tcp_receive+0x58c>)
 80479d8:	8a9b      	ldrh	r3, [r3, #20]
 80479da:	2b00      	cmp	r3, #0
 80479dc:	f000 8325 	beq.w	804802a <tcp_receive+0x992>
 80479e0:	7d22      	ldrb	r2, [r4, #20]
 80479e2:	2a06      	cmp	r2, #6
 80479e4:	f200 8321 	bhi.w	804802a <tcp_receive+0x992>
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 80479e8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80479ea:	4a8e      	ldr	r2, [pc, #568]	; (8047c24 <tcp_receive+0x58c>)
 80479ec:	6912      	ldr	r2, [r2, #16]
 80479ee:	1a8e      	subs	r6, r1, r2
 80479f0:	2e01      	cmp	r6, #1
 80479f2:	d404      	bmi.n	80479fe <tcp_receive+0x366>
 80479f4:	4413      	add	r3, r2
 80479f6:	1acb      	subs	r3, r1, r3
 80479f8:	3301      	adds	r3, #1
 80479fa:	2b00      	cmp	r3, #0
 80479fc:	dd38      	ble.n	8047a70 <tcp_receive+0x3d8>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
 80479fe:	1a52      	subs	r2, r2, r1
 8047a00:	2a00      	cmp	r2, #0
 8047a02:	f2c0 8094 	blt.w	8047b2e <tcp_receive+0x496>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8047a06:	4b87      	ldr	r3, [pc, #540]	; (8047c24 <tcp_receive+0x58c>)
 8047a08:	6919      	ldr	r1, [r3, #16]
 8047a0a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047a0c:	1a8b      	subs	r3, r1, r2
 8047a0e:	2b00      	cmp	r3, #0
 8047a10:	db06      	blt.n	8047a20 <tcp_receive+0x388>
 8047a12:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047a14:	4413      	add	r3, r2
 8047a16:	1acb      	subs	r3, r1, r3
 8047a18:	3301      	adds	r3, #1
 8047a1a:	2b00      	cmp	r3, #0
 8047a1c:	f340 808c 	ble.w	8047b38 <tcp_receive+0x4a0>
      tcp_send_empty_ack(pcb);
 8047a20:	4620      	mov	r0, r4
 8047a22:	f001 fd0d 	bl	8049440 <tcp_send_empty_ack>
 8047a26:	e310      	b.n	804804a <tcp_receive+0x9b2>
      m = (s16_t)(tcp_ticks - pcb->rttest);
 8047a28:	4a7f      	ldr	r2, [pc, #508]	; (8047c28 <tcp_receive+0x590>)
 8047a2a:	8816      	ldrh	r6, [r2, #0]
 8047a2c:	b29b      	uxth	r3, r3
 8047a2e:	1af1      	subs	r1, r6, r3
 8047a30:	b289      	uxth	r1, r1
      m = m - (pcb->sa >> 3);
 8047a32:	f9b4 503c 	ldrsh.w	r5, [r4, #60]	; 0x3c
 8047a36:	f3c5 00cf 	ubfx	r0, r5, #3, #16
 8047a3a:	1a09      	subs	r1, r1, r0
 8047a3c:	b20a      	sxth	r2, r1
      pcb->sa += m;
 8047a3e:	fa15 f181 	uxtah	r1, r5, r1
 8047a42:	b209      	sxth	r1, r1
 8047a44:	87a1      	strh	r1, [r4, #60]	; 0x3c
      if (m < 0) {
 8047a46:	2a00      	cmp	r2, #0
 8047a48:	db0e      	blt.n	8047a68 <tcp_receive+0x3d0>
      m = m - (pcb->sv >> 2);
 8047a4a:	f9b4 003e 	ldrsh.w	r0, [r4, #62]	; 0x3e
 8047a4e:	eba2 03a0 	sub.w	r3, r2, r0, asr #2
      pcb->sv += m;
 8047a52:	fa10 f383 	uxtah	r3, r0, r3
 8047a56:	b29b      	uxth	r3, r3
 8047a58:	87e3      	strh	r3, [r4, #62]	; 0x3e
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 8047a5a:	eb03 03e1 	add.w	r3, r3, r1, asr #3
 8047a5e:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      pcb->rttest = 0;
 8047a62:	2300      	movs	r3, #0
 8047a64:	6363      	str	r3, [r4, #52]	; 0x34
 8047a66:	e7b6      	b.n	80479d6 <tcp_receive+0x33e>
        m = -m;
 8047a68:	1b9b      	subs	r3, r3, r6
 8047a6a:	4403      	add	r3, r0
 8047a6c:	b21a      	sxth	r2, r3
 8047a6e:	e7ec      	b.n	8047a4a <tcp_receive+0x3b2>
      struct pbuf *p = inseg.p;
 8047a70:	4b6c      	ldr	r3, [pc, #432]	; (8047c24 <tcp_receive+0x58c>)
 8047a72:	6a5d      	ldr	r5, [r3, #36]	; 0x24
      off = pcb->rcv_nxt - seqno;
 8047a74:	4637      	mov	r7, r6
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 8047a76:	b195      	cbz	r5, 8047a9e <tcp_receive+0x406>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 8047a78:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 8047a7c:	429e      	cmp	r6, r3
 8047a7e:	dc16      	bgt.n	8047aae <tcp_receive+0x416>
      if (inseg.p->len < off) {
 8047a80:	4b68      	ldr	r3, [pc, #416]	; (8047c24 <tcp_receive+0x58c>)
 8047a82:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8047a84:	8943      	ldrh	r3, [r0, #10]
 8047a86:	42b3      	cmp	r3, r6
 8047a88:	da43      	bge.n	8047b12 <tcp_receive+0x47a>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 8047a8a:	8903      	ldrh	r3, [r0, #8]
 8047a8c:	42b3      	cmp	r3, r6
 8047a8e:	db16      	blt.n	8047abe <tcp_receive+0x426>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 8047a90:	4b64      	ldr	r3, [pc, #400]	; (8047c24 <tcp_receive+0x58c>)
 8047a92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8047a94:	891a      	ldrh	r2, [r3, #8]
 8047a96:	b2b6      	uxth	r6, r6
 8047a98:	1b92      	subs	r2, r2, r6
 8047a9a:	b292      	uxth	r2, r2
        while (p->len < off) {
 8047a9c:	e01c      	b.n	8047ad8 <tcp_receive+0x440>
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 8047a9e:	4b5e      	ldr	r3, [pc, #376]	; (8047c18 <tcp_receive+0x580>)
 8047aa0:	f240 523c 	movw	r2, #1340	; 0x53c
 8047aa4:	4961      	ldr	r1, [pc, #388]	; (8047c2c <tcp_receive+0x594>)
 8047aa6:	485e      	ldr	r0, [pc, #376]	; (8047c20 <tcp_receive+0x588>)
 8047aa8:	f009 fba0 	bl	80511ec <printf>
 8047aac:	e7e4      	b.n	8047a78 <tcp_receive+0x3e0>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 8047aae:	4b5a      	ldr	r3, [pc, #360]	; (8047c18 <tcp_receive+0x580>)
 8047ab0:	f240 523d 	movw	r2, #1341	; 0x53d
 8047ab4:	495e      	ldr	r1, [pc, #376]	; (8047c30 <tcp_receive+0x598>)
 8047ab6:	485a      	ldr	r0, [pc, #360]	; (8047c20 <tcp_receive+0x588>)
 8047ab8:	f009 fb98 	bl	80511ec <printf>
 8047abc:	e7e0      	b.n	8047a80 <tcp_receive+0x3e8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 8047abe:	4b56      	ldr	r3, [pc, #344]	; (8047c18 <tcp_receive+0x580>)
 8047ac0:	f240 523f 	movw	r2, #1343	; 0x53f
 8047ac4:	495b      	ldr	r1, [pc, #364]	; (8047c34 <tcp_receive+0x59c>)
 8047ac6:	4856      	ldr	r0, [pc, #344]	; (8047c20 <tcp_receive+0x588>)
 8047ac8:	f009 fb90 	bl	80511ec <printf>
 8047acc:	e7e0      	b.n	8047a90 <tcp_receive+0x3f8>
          off -= p->len;
 8047ace:	1aff      	subs	r7, r7, r3
          p->tot_len = new_tot_len;
 8047ad0:	812a      	strh	r2, [r5, #8]
          p->len = 0;
 8047ad2:	2300      	movs	r3, #0
 8047ad4:	816b      	strh	r3, [r5, #10]
          p = p->next;
 8047ad6:	682d      	ldr	r5, [r5, #0]
        while (p->len < off) {
 8047ad8:	896b      	ldrh	r3, [r5, #10]
 8047ada:	42bb      	cmp	r3, r7
 8047adc:	dbf7      	blt.n	8047ace <tcp_receive+0x436>
        if (pbuf_header(p, (s16_t)-off)) {
 8047ade:	4279      	negs	r1, r7
 8047ae0:	b209      	sxth	r1, r1
 8047ae2:	4628      	mov	r0, r5
 8047ae4:	f7fe f8ce 	bl	8045c84 <pbuf_header>
 8047ae8:	b958      	cbnz	r0, 8047b02 <tcp_receive+0x46a>
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 8047aea:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8047aec:	4b4d      	ldr	r3, [pc, #308]	; (8047c24 <tcp_receive+0x58c>)
 8047aee:	691a      	ldr	r2, [r3, #16]
 8047af0:	1a52      	subs	r2, r2, r1
 8047af2:	8d18      	ldrh	r0, [r3, #40]	; 0x28
 8047af4:	fa10 f282 	uxtah	r2, r0, r2
 8047af8:	851a      	strh	r2, [r3, #40]	; 0x28
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 8047afa:	6119      	str	r1, [r3, #16]
 8047afc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047afe:	6059      	str	r1, [r3, #4]
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
 8047b00:	e781      	b.n	8047a06 <tcp_receive+0x36e>
          LWIP_ASSERT("pbuf_header failed", 0);
 8047b02:	4b45      	ldr	r3, [pc, #276]	; (8047c18 <tcp_receive+0x580>)
 8047b04:	f240 524c 	movw	r2, #1356	; 0x54c
 8047b08:	494b      	ldr	r1, [pc, #300]	; (8047c38 <tcp_receive+0x5a0>)
 8047b0a:	4845      	ldr	r0, [pc, #276]	; (8047c20 <tcp_receive+0x588>)
 8047b0c:	f009 fb6e 	bl	80511ec <printf>
 8047b10:	e7eb      	b.n	8047aea <tcp_receive+0x452>
        if (pbuf_header(inseg.p, (s16_t)-off)) {
 8047b12:	4271      	negs	r1, r6
 8047b14:	b209      	sxth	r1, r1
 8047b16:	f7fe f8b5 	bl	8045c84 <pbuf_header>
 8047b1a:	2800      	cmp	r0, #0
 8047b1c:	d0e5      	beq.n	8047aea <tcp_receive+0x452>
          LWIP_ASSERT("pbuf_header failed", 0);
 8047b1e:	4b3e      	ldr	r3, [pc, #248]	; (8047c18 <tcp_receive+0x580>)
 8047b20:	f240 5251 	movw	r2, #1361	; 0x551
 8047b24:	4944      	ldr	r1, [pc, #272]	; (8047c38 <tcp_receive+0x5a0>)
 8047b26:	483e      	ldr	r0, [pc, #248]	; (8047c20 <tcp_receive+0x588>)
 8047b28:	f009 fb60 	bl	80511ec <printf>
 8047b2c:	e7dd      	b.n	8047aea <tcp_receive+0x452>
        tcp_ack_now(pcb);
 8047b2e:	7ea3      	ldrb	r3, [r4, #26]
 8047b30:	f043 0302 	orr.w	r3, r3, #2
 8047b34:	76a3      	strb	r3, [r4, #26]
 8047b36:	e766      	b.n	8047a06 <tcp_receive+0x36e>
      if (pcb->rcv_nxt == seqno) {
 8047b38:	4291      	cmp	r1, r2
 8047b3a:	d008      	beq.n	8047b4e <tcp_receive+0x4b6>
        tcp_send_empty_ack(pcb);
 8047b3c:	4620      	mov	r0, r4
 8047b3e:	f001 fc7f 	bl	8049440 <tcp_send_empty_ack>
        if (pcb->ooseq == NULL) {
 8047b42:	6f25      	ldr	r5, [r4, #112]	; 0x70
 8047b44:	2d00      	cmp	r5, #0
 8047b46:	f000 8194 	beq.w	8047e72 <tcp_receive+0x7da>
          prev = NULL;
 8047b4a:	2600      	movs	r6, #0
 8047b4c:	e1c2      	b.n	8047ed4 <tcp_receive+0x83c>
        tcplen = TCP_TCPLEN(&inseg);
 8047b4e:	4b35      	ldr	r3, [pc, #212]	; (8047c24 <tcp_receive+0x58c>)
 8047b50:	8d1d      	ldrh	r5, [r3, #40]	; 0x28
 8047b52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047b54:	8998      	ldrh	r0, [r3, #12]
 8047b56:	f7fd fc69 	bl	804542c <lwip_htons>
 8047b5a:	f010 0303 	ands.w	r3, r0, #3
 8047b5e:	d000      	beq.n	8047b62 <tcp_receive+0x4ca>
 8047b60:	2301      	movs	r3, #1
 8047b62:	442b      	add	r3, r5
 8047b64:	b29b      	uxth	r3, r3
 8047b66:	4a2f      	ldr	r2, [pc, #188]	; (8047c24 <tcp_receive+0x58c>)
 8047b68:	8293      	strh	r3, [r2, #20]
        if (tcplen > pcb->rcv_wnd) {
 8047b6a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8047b6c:	4293      	cmp	r3, r2
 8047b6e:	d80c      	bhi.n	8047b8a <tcp_receive+0x4f2>
        if (pcb->ooseq != NULL) {
 8047b70:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8047b72:	2b00      	cmp	r3, #0
 8047b74:	d06b      	beq.n	8047c4e <tcp_receive+0x5b6>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047b76:	4b2b      	ldr	r3, [pc, #172]	; (8047c24 <tcp_receive+0x58c>)
 8047b78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047b7a:	8998      	ldrh	r0, [r3, #12]
 8047b7c:	f7fd fc56 	bl	804542c <lwip_htons>
 8047b80:	f010 0f01 	tst.w	r0, #1
 8047b84:	d160      	bne.n	8047c48 <tcp_receive+0x5b0>
            next = pcb->ooseq;
 8047b86:	6f25      	ldr	r5, [r4, #112]	; 0x70
            while (next &&
 8047b88:	e08f      	b.n	8047caa <tcp_receive+0x612>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047b8a:	4b26      	ldr	r3, [pc, #152]	; (8047c24 <tcp_receive+0x58c>)
 8047b8c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047b8e:	8998      	ldrh	r0, [r3, #12]
 8047b90:	f7fd fc4c 	bl	804542c <lwip_htons>
 8047b94:	f010 0f01 	tst.w	r0, #1
 8047b98:	d12e      	bne.n	8047bf8 <tcp_receive+0x560>
          inseg.len = (u16_t)pcb->rcv_wnd;
 8047b9a:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8047b9c:	4b21      	ldr	r3, [pc, #132]	; (8047c24 <tcp_receive+0x58c>)
 8047b9e:	851a      	strh	r2, [r3, #40]	; 0x28
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8047ba0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047ba2:	8998      	ldrh	r0, [r3, #12]
 8047ba4:	f7fd fc42 	bl	804542c <lwip_htons>
 8047ba8:	f010 0f02 	tst.w	r0, #2
 8047bac:	d003      	beq.n	8047bb6 <tcp_receive+0x51e>
            inseg.len -= 1;
 8047bae:	4a1d      	ldr	r2, [pc, #116]	; (8047c24 <tcp_receive+0x58c>)
 8047bb0:	8d13      	ldrh	r3, [r2, #40]	; 0x28
 8047bb2:	3b01      	subs	r3, #1
 8047bb4:	8513      	strh	r3, [r2, #40]	; 0x28
          pbuf_realloc(inseg.p, inseg.len);
 8047bb6:	4e1b      	ldr	r6, [pc, #108]	; (8047c24 <tcp_receive+0x58c>)
 8047bb8:	8d31      	ldrh	r1, [r6, #40]	; 0x28
 8047bba:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8047bbc:	f7fe f9c0 	bl	8045f40 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8047bc0:	8d35      	ldrh	r5, [r6, #40]	; 0x28
 8047bc2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047bc4:	8998      	ldrh	r0, [r3, #12]
 8047bc6:	f7fd fc31 	bl	804542c <lwip_htons>
 8047bca:	f010 0303 	ands.w	r3, r0, #3
 8047bce:	d000      	beq.n	8047bd2 <tcp_receive+0x53a>
 8047bd0:	2301      	movs	r3, #1
 8047bd2:	442b      	add	r3, r5
 8047bd4:	b29b      	uxth	r3, r3
 8047bd6:	4a13      	ldr	r2, [pc, #76]	; (8047c24 <tcp_receive+0x58c>)
 8047bd8:	8293      	strh	r3, [r2, #20]
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8047bda:	6912      	ldr	r2, [r2, #16]
 8047bdc:	4413      	add	r3, r2
 8047bde:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047be0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8047be2:	440a      	add	r2, r1
 8047be4:	4293      	cmp	r3, r2
 8047be6:	d0c3      	beq.n	8047b70 <tcp_receive+0x4d8>
 8047be8:	4b0b      	ldr	r3, [pc, #44]	; (8047c18 <tcp_receive+0x580>)
 8047bea:	f240 527e 	movw	r2, #1406	; 0x57e
 8047bee:	4913      	ldr	r1, [pc, #76]	; (8047c3c <tcp_receive+0x5a4>)
 8047bf0:	480b      	ldr	r0, [pc, #44]	; (8047c20 <tcp_receive+0x588>)
 8047bf2:	f009 fafb 	bl	80511ec <printf>
 8047bf6:	e7bb      	b.n	8047b70 <tcp_receive+0x4d8>
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
 8047bf8:	4e0a      	ldr	r6, [pc, #40]	; (8047c24 <tcp_receive+0x58c>)
 8047bfa:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047bfc:	8998      	ldrh	r0, [r3, #12]
 8047bfe:	f420 557c 	bic.w	r5, r0, #16128	; 0x3f00
 8047c02:	b2ad      	uxth	r5, r5
 8047c04:	f7fd fc12 	bl	804542c <lwip_htons>
 8047c08:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 8047c0c:	f7fd fc0e 	bl	804542c <lwip_htons>
 8047c10:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047c12:	4305      	orrs	r5, r0
 8047c14:	819d      	strh	r5, [r3, #12]
 8047c16:	e7c0      	b.n	8047b9a <tcp_receive+0x502>
 8047c18:	080591d4 	.word	0x080591d4
 8047c1c:	08059224 	.word	0x08059224
 8047c20:	08058644 	.word	0x08058644
 8047c24:	200042cc 	.word	0x200042cc
 8047c28:	200089a0 	.word	0x200089a0
 8047c2c:	0805926c 	.word	0x0805926c
 8047c30:	0805927c 	.word	0x0805927c
 8047c34:	0805928c 	.word	0x0805928c
 8047c38:	0805929c 	.word	0x0805929c
 8047c3c:	080592b0 	.word	0x080592b0
              pcb->ooseq = pcb->ooseq->next;
 8047c40:	6803      	ldr	r3, [r0, #0]
 8047c42:	6723      	str	r3, [r4, #112]	; 0x70
              tcp_seg_free(old_ooseq);
 8047c44:	f7fe fd0c 	bl	8046660 <tcp_seg_free>
            while (pcb->ooseq != NULL) {
 8047c48:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8047c4a:	2800      	cmp	r0, #0
 8047c4c:	d1f8      	bne.n	8047c40 <tcp_receive+0x5a8>
        pcb->rcv_nxt = seqno + tcplen;
 8047c4e:	4b96      	ldr	r3, [pc, #600]	; (8047ea8 <tcp_receive+0x810>)
 8047c50:	8a9a      	ldrh	r2, [r3, #20]
 8047c52:	691b      	ldr	r3, [r3, #16]
 8047c54:	4413      	add	r3, r2
 8047c56:	6263      	str	r3, [r4, #36]	; 0x24
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8047c58:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047c5a:	429a      	cmp	r2, r3
 8047c5c:	f200 808c 	bhi.w	8047d78 <tcp_receive+0x6e0>
        pcb->rcv_wnd -= tcplen;
 8047c60:	4d91      	ldr	r5, [pc, #580]	; (8047ea8 <tcp_receive+0x810>)
 8047c62:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047c64:	8aaa      	ldrh	r2, [r5, #20]
 8047c66:	1a9b      	subs	r3, r3, r2
 8047c68:	8523      	strh	r3, [r4, #40]	; 0x28
        tcp_update_rcv_ann_wnd(pcb);
 8047c6a:	4620      	mov	r0, r4
 8047c6c:	f7fe fc88 	bl	8046580 <tcp_update_rcv_ann_wnd>
        if (inseg.p->tot_len > 0) {
 8047c70:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8047c72:	891a      	ldrh	r2, [r3, #8]
 8047c74:	b112      	cbz	r2, 8047c7c <tcp_receive+0x5e4>
          recv_data = inseg.p;
 8047c76:	632b      	str	r3, [r5, #48]	; 0x30
          inseg.p = NULL;
 8047c78:	2300      	movs	r3, #0
 8047c7a:	626b      	str	r3, [r5, #36]	; 0x24
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8047c7c:	4b8a      	ldr	r3, [pc, #552]	; (8047ea8 <tcp_receive+0x810>)
 8047c7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047c80:	8998      	ldrh	r0, [r3, #12]
 8047c82:	f7fd fbd3 	bl	804542c <lwip_htons>
 8047c86:	f010 0f01 	tst.w	r0, #1
 8047c8a:	f000 80a3 	beq.w	8047dd4 <tcp_receive+0x73c>
          recv_flags |= TF_GOT_FIN;
 8047c8e:	4a86      	ldr	r2, [pc, #536]	; (8047ea8 <tcp_receive+0x810>)
 8047c90:	7b93      	ldrb	r3, [r2, #14]
 8047c92:	f043 0320 	orr.w	r3, r3, #32
 8047c96:	7393      	strb	r3, [r2, #14]
 8047c98:	e09c      	b.n	8047dd4 <tcp_receive+0x73c>
                tcplen = TCP_TCPLEN(&inseg);
 8047c9a:	443b      	add	r3, r7
 8047c9c:	4a82      	ldr	r2, [pc, #520]	; (8047ea8 <tcp_receive+0x810>)
 8047c9e:	8293      	strh	r3, [r2, #20]
              next = next->next;
 8047ca0:	682e      	ldr	r6, [r5, #0]
              tcp_seg_free(prev);
 8047ca2:	4628      	mov	r0, r5
 8047ca4:	f7fe fcdc 	bl	8046660 <tcp_seg_free>
              next = next->next;
 8047ca8:	4635      	mov	r5, r6
            while (next &&
 8047caa:	b35d      	cbz	r5, 8047d04 <tcp_receive+0x66c>
                   TCP_SEQ_GEQ(seqno + tcplen,
 8047cac:	4a7e      	ldr	r2, [pc, #504]	; (8047ea8 <tcp_receive+0x810>)
 8047cae:	8a93      	ldrh	r3, [r2, #20]
 8047cb0:	6912      	ldr	r2, [r2, #16]
 8047cb2:	4413      	add	r3, r2
 8047cb4:	68e9      	ldr	r1, [r5, #12]
 8047cb6:	684a      	ldr	r2, [r1, #4]
 8047cb8:	8928      	ldrh	r0, [r5, #8]
 8047cba:	4402      	add	r2, r0
 8047cbc:	1a9b      	subs	r3, r3, r2
            while (next &&
 8047cbe:	2b00      	cmp	r3, #0
 8047cc0:	db20      	blt.n	8047d04 <tcp_receive+0x66c>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8047cc2:	8988      	ldrh	r0, [r1, #12]
 8047cc4:	f7fd fbb2 	bl	804542c <lwip_htons>
 8047cc8:	f010 0f01 	tst.w	r0, #1
 8047ccc:	d0e8      	beq.n	8047ca0 <tcp_receive+0x608>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 8047cce:	4b76      	ldr	r3, [pc, #472]	; (8047ea8 <tcp_receive+0x810>)
 8047cd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047cd2:	8998      	ldrh	r0, [r3, #12]
 8047cd4:	f7fd fbaa 	bl	804542c <lwip_htons>
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
 8047cd8:	f010 0f02 	tst.w	r0, #2
 8047cdc:	d1e0      	bne.n	8047ca0 <tcp_receive+0x608>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 8047cde:	4e72      	ldr	r6, [pc, #456]	; (8047ea8 <tcp_receive+0x810>)
 8047ce0:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047ce2:	899f      	ldrh	r7, [r3, #12]
 8047ce4:	2001      	movs	r0, #1
 8047ce6:	f7fd fba1 	bl	804542c <lwip_htons>
 8047cea:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047cec:	4307      	orrs	r7, r0
 8047cee:	819f      	strh	r7, [r3, #12]
                tcplen = TCP_TCPLEN(&inseg);
 8047cf0:	8d37      	ldrh	r7, [r6, #40]	; 0x28
 8047cf2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8047cf4:	8998      	ldrh	r0, [r3, #12]
 8047cf6:	f7fd fb99 	bl	804542c <lwip_htons>
 8047cfa:	f010 0303 	ands.w	r3, r0, #3
 8047cfe:	d0cc      	beq.n	8047c9a <tcp_receive+0x602>
 8047d00:	2301      	movs	r3, #1
 8047d02:	e7ca      	b.n	8047c9a <tcp_receive+0x602>
            if (next &&
 8047d04:	b145      	cbz	r5, 8047d18 <tcp_receive+0x680>
                TCP_SEQ_GT(seqno + tcplen,
 8047d06:	4b68      	ldr	r3, [pc, #416]	; (8047ea8 <tcp_receive+0x810>)
 8047d08:	6919      	ldr	r1, [r3, #16]
 8047d0a:	8a9b      	ldrh	r3, [r3, #20]
 8047d0c:	440b      	add	r3, r1
 8047d0e:	68ea      	ldr	r2, [r5, #12]
 8047d10:	6852      	ldr	r2, [r2, #4]
 8047d12:	1a9b      	subs	r3, r3, r2
            if (next &&
 8047d14:	2b00      	cmp	r3, #0
 8047d16:	dc01      	bgt.n	8047d1c <tcp_receive+0x684>
            pcb->ooseq = next;
 8047d18:	6725      	str	r5, [r4, #112]	; 0x70
 8047d1a:	e798      	b.n	8047c4e <tcp_receive+0x5b6>
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 8047d1c:	1a52      	subs	r2, r2, r1
 8047d1e:	4b62      	ldr	r3, [pc, #392]	; (8047ea8 <tcp_receive+0x810>)
 8047d20:	851a      	strh	r2, [r3, #40]	; 0x28
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8047d22:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8047d24:	8998      	ldrh	r0, [r3, #12]
 8047d26:	f7fd fb81 	bl	804542c <lwip_htons>
 8047d2a:	f010 0f02 	tst.w	r0, #2
 8047d2e:	d003      	beq.n	8047d38 <tcp_receive+0x6a0>
                inseg.len -= 1;
 8047d30:	4a5d      	ldr	r2, [pc, #372]	; (8047ea8 <tcp_receive+0x810>)
 8047d32:	8d13      	ldrh	r3, [r2, #40]	; 0x28
 8047d34:	3b01      	subs	r3, #1
 8047d36:	8513      	strh	r3, [r2, #40]	; 0x28
              pbuf_realloc(inseg.p, inseg.len);
 8047d38:	4f5b      	ldr	r7, [pc, #364]	; (8047ea8 <tcp_receive+0x810>)
 8047d3a:	8d39      	ldrh	r1, [r7, #40]	; 0x28
 8047d3c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8047d3e:	f7fe f8ff 	bl	8045f40 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 8047d42:	8d3e      	ldrh	r6, [r7, #40]	; 0x28
 8047d44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8047d46:	8998      	ldrh	r0, [r3, #12]
 8047d48:	f7fd fb70 	bl	804542c <lwip_htons>
 8047d4c:	f010 0303 	ands.w	r3, r0, #3
 8047d50:	d000      	beq.n	8047d54 <tcp_receive+0x6bc>
 8047d52:	2301      	movs	r3, #1
 8047d54:	4433      	add	r3, r6
 8047d56:	b29b      	uxth	r3, r3
 8047d58:	4a53      	ldr	r2, [pc, #332]	; (8047ea8 <tcp_receive+0x810>)
 8047d5a:	8293      	strh	r3, [r2, #20]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
 8047d5c:	6912      	ldr	r2, [r2, #16]
 8047d5e:	4413      	add	r3, r2
 8047d60:	68ea      	ldr	r2, [r5, #12]
 8047d62:	6852      	ldr	r2, [r2, #4]
 8047d64:	4293      	cmp	r3, r2
 8047d66:	d0d7      	beq.n	8047d18 <tcp_receive+0x680>
 8047d68:	4b50      	ldr	r3, [pc, #320]	; (8047eac <tcp_receive+0x814>)
 8047d6a:	f240 52ae 	movw	r2, #1454	; 0x5ae
 8047d6e:	4950      	ldr	r1, [pc, #320]	; (8047eb0 <tcp_receive+0x818>)
 8047d70:	4850      	ldr	r0, [pc, #320]	; (8047eb4 <tcp_receive+0x81c>)
 8047d72:	f009 fa3b 	bl	80511ec <printf>
 8047d76:	e7cf      	b.n	8047d18 <tcp_receive+0x680>
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8047d78:	4b4c      	ldr	r3, [pc, #304]	; (8047eac <tcp_receive+0x814>)
 8047d7a:	f240 52b9 	movw	r2, #1465	; 0x5b9
 8047d7e:	494e      	ldr	r1, [pc, #312]	; (8047eb8 <tcp_receive+0x820>)
 8047d80:	484c      	ldr	r0, [pc, #304]	; (8047eb4 <tcp_receive+0x81c>)
 8047d82:	f009 fa33 	bl	80511ec <printf>
 8047d86:	e76b      	b.n	8047c60 <tcp_receive+0x5c8>
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8047d88:	2300      	movs	r3, #0
 8047d8a:	e035      	b.n	8047df8 <tcp_receive+0x760>
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8047d8c:	2300      	movs	r3, #0
 8047d8e:	e041      	b.n	8047e14 <tcp_receive+0x77c>
 8047d90:	4b46      	ldr	r3, [pc, #280]	; (8047eac <tcp_receive+0x814>)
 8047d92:	f240 52dd 	movw	r2, #1501	; 0x5dd
 8047d96:	4949      	ldr	r1, [pc, #292]	; (8047ebc <tcp_receive+0x824>)
 8047d98:	4846      	ldr	r0, [pc, #280]	; (8047eb4 <tcp_receive+0x81c>)
 8047d9a:	f009 fa27 	bl	80511ec <printf>
 8047d9e:	e03c      	b.n	8047e1a <tcp_receive+0x782>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8047da0:	2300      	movs	r3, #0
 8047da2:	e043      	b.n	8047e2c <tcp_receive+0x794>
              recv_data = cseg->p;
 8047da4:	4b40      	ldr	r3, [pc, #256]	; (8047ea8 <tcp_receive+0x810>)
 8047da6:	6319      	str	r1, [r3, #48]	; 0x30
            cseg->p = NULL;
 8047da8:	2300      	movs	r3, #0
 8047daa:	606b      	str	r3, [r5, #4]
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 8047dac:	68eb      	ldr	r3, [r5, #12]
 8047dae:	8998      	ldrh	r0, [r3, #12]
 8047db0:	f7fd fb3c 	bl	804542c <lwip_htons>
 8047db4:	f010 0f01 	tst.w	r0, #1
 8047db8:	d007      	beq.n	8047dca <tcp_receive+0x732>
            recv_flags |= TF_GOT_FIN;
 8047dba:	4a3b      	ldr	r2, [pc, #236]	; (8047ea8 <tcp_receive+0x810>)
 8047dbc:	7b93      	ldrb	r3, [r2, #14]
 8047dbe:	f043 0320 	orr.w	r3, r3, #32
 8047dc2:	7393      	strb	r3, [r2, #14]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 8047dc4:	7d23      	ldrb	r3, [r4, #20]
 8047dc6:	2b04      	cmp	r3, #4
 8047dc8:	d042      	beq.n	8047e50 <tcp_receive+0x7b8>
          pcb->ooseq = cseg->next;
 8047dca:	682b      	ldr	r3, [r5, #0]
 8047dcc:	6723      	str	r3, [r4, #112]	; 0x70
          tcp_seg_free(cseg);
 8047dce:	4628      	mov	r0, r5
 8047dd0:	f7fe fc46 	bl	8046660 <tcp_seg_free>
        while (pcb->ooseq != NULL &&
 8047dd4:	6f25      	ldr	r5, [r4, #112]	; 0x70
 8047dd6:	2d00      	cmp	r5, #0
 8047dd8:	d03d      	beq.n	8047e56 <tcp_receive+0x7be>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 8047dda:	68ea      	ldr	r2, [r5, #12]
 8047ddc:	6853      	ldr	r3, [r2, #4]
 8047dde:	6a61      	ldr	r1, [r4, #36]	; 0x24
        while (pcb->ooseq != NULL &&
 8047de0:	428b      	cmp	r3, r1
 8047de2:	d138      	bne.n	8047e56 <tcp_receive+0x7be>
          seqno = pcb->ooseq->tcphdr->seqno;
 8047de4:	4930      	ldr	r1, [pc, #192]	; (8047ea8 <tcp_receive+0x810>)
 8047de6:	610b      	str	r3, [r1, #16]
          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 8047de8:	892e      	ldrh	r6, [r5, #8]
 8047dea:	8990      	ldrh	r0, [r2, #12]
 8047dec:	f7fd fb1e 	bl	804542c <lwip_htons>
 8047df0:	f010 0f03 	tst.w	r0, #3
 8047df4:	d0c8      	beq.n	8047d88 <tcp_receive+0x6f0>
 8047df6:	2301      	movs	r3, #1
 8047df8:	441e      	add	r6, r3
 8047dfa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8047dfc:	4433      	add	r3, r6
 8047dfe:	6263      	str	r3, [r4, #36]	; 0x24
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
 8047e00:	8d27      	ldrh	r7, [r4, #40]	; 0x28
 8047e02:	892e      	ldrh	r6, [r5, #8]
 8047e04:	68eb      	ldr	r3, [r5, #12]
 8047e06:	8998      	ldrh	r0, [r3, #12]
 8047e08:	f7fd fb10 	bl	804542c <lwip_htons>
 8047e0c:	f010 0f03 	tst.w	r0, #3
 8047e10:	d0bc      	beq.n	8047d8c <tcp_receive+0x6f4>
 8047e12:	2301      	movs	r3, #1
 8047e14:	441e      	add	r6, r3
 8047e16:	42b7      	cmp	r7, r6
 8047e18:	d3ba      	bcc.n	8047d90 <tcp_receive+0x6f8>
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 8047e1a:	892e      	ldrh	r6, [r5, #8]
 8047e1c:	68eb      	ldr	r3, [r5, #12]
 8047e1e:	8998      	ldrh	r0, [r3, #12]
 8047e20:	f7fd fb04 	bl	804542c <lwip_htons>
 8047e24:	f010 0f03 	tst.w	r0, #3
 8047e28:	d0ba      	beq.n	8047da0 <tcp_receive+0x708>
 8047e2a:	2301      	movs	r3, #1
 8047e2c:	441e      	add	r6, r3
 8047e2e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047e30:	1b9b      	subs	r3, r3, r6
 8047e32:	8523      	strh	r3, [r4, #40]	; 0x28
          tcp_update_rcv_ann_wnd(pcb);
 8047e34:	4620      	mov	r0, r4
 8047e36:	f7fe fba3 	bl	8046580 <tcp_update_rcv_ann_wnd>
          if (cseg->p->tot_len > 0) {
 8047e3a:	6869      	ldr	r1, [r5, #4]
 8047e3c:	890b      	ldrh	r3, [r1, #8]
 8047e3e:	2b00      	cmp	r3, #0
 8047e40:	d0b4      	beq.n	8047dac <tcp_receive+0x714>
            if (recv_data) {
 8047e42:	4b19      	ldr	r3, [pc, #100]	; (8047ea8 <tcp_receive+0x810>)
 8047e44:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8047e46:	2800      	cmp	r0, #0
 8047e48:	d0ac      	beq.n	8047da4 <tcp_receive+0x70c>
              pbuf_cat(recv_data, cseg->p);
 8047e4a:	f7fe f911 	bl	8046070 <pbuf_cat>
 8047e4e:	e7ab      	b.n	8047da8 <tcp_receive+0x710>
              pcb->state = CLOSE_WAIT;
 8047e50:	2307      	movs	r3, #7
 8047e52:	7523      	strb	r3, [r4, #20]
 8047e54:	e7b9      	b.n	8047dca <tcp_receive+0x732>
        tcp_ack(pcb);
 8047e56:	7ea3      	ldrb	r3, [r4, #26]
 8047e58:	f013 0f01 	tst.w	r3, #1
 8047e5c:	d005      	beq.n	8047e6a <tcp_receive+0x7d2>
 8047e5e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8047e62:	f043 0302 	orr.w	r3, r3, #2
 8047e66:	76a3      	strb	r3, [r4, #26]
 8047e68:	e0ef      	b.n	804804a <tcp_receive+0x9b2>
 8047e6a:	f043 0301 	orr.w	r3, r3, #1
 8047e6e:	76a3      	strb	r3, [r4, #26]
 8047e70:	e0eb      	b.n	804804a <tcp_receive+0x9b2>
          pcb->ooseq = tcp_seg_copy(&inseg);
 8047e72:	4813      	ldr	r0, [pc, #76]	; (8047ec0 <tcp_receive+0x828>)
 8047e74:	f7fe fc0b 	bl	804668e <tcp_seg_copy>
 8047e78:	6720      	str	r0, [r4, #112]	; 0x70
 8047e7a:	e0e6      	b.n	804804a <tcp_receive+0x9b2>
              if (inseg.len > next->len) {
 8047e7c:	4b0a      	ldr	r3, [pc, #40]	; (8047ea8 <tcp_receive+0x810>)
 8047e7e:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8047e80:	892b      	ldrh	r3, [r5, #8]
 8047e82:	429a      	cmp	r2, r3
 8047e84:	f240 80e1 	bls.w	804804a <tcp_receive+0x9b2>
                cseg = tcp_seg_copy(&inseg);
 8047e88:	480d      	ldr	r0, [pc, #52]	; (8047ec0 <tcp_receive+0x828>)
 8047e8a:	f7fe fc00 	bl	804668e <tcp_seg_copy>
                if (cseg != NULL) {
 8047e8e:	4603      	mov	r3, r0
 8047e90:	2800      	cmp	r0, #0
 8047e92:	f000 80da 	beq.w	804804a <tcp_receive+0x9b2>
                  if (prev != NULL) {
 8047e96:	b12e      	cbz	r6, 8047ea4 <tcp_receive+0x80c>
                    prev->next = cseg;
 8047e98:	6030      	str	r0, [r6, #0]
                  tcp_oos_insert_segment(cseg, next);
 8047e9a:	4629      	mov	r1, r5
 8047e9c:	4618      	mov	r0, r3
 8047e9e:	f7ff fbb7 	bl	8047610 <tcp_oos_insert_segment>
 8047ea2:	e0d2      	b.n	804804a <tcp_receive+0x9b2>
                    pcb->ooseq = cseg;
 8047ea4:	6720      	str	r0, [r4, #112]	; 0x70
 8047ea6:	e7f8      	b.n	8047e9a <tcp_receive+0x802>
 8047ea8:	200042cc 	.word	0x200042cc
 8047eac:	080591d4 	.word	0x080591d4
 8047eb0:	080592e8 	.word	0x080592e8
 8047eb4:	08058644 	.word	0x08058644
 8047eb8:	08059324 	.word	0x08059324
 8047ebc:	08059344 	.word	0x08059344
 8047ec0:	200042ec 	.word	0x200042ec
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 8047ec4:	1a99      	subs	r1, r3, r2
 8047ec6:	2900      	cmp	r1, #0
 8047ec8:	db2e      	blt.n	8047f28 <tcp_receive+0x890>
              if (next->next == NULL &&
 8047eca:	6829      	ldr	r1, [r5, #0]
 8047ecc:	462e      	mov	r6, r5
 8047ece:	2900      	cmp	r1, #0
 8047ed0:	d03c      	beq.n	8047f4c <tcp_receive+0x8b4>
 8047ed2:	460d      	mov	r5, r1
          for (next = pcb->ooseq; next != NULL; next = next->next) {
 8047ed4:	2d00      	cmp	r5, #0
 8047ed6:	f000 80b8 	beq.w	804804a <tcp_receive+0x9b2>
            if (seqno == next->tcphdr->seqno) {
 8047eda:	68e8      	ldr	r0, [r5, #12]
 8047edc:	6842      	ldr	r2, [r0, #4]
 8047ede:	4b5b      	ldr	r3, [pc, #364]	; (804804c <tcp_receive+0x9b4>)
 8047ee0:	691b      	ldr	r3, [r3, #16]
 8047ee2:	429a      	cmp	r2, r3
 8047ee4:	d0ca      	beq.n	8047e7c <tcp_receive+0x7e4>
              if (prev == NULL) {
 8047ee6:	2e00      	cmp	r6, #0
 8047ee8:	d0ec      	beq.n	8047ec4 <tcp_receive+0x82c>
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 8047eea:	68f1      	ldr	r1, [r6, #12]
 8047eec:	6849      	ldr	r1, [r1, #4]
 8047eee:	1a59      	subs	r1, r3, r1
 8047ef0:	2901      	cmp	r1, #1
 8047ef2:	d4ea      	bmi.n	8047eca <tcp_receive+0x832>
 8047ef4:	1a99      	subs	r1, r3, r2
 8047ef6:	3101      	adds	r1, #1
 8047ef8:	2900      	cmp	r1, #0
 8047efa:	dce6      	bgt.n	8047eca <tcp_receive+0x832>
                  cseg = tcp_seg_copy(&inseg);
 8047efc:	4854      	ldr	r0, [pc, #336]	; (8048050 <tcp_receive+0x9b8>)
 8047efe:	f7fe fbc6 	bl	804668e <tcp_seg_copy>
                  if (cseg != NULL) {
 8047f02:	4604      	mov	r4, r0
 8047f04:	2800      	cmp	r0, #0
 8047f06:	f000 80a0 	beq.w	804804a <tcp_receive+0x9b2>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 8047f0a:	68f3      	ldr	r3, [r6, #12]
 8047f0c:	6859      	ldr	r1, [r3, #4]
 8047f0e:	8932      	ldrh	r2, [r6, #8]
 8047f10:	440a      	add	r2, r1
 8047f12:	4b4e      	ldr	r3, [pc, #312]	; (804804c <tcp_receive+0x9b4>)
 8047f14:	691b      	ldr	r3, [r3, #16]
 8047f16:	1ad2      	subs	r2, r2, r3
 8047f18:	2a00      	cmp	r2, #0
 8047f1a:	dc10      	bgt.n	8047f3e <tcp_receive+0x8a6>
                    prev->next = cseg;
 8047f1c:	6034      	str	r4, [r6, #0]
                    tcp_oos_insert_segment(cseg, next);
 8047f1e:	4629      	mov	r1, r5
 8047f20:	4620      	mov	r0, r4
 8047f22:	f7ff fb75 	bl	8047610 <tcp_oos_insert_segment>
 8047f26:	e090      	b.n	804804a <tcp_receive+0x9b2>
                  cseg = tcp_seg_copy(&inseg);
 8047f28:	4849      	ldr	r0, [pc, #292]	; (8048050 <tcp_receive+0x9b8>)
 8047f2a:	f7fe fbb0 	bl	804668e <tcp_seg_copy>
                  if (cseg != NULL) {
 8047f2e:	2800      	cmp	r0, #0
 8047f30:	f000 808b 	beq.w	804804a <tcp_receive+0x9b2>
                    pcb->ooseq = cseg;
 8047f34:	6720      	str	r0, [r4, #112]	; 0x70
                    tcp_oos_insert_segment(cseg, next);
 8047f36:	4629      	mov	r1, r5
 8047f38:	f7ff fb6a 	bl	8047610 <tcp_oos_insert_segment>
 8047f3c:	e085      	b.n	804804a <tcp_receive+0x9b2>
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 8047f3e:	1a5b      	subs	r3, r3, r1
 8047f40:	b299      	uxth	r1, r3
 8047f42:	8131      	strh	r1, [r6, #8]
                      pbuf_realloc(prev->p, prev->len);
 8047f44:	6870      	ldr	r0, [r6, #4]
 8047f46:	f7fd fffb 	bl	8045f40 <pbuf_realloc>
 8047f4a:	e7e7      	b.n	8047f1c <tcp_receive+0x884>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 8047f4c:	1a9b      	subs	r3, r3, r2
              if (next->next == NULL &&
 8047f4e:	2b00      	cmp	r3, #0
 8047f50:	dc01      	bgt.n	8047f56 <tcp_receive+0x8be>
 8047f52:	460d      	mov	r5, r1
 8047f54:	e7be      	b.n	8047ed4 <tcp_receive+0x83c>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 8047f56:	8980      	ldrh	r0, [r0, #12]
 8047f58:	f7fd fa68 	bl	804542c <lwip_htons>
 8047f5c:	f010 0f01 	tst.w	r0, #1
 8047f60:	d173      	bne.n	804804a <tcp_receive+0x9b2>
                next->next = tcp_seg_copy(&inseg);
 8047f62:	483b      	ldr	r0, [pc, #236]	; (8048050 <tcp_receive+0x9b8>)
 8047f64:	f7fe fb93 	bl	804668e <tcp_seg_copy>
 8047f68:	6028      	str	r0, [r5, #0]
                if (next->next != NULL) {
 8047f6a:	2800      	cmp	r0, #0
 8047f6c:	d06d      	beq.n	804804a <tcp_receive+0x9b2>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 8047f6e:	68eb      	ldr	r3, [r5, #12]
 8047f70:	6859      	ldr	r1, [r3, #4]
 8047f72:	892a      	ldrh	r2, [r5, #8]
 8047f74:	440a      	add	r2, r1
 8047f76:	4b35      	ldr	r3, [pc, #212]	; (804804c <tcp_receive+0x9b4>)
 8047f78:	691b      	ldr	r3, [r3, #16]
 8047f7a:	1ad2      	subs	r2, r2, r3
 8047f7c:	2a00      	cmp	r2, #0
 8047f7e:	dc3c      	bgt.n	8047ffa <tcp_receive+0x962>
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
 8047f80:	4a32      	ldr	r2, [pc, #200]	; (804804c <tcp_receive+0x9b4>)
 8047f82:	8a93      	ldrh	r3, [r2, #20]
 8047f84:	6912      	ldr	r2, [r2, #16]
 8047f86:	4413      	add	r3, r2
 8047f88:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047f8a:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8047f8c:	440a      	add	r2, r1
 8047f8e:	1a9b      	subs	r3, r3, r2
 8047f90:	2b00      	cmp	r3, #0
 8047f92:	dd5a      	ble.n	804804a <tcp_receive+0x9b2>
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 8047f94:	682b      	ldr	r3, [r5, #0]
 8047f96:	68db      	ldr	r3, [r3, #12]
 8047f98:	8998      	ldrh	r0, [r3, #12]
 8047f9a:	f7fd fa47 	bl	804542c <lwip_htons>
 8047f9e:	f010 0f01 	tst.w	r0, #1
 8047fa2:	d131      	bne.n	8048008 <tcp_receive+0x970>
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
 8047fa4:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047fa6:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8047fa8:	4413      	add	r3, r2
 8047faa:	b29b      	uxth	r3, r3
 8047fac:	682a      	ldr	r2, [r5, #0]
 8047fae:	4927      	ldr	r1, [pc, #156]	; (804804c <tcp_receive+0x9b4>)
 8047fb0:	6909      	ldr	r1, [r1, #16]
 8047fb2:	1a5b      	subs	r3, r3, r1
 8047fb4:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
 8047fb6:	682b      	ldr	r3, [r5, #0]
 8047fb8:	8919      	ldrh	r1, [r3, #8]
 8047fba:	6858      	ldr	r0, [r3, #4]
 8047fbc:	f7fd ffc0 	bl	8045f40 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 8047fc0:	682b      	ldr	r3, [r5, #0]
 8047fc2:	891d      	ldrh	r5, [r3, #8]
 8047fc4:	68db      	ldr	r3, [r3, #12]
 8047fc6:	8998      	ldrh	r0, [r3, #12]
 8047fc8:	f7fd fa30 	bl	804542c <lwip_htons>
 8047fcc:	f010 0303 	ands.w	r3, r0, #3
 8047fd0:	d000      	beq.n	8047fd4 <tcp_receive+0x93c>
 8047fd2:	2301      	movs	r3, #1
 8047fd4:	442b      	add	r3, r5
 8047fd6:	b29b      	uxth	r3, r3
 8047fd8:	4a1c      	ldr	r2, [pc, #112]	; (804804c <tcp_receive+0x9b4>)
 8047fda:	8293      	strh	r3, [r2, #20]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8047fdc:	6912      	ldr	r2, [r2, #16]
 8047fde:	4413      	add	r3, r2
 8047fe0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8047fe2:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8047fe4:	440a      	add	r2, r1
 8047fe6:	4293      	cmp	r3, r2
 8047fe8:	d02f      	beq.n	804804a <tcp_receive+0x9b2>
 8047fea:	4b1a      	ldr	r3, [pc, #104]	; (8048054 <tcp_receive+0x9bc>)
 8047fec:	f240 627a 	movw	r2, #1658	; 0x67a
 8047ff0:	4919      	ldr	r1, [pc, #100]	; (8048058 <tcp_receive+0x9c0>)
 8047ff2:	481a      	ldr	r0, [pc, #104]	; (804805c <tcp_receive+0x9c4>)
 8047ff4:	f009 f8fa 	bl	80511ec <printf>
 8047ff8:	e027      	b.n	804804a <tcp_receive+0x9b2>
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 8047ffa:	1a5b      	subs	r3, r3, r1
 8047ffc:	b299      	uxth	r1, r3
 8047ffe:	8129      	strh	r1, [r5, #8]
                    pbuf_realloc(next->p, next->len);
 8048000:	6868      	ldr	r0, [r5, #4]
 8048002:	f7fd ff9d 	bl	8045f40 <pbuf_realloc>
 8048006:	e7bb      	b.n	8047f80 <tcp_receive+0x8e8>
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
 8048008:	682b      	ldr	r3, [r5, #0]
 804800a:	68db      	ldr	r3, [r3, #12]
 804800c:	8998      	ldrh	r0, [r3, #12]
 804800e:	f420 567c 	bic.w	r6, r0, #16128	; 0x3f00
 8048012:	b2b6      	uxth	r6, r6
 8048014:	f7fd fa0a 	bl	804542c <lwip_htons>
 8048018:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 804801c:	f7fd fa06 	bl	804542c <lwip_htons>
 8048020:	682b      	ldr	r3, [r5, #0]
 8048022:	68db      	ldr	r3, [r3, #12]
 8048024:	4306      	orrs	r6, r0
 8048026:	819e      	strh	r6, [r3, #12]
 8048028:	e7bc      	b.n	8047fa4 <tcp_receive+0x90c>
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
 804802a:	4b08      	ldr	r3, [pc, #32]	; (804804c <tcp_receive+0x9b4>)
 804802c:	691b      	ldr	r3, [r3, #16]
 804802e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8048030:	1a99      	subs	r1, r3, r2
 8048032:	2900      	cmp	r1, #0
 8048034:	db05      	blt.n	8048042 <tcp_receive+0x9aa>
 8048036:	8d21      	ldrh	r1, [r4, #40]	; 0x28
 8048038:	440a      	add	r2, r1
 804803a:	1a9b      	subs	r3, r3, r2
 804803c:	3301      	adds	r3, #1
 804803e:	2b00      	cmp	r3, #0
 8048040:	dd03      	ble.n	804804a <tcp_receive+0x9b2>
      tcp_ack_now(pcb);
 8048042:	7ea3      	ldrb	r3, [r4, #26]
 8048044:	f043 0302 	orr.w	r3, r3, #2
 8048048:	76a3      	strb	r3, [r4, #26]
}
 804804a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804804c:	200042cc 	.word	0x200042cc
 8048050:	200042ec 	.word	0x200042ec
 8048054:	080591d4 	.word	0x080591d4
 8048058:	080592b0 	.word	0x080592b0
 804805c:	08058644 	.word	0x08058644

08048060 <tcp_process>:
{
 8048060:	b570      	push	{r4, r5, r6, lr}
 8048062:	b082      	sub	sp, #8
 8048064:	4604      	mov	r4, r0
  if (flags & TCP_RST) {
 8048066:	4ba5      	ldr	r3, [pc, #660]	; (80482fc <tcp_process+0x29c>)
 8048068:	7bdb      	ldrb	r3, [r3, #15]
 804806a:	f013 0f04 	tst.w	r3, #4
 804806e:	d032      	beq.n	80480d6 <tcp_process+0x76>
    if (pcb->state == SYN_SENT) {
 8048070:	7d01      	ldrb	r1, [r0, #20]
 8048072:	2902      	cmp	r1, #2
 8048074:	d011      	beq.n	804809a <tcp_process+0x3a>
      if (seqno == pcb->rcv_nxt) {
 8048076:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8048078:	4ba0      	ldr	r3, [pc, #640]	; (80482fc <tcp_process+0x29c>)
 804807a:	691b      	ldr	r3, [r3, #16]
 804807c:	429a      	cmp	r2, r3
 804807e:	d015      	beq.n	80480ac <tcp_process+0x4c>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
 8048080:	1a99      	subs	r1, r3, r2
 8048082:	2900      	cmp	r1, #0
 8048084:	db0e      	blt.n	80480a4 <tcp_process+0x44>
 8048086:	8d01      	ldrh	r1, [r0, #40]	; 0x28
 8048088:	440a      	add	r2, r1
 804808a:	1a9b      	subs	r3, r3, r2
 804808c:	2b00      	cmp	r3, #0
 804808e:	dc09      	bgt.n	80480a4 <tcp_process+0x44>
        tcp_ack_now(pcb);
 8048090:	7e83      	ldrb	r3, [r0, #26]
 8048092:	f043 0302 	orr.w	r3, r3, #2
 8048096:	7683      	strb	r3, [r0, #26]
    if (acceptable) {
 8048098:	e004      	b.n	80480a4 <tcp_process+0x44>
      if (ackno == pcb->snd_nxt) {
 804809a:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 804809c:	4b97      	ldr	r3, [pc, #604]	; (80482fc <tcp_process+0x29c>)
 804809e:	699b      	ldr	r3, [r3, #24]
 80480a0:	429a      	cmp	r2, r3
 80480a2:	d003      	beq.n	80480ac <tcp_process+0x4c>
      return ERR_OK;
 80480a4:	2500      	movs	r5, #0
}
 80480a6:	4628      	mov	r0, r5
 80480a8:	b002      	add	sp, #8
 80480aa:	bd70      	pop	{r4, r5, r6, pc}
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 80480ac:	b159      	cbz	r1, 80480c6 <tcp_process+0x66>
      recv_flags |= TF_RESET;
 80480ae:	4a93      	ldr	r2, [pc, #588]	; (80482fc <tcp_process+0x29c>)
 80480b0:	7b93      	ldrb	r3, [r2, #14]
 80480b2:	f043 0308 	orr.w	r3, r3, #8
 80480b6:	7393      	strb	r3, [r2, #14]
      pcb->flags &= ~TF_ACK_DELAY;
 80480b8:	7ea3      	ldrb	r3, [r4, #26]
 80480ba:	f023 0301 	bic.w	r3, r3, #1
 80480be:	76a3      	strb	r3, [r4, #26]
      return ERR_RST;
 80480c0:	f06f 050d 	mvn.w	r5, #13
 80480c4:	e7ef      	b.n	80480a6 <tcp_process+0x46>
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 80480c6:	4b8e      	ldr	r3, [pc, #568]	; (8048300 <tcp_process+0x2a0>)
 80480c8:	f240 22e7 	movw	r2, #743	; 0x2e7
 80480cc:	498d      	ldr	r1, [pc, #564]	; (8048304 <tcp_process+0x2a4>)
 80480ce:	488e      	ldr	r0, [pc, #568]	; (8048308 <tcp_process+0x2a8>)
 80480d0:	f009 f88c 	bl	80511ec <printf>
 80480d4:	e7eb      	b.n	80480ae <tcp_process+0x4e>
  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
 80480d6:	f013 0f02 	tst.w	r3, #2
 80480da:	d004      	beq.n	80480e6 <tcp_process+0x86>
 80480dc:	7d03      	ldrb	r3, [r0, #20]
 80480de:	3b02      	subs	r3, #2
 80480e0:	b2db      	uxtb	r3, r3
 80480e2:	2b01      	cmp	r3, #1
 80480e4:	d81b      	bhi.n	804811e <tcp_process+0xbe>
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 80480e6:	7ea3      	ldrb	r3, [r4, #26]
 80480e8:	f013 0f10 	tst.w	r3, #16
 80480ec:	d102      	bne.n	80480f4 <tcp_process+0x94>
    pcb->tmr = tcp_ticks;
 80480ee:	4b87      	ldr	r3, [pc, #540]	; (804830c <tcp_process+0x2ac>)
 80480f0:	681b      	ldr	r3, [r3, #0]
 80480f2:	6223      	str	r3, [r4, #32]
  pcb->keep_cnt_sent = 0;
 80480f4:	2300      	movs	r3, #0
 80480f6:	f884 3096 	strb.w	r3, [r4, #150]	; 0x96
  tcp_parseopt(pcb);
 80480fa:	4620      	mov	r0, r4
 80480fc:	f7ff f968 	bl	80473d0 <tcp_parseopt>
  switch (pcb->state) {
 8048100:	7d23      	ldrb	r3, [r4, #20]
 8048102:	3b02      	subs	r3, #2
 8048104:	2b07      	cmp	r3, #7
 8048106:	f200 820d 	bhi.w	8048524 <tcp_process+0x4c4>
 804810a:	e8df f013 	tbh	[pc, r3, lsl #1]
 804810e:	000e      	.short	0x000e
 8048110:	0129009a 	.word	0x0129009a
 8048114:	0190013a 	.word	0x0190013a
 8048118:	01be0129 	.word	0x01be0129
 804811c:	01f1      	.short	0x01f1
    tcp_ack_now(pcb);
 804811e:	7e83      	ldrb	r3, [r0, #26]
 8048120:	f043 0302 	orr.w	r3, r3, #2
 8048124:	7683      	strb	r3, [r0, #26]
    return ERR_OK;
 8048126:	2500      	movs	r5, #0
 8048128:	e7bd      	b.n	80480a6 <tcp_process+0x46>
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 804812a:	4b74      	ldr	r3, [pc, #464]	; (80482fc <tcp_process+0x29c>)
 804812c:	7bdb      	ldrb	r3, [r3, #15]
 804812e:	f003 0212 	and.w	r2, r3, #18
 8048132:	2a12      	cmp	r2, #18
 8048134:	d004      	beq.n	8048140 <tcp_process+0xe0>
    else if (flags & TCP_ACK) {
 8048136:	f013 0f10 	tst.w	r3, #16
 804813a:	d168      	bne.n	804820e <tcp_process+0x1ae>
  return ERR_OK;
 804813c:	2500      	movs	r5, #0
 804813e:	e7b2      	b.n	80480a6 <tcp_process+0x46>
        && (ackno == pcb->lastack + 1)) {
 8048140:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8048142:	3201      	adds	r2, #1
 8048144:	496d      	ldr	r1, [pc, #436]	; (80482fc <tcp_process+0x29c>)
 8048146:	6989      	ldr	r1, [r1, #24]
 8048148:	428a      	cmp	r2, r1
 804814a:	d1f4      	bne.n	8048136 <tcp_process+0xd6>
      pcb->rcv_nxt = seqno + 1;
 804814c:	4a6b      	ldr	r2, [pc, #428]	; (80482fc <tcp_process+0x29c>)
 804814e:	6913      	ldr	r3, [r2, #16]
 8048150:	1c58      	adds	r0, r3, #1
 8048152:	6260      	str	r0, [r4, #36]	; 0x24
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8048154:	62e0      	str	r0, [r4, #44]	; 0x2c
      pcb->lastack = ackno;
 8048156:	6461      	str	r1, [r4, #68]	; 0x44
      pcb->snd_wnd = tcphdr->wnd;
 8048158:	6892      	ldr	r2, [r2, #8]
 804815a:	89d2      	ldrh	r2, [r2, #14]
 804815c:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
      pcb->snd_wnd_max = pcb->snd_wnd;
 8048160:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 8048164:	3b01      	subs	r3, #1
 8048166:	6523      	str	r3, [r4, #80]	; 0x50
      pcb->state = ESTABLISHED;
 8048168:	2304      	movs	r3, #4
 804816a:	7523      	strb	r3, [r4, #20]
      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
 804816c:	18e1      	adds	r1, r4, r3
 804816e:	8e60      	ldrh	r0, [r4, #50]	; 0x32
 8048170:	f7ff f846 	bl	8047200 <tcp_eff_send_mss_impl>
 8048174:	8660      	strh	r0, [r4, #50]	; 0x32
      pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 8048176:	0043      	lsls	r3, r0, #1
 8048178:	f241 121c 	movw	r2, #4380	; 0x111c
 804817c:	4293      	cmp	r3, r2
 804817e:	bf38      	it	cc
 8048180:	4613      	movcc	r3, r2
 8048182:	0080      	lsls	r0, r0, #2
 8048184:	4298      	cmp	r0, r3
 8048186:	bf28      	it	cs
 8048188:	4618      	movcs	r0, r3
 804818a:	f8a4 0048 	strh.w	r0, [r4, #72]	; 0x48
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 804818e:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8048192:	b31b      	cbz	r3, 80481dc <tcp_process+0x17c>
      --pcb->snd_queuelen;
 8048194:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8048198:	3b01      	subs	r3, #1
 804819a:	f8a4 3062 	strh.w	r3, [r4, #98]	; 0x62
      rseg = pcb->unacked;
 804819e:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      if (rseg == NULL) {
 80481a0:	b325      	cbz	r5, 80481ec <tcp_process+0x18c>
        pcb->unacked = rseg->next;
 80481a2:	682b      	ldr	r3, [r5, #0]
 80481a4:	66e3      	str	r3, [r4, #108]	; 0x6c
      tcp_seg_free(rseg);
 80481a6:	4628      	mov	r0, r5
 80481a8:	f7fe fa5a 	bl	8046660 <tcp_seg_free>
      if (pcb->unacked == NULL) {
 80481ac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 80481ae:	b353      	cbz	r3, 8048206 <tcp_process+0x1a6>
        pcb->rtime = 0;
 80481b0:	2300      	movs	r3, #0
 80481b2:	8623      	strh	r3, [r4, #48]	; 0x30
        pcb->nrtx = 0;
 80481b4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 80481b8:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 80481bc:	b143      	cbz	r3, 80481d0 <tcp_process+0x170>
 80481be:	2200      	movs	r2, #0
 80481c0:	4621      	mov	r1, r4
 80481c2:	6920      	ldr	r0, [r4, #16]
 80481c4:	4798      	blx	r3
 80481c6:	4605      	mov	r5, r0
      if (err == ERR_ABRT) {
 80481c8:	f110 0f0d 	cmn.w	r0, #13
 80481cc:	f43f af6b 	beq.w	80480a6 <tcp_process+0x46>
      tcp_ack_now(pcb);
 80481d0:	7ea3      	ldrb	r3, [r4, #26]
 80481d2:	f043 0302 	orr.w	r3, r3, #2
 80481d6:	76a3      	strb	r3, [r4, #26]
  return ERR_OK;
 80481d8:	2500      	movs	r5, #0
      tcp_ack_now(pcb);
 80481da:	e764      	b.n	80480a6 <tcp_process+0x46>
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 80481dc:	4b48      	ldr	r3, [pc, #288]	; (8048300 <tcp_process+0x2a0>)
 80481de:	f240 321a 	movw	r2, #794	; 0x31a
 80481e2:	494b      	ldr	r1, [pc, #300]	; (8048310 <tcp_process+0x2b0>)
 80481e4:	4848      	ldr	r0, [pc, #288]	; (8048308 <tcp_process+0x2a8>)
 80481e6:	f009 f801 	bl	80511ec <printf>
 80481ea:	e7d3      	b.n	8048194 <tcp_process+0x134>
        rseg = pcb->unsent;
 80481ec:	6ea5      	ldr	r5, [r4, #104]	; 0x68
        LWIP_ASSERT("no segment to free", rseg != NULL);
 80481ee:	b115      	cbz	r5, 80481f6 <tcp_process+0x196>
        pcb->unsent = rseg->next;
 80481f0:	682b      	ldr	r3, [r5, #0]
 80481f2:	66a3      	str	r3, [r4, #104]	; 0x68
 80481f4:	e7d7      	b.n	80481a6 <tcp_process+0x146>
        LWIP_ASSERT("no segment to free", rseg != NULL);
 80481f6:	4b42      	ldr	r3, [pc, #264]	; (8048300 <tcp_process+0x2a0>)
 80481f8:	f240 3222 	movw	r2, #802	; 0x322
 80481fc:	4945      	ldr	r1, [pc, #276]	; (8048314 <tcp_process+0x2b4>)
 80481fe:	4842      	ldr	r0, [pc, #264]	; (8048308 <tcp_process+0x2a8>)
 8048200:	f008 fff4 	bl	80511ec <printf>
 8048204:	e7f4      	b.n	80481f0 <tcp_process+0x190>
        pcb->rtime = -1;
 8048206:	f64f 73ff 	movw	r3, #65535	; 0xffff
 804820a:	8623      	strh	r3, [r4, #48]	; 0x30
 804820c:	e7d4      	b.n	80481b8 <tcp_process+0x158>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 804820e:	483b      	ldr	r0, [pc, #236]	; (80482fc <tcp_process+0x29c>)
 8048210:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8048212:	4b41      	ldr	r3, [pc, #260]	; (8048318 <tcp_process+0x2b8>)
 8048214:	8a85      	ldrh	r5, [r0, #20]
 8048216:	6901      	ldr	r1, [r0, #16]
 8048218:	8816      	ldrh	r6, [r2, #0]
 804821a:	9601      	str	r6, [sp, #4]
 804821c:	8852      	ldrh	r2, [r2, #2]
 804821e:	9200      	str	r2, [sp, #0]
 8048220:	1d1a      	adds	r2, r3, #4
 8048222:	4429      	add	r1, r5
 8048224:	6980      	ldr	r0, [r0, #24]
 8048226:	f001 fa8d 	bl	8049744 <tcp_rst>
      if (pcb->nrtx < TCP_SYNMAXRTX) {
 804822a:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 804822e:	2b05      	cmp	r3, #5
 8048230:	d901      	bls.n	8048236 <tcp_process+0x1d6>
  return ERR_OK;
 8048232:	2500      	movs	r5, #0
 8048234:	e737      	b.n	80480a6 <tcp_process+0x46>
        pcb->rtime = 0;
 8048236:	2500      	movs	r5, #0
 8048238:	8625      	strh	r5, [r4, #48]	; 0x30
        tcp_rexmit_rto(pcb);
 804823a:	4620      	mov	r0, r4
 804823c:	f001 fad8 	bl	80497f0 <tcp_rexmit_rto>
 8048240:	e731      	b.n	80480a6 <tcp_process+0x46>
    if (flags & TCP_ACK) {
 8048242:	4b2e      	ldr	r3, [pc, #184]	; (80482fc <tcp_process+0x29c>)
 8048244:	7bdb      	ldrb	r3, [r3, #15]
 8048246:	f013 0f10 	tst.w	r3, #16
 804824a:	d078      	beq.n	804833e <tcp_process+0x2de>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 804824c:	4b2b      	ldr	r3, [pc, #172]	; (80482fc <tcp_process+0x29c>)
 804824e:	6998      	ldr	r0, [r3, #24]
 8048250:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8048252:	1ac3      	subs	r3, r0, r3
 8048254:	2b01      	cmp	r3, #1
 8048256:	d403      	bmi.n	8048260 <tcp_process+0x200>
 8048258:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 804825a:	1ac3      	subs	r3, r0, r3
 804825c:	2b00      	cmp	r3, #0
 804825e:	dd0e      	ble.n	804827e <tcp_process+0x21e>
          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 8048260:	4c26      	ldr	r4, [pc, #152]	; (80482fc <tcp_process+0x29c>)
 8048262:	68a2      	ldr	r2, [r4, #8]
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8048264:	4b2c      	ldr	r3, [pc, #176]	; (8048318 <tcp_process+0x2b8>)
 8048266:	8aa5      	ldrh	r5, [r4, #20]
 8048268:	6921      	ldr	r1, [r4, #16]
 804826a:	8814      	ldrh	r4, [r2, #0]
 804826c:	9401      	str	r4, [sp, #4]
 804826e:	8852      	ldrh	r2, [r2, #2]
 8048270:	9200      	str	r2, [sp, #0]
 8048272:	1d1a      	adds	r2, r3, #4
 8048274:	4429      	add	r1, r5
 8048276:	f001 fa65 	bl	8049744 <tcp_rst>
  return ERR_OK;
 804827a:	2500      	movs	r5, #0
 804827c:	e713      	b.n	80480a6 <tcp_process+0x46>
        pcb->state = ESTABLISHED;
 804827e:	2304      	movs	r3, #4
 8048280:	7523      	strb	r3, [r4, #20]
        LWIP_ASSERT("pcb->listener->accept != NULL",
 8048282:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8048284:	b113      	cbz	r3, 804828c <tcp_process+0x22c>
 8048286:	699b      	ldr	r3, [r3, #24]
 8048288:	2b00      	cmp	r3, #0
 804828a:	d02f      	beq.n	80482ec <tcp_process+0x28c>
        if (pcb->listener == NULL) {
 804828c:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 804828e:	2b00      	cmp	r3, #0
 8048290:	d046      	beq.n	8048320 <tcp_process+0x2c0>
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 8048292:	699b      	ldr	r3, [r3, #24]
 8048294:	2b00      	cmp	r3, #0
 8048296:	d04b      	beq.n	8048330 <tcp_process+0x2d0>
 8048298:	2200      	movs	r2, #0
 804829a:	4621      	mov	r1, r4
 804829c:	6920      	ldr	r0, [r4, #16]
 804829e:	4798      	blx	r3
        if (err != ERR_OK) {
 80482a0:	4605      	mov	r5, r0
 80482a2:	2800      	cmp	r0, #0
 80482a4:	d13e      	bne.n	8048324 <tcp_process+0x2c4>
        tcp_receive(pcb);
 80482a6:	4620      	mov	r0, r4
 80482a8:	f7ff f9f6 	bl	8047698 <tcp_receive>
        if (recv_acked != 0) {
 80482ac:	4b13      	ldr	r3, [pc, #76]	; (80482fc <tcp_process+0x29c>)
 80482ae:	8b9b      	ldrh	r3, [r3, #28]
 80482b0:	b113      	cbz	r3, 80482b8 <tcp_process+0x258>
          recv_acked--;
 80482b2:	3b01      	subs	r3, #1
 80482b4:	4a11      	ldr	r2, [pc, #68]	; (80482fc <tcp_process+0x29c>)
 80482b6:	8393      	strh	r3, [r2, #28]
        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
 80482b8:	8e62      	ldrh	r2, [r4, #50]	; 0x32
 80482ba:	0053      	lsls	r3, r2, #1
 80482bc:	f241 111c 	movw	r1, #4380	; 0x111c
 80482c0:	428b      	cmp	r3, r1
 80482c2:	bf38      	it	cc
 80482c4:	460b      	movcc	r3, r1
 80482c6:	0092      	lsls	r2, r2, #2
 80482c8:	4293      	cmp	r3, r2
 80482ca:	bf28      	it	cs
 80482cc:	4613      	movcs	r3, r2
 80482ce:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
        if (recv_flags & TF_GOT_FIN) {
 80482d2:	4b0a      	ldr	r3, [pc, #40]	; (80482fc <tcp_process+0x29c>)
 80482d4:	7b9b      	ldrb	r3, [r3, #14]
 80482d6:	f013 0f20 	tst.w	r3, #32
 80482da:	f43f aee4 	beq.w	80480a6 <tcp_process+0x46>
          tcp_ack_now(pcb);
 80482de:	7ea3      	ldrb	r3, [r4, #26]
 80482e0:	f043 0302 	orr.w	r3, r3, #2
 80482e4:	76a3      	strb	r3, [r4, #26]
          pcb->state = CLOSE_WAIT;
 80482e6:	2307      	movs	r3, #7
 80482e8:	7523      	strb	r3, [r4, #20]
 80482ea:	e6dc      	b.n	80480a6 <tcp_process+0x46>
        LWIP_ASSERT("pcb->listener->accept != NULL",
 80482ec:	4b04      	ldr	r3, [pc, #16]	; (8048300 <tcp_process+0x2a0>)
 80482ee:	f44f 7254 	mov.w	r2, #848	; 0x350
 80482f2:	490a      	ldr	r1, [pc, #40]	; (804831c <tcp_process+0x2bc>)
 80482f4:	4804      	ldr	r0, [pc, #16]	; (8048308 <tcp_process+0x2a8>)
 80482f6:	f008 ff79 	bl	80511ec <printf>
 80482fa:	e7c7      	b.n	804828c <tcp_process+0x22c>
 80482fc:	200042cc 	.word	0x200042cc
 8048300:	080591d4 	.word	0x080591d4
 8048304:	0805936c 	.word	0x0805936c
 8048308:	08058644 	.word	0x08058644
 804830c:	200089a0 	.word	0x200089a0
 8048310:	0805938c 	.word	0x0805938c
 8048314:	080593a4 	.word	0x080593a4
 8048318:	2000547c 	.word	0x2000547c
 804831c:	080593b8 	.word	0x080593b8
          err = ERR_VAL;
 8048320:	f06f 0505 	mvn.w	r5, #5
          if (err != ERR_ABRT) {
 8048324:	f115 0f0d 	cmn.w	r5, #13
 8048328:	d105      	bne.n	8048336 <tcp_process+0x2d6>
          return ERR_ABRT;
 804832a:	f06f 050c 	mvn.w	r5, #12
 804832e:	e6ba      	b.n	80480a6 <tcp_process+0x46>
          TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
 8048330:	f06f 050f 	mvn.w	r5, #15
 8048334:	e7f6      	b.n	8048324 <tcp_process+0x2c4>
            tcp_abort(pcb);
 8048336:	4620      	mov	r0, r4
 8048338:	f7fe fe6a 	bl	8047010 <tcp_abort>
 804833c:	e7f5      	b.n	804832a <tcp_process+0x2ca>
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 804833e:	f013 0f02 	tst.w	r3, #2
 8048342:	f000 80f1 	beq.w	8048528 <tcp_process+0x4c8>
 8048346:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8048348:	3b01      	subs	r3, #1
 804834a:	4a7c      	ldr	r2, [pc, #496]	; (804853c <tcp_process+0x4dc>)
 804834c:	6912      	ldr	r2, [r2, #16]
 804834e:	4293      	cmp	r3, r2
 8048350:	d001      	beq.n	8048356 <tcp_process+0x2f6>
  return ERR_OK;
 8048352:	2500      	movs	r5, #0
 8048354:	e6a7      	b.n	80480a6 <tcp_process+0x46>
      tcp_rexmit(pcb);
 8048356:	4620      	mov	r0, r4
 8048358:	f001 fa63 	bl	8049822 <tcp_rexmit>
  return ERR_OK;
 804835c:	2500      	movs	r5, #0
 804835e:	e6a2      	b.n	80480a6 <tcp_process+0x46>
    tcp_receive(pcb);
 8048360:	4620      	mov	r0, r4
 8048362:	f7ff f999 	bl	8047698 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 8048366:	4b75      	ldr	r3, [pc, #468]	; (804853c <tcp_process+0x4dc>)
 8048368:	7b9b      	ldrb	r3, [r3, #14]
 804836a:	f013 0f20 	tst.w	r3, #32
 804836e:	f000 80dd 	beq.w	804852c <tcp_process+0x4cc>
      tcp_ack_now(pcb);
 8048372:	7ea3      	ldrb	r3, [r4, #26]
 8048374:	f043 0302 	orr.w	r3, r3, #2
 8048378:	76a3      	strb	r3, [r4, #26]
      pcb->state = CLOSE_WAIT;
 804837a:	2307      	movs	r3, #7
 804837c:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 804837e:	2500      	movs	r5, #0
 8048380:	e691      	b.n	80480a6 <tcp_process+0x46>
    tcp_receive(pcb);
 8048382:	4620      	mov	r0, r4
 8048384:	f7ff f988 	bl	8047698 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8048388:	4b6c      	ldr	r3, [pc, #432]	; (804853c <tcp_process+0x4dc>)
 804838a:	7b9b      	ldrb	r3, [r3, #14]
 804838c:	f013 0f20 	tst.w	r3, #32
 8048390:	d038      	beq.n	8048404 <tcp_process+0x3a4>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8048392:	4b6a      	ldr	r3, [pc, #424]	; (804853c <tcp_process+0x4dc>)
 8048394:	7bdb      	ldrb	r3, [r3, #15]
 8048396:	f013 0f10 	tst.w	r3, #16
 804839a:	d004      	beq.n	80483a6 <tcp_process+0x346>
 804839c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 804839e:	4b67      	ldr	r3, [pc, #412]	; (804853c <tcp_process+0x4dc>)
 80483a0:	699b      	ldr	r3, [r3, #24]
 80483a2:	429a      	cmp	r2, r3
 80483a4:	d007      	beq.n	80483b6 <tcp_process+0x356>
        tcp_ack_now(pcb);
 80483a6:	7ea3      	ldrb	r3, [r4, #26]
 80483a8:	f043 0302 	orr.w	r3, r3, #2
 80483ac:	76a3      	strb	r3, [r4, #26]
        pcb->state = CLOSING;
 80483ae:	2308      	movs	r3, #8
 80483b0:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 80483b2:	2500      	movs	r5, #0
 80483b4:	e677      	b.n	80480a6 <tcp_process+0x46>
          pcb->unsent == NULL) {
 80483b6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 80483b8:	2b00      	cmp	r3, #0
 80483ba:	d1f4      	bne.n	80483a6 <tcp_process+0x346>
        tcp_ack_now(pcb);
 80483bc:	7ea3      	ldrb	r3, [r4, #26]
 80483be:	f043 0302 	orr.w	r3, r3, #2
 80483c2:	76a3      	strb	r3, [r4, #26]
        tcp_pcb_purge(pcb);
 80483c4:	4620      	mov	r0, r4
 80483c6:	f7fe f9df 	bl	8046788 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 80483ca:	4b5d      	ldr	r3, [pc, #372]	; (8048540 <tcp_process+0x4e0>)
 80483cc:	681b      	ldr	r3, [r3, #0]
 80483ce:	42a3      	cmp	r3, r4
 80483d0:	d005      	beq.n	80483de <tcp_process+0x37e>
 80483d2:	b153      	cbz	r3, 80483ea <tcp_process+0x38a>
 80483d4:	68da      	ldr	r2, [r3, #12]
 80483d6:	42a2      	cmp	r2, r4
 80483d8:	d005      	beq.n	80483e6 <tcp_process+0x386>
 80483da:	4613      	mov	r3, r2
 80483dc:	e7f9      	b.n	80483d2 <tcp_process+0x372>
 80483de:	68da      	ldr	r2, [r3, #12]
 80483e0:	4b57      	ldr	r3, [pc, #348]	; (8048540 <tcp_process+0x4e0>)
 80483e2:	601a      	str	r2, [r3, #0]
 80483e4:	e001      	b.n	80483ea <tcp_process+0x38a>
 80483e6:	68e2      	ldr	r2, [r4, #12]
 80483e8:	60da      	str	r2, [r3, #12]
 80483ea:	4b56      	ldr	r3, [pc, #344]	; (8048544 <tcp_process+0x4e4>)
 80483ec:	2201      	movs	r2, #1
 80483ee:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
 80483f0:	230a      	movs	r3, #10
 80483f2:	7523      	strb	r3, [r4, #20]
        TCP_REG(&tcp_tw_pcbs, pcb);
 80483f4:	4b54      	ldr	r3, [pc, #336]	; (8048548 <tcp_process+0x4e8>)
 80483f6:	681a      	ldr	r2, [r3, #0]
 80483f8:	60e2      	str	r2, [r4, #12]
 80483fa:	601c      	str	r4, [r3, #0]
 80483fc:	f001 fb52 	bl	8049aa4 <tcp_timer_needed>
  return ERR_OK;
 8048400:	2500      	movs	r5, #0
        TCP_REG(&tcp_tw_pcbs, pcb);
 8048402:	e650      	b.n	80480a6 <tcp_process+0x46>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8048404:	4b4d      	ldr	r3, [pc, #308]	; (804853c <tcp_process+0x4dc>)
 8048406:	7bdb      	ldrb	r3, [r3, #15]
 8048408:	f013 0f10 	tst.w	r3, #16
 804840c:	f000 8090 	beq.w	8048530 <tcp_process+0x4d0>
 8048410:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8048412:	4b4a      	ldr	r3, [pc, #296]	; (804853c <tcp_process+0x4dc>)
 8048414:	699b      	ldr	r3, [r3, #24]
 8048416:	429a      	cmp	r2, r3
 8048418:	d001      	beq.n	804841e <tcp_process+0x3be>
  return ERR_OK;
 804841a:	2500      	movs	r5, #0
 804841c:	e643      	b.n	80480a6 <tcp_process+0x46>
               pcb->unsent == NULL) {
 804841e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
 8048420:	b10b      	cbz	r3, 8048426 <tcp_process+0x3c6>
  return ERR_OK;
 8048422:	2500      	movs	r5, #0
 8048424:	e63f      	b.n	80480a6 <tcp_process+0x46>
      pcb->state = FIN_WAIT_2;
 8048426:	2306      	movs	r3, #6
 8048428:	7523      	strb	r3, [r4, #20]
  return ERR_OK;
 804842a:	2500      	movs	r5, #0
 804842c:	e63b      	b.n	80480a6 <tcp_process+0x46>
    tcp_receive(pcb);
 804842e:	4620      	mov	r0, r4
 8048430:	f7ff f932 	bl	8047698 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8048434:	4b41      	ldr	r3, [pc, #260]	; (804853c <tcp_process+0x4dc>)
 8048436:	7b9b      	ldrb	r3, [r3, #14]
 8048438:	f013 0f20 	tst.w	r3, #32
 804843c:	d101      	bne.n	8048442 <tcp_process+0x3e2>
  return ERR_OK;
 804843e:	2500      	movs	r5, #0
 8048440:	e631      	b.n	80480a6 <tcp_process+0x46>
      tcp_ack_now(pcb);
 8048442:	7ea3      	ldrb	r3, [r4, #26]
 8048444:	f043 0302 	orr.w	r3, r3, #2
 8048448:	76a3      	strb	r3, [r4, #26]
      tcp_pcb_purge(pcb);
 804844a:	4620      	mov	r0, r4
 804844c:	f7fe f99c 	bl	8046788 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8048450:	4b3b      	ldr	r3, [pc, #236]	; (8048540 <tcp_process+0x4e0>)
 8048452:	681b      	ldr	r3, [r3, #0]
 8048454:	42a3      	cmp	r3, r4
 8048456:	d005      	beq.n	8048464 <tcp_process+0x404>
 8048458:	b153      	cbz	r3, 8048470 <tcp_process+0x410>
 804845a:	68da      	ldr	r2, [r3, #12]
 804845c:	42a2      	cmp	r2, r4
 804845e:	d005      	beq.n	804846c <tcp_process+0x40c>
 8048460:	4613      	mov	r3, r2
 8048462:	e7f9      	b.n	8048458 <tcp_process+0x3f8>
 8048464:	68da      	ldr	r2, [r3, #12]
 8048466:	4b36      	ldr	r3, [pc, #216]	; (8048540 <tcp_process+0x4e0>)
 8048468:	601a      	str	r2, [r3, #0]
 804846a:	e001      	b.n	8048470 <tcp_process+0x410>
 804846c:	68e2      	ldr	r2, [r4, #12]
 804846e:	60da      	str	r2, [r3, #12]
 8048470:	4b34      	ldr	r3, [pc, #208]	; (8048544 <tcp_process+0x4e4>)
 8048472:	2201      	movs	r2, #1
 8048474:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 8048476:	230a      	movs	r3, #10
 8048478:	7523      	strb	r3, [r4, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
 804847a:	4b33      	ldr	r3, [pc, #204]	; (8048548 <tcp_process+0x4e8>)
 804847c:	681a      	ldr	r2, [r3, #0]
 804847e:	60e2      	str	r2, [r4, #12]
 8048480:	601c      	str	r4, [r3, #0]
 8048482:	f001 fb0f 	bl	8049aa4 <tcp_timer_needed>
  return ERR_OK;
 8048486:	2500      	movs	r5, #0
 8048488:	e60d      	b.n	80480a6 <tcp_process+0x46>
    tcp_receive(pcb);
 804848a:	4620      	mov	r0, r4
 804848c:	f7ff f904 	bl	8047698 <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 8048490:	4b2a      	ldr	r3, [pc, #168]	; (804853c <tcp_process+0x4dc>)
 8048492:	7bdb      	ldrb	r3, [r3, #15]
 8048494:	f013 0f10 	tst.w	r3, #16
 8048498:	d04c      	beq.n	8048534 <tcp_process+0x4d4>
 804849a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 804849c:	4b27      	ldr	r3, [pc, #156]	; (804853c <tcp_process+0x4dc>)
 804849e:	699b      	ldr	r3, [r3, #24]
 80484a0:	429a      	cmp	r2, r3
 80484a2:	d001      	beq.n	80484a8 <tcp_process+0x448>
  return ERR_OK;
 80484a4:	2500      	movs	r5, #0
 80484a6:	e5fe      	b.n	80480a6 <tcp_process+0x46>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 80484a8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80484aa:	b10b      	cbz	r3, 80484b0 <tcp_process+0x450>
  return ERR_OK;
 80484ac:	2500      	movs	r5, #0
 80484ae:	e5fa      	b.n	80480a6 <tcp_process+0x46>
      tcp_pcb_purge(pcb);
 80484b0:	4620      	mov	r0, r4
 80484b2:	f7fe f969 	bl	8046788 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 80484b6:	4b22      	ldr	r3, [pc, #136]	; (8048540 <tcp_process+0x4e0>)
 80484b8:	681b      	ldr	r3, [r3, #0]
 80484ba:	42a3      	cmp	r3, r4
 80484bc:	d005      	beq.n	80484ca <tcp_process+0x46a>
 80484be:	b153      	cbz	r3, 80484d6 <tcp_process+0x476>
 80484c0:	68da      	ldr	r2, [r3, #12]
 80484c2:	42a2      	cmp	r2, r4
 80484c4:	d005      	beq.n	80484d2 <tcp_process+0x472>
 80484c6:	4613      	mov	r3, r2
 80484c8:	e7f9      	b.n	80484be <tcp_process+0x45e>
 80484ca:	68da      	ldr	r2, [r3, #12]
 80484cc:	4b1c      	ldr	r3, [pc, #112]	; (8048540 <tcp_process+0x4e0>)
 80484ce:	601a      	str	r2, [r3, #0]
 80484d0:	e001      	b.n	80484d6 <tcp_process+0x476>
 80484d2:	68e2      	ldr	r2, [r4, #12]
 80484d4:	60da      	str	r2, [r3, #12]
 80484d6:	4b1b      	ldr	r3, [pc, #108]	; (8048544 <tcp_process+0x4e4>)
 80484d8:	2201      	movs	r2, #1
 80484da:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
 80484dc:	230a      	movs	r3, #10
 80484de:	7523      	strb	r3, [r4, #20]
      TCP_REG(&tcp_tw_pcbs, pcb);
 80484e0:	4b19      	ldr	r3, [pc, #100]	; (8048548 <tcp_process+0x4e8>)
 80484e2:	681a      	ldr	r2, [r3, #0]
 80484e4:	60e2      	str	r2, [r4, #12]
 80484e6:	601c      	str	r4, [r3, #0]
 80484e8:	f001 fadc 	bl	8049aa4 <tcp_timer_needed>
  return ERR_OK;
 80484ec:	2500      	movs	r5, #0
 80484ee:	e5da      	b.n	80480a6 <tcp_process+0x46>
    tcp_receive(pcb);
 80484f0:	4620      	mov	r0, r4
 80484f2:	f7ff f8d1 	bl	8047698 <tcp_receive>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 80484f6:	4b11      	ldr	r3, [pc, #68]	; (804853c <tcp_process+0x4dc>)
 80484f8:	7bdb      	ldrb	r3, [r3, #15]
 80484fa:	f013 0f10 	tst.w	r3, #16
 80484fe:	d01b      	beq.n	8048538 <tcp_process+0x4d8>
 8048500:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8048502:	4b0e      	ldr	r3, [pc, #56]	; (804853c <tcp_process+0x4dc>)
 8048504:	699b      	ldr	r3, [r3, #24]
 8048506:	429a      	cmp	r2, r3
 8048508:	d001      	beq.n	804850e <tcp_process+0x4ae>
  return ERR_OK;
 804850a:	2500      	movs	r5, #0
 804850c:	e5cb      	b.n	80480a6 <tcp_process+0x46>
    if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
 804850e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8048510:	b10b      	cbz	r3, 8048516 <tcp_process+0x4b6>
  return ERR_OK;
 8048512:	2500      	movs	r5, #0
 8048514:	e5c7      	b.n	80480a6 <tcp_process+0x46>
      recv_flags |= TF_CLOSED;
 8048516:	4a09      	ldr	r2, [pc, #36]	; (804853c <tcp_process+0x4dc>)
 8048518:	7b93      	ldrb	r3, [r2, #14]
 804851a:	f043 0310 	orr.w	r3, r3, #16
 804851e:	7393      	strb	r3, [r2, #14]
  return ERR_OK;
 8048520:	2500      	movs	r5, #0
 8048522:	e5c0      	b.n	80480a6 <tcp_process+0x46>
  switch (pcb->state) {
 8048524:	2500      	movs	r5, #0
 8048526:	e5be      	b.n	80480a6 <tcp_process+0x46>
  return ERR_OK;
 8048528:	2500      	movs	r5, #0
 804852a:	e5bc      	b.n	80480a6 <tcp_process+0x46>
 804852c:	2500      	movs	r5, #0
 804852e:	e5ba      	b.n	80480a6 <tcp_process+0x46>
 8048530:	2500      	movs	r5, #0
 8048532:	e5b8      	b.n	80480a6 <tcp_process+0x46>
 8048534:	2500      	movs	r5, #0
 8048536:	e5b6      	b.n	80480a6 <tcp_process+0x46>
 8048538:	2500      	movs	r5, #0
 804853a:	e5b4      	b.n	80480a6 <tcp_process+0x46>
 804853c:	200042cc 	.word	0x200042cc
 8048540:	2000899c 	.word	0x2000899c
 8048544:	20008998 	.word	0x20008998
 8048548:	200089ac 	.word	0x200089ac

0804854c <tcp_input>:
{
 804854c:	b5f0      	push	{r4, r5, r6, r7, lr}
 804854e:	b083      	sub	sp, #12
 8048550:	4605      	mov	r5, r0
  tcphdr = (struct tcp_hdr *)p->payload;
 8048552:	6842      	ldr	r2, [r0, #4]
 8048554:	4b62      	ldr	r3, [pc, #392]	; (80486e0 <tcp_input+0x194>)
 8048556:	609a      	str	r2, [r3, #8]
  if (p->len < TCP_HLEN) {
 8048558:	8943      	ldrh	r3, [r0, #10]
 804855a:	2b13      	cmp	r3, #19
 804855c:	d804      	bhi.n	8048568 <tcp_input+0x1c>
  pbuf_free(p);
 804855e:	4628      	mov	r0, r5
 8048560:	f7fd fb9a 	bl	8045c98 <pbuf_free>
}
 8048564:	b003      	add	sp, #12
 8048566:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 8048568:	4b5e      	ldr	r3, [pc, #376]	; (80486e4 <tcp_input+0x198>)
 804856a:	6819      	ldr	r1, [r3, #0]
 804856c:	6958      	ldr	r0, [r3, #20]
 804856e:	f002 fb3a 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 8048572:	2800      	cmp	r0, #0
 8048574:	d1f3      	bne.n	804855e <tcp_input+0x12>
      ip_addr_ismulticast(ip_current_dest_addr())) {
 8048576:	4b5b      	ldr	r3, [pc, #364]	; (80486e4 <tcp_input+0x198>)
 8048578:	695b      	ldr	r3, [r3, #20]
 804857a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
 804857e:	2be0      	cmp	r3, #224	; 0xe0
 8048580:	d0ed      	beq.n	804855e <tcp_input+0x12>
  hdrlen_bytes = TCPH_HDRLEN(tcphdr) * 4;
 8048582:	4b57      	ldr	r3, [pc, #348]	; (80486e0 <tcp_input+0x194>)
 8048584:	689b      	ldr	r3, [r3, #8]
 8048586:	8998      	ldrh	r0, [r3, #12]
 8048588:	f7fc ff50 	bl	804542c <lwip_htons>
 804858c:	f3c0 310f 	ubfx	r1, r0, #12, #16
 8048590:	0089      	lsls	r1, r1, #2
 8048592:	b2c9      	uxtb	r1, r1
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
 8048594:	2913      	cmp	r1, #19
 8048596:	d9e2      	bls.n	804855e <tcp_input+0x12>
 8048598:	b289      	uxth	r1, r1
 804859a:	892b      	ldrh	r3, [r5, #8]
 804859c:	4299      	cmp	r1, r3
 804859e:	d8de      	bhi.n	804855e <tcp_input+0x12>
  tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
 80485a0:	f1a1 0314 	sub.w	r3, r1, #20
 80485a4:	b29b      	uxth	r3, r3
 80485a6:	4a4e      	ldr	r2, [pc, #312]	; (80486e0 <tcp_input+0x194>)
 80485a8:	8193      	strh	r3, [r2, #12]
  tcphdr_opt2 = NULL;
 80485aa:	2000      	movs	r0, #0
 80485ac:	6010      	str	r0, [r2, #0]
  if (p->len >= hdrlen_bytes) {
 80485ae:	896a      	ldrh	r2, [r5, #10]
 80485b0:	4291      	cmp	r1, r2
 80485b2:	d930      	bls.n	8048616 <tcp_input+0xca>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 80485b4:	682b      	ldr	r3, [r5, #0]
 80485b6:	2b00      	cmp	r3, #0
 80485b8:	d061      	beq.n	804867e <tcp_input+0x132>
    pbuf_header(p, -TCP_HLEN);
 80485ba:	f06f 0113 	mvn.w	r1, #19
 80485be:	4628      	mov	r0, r5
 80485c0:	f7fd fb60 	bl	8045c84 <pbuf_header>
    tcphdr_opt1len = p->len;
 80485c4:	896c      	ldrh	r4, [r5, #10]
 80485c6:	4b46      	ldr	r3, [pc, #280]	; (80486e0 <tcp_input+0x194>)
 80485c8:	80dc      	strh	r4, [r3, #6]
    opt2len = tcphdr_optlen - tcphdr_opt1len;
 80485ca:	899f      	ldrh	r7, [r3, #12]
 80485cc:	1b3e      	subs	r6, r7, r4
 80485ce:	b2b6      	uxth	r6, r6
    pbuf_header(p, -(s16_t)tcphdr_opt1len);
 80485d0:	4261      	negs	r1, r4
 80485d2:	b209      	sxth	r1, r1
 80485d4:	4628      	mov	r0, r5
 80485d6:	f7fd fb55 	bl	8045c84 <pbuf_header>
    if (opt2len > p->next->len) {
 80485da:	6828      	ldr	r0, [r5, #0]
 80485dc:	8943      	ldrh	r3, [r0, #10]
 80485de:	42b3      	cmp	r3, r6
 80485e0:	d3bd      	bcc.n	804855e <tcp_input+0x12>
    tcphdr_opt2 = (u8_t*)p->next->payload;
 80485e2:	6842      	ldr	r2, [r0, #4]
 80485e4:	4b3e      	ldr	r3, [pc, #248]	; (80486e0 <tcp_input+0x194>)
 80485e6:	601a      	str	r2, [r3, #0]
    pbuf_header(p->next, -(s16_t)opt2len);
 80485e8:	1be1      	subs	r1, r4, r7
 80485ea:	b28c      	uxth	r4, r1
 80485ec:	b209      	sxth	r1, r1
 80485ee:	f7fd fb49 	bl	8045c84 <pbuf_header>
    p->tot_len -= opt2len;
 80485f2:	892b      	ldrh	r3, [r5, #8]
 80485f4:	441c      	add	r4, r3
 80485f6:	812c      	strh	r4, [r5, #8]
    LWIP_ASSERT("p->len == 0", p->len == 0);
 80485f8:	896b      	ldrh	r3, [r5, #10]
 80485fa:	2b00      	cmp	r3, #0
 80485fc:	d146      	bne.n	804868c <tcp_input+0x140>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
 80485fe:	892a      	ldrh	r2, [r5, #8]
 8048600:	682b      	ldr	r3, [r5, #0]
 8048602:	891b      	ldrh	r3, [r3, #8]
 8048604:	429a      	cmp	r2, r3
 8048606:	d00c      	beq.n	8048622 <tcp_input+0xd6>
 8048608:	4b37      	ldr	r3, [pc, #220]	; (80486e8 <tcp_input+0x19c>)
 804860a:	22d0      	movs	r2, #208	; 0xd0
 804860c:	4937      	ldr	r1, [pc, #220]	; (80486ec <tcp_input+0x1a0>)
 804860e:	4838      	ldr	r0, [pc, #224]	; (80486f0 <tcp_input+0x1a4>)
 8048610:	f008 fdec 	bl	80511ec <printf>
 8048614:	e005      	b.n	8048622 <tcp_input+0xd6>
    tcphdr_opt1len = tcphdr_optlen;
 8048616:	4a32      	ldr	r2, [pc, #200]	; (80486e0 <tcp_input+0x194>)
 8048618:	80d3      	strh	r3, [r2, #6]
    pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
 804861a:	4249      	negs	r1, r1
 804861c:	4628      	mov	r0, r5
 804861e:	f7fd fb31 	bl	8045c84 <pbuf_header>
  tcphdr->src = lwip_ntohs(tcphdr->src);
 8048622:	4c2f      	ldr	r4, [pc, #188]	; (80486e0 <tcp_input+0x194>)
 8048624:	68a6      	ldr	r6, [r4, #8]
 8048626:	8830      	ldrh	r0, [r6, #0]
 8048628:	f7fc ff00 	bl	804542c <lwip_htons>
 804862c:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
 804862e:	68a6      	ldr	r6, [r4, #8]
 8048630:	8870      	ldrh	r0, [r6, #2]
 8048632:	f7fc fefb 	bl	804542c <lwip_htons>
 8048636:	8070      	strh	r0, [r6, #2]
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
 8048638:	68a6      	ldr	r6, [r4, #8]
 804863a:	6870      	ldr	r0, [r6, #4]
 804863c:	f7fc fef9 	bl	8045432 <lwip_htonl>
 8048640:	6070      	str	r0, [r6, #4]
 8048642:	6120      	str	r0, [r4, #16]
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
 8048644:	68a6      	ldr	r6, [r4, #8]
 8048646:	68b0      	ldr	r0, [r6, #8]
 8048648:	f7fc fef3 	bl	8045432 <lwip_htonl>
 804864c:	60b0      	str	r0, [r6, #8]
 804864e:	61a0      	str	r0, [r4, #24]
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
 8048650:	68a6      	ldr	r6, [r4, #8]
 8048652:	89f0      	ldrh	r0, [r6, #14]
 8048654:	f7fc feea 	bl	804542c <lwip_htons>
 8048658:	81f0      	strh	r0, [r6, #14]
  flags = TCPH_FLAGS(tcphdr);
 804865a:	68a3      	ldr	r3, [r4, #8]
 804865c:	8998      	ldrh	r0, [r3, #12]
 804865e:	f7fc fee5 	bl	804542c <lwip_htons>
 8048662:	f000 033f 	and.w	r3, r0, #63	; 0x3f
 8048666:	73e3      	strb	r3, [r4, #15]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8048668:	892a      	ldrh	r2, [r5, #8]
 804866a:	f013 0303 	ands.w	r3, r3, #3
 804866e:	bf18      	it	ne
 8048670:	2301      	movne	r3, #1
 8048672:	4413      	add	r3, r2
 8048674:	82a3      	strh	r3, [r4, #20]
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8048676:	4b1f      	ldr	r3, [pc, #124]	; (80486f4 <tcp_input+0x1a8>)
 8048678:	681c      	ldr	r4, [r3, #0]
  prev = NULL;
 804867a:	2600      	movs	r6, #0
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 804867c:	e04c      	b.n	8048718 <tcp_input+0x1cc>
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
 804867e:	4b1a      	ldr	r3, [pc, #104]	; (80486e8 <tcp_input+0x19c>)
 8048680:	22b2      	movs	r2, #178	; 0xb2
 8048682:	491d      	ldr	r1, [pc, #116]	; (80486f8 <tcp_input+0x1ac>)
 8048684:	481a      	ldr	r0, [pc, #104]	; (80486f0 <tcp_input+0x1a4>)
 8048686:	f008 fdb1 	bl	80511ec <printf>
 804868a:	e796      	b.n	80485ba <tcp_input+0x6e>
    LWIP_ASSERT("p->len == 0", p->len == 0);
 804868c:	4b16      	ldr	r3, [pc, #88]	; (80486e8 <tcp_input+0x19c>)
 804868e:	22cf      	movs	r2, #207	; 0xcf
 8048690:	491a      	ldr	r1, [pc, #104]	; (80486fc <tcp_input+0x1b0>)
 8048692:	4817      	ldr	r0, [pc, #92]	; (80486f0 <tcp_input+0x1a4>)
 8048694:	f008 fdaa 	bl	80511ec <printf>
 8048698:	e7b1      	b.n	80485fe <tcp_input+0xb2>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 804869a:	4b13      	ldr	r3, [pc, #76]	; (80486e8 <tcp_input+0x19c>)
 804869c:	22e2      	movs	r2, #226	; 0xe2
 804869e:	4918      	ldr	r1, [pc, #96]	; (8048700 <tcp_input+0x1b4>)
 80486a0:	4813      	ldr	r0, [pc, #76]	; (80486f0 <tcp_input+0x1a4>)
 80486a2:	f008 fda3 	bl	80511ec <printf>
 80486a6:	e03c      	b.n	8048722 <tcp_input+0x1d6>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 80486a8:	4b0f      	ldr	r3, [pc, #60]	; (80486e8 <tcp_input+0x19c>)
 80486aa:	22e3      	movs	r2, #227	; 0xe3
 80486ac:	4915      	ldr	r1, [pc, #84]	; (8048704 <tcp_input+0x1b8>)
 80486ae:	4810      	ldr	r0, [pc, #64]	; (80486f0 <tcp_input+0x1a4>)
 80486b0:	f008 fd9c 	bl	80511ec <printf>
 80486b4:	e038      	b.n	8048728 <tcp_input+0x1dc>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 80486b6:	4b0c      	ldr	r3, [pc, #48]	; (80486e8 <tcp_input+0x19c>)
 80486b8:	22e4      	movs	r2, #228	; 0xe4
 80486ba:	4913      	ldr	r1, [pc, #76]	; (8048708 <tcp_input+0x1bc>)
 80486bc:	480c      	ldr	r0, [pc, #48]	; (80486f0 <tcp_input+0x1a4>)
 80486be:	f008 fd95 	bl	80511ec <printf>
 80486c2:	e034      	b.n	804872e <tcp_input+0x1e2>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 80486c4:	4b08      	ldr	r3, [pc, #32]	; (80486e8 <tcp_input+0x19c>)
 80486c6:	22ec      	movs	r2, #236	; 0xec
 80486c8:	4910      	ldr	r1, [pc, #64]	; (804870c <tcp_input+0x1c0>)
 80486ca:	4809      	ldr	r0, [pc, #36]	; (80486f0 <tcp_input+0x1a4>)
 80486cc:	f008 fd8e 	bl	80511ec <printf>
 80486d0:	e044      	b.n	804875c <tcp_input+0x210>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 80486d2:	4b05      	ldr	r3, [pc, #20]	; (80486e8 <tcp_input+0x19c>)
 80486d4:	22f4      	movs	r2, #244	; 0xf4
 80486d6:	490e      	ldr	r1, [pc, #56]	; (8048710 <tcp_input+0x1c4>)
 80486d8:	4805      	ldr	r0, [pc, #20]	; (80486f0 <tcp_input+0x1a4>)
 80486da:	f008 fd87 	bl	80511ec <printf>
 80486de:	e047      	b.n	8048770 <tcp_input+0x224>
 80486e0:	200042cc 	.word	0x200042cc
 80486e4:	2000546c 	.word	0x2000546c
 80486e8:	080591d4 	.word	0x080591d4
 80486ec:	080593f4 	.word	0x080593f4
 80486f0:	08058644 	.word	0x08058644
 80486f4:	2000899c 	.word	0x2000899c
 80486f8:	080593d8 	.word	0x080593d8
 80486fc:	080593e8 	.word	0x080593e8
 8048700:	08059414 	.word	0x08059414
 8048704:	0805943c 	.word	0x0805943c
 8048708:	08059468 	.word	0x08059468
 804870c:	08059490 	.word	0x08059490
 8048710:	080594bc 	.word	0x080594bc
    prev = pcb;
 8048714:	4626      	mov	r6, r4
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8048716:	68e4      	ldr	r4, [r4, #12]
 8048718:	2c00      	cmp	r4, #0
 804871a:	d029      	beq.n	8048770 <tcp_input+0x224>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 804871c:	7d23      	ldrb	r3, [r4, #20]
 804871e:	2b00      	cmp	r3, #0
 8048720:	d0bb      	beq.n	804869a <tcp_input+0x14e>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 8048722:	7d23      	ldrb	r3, [r4, #20]
 8048724:	2b0a      	cmp	r3, #10
 8048726:	d0bf      	beq.n	80486a8 <tcp_input+0x15c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 8048728:	7d23      	ldrb	r3, [r4, #20]
 804872a:	2b01      	cmp	r3, #1
 804872c:	d0c3      	beq.n	80486b6 <tcp_input+0x16a>
    if (pcb->remote_port == tcphdr->src &&
 804872e:	8b21      	ldrh	r1, [r4, #24]
 8048730:	4b92      	ldr	r3, [pc, #584]	; (804897c <tcp_input+0x430>)
 8048732:	689b      	ldr	r3, [r3, #8]
 8048734:	881a      	ldrh	r2, [r3, #0]
 8048736:	4291      	cmp	r1, r2
 8048738:	d1ec      	bne.n	8048714 <tcp_input+0x1c8>
        pcb->local_port == tcphdr->dest &&
 804873a:	8ae2      	ldrh	r2, [r4, #22]
 804873c:	885b      	ldrh	r3, [r3, #2]
    if (pcb->remote_port == tcphdr->src &&
 804873e:	429a      	cmp	r2, r3
 8048740:	d1e8      	bne.n	8048714 <tcp_input+0x1c8>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048742:	6862      	ldr	r2, [r4, #4]
 8048744:	4b8e      	ldr	r3, [pc, #568]	; (8048980 <tcp_input+0x434>)
 8048746:	691b      	ldr	r3, [r3, #16]
        pcb->local_port == tcphdr->dest &&
 8048748:	429a      	cmp	r2, r3
 804874a:	d1e3      	bne.n	8048714 <tcp_input+0x1c8>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 804874c:	6822      	ldr	r2, [r4, #0]
 804874e:	4b8c      	ldr	r3, [pc, #560]	; (8048980 <tcp_input+0x434>)
 8048750:	695b      	ldr	r3, [r3, #20]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048752:	429a      	cmp	r2, r3
 8048754:	d1de      	bne.n	8048714 <tcp_input+0x1c8>
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8048756:	68e3      	ldr	r3, [r4, #12]
 8048758:	42a3      	cmp	r3, r4
 804875a:	d0b3      	beq.n	80486c4 <tcp_input+0x178>
      if (prev != NULL) {
 804875c:	b12e      	cbz	r6, 804876a <tcp_input+0x21e>
        prev->next = pcb->next;
 804875e:	68e3      	ldr	r3, [r4, #12]
 8048760:	60f3      	str	r3, [r6, #12]
        pcb->next = tcp_active_pcbs;
 8048762:	4b88      	ldr	r3, [pc, #544]	; (8048984 <tcp_input+0x438>)
 8048764:	681a      	ldr	r2, [r3, #0]
 8048766:	60e2      	str	r2, [r4, #12]
        tcp_active_pcbs = pcb;
 8048768:	601c      	str	r4, [r3, #0]
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 804876a:	68e3      	ldr	r3, [r4, #12]
 804876c:	42a3      	cmp	r3, r4
 804876e:	d0b0      	beq.n	80486d2 <tcp_input+0x186>
  if (pcb == NULL) {
 8048770:	2c00      	cmp	r4, #0
 8048772:	d04e      	beq.n	8048812 <tcp_input+0x2c6>
  if (pcb != NULL) {
 8048774:	2c00      	cmp	r4, #0
 8048776:	f000 8128 	beq.w	80489ca <tcp_input+0x47e>
    inseg.next = NULL;
 804877a:	4b80      	ldr	r3, [pc, #512]	; (804897c <tcp_input+0x430>)
 804877c:	2200      	movs	r2, #0
 804877e:	621a      	str	r2, [r3, #32]
    inseg.len = p->tot_len;
 8048780:	8929      	ldrh	r1, [r5, #8]
 8048782:	8519      	strh	r1, [r3, #40]	; 0x28
    inseg.p = p;
 8048784:	625d      	str	r5, [r3, #36]	; 0x24
    inseg.tcphdr = tcphdr;
 8048786:	6899      	ldr	r1, [r3, #8]
 8048788:	62d9      	str	r1, [r3, #44]	; 0x2c
    recv_data = NULL;
 804878a:	631a      	str	r2, [r3, #48]	; 0x30
    recv_flags = 0;
 804878c:	739a      	strb	r2, [r3, #14]
    recv_acked = 0;
 804878e:	839a      	strh	r2, [r3, #28]
    if (flags & TCP_PSH) {
 8048790:	7bdb      	ldrb	r3, [r3, #15]
 8048792:	f013 0f08 	tst.w	r3, #8
 8048796:	d003      	beq.n	80487a0 <tcp_input+0x254>
      p->flags |= PBUF_FLAG_PUSH;
 8048798:	7b6b      	ldrb	r3, [r5, #13]
 804879a:	f043 0301 	orr.w	r3, r3, #1
 804879e:	736b      	strb	r3, [r5, #13]
    if (pcb->refused_data != NULL) {
 80487a0:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80487a2:	b15b      	cbz	r3, 80487bc <tcp_input+0x270>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 80487a4:	4620      	mov	r0, r4
 80487a6:	f7fe fb2f 	bl	8046e08 <tcp_process_refused_data>
 80487aa:	f110 0f0d 	cmn.w	r0, #13
 80487ae:	d07f      	beq.n	80488b0 <tcp_input+0x364>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 80487b0:	6f63      	ldr	r3, [r4, #116]	; 0x74
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 80487b2:	b11b      	cbz	r3, 80487bc <tcp_input+0x270>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 80487b4:	4b71      	ldr	r3, [pc, #452]	; (804897c <tcp_input+0x430>)
 80487b6:	8a9b      	ldrh	r3, [r3, #20]
 80487b8:	2b00      	cmp	r3, #0
 80487ba:	d179      	bne.n	80488b0 <tcp_input+0x364>
    tcp_input_pcb = pcb;
 80487bc:	4b72      	ldr	r3, [pc, #456]	; (8048988 <tcp_input+0x43c>)
 80487be:	601c      	str	r4, [r3, #0]
    err = tcp_process(pcb);
 80487c0:	4620      	mov	r0, r4
 80487c2:	f7ff fc4d 	bl	8048060 <tcp_process>
    if (err != ERR_ABRT) {
 80487c6:	f110 0f0d 	cmn.w	r0, #13
 80487ca:	d013      	beq.n	80487f4 <tcp_input+0x2a8>
      if (recv_flags & TF_RESET) {
 80487cc:	4b6b      	ldr	r3, [pc, #428]	; (804897c <tcp_input+0x430>)
 80487ce:	7b9b      	ldrb	r3, [r3, #14]
 80487d0:	f013 0f08 	tst.w	r3, #8
 80487d4:	d073      	beq.n	80488be <tcp_input+0x372>
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
 80487d6:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80487da:	b11b      	cbz	r3, 80487e4 <tcp_input+0x298>
 80487dc:	f06f 010d 	mvn.w	r1, #13
 80487e0:	6920      	ldr	r0, [r4, #16]
 80487e2:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 80487e4:	4621      	mov	r1, r4
 80487e6:	4867      	ldr	r0, [pc, #412]	; (8048984 <tcp_input+0x438>)
 80487e8:	f7fe f9f6 	bl	8046bd8 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 80487ec:	4621      	mov	r1, r4
 80487ee:	2001      	movs	r0, #1
 80487f0:	f7fd f89e 	bl	8045930 <memp_free>
    tcp_input_pcb = NULL;
 80487f4:	2200      	movs	r2, #0
 80487f6:	4b64      	ldr	r3, [pc, #400]	; (8048988 <tcp_input+0x43c>)
 80487f8:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
 80487fa:	4b60      	ldr	r3, [pc, #384]	; (804897c <tcp_input+0x430>)
 80487fc:	631a      	str	r2, [r3, #48]	; 0x30
    if (inseg.p != NULL)
 80487fe:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8048800:	2800      	cmp	r0, #0
 8048802:	f43f aeaf 	beq.w	8048564 <tcp_input+0x18>
      pbuf_free(inseg.p);
 8048806:	f7fd fa47 	bl	8045c98 <pbuf_free>
      inseg.p = NULL;
 804880a:	4b5c      	ldr	r3, [pc, #368]	; (804897c <tcp_input+0x430>)
 804880c:	2200      	movs	r2, #0
 804880e:	625a      	str	r2, [r3, #36]	; 0x24
 8048810:	e6a8      	b.n	8048564 <tcp_input+0x18>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8048812:	4b5e      	ldr	r3, [pc, #376]	; (804898c <tcp_input+0x440>)
 8048814:	681c      	ldr	r4, [r3, #0]
 8048816:	e00c      	b.n	8048832 <tcp_input+0x2e6>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8048818:	4b5d      	ldr	r3, [pc, #372]	; (8048990 <tcp_input+0x444>)
 804881a:	22fe      	movs	r2, #254	; 0xfe
 804881c:	495d      	ldr	r1, [pc, #372]	; (8048994 <tcp_input+0x448>)
 804881e:	485e      	ldr	r0, [pc, #376]	; (8048998 <tcp_input+0x44c>)
 8048820:	f008 fce4 	bl	80511ec <printf>
      if (pcb->remote_port == tcphdr->src &&
 8048824:	8b21      	ldrh	r1, [r4, #24]
 8048826:	4b55      	ldr	r3, [pc, #340]	; (804897c <tcp_input+0x430>)
 8048828:	689b      	ldr	r3, [r3, #8]
 804882a:	881a      	ldrh	r2, [r3, #0]
 804882c:	4291      	cmp	r1, r2
 804882e:	d005      	beq.n	804883c <tcp_input+0x2f0>
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8048830:	68e4      	ldr	r4, [r4, #12]
 8048832:	b1c4      	cbz	r4, 8048866 <tcp_input+0x31a>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8048834:	7d23      	ldrb	r3, [r4, #20]
 8048836:	2b0a      	cmp	r3, #10
 8048838:	d0f4      	beq.n	8048824 <tcp_input+0x2d8>
 804883a:	e7ed      	b.n	8048818 <tcp_input+0x2cc>
          pcb->local_port == tcphdr->dest &&
 804883c:	8ae2      	ldrh	r2, [r4, #22]
 804883e:	885b      	ldrh	r3, [r3, #2]
      if (pcb->remote_port == tcphdr->src &&
 8048840:	429a      	cmp	r2, r3
 8048842:	d1f5      	bne.n	8048830 <tcp_input+0x2e4>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048844:	6862      	ldr	r2, [r4, #4]
 8048846:	4b4e      	ldr	r3, [pc, #312]	; (8048980 <tcp_input+0x434>)
 8048848:	691b      	ldr	r3, [r3, #16]
          pcb->local_port == tcphdr->dest &&
 804884a:	429a      	cmp	r2, r3
 804884c:	d1f0      	bne.n	8048830 <tcp_input+0x2e4>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 804884e:	6822      	ldr	r2, [r4, #0]
 8048850:	4b4b      	ldr	r3, [pc, #300]	; (8048980 <tcp_input+0x434>)
 8048852:	695b      	ldr	r3, [r3, #20]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
 8048854:	429a      	cmp	r2, r3
 8048856:	d1eb      	bne.n	8048830 <tcp_input+0x2e4>
        tcp_timewait_input(pcb);
 8048858:	4620      	mov	r0, r4
 804885a:	f7fe fe1b 	bl	8047494 <tcp_timewait_input>
        pbuf_free(p);
 804885e:	4628      	mov	r0, r5
 8048860:	f7fd fa1a 	bl	8045c98 <pbuf_free>
        return;
 8048864:	e67e      	b.n	8048564 <tcp_input+0x18>
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8048866:	4b4d      	ldr	r3, [pc, #308]	; (804899c <tcp_input+0x450>)
 8048868:	681e      	ldr	r6, [r3, #0]
 804886a:	4630      	mov	r0, r6
    prev = NULL;
 804886c:	4621      	mov	r1, r4
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 804886e:	e001      	b.n	8048874 <tcp_input+0x328>
      prev = (struct tcp_pcb *)lpcb;
 8048870:	4601      	mov	r1, r0
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8048872:	68c0      	ldr	r0, [r0, #12]
 8048874:	b168      	cbz	r0, 8048892 <tcp_input+0x346>
      if (lpcb->local_port == tcphdr->dest) {
 8048876:	8ac2      	ldrh	r2, [r0, #22]
 8048878:	4b40      	ldr	r3, [pc, #256]	; (804897c <tcp_input+0x430>)
 804887a:	689b      	ldr	r3, [r3, #8]
 804887c:	885b      	ldrh	r3, [r3, #2]
 804887e:	429a      	cmp	r2, r3
 8048880:	d1f6      	bne.n	8048870 <tcp_input+0x324>
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
 8048882:	6803      	ldr	r3, [r0, #0]
 8048884:	4a3e      	ldr	r2, [pc, #248]	; (8048980 <tcp_input+0x434>)
 8048886:	6952      	ldr	r2, [r2, #20]
 8048888:	4293      	cmp	r3, r2
 804888a:	d002      	beq.n	8048892 <tcp_input+0x346>
          } else if (ip_addr_isany(&lpcb->local_ip)) {
 804888c:	b108      	cbz	r0, 8048892 <tcp_input+0x346>
 804888e:	2b00      	cmp	r3, #0
 8048890:	d1ee      	bne.n	8048870 <tcp_input+0x324>
    if (lpcb != NULL) {
 8048892:	2800      	cmp	r0, #0
 8048894:	f43f af6e 	beq.w	8048774 <tcp_input+0x228>
      if (prev != NULL) {
 8048898:	b121      	cbz	r1, 80488a4 <tcp_input+0x358>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 804889a:	68c3      	ldr	r3, [r0, #12]
 804889c:	60cb      	str	r3, [r1, #12]
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 804889e:	60c6      	str	r6, [r0, #12]
        tcp_listen_pcbs.listen_pcbs = lpcb;
 80488a0:	4b3e      	ldr	r3, [pc, #248]	; (804899c <tcp_input+0x450>)
 80488a2:	6018      	str	r0, [r3, #0]
      tcp_listen_input(lpcb);
 80488a4:	f7fe fe34 	bl	8047510 <tcp_listen_input>
      pbuf_free(p);
 80488a8:	4628      	mov	r0, r5
 80488aa:	f7fd f9f5 	bl	8045c98 <pbuf_free>
      return;
 80488ae:	e659      	b.n	8048564 <tcp_input+0x18>
        if (pcb->rcv_ann_wnd == 0) {
 80488b0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80488b2:	2b00      	cmp	r3, #0
 80488b4:	d19e      	bne.n	80487f4 <tcp_input+0x2a8>
          tcp_send_empty_ack(pcb);
 80488b6:	4620      	mov	r0, r4
 80488b8:	f000 fdc2 	bl	8049440 <tcp_send_empty_ack>
        goto aborted;
 80488bc:	e79a      	b.n	80487f4 <tcp_input+0x2a8>
        if (recv_acked > 0) {
 80488be:	4b2f      	ldr	r3, [pc, #188]	; (804897c <tcp_input+0x430>)
 80488c0:	8b9a      	ldrh	r2, [r3, #28]
 80488c2:	b152      	cbz	r2, 80488da <tcp_input+0x38e>
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
 80488c4:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 80488c6:	b12b      	cbz	r3, 80488d4 <tcp_input+0x388>
 80488c8:	4621      	mov	r1, r4
 80488ca:	6920      	ldr	r0, [r4, #16]
 80488cc:	4798      	blx	r3
            if (err == ERR_ABRT) {
 80488ce:	f110 0f0d 	cmn.w	r0, #13
 80488d2:	d08f      	beq.n	80487f4 <tcp_input+0x2a8>
          recv_acked = 0;
 80488d4:	4b29      	ldr	r3, [pc, #164]	; (804897c <tcp_input+0x430>)
 80488d6:	2200      	movs	r2, #0
 80488d8:	839a      	strh	r2, [r3, #28]
        if (tcp_input_delayed_close(pcb)) {
 80488da:	4620      	mov	r0, r4
 80488dc:	f7fe fdb8 	bl	8047450 <tcp_input_delayed_close>
 80488e0:	2800      	cmp	r0, #0
 80488e2:	d187      	bne.n	80487f4 <tcp_input+0x2a8>
        if (recv_data != NULL) {
 80488e4:	4b25      	ldr	r3, [pc, #148]	; (804897c <tcp_input+0x430>)
 80488e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80488e8:	b1f3      	cbz	r3, 8048928 <tcp_input+0x3dc>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 80488ea:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80488ec:	b133      	cbz	r3, 80488fc <tcp_input+0x3b0>
 80488ee:	4b28      	ldr	r3, [pc, #160]	; (8048990 <tcp_input+0x444>)
 80488f0:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 80488f4:	492a      	ldr	r1, [pc, #168]	; (80489a0 <tcp_input+0x454>)
 80488f6:	4828      	ldr	r0, [pc, #160]	; (8048998 <tcp_input+0x44c>)
 80488f8:	f008 fc78 	bl	80511ec <printf>
          if (pcb->flags & TF_RXCLOSED) {
 80488fc:	7ea3      	ldrb	r3, [r4, #26]
 80488fe:	f013 0f10 	tst.w	r3, #16
 8048902:	d12a      	bne.n	804895a <tcp_input+0x40e>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8048904:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 8048908:	2d00      	cmp	r5, #0
 804890a:	d02e      	beq.n	804896a <tcp_input+0x41e>
 804890c:	2300      	movs	r3, #0
 804890e:	4a1b      	ldr	r2, [pc, #108]	; (804897c <tcp_input+0x430>)
 8048910:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8048912:	4621      	mov	r1, r4
 8048914:	6920      	ldr	r0, [r4, #16]
 8048916:	47a8      	blx	r5
          if (err == ERR_ABRT) {
 8048918:	f110 0f0d 	cmn.w	r0, #13
 804891c:	f43f af6a 	beq.w	80487f4 <tcp_input+0x2a8>
          if (err != ERR_OK) {
 8048920:	b110      	cbz	r0, 8048928 <tcp_input+0x3dc>
            pcb->refused_data = recv_data;
 8048922:	4b16      	ldr	r3, [pc, #88]	; (804897c <tcp_input+0x430>)
 8048924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8048926:	6763      	str	r3, [r4, #116]	; 0x74
        if (recv_flags & TF_GOT_FIN) {
 8048928:	4b14      	ldr	r3, [pc, #80]	; (804897c <tcp_input+0x430>)
 804892a:	7b9b      	ldrb	r3, [r3, #14]
 804892c:	f013 0f20 	tst.w	r3, #32
 8048930:	d006      	beq.n	8048940 <tcp_input+0x3f4>
          if (pcb->refused_data != NULL) {
 8048932:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8048934:	2b00      	cmp	r3, #0
 8048936:	d035      	beq.n	80489a4 <tcp_input+0x458>
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 8048938:	7b5a      	ldrb	r2, [r3, #13]
 804893a:	f042 0220 	orr.w	r2, r2, #32
 804893e:	735a      	strb	r2, [r3, #13]
        tcp_input_pcb = NULL;
 8048940:	4b11      	ldr	r3, [pc, #68]	; (8048988 <tcp_input+0x43c>)
 8048942:	2200      	movs	r2, #0
 8048944:	601a      	str	r2, [r3, #0]
        if (tcp_input_delayed_close(pcb)) {
 8048946:	4620      	mov	r0, r4
 8048948:	f7fe fd82 	bl	8047450 <tcp_input_delayed_close>
 804894c:	2800      	cmp	r0, #0
 804894e:	f47f af51 	bne.w	80487f4 <tcp_input+0x2a8>
        tcp_output(pcb);
 8048952:	4620      	mov	r0, r4
 8048954:	f000 fdae 	bl	80494b4 <tcp_output>
 8048958:	e74c      	b.n	80487f4 <tcp_input+0x2a8>
            pbuf_free(recv_data);
 804895a:	4b08      	ldr	r3, [pc, #32]	; (804897c <tcp_input+0x430>)
 804895c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 804895e:	f7fd f99b 	bl	8045c98 <pbuf_free>
            tcp_abort(pcb);
 8048962:	4620      	mov	r0, r4
 8048964:	f7fe fb54 	bl	8047010 <tcp_abort>
            goto aborted;
 8048968:	e744      	b.n	80487f4 <tcp_input+0x2a8>
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 804896a:	2300      	movs	r3, #0
 804896c:	4a03      	ldr	r2, [pc, #12]	; (804897c <tcp_input+0x430>)
 804896e:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8048970:	4621      	mov	r1, r4
 8048972:	4618      	mov	r0, r3
 8048974:	f7fe fa36 	bl	8046de4 <tcp_recv_null>
 8048978:	e7ce      	b.n	8048918 <tcp_input+0x3cc>
 804897a:	bf00      	nop
 804897c:	200042cc 	.word	0x200042cc
 8048980:	2000546c 	.word	0x2000546c
 8048984:	2000899c 	.word	0x2000899c
 8048988:	200089b0 	.word	0x200089b0
 804898c:	200089ac 	.word	0x200089ac
 8048990:	080591d4 	.word	0x080591d4
 8048994:	080594e8 	.word	0x080594e8
 8048998:	08058644 	.word	0x08058644
 804899c:	200089a4 	.word	0x200089a4
 80489a0:	08059518 	.word	0x08059518
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
 80489a4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 80489a6:	f5b3 6f06 	cmp.w	r3, #2144	; 0x860
 80489aa:	d001      	beq.n	80489b0 <tcp_input+0x464>
              pcb->rcv_wnd++;
 80489ac:	3301      	adds	r3, #1
 80489ae:	8523      	strh	r3, [r4, #40]	; 0x28
            TCP_EVENT_CLOSED(pcb, err);
 80489b0:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 80489b4:	2d00      	cmp	r5, #0
 80489b6:	d0c3      	beq.n	8048940 <tcp_input+0x3f4>
 80489b8:	2300      	movs	r3, #0
 80489ba:	461a      	mov	r2, r3
 80489bc:	4621      	mov	r1, r4
 80489be:	6920      	ldr	r0, [r4, #16]
 80489c0:	47a8      	blx	r5
            if (err == ERR_ABRT) {
 80489c2:	f110 0f0d 	cmn.w	r0, #13
 80489c6:	d1bb      	bne.n	8048940 <tcp_input+0x3f4>
 80489c8:	e714      	b.n	80487f4 <tcp_input+0x2a8>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80489ca:	4b0d      	ldr	r3, [pc, #52]	; (8048a00 <tcp_input+0x4b4>)
 80489cc:	689b      	ldr	r3, [r3, #8]
 80489ce:	8998      	ldrh	r0, [r3, #12]
 80489d0:	f7fc fd2c 	bl	804542c <lwip_htons>
 80489d4:	f010 0f04 	tst.w	r0, #4
 80489d8:	d003      	beq.n	80489e2 <tcp_input+0x496>
    pbuf_free(p);
 80489da:	4628      	mov	r0, r5
 80489dc:	f7fd f95c 	bl	8045c98 <pbuf_free>
 80489e0:	e5c0      	b.n	8048564 <tcp_input+0x18>
        ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 80489e2:	4807      	ldr	r0, [pc, #28]	; (8048a00 <tcp_input+0x4b4>)
 80489e4:	6882      	ldr	r2, [r0, #8]
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 80489e6:	4b07      	ldr	r3, [pc, #28]	; (8048a04 <tcp_input+0x4b8>)
 80489e8:	8a84      	ldrh	r4, [r0, #20]
 80489ea:	6901      	ldr	r1, [r0, #16]
 80489ec:	8816      	ldrh	r6, [r2, #0]
 80489ee:	9601      	str	r6, [sp, #4]
 80489f0:	8852      	ldrh	r2, [r2, #2]
 80489f2:	9200      	str	r2, [sp, #0]
 80489f4:	1d1a      	adds	r2, r3, #4
 80489f6:	4421      	add	r1, r4
 80489f8:	6980      	ldr	r0, [r0, #24]
 80489fa:	f000 fea3 	bl	8049744 <tcp_rst>
 80489fe:	e7ec      	b.n	80489da <tcp_input+0x48e>
 8048a00:	200042cc 	.word	0x200042cc
 8048a04:	2000547c 	.word	0x2000547c

08048a08 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
  recv_flags |= TF_CLOSED;
 8048a08:	4a02      	ldr	r2, [pc, #8]	; (8048a14 <tcp_trigger_input_pcb_close+0xc>)
 8048a0a:	7b93      	ldrb	r3, [r2, #14]
 8048a0c:	f043 0310 	orr.w	r3, r3, #16
 8048a10:	7393      	strb	r3, [r2, #14]
}
 8048a12:	4770      	bx	lr
 8048a14:	200042cc 	.word	0x200042cc

08048a18 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 8048a18:	b508      	push	{r3, lr}
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 8048a1a:	7d03      	ldrb	r3, [r0, #20]
 8048a1c:	2b04      	cmp	r3, #4
 8048a1e:	d005      	beq.n	8048a2c <tcp_write_checks+0x14>
 8048a20:	2b07      	cmp	r3, #7
 8048a22:	d003      	beq.n	8048a2c <tcp_write_checks+0x14>
      (pcb->state != CLOSE_WAIT) &&
 8048a24:	2b02      	cmp	r3, #2
 8048a26:	d001      	beq.n	8048a2c <tcp_write_checks+0x14>
      (pcb->state != SYN_SENT) &&
 8048a28:	2b03      	cmp	r3, #3
 8048a2a:	d139      	bne.n	8048aa0 <tcp_write_checks+0x88>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 8048a2c:	2900      	cmp	r1, #0
 8048a2e:	d03a      	beq.n	8048aa6 <tcp_write_checks+0x8e>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 8048a30:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
 8048a34:	428b      	cmp	r3, r1
 8048a36:	d308      	bcc.n	8048a4a <tcp_write_checks+0x32>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8048a38:	f8b0 3062 	ldrh.w	r3, [r0, #98]	; 0x62
 8048a3c:	2b08      	cmp	r3, #8
 8048a3e:	d80b      	bhi.n	8048a58 <tcp_write_checks+0x40>
      pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
 8048a40:	b1f3      	cbz	r3, 8048a80 <tcp_write_checks+0x68>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048a42:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8048a44:	b17b      	cbz	r3, 8048a66 <tcp_write_checks+0x4e>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 8048a46:	2000      	movs	r0, #0
 8048a48:	e02e      	b.n	8048aa8 <tcp_write_checks+0x90>
    pcb->flags |= TF_NAGLEMEMERR;
 8048a4a:	7e83      	ldrb	r3, [r0, #26]
 8048a4c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8048a50:	7683      	strb	r3, [r0, #26]
    return ERR_MEM;
 8048a52:	f04f 30ff 	mov.w	r0, #4294967295
 8048a56:	e027      	b.n	8048aa8 <tcp_write_checks+0x90>
    pcb->flags |= TF_NAGLEMEMERR;
 8048a58:	7e83      	ldrb	r3, [r0, #26]
 8048a5a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8048a5e:	7683      	strb	r3, [r0, #26]
    return ERR_MEM;
 8048a60:	f04f 30ff 	mov.w	r0, #4294967295
 8048a64:	e020      	b.n	8048aa8 <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048a66:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8048a68:	b10b      	cbz	r3, 8048a6e <tcp_write_checks+0x56>
  return ERR_OK;
 8048a6a:	2000      	movs	r0, #0
 8048a6c:	e01c      	b.n	8048aa8 <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 8048a6e:	4b0f      	ldr	r3, [pc, #60]	; (8048aac <tcp_write_checks+0x94>)
 8048a70:	f240 1255 	movw	r2, #341	; 0x155
 8048a74:	490e      	ldr	r1, [pc, #56]	; (8048ab0 <tcp_write_checks+0x98>)
 8048a76:	480f      	ldr	r0, [pc, #60]	; (8048ab4 <tcp_write_checks+0x9c>)
 8048a78:	f008 fbb8 	bl	80511ec <printf>
  return ERR_OK;
 8048a7c:	2000      	movs	r0, #0
 8048a7e:	e013      	b.n	8048aa8 <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 8048a80:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8048a82:	b143      	cbz	r3, 8048a96 <tcp_write_checks+0x7e>
 8048a84:	4b09      	ldr	r3, [pc, #36]	; (8048aac <tcp_write_checks+0x94>)
 8048a86:	f44f 72ac 	mov.w	r2, #344	; 0x158
 8048a8a:	490b      	ldr	r1, [pc, #44]	; (8048ab8 <tcp_write_checks+0xa0>)
 8048a8c:	4809      	ldr	r0, [pc, #36]	; (8048ab4 <tcp_write_checks+0x9c>)
 8048a8e:	f008 fbad 	bl	80511ec <printf>
  return ERR_OK;
 8048a92:	2000      	movs	r0, #0
 8048a94:	e008      	b.n	8048aa8 <tcp_write_checks+0x90>
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 8048a96:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8048a98:	2b00      	cmp	r3, #0
 8048a9a:	d1f3      	bne.n	8048a84 <tcp_write_checks+0x6c>
  return ERR_OK;
 8048a9c:	2000      	movs	r0, #0
 8048a9e:	e003      	b.n	8048aa8 <tcp_write_checks+0x90>
    return ERR_CONN;
 8048aa0:	f06f 000a 	mvn.w	r0, #10
 8048aa4:	e000      	b.n	8048aa8 <tcp_write_checks+0x90>
    return ERR_OK;
 8048aa6:	2000      	movs	r0, #0
}
 8048aa8:	bd08      	pop	{r3, pc}
 8048aaa:	bf00      	nop
 8048aac:	08059534 	.word	0x08059534
 8048ab0:	08059568 	.word	0x08059568
 8048ab4:	08058644 	.word	0x08058644
 8048ab8:	080595a4 	.word	0x080595a4

08048abc <tcp_pbuf_prealloc>:
{
 8048abc:	b570      	push	{r4, r5, r6, lr}
 8048abe:	460c      	mov	r4, r1
 8048ac0:	461e      	mov	r6, r3
 8048ac2:	f89d 3018 	ldrb.w	r3, [sp, #24]
  if (length < max_length) {
 8048ac6:	4291      	cmp	r1, r2
 8048ac8:	d215      	bcs.n	8048af6 <tcp_pbuf_prealloc+0x3a>
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8048aca:	f89d 1014 	ldrb.w	r1, [sp, #20]
 8048ace:	f011 0f02 	tst.w	r1, #2
 8048ad2:	d108      	bne.n	8048ae6 <tcp_pbuf_prealloc+0x2a>
        (!(pcb->flags & TF_NODELAY) &&
 8048ad4:	9904      	ldr	r1, [sp, #16]
 8048ad6:	7e89      	ldrb	r1, [r1, #26]
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 8048ad8:	f011 0f40 	tst.w	r1, #64	; 0x40
 8048adc:	d126      	bne.n	8048b2c <tcp_pbuf_prealloc+0x70>
        (!(pcb->flags & TF_NODELAY) &&
 8048ade:	b113      	cbz	r3, 8048ae6 <tcp_pbuf_prealloc+0x2a>
          pcb->unsent != NULL ||
 8048ae0:	9b04      	ldr	r3, [sp, #16]
 8048ae2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
         (!first_seg ||
 8048ae4:	b1e3      	cbz	r3, 8048b20 <tcp_pbuf_prealloc+0x64>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
 8048ae6:	f204 211b 	addw	r1, r4, #539	; 0x21b
 8048aea:	f021 0103 	bic.w	r1, r1, #3
 8048aee:	428a      	cmp	r2, r1
 8048af0:	bf28      	it	cs
 8048af2:	460a      	movcs	r2, r1
 8048af4:	b291      	uxth	r1, r2
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 8048af6:	2200      	movs	r2, #0
 8048af8:	f7fd f932 	bl	8045d60 <pbuf_alloc>
  if (p == NULL) {
 8048afc:	4605      	mov	r5, r0
 8048afe:	b168      	cbz	r0, 8048b1c <tcp_pbuf_prealloc+0x60>
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 8048b00:	6803      	ldr	r3, [r0, #0]
 8048b02:	b133      	cbz	r3, 8048b12 <tcp_pbuf_prealloc+0x56>
 8048b04:	4b0a      	ldr	r3, [pc, #40]	; (8048b30 <tcp_pbuf_prealloc+0x74>)
 8048b06:	f44f 7288 	mov.w	r2, #272	; 0x110
 8048b0a:	490a      	ldr	r1, [pc, #40]	; (8048b34 <tcp_pbuf_prealloc+0x78>)
 8048b0c:	480a      	ldr	r0, [pc, #40]	; (8048b38 <tcp_pbuf_prealloc+0x7c>)
 8048b0e:	f008 fb6d 	bl	80511ec <printf>
  *oversize = p->len - length;
 8048b12:	896b      	ldrh	r3, [r5, #10]
 8048b14:	1b1b      	subs	r3, r3, r4
 8048b16:	8033      	strh	r3, [r6, #0]
  p->len = p->tot_len = length;
 8048b18:	812c      	strh	r4, [r5, #8]
 8048b1a:	816c      	strh	r4, [r5, #10]
}
 8048b1c:	4628      	mov	r0, r5
 8048b1e:	bd70      	pop	{r4, r5, r6, pc}
          pcb->unacked != NULL))) {
 8048b20:	9b04      	ldr	r3, [sp, #16]
 8048b22:	6edb      	ldr	r3, [r3, #108]	; 0x6c
          pcb->unsent != NULL ||
 8048b24:	2b00      	cmp	r3, #0
 8048b26:	d1de      	bne.n	8048ae6 <tcp_pbuf_prealloc+0x2a>
  u16_t alloc = length;
 8048b28:	4621      	mov	r1, r4
 8048b2a:	e7e4      	b.n	8048af6 <tcp_pbuf_prealloc+0x3a>
 8048b2c:	4621      	mov	r1, r4
 8048b2e:	e7e2      	b.n	8048af6 <tcp_pbuf_prealloc+0x3a>
 8048b30:	08059534 	.word	0x08059534
 8048b34:	080595d8 	.word	0x080595d8
 8048b38:	08058644 	.word	0x08058644

08048b3c <tcp_create_segment>:
{
 8048b3c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8048b40:	4607      	mov	r7, r0
 8048b42:	460e      	mov	r6, r1
 8048b44:	4690      	mov	r8, r2
 8048b46:	4699      	mov	r9, r3
 8048b48:	f89d a020 	ldrb.w	sl, [sp, #32]
  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 8048b4c:	2003      	movs	r0, #3
 8048b4e:	f7fc fed5 	bl	80458fc <memp_malloc>
 8048b52:	4604      	mov	r4, r0
 8048b54:	2800      	cmp	r0, #0
 8048b56:	d036      	beq.n	8048bc6 <tcp_create_segment+0x8a>
 8048b58:	ea4f 058a 	mov.w	r5, sl, lsl #2
 8048b5c:	f005 0504 	and.w	r5, r5, #4
  seg->flags = optflags;
 8048b60:	f880 a00a 	strb.w	sl, [r0, #10]
  seg->next = NULL;
 8048b64:	2300      	movs	r3, #0
 8048b66:	6003      	str	r3, [r0, #0]
  seg->p = p;
 8048b68:	6046      	str	r6, [r0, #4]
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 8048b6a:	8933      	ldrh	r3, [r6, #8]
 8048b6c:	fa1f fa85 	uxth.w	sl, r5
 8048b70:	4553      	cmp	r3, sl
 8048b72:	d32c      	bcc.n	8048bce <tcp_create_segment+0x92>
  seg->len = p->tot_len - optlen;
 8048b74:	8931      	ldrh	r1, [r6, #8]
 8048b76:	eba1 010a 	sub.w	r1, r1, sl
 8048b7a:	8121      	strh	r1, [r4, #8]
  if (pbuf_header(p, TCP_HLEN)) {
 8048b7c:	2114      	movs	r1, #20
 8048b7e:	4630      	mov	r0, r6
 8048b80:	f7fd f880 	bl	8045c84 <pbuf_header>
 8048b84:	bb50      	cbnz	r0, 8048bdc <tcp_create_segment+0xa0>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 8048b86:	6863      	ldr	r3, [r4, #4]
 8048b88:	685e      	ldr	r6, [r3, #4]
 8048b8a:	60e6      	str	r6, [r4, #12]
  seg->tcphdr->src = lwip_htons(pcb->local_port);
 8048b8c:	8af8      	ldrh	r0, [r7, #22]
 8048b8e:	f7fc fc4d 	bl	804542c <lwip_htons>
 8048b92:	8030      	strh	r0, [r6, #0]
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
 8048b94:	68e6      	ldr	r6, [r4, #12]
 8048b96:	8b38      	ldrh	r0, [r7, #24]
 8048b98:	f7fc fc48 	bl	804542c <lwip_htons>
 8048b9c:	8070      	strh	r0, [r6, #2]
  seg->tcphdr->seqno = lwip_htonl(seqno);
 8048b9e:	68e6      	ldr	r6, [r4, #12]
 8048ba0:	4648      	mov	r0, r9
 8048ba2:	f7fc fc46 	bl	8045432 <lwip_htonl>
 8048ba6:	6070      	str	r0, [r6, #4]
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 8048ba8:	08a8      	lsrs	r0, r5, #2
 8048baa:	3005      	adds	r0, #5
 8048bac:	68e5      	ldr	r5, [r4, #12]
 8048bae:	ea48 3000 	orr.w	r0, r8, r0, lsl #12
 8048bb2:	f7fc fc3b 	bl	804542c <lwip_htons>
 8048bb6:	81a8      	strh	r0, [r5, #12]
  seg->tcphdr->urgp = 0;
 8048bb8:	68e3      	ldr	r3, [r4, #12]
 8048bba:	2200      	movs	r2, #0
 8048bbc:	749a      	strb	r2, [r3, #18]
 8048bbe:	74da      	strb	r2, [r3, #19]
}
 8048bc0:	4620      	mov	r0, r4
 8048bc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pbuf_free(p);
 8048bc6:	4630      	mov	r0, r6
 8048bc8:	f7fd f866 	bl	8045c98 <pbuf_free>
    return NULL;
 8048bcc:	e7f8      	b.n	8048bc0 <tcp_create_segment+0x84>
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
 8048bce:	4b06      	ldr	r3, [pc, #24]	; (8048be8 <tcp_create_segment+0xac>)
 8048bd0:	22ba      	movs	r2, #186	; 0xba
 8048bd2:	4906      	ldr	r1, [pc, #24]	; (8048bec <tcp_create_segment+0xb0>)
 8048bd4:	4806      	ldr	r0, [pc, #24]	; (8048bf0 <tcp_create_segment+0xb4>)
 8048bd6:	f008 fb09 	bl	80511ec <printf>
 8048bda:	e7cb      	b.n	8048b74 <tcp_create_segment+0x38>
    tcp_seg_free(seg);
 8048bdc:	4620      	mov	r0, r4
 8048bde:	f7fd fd3f 	bl	8046660 <tcp_seg_free>
    return NULL;
 8048be2:	2400      	movs	r4, #0
 8048be4:	e7ec      	b.n	8048bc0 <tcp_create_segment+0x84>
 8048be6:	bf00      	nop
 8048be8:	08059534 	.word	0x08059534
 8048bec:	080595ec 	.word	0x080595ec
 8048bf0:	08058644 	.word	0x08058644

08048bf4 <tcp_output_alloc_header>:
{
 8048bf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8048bf8:	4605      	mov	r5, r0
 8048bfa:	460c      	mov	r4, r1
 8048bfc:	4698      	mov	r8, r3
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 8048bfe:	4411      	add	r1, r2
 8048c00:	b289      	uxth	r1, r1
 8048c02:	3114      	adds	r1, #20
 8048c04:	2200      	movs	r2, #0
 8048c06:	b289      	uxth	r1, r1
 8048c08:	2001      	movs	r0, #1
 8048c0a:	f7fd f8a9 	bl	8045d60 <pbuf_alloc>
  if (p != NULL) {
 8048c0e:	4607      	mov	r7, r0
 8048c10:	b348      	cbz	r0, 8048c66 <tcp_output_alloc_header+0x72>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8048c12:	f104 0313 	add.w	r3, r4, #19
 8048c16:	8942      	ldrh	r2, [r0, #10]
 8048c18:	4293      	cmp	r3, r2
 8048c1a:	da27      	bge.n	8048c6c <tcp_output_alloc_header+0x78>
    tcphdr = (struct tcp_hdr *)p->payload;
 8048c1c:	687e      	ldr	r6, [r7, #4]
    tcphdr->src = lwip_htons(pcb->local_port);
 8048c1e:	8ae8      	ldrh	r0, [r5, #22]
 8048c20:	f7fc fc04 	bl	804542c <lwip_htons>
 8048c24:	8030      	strh	r0, [r6, #0]
    tcphdr->dest = lwip_htons(pcb->remote_port);
 8048c26:	8b28      	ldrh	r0, [r5, #24]
 8048c28:	f7fc fc00 	bl	804542c <lwip_htons>
 8048c2c:	8070      	strh	r0, [r6, #2]
    tcphdr->seqno = seqno_be;
 8048c2e:	f8c6 8004 	str.w	r8, [r6, #4]
    tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8048c32:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8048c34:	f7fc fbfd 	bl	8045432 <lwip_htonl>
 8048c38:	60b0      	str	r0, [r6, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 8048c3a:	08a4      	lsrs	r4, r4, #2
 8048c3c:	3405      	adds	r4, #5
 8048c3e:	0324      	lsls	r4, r4, #12
 8048c40:	b2a4      	uxth	r4, r4
 8048c42:	f044 0010 	orr.w	r0, r4, #16
 8048c46:	f7fc fbf1 	bl	804542c <lwip_htons>
 8048c4a:	81b0      	strh	r0, [r6, #12]
    tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8048c4c:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
 8048c4e:	f7fc fbed 	bl	804542c <lwip_htons>
 8048c52:	81f0      	strh	r0, [r6, #14]
    tcphdr->chksum = 0;
 8048c54:	2300      	movs	r3, #0
 8048c56:	7433      	strb	r3, [r6, #16]
 8048c58:	7473      	strb	r3, [r6, #17]
    tcphdr->urgp = 0;
 8048c5a:	74b3      	strb	r3, [r6, #18]
 8048c5c:	74f3      	strb	r3, [r6, #19]
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8048c5e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8048c60:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
 8048c62:	4413      	add	r3, r2
 8048c64:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 8048c66:	4638      	mov	r0, r7
 8048c68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8048c6c:	4b03      	ldr	r3, [pc, #12]	; (8048c7c <tcp_output_alloc_header+0x88>)
 8048c6e:	2272      	movs	r2, #114	; 0x72
 8048c70:	4903      	ldr	r1, [pc, #12]	; (8048c80 <tcp_output_alloc_header+0x8c>)
 8048c72:	4804      	ldr	r0, [pc, #16]	; (8048c84 <tcp_output_alloc_header+0x90>)
 8048c74:	f008 faba 	bl	80511ec <printf>
 8048c78:	e7d0      	b.n	8048c1c <tcp_output_alloc_header+0x28>
 8048c7a:	bf00      	nop
 8048c7c:	08059534 	.word	0x08059534
 8048c80:	08059604 	.word	0x08059604
 8048c84:	08058644 	.word	0x08058644

08048c88 <tcp_output_segment>:
{
  err_t err;
  u16_t len;
  u32_t *opts;

  if (seg->p->ref != 1) {
 8048c88:	6843      	ldr	r3, [r0, #4]
 8048c8a:	89db      	ldrh	r3, [r3, #14]
 8048c8c:	2b01      	cmp	r3, #1
 8048c8e:	d001      	beq.n	8048c94 <tcp_output_segment+0xc>
    /* This can happen if the pbuf of this segment is still referenced by the
       netif driver due to deferred transmission. Since this function modifies
       p->len, we must not continue in this case. */
    return ERR_OK;
 8048c90:	2000      	movs	r0, #0
  NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
    pcb->tos, IP_PROTO_TCP, netif);
  NETIF_SET_HWADDRHINT(netif, NULL);
  return err;
}
 8048c92:	4770      	bx	lr
{
 8048c94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8048c96:	b085      	sub	sp, #20
 8048c98:	4604      	mov	r4, r0
 8048c9a:	460d      	mov	r5, r1
 8048c9c:	4616      	mov	r6, r2
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
 8048c9e:	68c7      	ldr	r7, [r0, #12]
 8048ca0:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8048ca2:	f7fc fbc6 	bl	8045432 <lwip_htonl>
 8048ca6:	60b8      	str	r0, [r7, #8]
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
 8048ca8:	68e7      	ldr	r7, [r4, #12]
 8048caa:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
 8048cac:	f7fc fbbe 	bl	804542c <lwip_htons>
 8048cb0:	81f8      	strh	r0, [r7, #14]
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 8048cb2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8048cb4:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
 8048cb6:	4413      	add	r3, r2
 8048cb8:	62eb      	str	r3, [r5, #44]	; 0x2c
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 8048cba:	68e7      	ldr	r7, [r4, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
 8048cbc:	7aa3      	ldrb	r3, [r4, #10]
 8048cbe:	f013 0f01 	tst.w	r3, #1
 8048cc2:	d125      	bne.n	8048d10 <tcp_output_segment+0x88>
  if (pcb->rtime < 0) {
 8048cc4:	f9b5 3030 	ldrsh.w	r3, [r5, #48]	; 0x30
 8048cc8:	2b00      	cmp	r3, #0
 8048cca:	db2c      	blt.n	8048d26 <tcp_output_segment+0x9e>
  if (pcb->rttest == 0) {
 8048ccc:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8048cce:	2b00      	cmp	r3, #0
 8048cd0:	d02c      	beq.n	8048d2c <tcp_output_segment+0xa4>
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 8048cd2:	68e3      	ldr	r3, [r4, #12]
 8048cd4:	6862      	ldr	r2, [r4, #4]
 8048cd6:	6851      	ldr	r1, [r2, #4]
 8048cd8:	1a5b      	subs	r3, r3, r1
 8048cda:	b29b      	uxth	r3, r3
  seg->p->len -= len;
 8048cdc:	8951      	ldrh	r1, [r2, #10]
 8048cde:	1ac9      	subs	r1, r1, r3
 8048ce0:	8151      	strh	r1, [r2, #10]
  seg->p->tot_len -= len;
 8048ce2:	6861      	ldr	r1, [r4, #4]
 8048ce4:	890a      	ldrh	r2, [r1, #8]
 8048ce6:	1ad3      	subs	r3, r2, r3
 8048ce8:	810b      	strh	r3, [r1, #8]
  seg->p->payload = seg->tcphdr;
 8048cea:	6862      	ldr	r2, [r4, #4]
 8048cec:	68e3      	ldr	r3, [r4, #12]
 8048cee:	6053      	str	r3, [r2, #4]
  seg->tcphdr->chksum = 0;
 8048cf0:	2200      	movs	r2, #0
 8048cf2:	741a      	strb	r2, [r3, #16]
 8048cf4:	745a      	strb	r2, [r3, #17]
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 8048cf6:	9602      	str	r6, [sp, #8]
 8048cf8:	2306      	movs	r3, #6
 8048cfa:	9301      	str	r3, [sp, #4]
 8048cfc:	7a6b      	ldrb	r3, [r5, #9]
 8048cfe:	9300      	str	r3, [sp, #0]
 8048d00:	7aab      	ldrb	r3, [r5, #10]
 8048d02:	1d2a      	adds	r2, r5, #4
 8048d04:	4629      	mov	r1, r5
 8048d06:	6860      	ldr	r0, [r4, #4]
 8048d08:	f001 ff58 	bl	804abbc <ip4_output_if>
}
 8048d0c:	b005      	add	sp, #20
 8048d0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
 8048d10:	1d29      	adds	r1, r5, #4
 8048d12:	f44f 7006 	mov.w	r0, #536	; 0x218
 8048d16:	f7fe fa73 	bl	8047200 <tcp_eff_send_mss_impl>
    *opts = TCP_BUILD_MSS_OPTION(mss);
 8048d1a:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 8048d1e:	f7fc fb88 	bl	8045432 <lwip_htonl>
 8048d22:	6178      	str	r0, [r7, #20]
    opts += 1;
 8048d24:	e7ce      	b.n	8048cc4 <tcp_output_segment+0x3c>
    pcb->rtime = 0;
 8048d26:	2300      	movs	r3, #0
 8048d28:	862b      	strh	r3, [r5, #48]	; 0x30
 8048d2a:	e7cf      	b.n	8048ccc <tcp_output_segment+0x44>
    pcb->rttest = tcp_ticks;
 8048d2c:	4b04      	ldr	r3, [pc, #16]	; (8048d40 <tcp_output_segment+0xb8>)
 8048d2e:	681b      	ldr	r3, [r3, #0]
 8048d30:	636b      	str	r3, [r5, #52]	; 0x34
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
 8048d32:	68e3      	ldr	r3, [r4, #12]
 8048d34:	6858      	ldr	r0, [r3, #4]
 8048d36:	f7fc fb7c 	bl	8045432 <lwip_htonl>
 8048d3a:	63a8      	str	r0, [r5, #56]	; 0x38
 8048d3c:	e7c9      	b.n	8048cd2 <tcp_output_segment+0x4a>
 8048d3e:	bf00      	nop
 8048d40:	200089a0 	.word	0x200089a0

08048d44 <tcp_write>:
{
 8048d44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8048d48:	b091      	sub	sp, #68	; 0x44
 8048d4a:	4680      	mov	r8, r0
 8048d4c:	9108      	str	r1, [sp, #32]
 8048d4e:	4692      	mov	sl, r2
 8048d50:	9307      	str	r3, [sp, #28]
  u16_t oversize = 0;
 8048d52:	2300      	movs	r3, #0
 8048d54:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
  u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
 8048d58:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8048d5c:	085b      	lsrs	r3, r3, #1
 8048d5e:	f8b0 b032 	ldrh.w	fp, [r0, #50]	; 0x32
 8048d62:	455b      	cmp	r3, fp
 8048d64:	bf28      	it	cs
 8048d66:	465b      	movcs	r3, fp
  mss_local = mss_local ? mss_local : pcb->mss;
 8048d68:	b103      	cbz	r3, 8048d6c <tcp_write+0x28>
 8048d6a:	469b      	mov	fp, r3
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8048d6c:	9b08      	ldr	r3, [sp, #32]
 8048d6e:	2b00      	cmp	r3, #0
 8048d70:	f000 808a 	beq.w	8048e88 <tcp_write+0x144>
  err = tcp_write_checks(pcb, len);
 8048d74:	4651      	mov	r1, sl
 8048d76:	4640      	mov	r0, r8
 8048d78:	f7ff fe4e 	bl	8048a18 <tcp_write_checks>
  if (err != ERR_OK) {
 8048d7c:	900a      	str	r0, [sp, #40]	; 0x28
 8048d7e:	2800      	cmp	r0, #0
 8048d80:	f040 818d 	bne.w	804909e <tcp_write+0x35a>
  queuelen = pcb->snd_queuelen;
 8048d84:	f8b8 6062 	ldrh.w	r6, [r8, #98]	; 0x62
  if (pcb->unsent != NULL) {
 8048d88:	f8d8 9068 	ldr.w	r9, [r8, #104]	; 0x68
 8048d8c:	f1b9 0f00 	cmp.w	r9, #0
 8048d90:	f000 80cc 	beq.w	8048f2c <tcp_write+0x1e8>
 8048d94:	464b      	mov	r3, r9
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8048d96:	9309      	str	r3, [sp, #36]	; 0x24
 8048d98:	681b      	ldr	r3, [r3, #0]
 8048d9a:	2b00      	cmp	r3, #0
 8048d9c:	d1fb      	bne.n	8048d96 <tcp_write+0x52>
 8048d9e:	4699      	mov	r9, r3
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 8048da0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048da2:	7a9c      	ldrb	r4, [r3, #10]
 8048da4:	00a4      	lsls	r4, r4, #2
 8048da6:	f004 0404 	and.w	r4, r4, #4
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 8048daa:	891b      	ldrh	r3, [r3, #8]
 8048dac:	4423      	add	r3, r4
 8048dae:	459b      	cmp	fp, r3
 8048db0:	db75      	blt.n	8048e9e <tcp_write+0x15a>
    space = mss_local - (last_unsent->len + unsent_optlen);
 8048db2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048db4:	891b      	ldrh	r3, [r3, #8]
 8048db6:	441c      	add	r4, r3
 8048db8:	b2a4      	uxth	r4, r4
 8048dba:	ebab 0404 	sub.w	r4, fp, r4
 8048dbe:	b2a1      	uxth	r1, r4
 8048dc0:	910c      	str	r1, [sp, #48]	; 0x30
    oversize = pcb->unsent_oversize;
 8048dc2:	f8b8 3064 	ldrh.w	r3, [r8, #100]	; 0x64
 8048dc6:	930b      	str	r3, [sp, #44]	; 0x2c
 8048dc8:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
    if (oversize > 0) {
 8048dcc:	2b00      	cmp	r3, #0
 8048dce:	d076      	beq.n	8048ebe <tcp_write+0x17a>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 8048dd0:	428b      	cmp	r3, r1
 8048dd2:	d86c      	bhi.n	8048eae <tcp_write+0x16a>
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
 8048dd4:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 8048dd8:	461a      	mov	r2, r3
 8048dda:	4553      	cmp	r3, sl
 8048ddc:	bf28      	it	cs
 8048dde:	4652      	movcs	r2, sl
 8048de0:	990c      	ldr	r1, [sp, #48]	; 0x30
 8048de2:	428a      	cmp	r2, r1
 8048de4:	bf28      	it	cs
 8048de6:	460a      	movcs	r2, r1
 8048de8:	b292      	uxth	r2, r2
 8048dea:	920b      	str	r2, [sp, #44]	; 0x2c
      oversize -= oversize_used;
 8048dec:	1a9b      	subs	r3, r3, r2
 8048dee:	f8ad 303e 	strh.w	r3, [sp, #62]	; 0x3e
      space -= oversize_used;
 8048df2:	1a8b      	subs	r3, r1, r2
 8048df4:	b29b      	uxth	r3, r3
 8048df6:	930c      	str	r3, [sp, #48]	; 0x30
      seg = last_unsent;
 8048df8:	9f09      	ldr	r7, [sp, #36]	; 0x24
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 8048dfa:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 8048dfe:	b113      	cbz	r3, 8048e06 <tcp_write+0xc2>
 8048e00:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048e02:	4553      	cmp	r3, sl
 8048e04:	d15d      	bne.n	8048ec2 <tcp_write+0x17e>
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 8048e06:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8048e08:	4552      	cmp	r2, sl
 8048e0a:	f080 8156 	bcs.w	80490ba <tcp_write+0x376>
 8048e0e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8048e10:	2900      	cmp	r1, #0
 8048e12:	f000 815b 	beq.w	80490cc <tcp_write+0x388>
 8048e16:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048e18:	891b      	ldrh	r3, [r3, #8]
 8048e1a:	2b00      	cmp	r3, #0
 8048e1c:	f000 8158 	beq.w	80490d0 <tcp_write+0x38c>
      u16_t seglen = LWIP_MIN(space, len - pos);
 8048e20:	ebaa 0402 	sub.w	r4, sl, r2
 8048e24:	428c      	cmp	r4, r1
 8048e26:	bfa8      	it	ge
 8048e28:	460c      	movge	r4, r1
 8048e2a:	b2a5      	uxth	r5, r4
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 8048e2c:	9b07      	ldr	r3, [sp, #28]
 8048e2e:	f013 0f01 	tst.w	r3, #1
 8048e32:	d14e      	bne.n	8048ed2 <tcp_write+0x18e>
        for (p = last_unsent->p; p->next != NULL; p = p->next);
 8048e34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8048e36:	f8d3 9004 	ldr.w	r9, [r3, #4]
 8048e3a:	464a      	mov	r2, r9
 8048e3c:	4613      	mov	r3, r2
 8048e3e:	6812      	ldr	r2, [r2, #0]
 8048e40:	2a00      	cmp	r2, #0
 8048e42:	d1fb      	bne.n	8048e3c <tcp_write+0xf8>
 8048e44:	4691      	mov	r9, r2
        if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
 8048e46:	7b1a      	ldrb	r2, [r3, #12]
 8048e48:	2a01      	cmp	r2, #1
 8048e4a:	d105      	bne.n	8048e58 <tcp_write+0x114>
 8048e4c:	685a      	ldr	r2, [r3, #4]
 8048e4e:	895b      	ldrh	r3, [r3, #10]
 8048e50:	4413      	add	r3, r2
 8048e52:	9a08      	ldr	r2, [sp, #32]
 8048e54:	4293      	cmp	r3, r2
 8048e56:	d05c      	beq.n	8048f12 <tcp_write+0x1ce>
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 8048e58:	2201      	movs	r2, #1
 8048e5a:	4629      	mov	r1, r5
 8048e5c:	2004      	movs	r0, #4
 8048e5e:	f7fc ff7f 	bl	8045d60 <pbuf_alloc>
 8048e62:	4681      	mov	r9, r0
 8048e64:	2800      	cmp	r0, #0
 8048e66:	f000 81ef 	beq.w	8049248 <tcp_write+0x504>
          ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
 8048e6a:	9b08      	ldr	r3, [sp, #32]
 8048e6c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8048e6e:	4413      	add	r3, r2
 8048e70:	6043      	str	r3, [r0, #4]
          queuelen += pbuf_clen(concat_p);
 8048e72:	f7fd f8dd 	bl	8046030 <pbuf_clen>
 8048e76:	4406      	add	r6, r0
 8048e78:	b2b6      	uxth	r6, r6
  u16_t extendlen = 0;
 8048e7a:	2300      	movs	r3, #0
 8048e7c:	930c      	str	r3, [sp, #48]	; 0x30
      pos += seglen;
 8048e7e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048e80:	195c      	adds	r4, r3, r5
 8048e82:	b2a4      	uxth	r4, r4
      seg = last_unsent;
 8048e84:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8048e86:	e11b      	b.n	80490c0 <tcp_write+0x37c>
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
 8048e88:	4ba1      	ldr	r3, [pc, #644]	; (8049110 <tcp_write+0x3cc>)
 8048e8a:	f240 1291 	movw	r2, #401	; 0x191
 8048e8e:	49a1      	ldr	r1, [pc, #644]	; (8049114 <tcp_write+0x3d0>)
 8048e90:	48a1      	ldr	r0, [pc, #644]	; (8049118 <tcp_write+0x3d4>)
 8048e92:	f008 f9ab 	bl	80511ec <printf>
 8048e96:	f06f 030f 	mvn.w	r3, #15
 8048e9a:	930a      	str	r3, [sp, #40]	; 0x28
 8048e9c:	e0ff      	b.n	804909e <tcp_write+0x35a>
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
 8048e9e:	4b9c      	ldr	r3, [pc, #624]	; (8049110 <tcp_write+0x3cc>)
 8048ea0:	f240 12c7 	movw	r2, #455	; 0x1c7
 8048ea4:	499d      	ldr	r1, [pc, #628]	; (804911c <tcp_write+0x3d8>)
 8048ea6:	489c      	ldr	r0, [pc, #624]	; (8049118 <tcp_write+0x3d4>)
 8048ea8:	f008 f9a0 	bl	80511ec <printf>
 8048eac:	e781      	b.n	8048db2 <tcp_write+0x6e>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
 8048eae:	4b98      	ldr	r3, [pc, #608]	; (8049110 <tcp_write+0x3cc>)
 8048eb0:	f240 12d9 	movw	r2, #473	; 0x1d9
 8048eb4:	499a      	ldr	r1, [pc, #616]	; (8049120 <tcp_write+0x3dc>)
 8048eb6:	4898      	ldr	r0, [pc, #608]	; (8049118 <tcp_write+0x3d4>)
 8048eb8:	f008 f998 	bl	80511ec <printf>
 8048ebc:	e78a      	b.n	8048dd4 <tcp_write+0x90>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048ebe:	464f      	mov	r7, r9
 8048ec0:	e79b      	b.n	8048dfa <tcp_write+0xb6>
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
 8048ec2:	4b93      	ldr	r3, [pc, #588]	; (8049110 <tcp_write+0x3cc>)
 8048ec4:	f240 12e1 	movw	r2, #481	; 0x1e1
 8048ec8:	4996      	ldr	r1, [pc, #600]	; (8049124 <tcp_write+0x3e0>)
 8048eca:	4893      	ldr	r0, [pc, #588]	; (8049118 <tcp_write+0x3d4>)
 8048ecc:	f008 f98e 	bl	80511ec <printf>
 8048ed0:	e799      	b.n	8048e06 <tcp_write+0xc2>
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 8048ed2:	2301      	movs	r3, #1
 8048ed4:	9302      	str	r3, [sp, #8]
 8048ed6:	9b07      	ldr	r3, [sp, #28]
 8048ed8:	9301      	str	r3, [sp, #4]
 8048eda:	f8cd 8000 	str.w	r8, [sp]
 8048ede:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 8048ee2:	460a      	mov	r2, r1
 8048ee4:	4629      	mov	r1, r5
 8048ee6:	2004      	movs	r0, #4
 8048ee8:	f7ff fde8 	bl	8048abc <tcp_pbuf_prealloc>
 8048eec:	4681      	mov	r9, r0
 8048eee:	2800      	cmp	r0, #0
 8048ef0:	f000 81a8 	beq.w	8049244 <tcp_write+0x500>
        TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 8048ef4:	462a      	mov	r2, r5
 8048ef6:	9b08      	ldr	r3, [sp, #32]
 8048ef8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8048efa:	1859      	adds	r1, r3, r1
 8048efc:	6840      	ldr	r0, [r0, #4]
 8048efe:	f008 f953 	bl	80511a8 <memcpy>
        queuelen += pbuf_clen(concat_p);
 8048f02:	4648      	mov	r0, r9
 8048f04:	f7fd f894 	bl	8046030 <pbuf_clen>
 8048f08:	4406      	add	r6, r0
 8048f0a:	b2b6      	uxth	r6, r6
  u16_t extendlen = 0;
 8048f0c:	2300      	movs	r3, #0
 8048f0e:	930c      	str	r3, [sp, #48]	; 0x30
 8048f10:	e7b5      	b.n	8048e7e <tcp_write+0x13a>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 8048f12:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8048f14:	b90b      	cbnz	r3, 8048f1a <tcp_write+0x1d6>
          extendlen = seglen;
 8048f16:	950c      	str	r5, [sp, #48]	; 0x30
 8048f18:	e7b1      	b.n	8048e7e <tcp_write+0x13a>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
 8048f1a:	4b7d      	ldr	r3, [pc, #500]	; (8049110 <tcp_write+0x3cc>)
 8048f1c:	f44f 7203 	mov.w	r2, #524	; 0x20c
 8048f20:	4981      	ldr	r1, [pc, #516]	; (8049128 <tcp_write+0x3e4>)
 8048f22:	487d      	ldr	r0, [pc, #500]	; (8049118 <tcp_write+0x3d4>)
 8048f24:	f008 f962 	bl	80511ec <printf>
          extendlen = seglen;
 8048f28:	950c      	str	r5, [sp, #48]	; 0x30
 8048f2a:	e7a8      	b.n	8048e7e <tcp_write+0x13a>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 8048f2c:	f8b8 4064 	ldrh.w	r4, [r8, #100]	; 0x64
 8048f30:	b92c      	cbnz	r4, 8048f3e <tcp_write+0x1fa>
  u16_t extendlen = 0;
 8048f32:	940c      	str	r4, [sp, #48]	; 0x30
  u16_t oversize_used = 0;
 8048f34:	940b      	str	r4, [sp, #44]	; 0x2c
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048f36:	464f      	mov	r7, r9
 8048f38:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8048f3c:	e0c0      	b.n	80490c0 <tcp_write+0x37c>
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 8048f3e:	4b74      	ldr	r3, [pc, #464]	; (8049110 <tcp_write+0x3cc>)
 8048f40:	f44f 7209 	mov.w	r2, #548	; 0x224
 8048f44:	4979      	ldr	r1, [pc, #484]	; (804912c <tcp_write+0x3e8>)
 8048f46:	4874      	ldr	r0, [pc, #464]	; (8049118 <tcp_write+0x3d4>)
 8048f48:	f008 f950 	bl	80511ec <printf>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8048f4c:	464f      	mov	r7, r9
 8048f4e:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
  u16_t extendlen = 0;
 8048f52:	2400      	movs	r4, #0
 8048f54:	940c      	str	r4, [sp, #48]	; 0x30
  u16_t oversize_used = 0;
 8048f56:	940b      	str	r4, [sp, #44]	; 0x2c
 8048f58:	e0b2      	b.n	80490c0 <tcp_write+0x37c>
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 8048f5a:	9b06      	ldr	r3, [sp, #24]
 8048f5c:	fab3 f383 	clz	r3, r3
 8048f60:	095b      	lsrs	r3, r3, #5
 8048f62:	9302      	str	r3, [sp, #8]
 8048f64:	9b07      	ldr	r3, [sp, #28]
 8048f66:	9301      	str	r3, [sp, #4]
 8048f68:	f8cd 8000 	str.w	r8, [sp]
 8048f6c:	f10d 033e 	add.w	r3, sp, #62	; 0x3e
 8048f70:	465a      	mov	r2, fp
 8048f72:	4629      	mov	r1, r5
 8048f74:	2000      	movs	r0, #0
 8048f76:	f7ff fda1 	bl	8048abc <tcp_pbuf_prealloc>
 8048f7a:	4607      	mov	r7, r0
 8048f7c:	2800      	cmp	r0, #0
 8048f7e:	f000 8165 	beq.w	804924c <tcp_write+0x508>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8048f82:	8943      	ldrh	r3, [r0, #10]
 8048f84:	42ab      	cmp	r3, r5
 8048f86:	d306      	bcc.n	8048f96 <tcp_write+0x252>
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 8048f88:	462a      	mov	r2, r5
 8048f8a:	9b08      	ldr	r3, [sp, #32]
 8048f8c:	1919      	adds	r1, r3, r4
 8048f8e:	6878      	ldr	r0, [r7, #4]
 8048f90:	f008 f90a 	bl	80511a8 <memcpy>
 8048f94:	e025      	b.n	8048fe2 <tcp_write+0x29e>
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 8048f96:	4b5e      	ldr	r3, [pc, #376]	; (8049110 <tcp_write+0x3cc>)
 8048f98:	f44f 7210 	mov.w	r2, #576	; 0x240
 8048f9c:	4964      	ldr	r1, [pc, #400]	; (8049130 <tcp_write+0x3ec>)
 8048f9e:	485e      	ldr	r0, [pc, #376]	; (8049118 <tcp_write+0x3d4>)
 8048fa0:	f008 f924 	bl	80511ec <printf>
 8048fa4:	e7f0      	b.n	8048f88 <tcp_write+0x244>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 8048fa6:	4b5a      	ldr	r3, [pc, #360]	; (8049110 <tcp_write+0x3cc>)
 8048fa8:	f240 224b 	movw	r2, #587	; 0x24b
 8048fac:	4961      	ldr	r1, [pc, #388]	; (8049134 <tcp_write+0x3f0>)
 8048fae:	485a      	ldr	r0, [pc, #360]	; (8049118 <tcp_write+0x3d4>)
 8048fb0:	f008 f91c 	bl	80511ec <printf>
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 8048fb4:	2201      	movs	r2, #1
 8048fb6:	4629      	mov	r1, r5
 8048fb8:	2000      	movs	r0, #0
 8048fba:	f7fc fed1 	bl	8045d60 <pbuf_alloc>
 8048fbe:	4681      	mov	r9, r0
 8048fc0:	2800      	cmp	r0, #0
 8048fc2:	f000 8146 	beq.w	8049252 <tcp_write+0x50e>
      ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
 8048fc6:	9b08      	ldr	r3, [sp, #32]
 8048fc8:	4423      	add	r3, r4
 8048fca:	6043      	str	r3, [r0, #4]
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 8048fcc:	2200      	movs	r2, #0
 8048fce:	4611      	mov	r1, r2
 8048fd0:	4610      	mov	r0, r2
 8048fd2:	f7fc fec5 	bl	8045d60 <pbuf_alloc>
 8048fd6:	4607      	mov	r7, r0
 8048fd8:	2800      	cmp	r0, #0
 8048fda:	d032      	beq.n	8049042 <tcp_write+0x2fe>
      pbuf_cat(p/*header*/, p2/*data*/);
 8048fdc:	4649      	mov	r1, r9
 8048fde:	f7fd f847 	bl	8046070 <pbuf_cat>
    queuelen += pbuf_clen(p);
 8048fe2:	4638      	mov	r0, r7
 8048fe4:	f7fd f824 	bl	8046030 <pbuf_clen>
 8048fe8:	4406      	add	r6, r0
 8048fea:	b2b6      	uxth	r6, r6
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 8048fec:	2e09      	cmp	r6, #9
 8048fee:	d82e      	bhi.n	804904e <tcp_write+0x30a>
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 8048ff0:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 8048ff4:	2200      	movs	r2, #0
 8048ff6:	9200      	str	r2, [sp, #0]
 8048ff8:	4423      	add	r3, r4
 8048ffa:	4639      	mov	r1, r7
 8048ffc:	4640      	mov	r0, r8
 8048ffe:	f7ff fd9d 	bl	8048b3c <tcp_create_segment>
 8049002:	4607      	mov	r7, r0
 8049004:	2800      	cmp	r0, #0
 8049006:	f000 8127 	beq.w	8049258 <tcp_write+0x514>
    if (queue == NULL) {
 804900a:	9b06      	ldr	r3, [sp, #24]
 804900c:	2b00      	cmp	r3, #0
 804900e:	d052      	beq.n	80490b6 <tcp_write+0x372>
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 8049010:	9b05      	ldr	r3, [sp, #20]
 8049012:	2b00      	cmp	r3, #0
 8049014:	d047      	beq.n	80490a6 <tcp_write+0x362>
      prev_seg->next = seg;
 8049016:	9b05      	ldr	r3, [sp, #20]
 8049018:	601f      	str	r7, [r3, #0]
    pos += seglen;
 804901a:	442c      	add	r4, r5
 804901c:	b2a4      	uxth	r4, r4
    prev_seg = seg;
 804901e:	9705      	str	r7, [sp, #20]
  while (pos < len) {
 8049020:	4554      	cmp	r4, sl
 8049022:	d258      	bcs.n	80490d6 <tcp_write+0x392>
    u16_t left = len - pos;
 8049024:	ebaa 0504 	sub.w	r5, sl, r4
 8049028:	b2ad      	uxth	r5, r5
    u16_t seglen = LWIP_MIN(left, max_len);
 804902a:	455d      	cmp	r5, fp
 804902c:	bf28      	it	cs
 804902e:	465d      	movcs	r5, fp
    if (apiflags & TCP_WRITE_FLAG_COPY) {
 8049030:	9b07      	ldr	r3, [sp, #28]
 8049032:	f013 0f01 	tst.w	r3, #1
 8049036:	d190      	bne.n	8048f5a <tcp_write+0x216>
      LWIP_ASSERT("oversize == 0", oversize == 0);
 8049038:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 804903c:	2b00      	cmp	r3, #0
 804903e:	d0b9      	beq.n	8048fb4 <tcp_write+0x270>
 8049040:	e7b1      	b.n	8048fa6 <tcp_write+0x262>
 8049042:	4648      	mov	r0, r9
 8049044:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
        pbuf_free(p2);
 8049048:	f7fc fe26 	bl	8045c98 <pbuf_free>
        goto memerr;
 804904c:	e004      	b.n	8049058 <tcp_write+0x314>
 804904e:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
      pbuf_free(p);
 8049052:	4638      	mov	r0, r7
 8049054:	f7fc fe20 	bl	8045c98 <pbuf_free>
  pcb->flags |= TF_NAGLEMEMERR;
 8049058:	f898 301a 	ldrb.w	r3, [r8, #26]
 804905c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8049060:	f888 301a 	strb.w	r3, [r8, #26]
  if (concat_p != NULL) {
 8049064:	f1b9 0f00 	cmp.w	r9, #0
 8049068:	d002      	beq.n	8049070 <tcp_write+0x32c>
    pbuf_free(concat_p);
 804906a:	4648      	mov	r0, r9
 804906c:	f7fc fe14 	bl	8045c98 <pbuf_free>
  if (queue != NULL) {
 8049070:	9b06      	ldr	r3, [sp, #24]
 8049072:	b113      	cbz	r3, 804907a <tcp_write+0x336>
    tcp_segs_free(queue);
 8049074:	4618      	mov	r0, r3
 8049076:	f7fd fb00 	bl	804667a <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
 804907a:	f8b8 3062 	ldrh.w	r3, [r8, #98]	; 0x62
 804907e:	2b00      	cmp	r3, #0
 8049080:	f000 80f8 	beq.w	8049274 <tcp_write+0x530>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 8049084:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 8049088:	2b00      	cmp	r3, #0
 804908a:	f040 80f7 	bne.w	804927c <tcp_write+0x538>
 804908e:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 8049092:	2b00      	cmp	r3, #0
 8049094:	f000 80e3 	beq.w	804925e <tcp_write+0x51a>
  return ERR_MEM;
 8049098:	f04f 33ff 	mov.w	r3, #4294967295
 804909c:	930a      	str	r3, [sp, #40]	; 0x28
}
 804909e:	980a      	ldr	r0, [sp, #40]	; 0x28
 80490a0:	b011      	add	sp, #68	; 0x44
 80490a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 80490a6:	4b1a      	ldr	r3, [pc, #104]	; (8049110 <tcp_write+0x3cc>)
 80490a8:	f240 2285 	movw	r2, #645	; 0x285
 80490ac:	4922      	ldr	r1, [pc, #136]	; (8049138 <tcp_write+0x3f4>)
 80490ae:	481a      	ldr	r0, [pc, #104]	; (8049118 <tcp_write+0x3d4>)
 80490b0:	f008 f89c 	bl	80511ec <printf>
 80490b4:	e7af      	b.n	8049016 <tcp_write+0x2d2>
      queue = seg;
 80490b6:	9006      	str	r0, [sp, #24]
 80490b8:	e7af      	b.n	804901a <tcp_write+0x2d6>
 80490ba:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  u16_t extendlen = 0;
 80490bc:	2300      	movs	r3, #0
 80490be:	930c      	str	r3, [sp, #48]	; 0x30
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 80490c0:	2300      	movs	r3, #0
 80490c2:	9306      	str	r3, [sp, #24]
 80490c4:	9305      	str	r3, [sp, #20]
 80490c6:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
 80490ca:	e7a9      	b.n	8049020 <tcp_write+0x2dc>
 80490cc:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80490ce:	e7f7      	b.n	80490c0 <tcp_write+0x37c>
  u16_t extendlen = 0;
 80490d0:	930c      	str	r3, [sp, #48]	; 0x30
 80490d2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80490d4:	e7f4      	b.n	80490c0 <tcp_write+0x37c>
 80490d6:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  if (oversize_used > 0) {
 80490da:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80490dc:	2d00      	cmp	r5, #0
 80490de:	d032      	beq.n	8049146 <tcp_write+0x402>
    for (p = last_unsent->p; p; p = p->next) {
 80490e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80490e2:	685c      	ldr	r4, [r3, #4]
 80490e4:	f8dd b020 	ldr.w	fp, [sp, #32]
 80490e8:	e000      	b.n	80490ec <tcp_write+0x3a8>
 80490ea:	6824      	ldr	r4, [r4, #0]
 80490ec:	b334      	cbz	r4, 804913c <tcp_write+0x3f8>
      p->tot_len += oversize_used;
 80490ee:	8923      	ldrh	r3, [r4, #8]
 80490f0:	442b      	add	r3, r5
 80490f2:	8123      	strh	r3, [r4, #8]
      if (p->next == NULL) {
 80490f4:	6823      	ldr	r3, [r4, #0]
 80490f6:	2b00      	cmp	r3, #0
 80490f8:	d1f7      	bne.n	80490ea <tcp_write+0x3a6>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 80490fa:	6860      	ldr	r0, [r4, #4]
 80490fc:	8963      	ldrh	r3, [r4, #10]
 80490fe:	462a      	mov	r2, r5
 8049100:	4659      	mov	r1, fp
 8049102:	4418      	add	r0, r3
 8049104:	f008 f850 	bl	80511a8 <memcpy>
        p->len += oversize_used;
 8049108:	8963      	ldrh	r3, [r4, #10]
 804910a:	442b      	add	r3, r5
 804910c:	8163      	strh	r3, [r4, #10]
 804910e:	e7ec      	b.n	80490ea <tcp_write+0x3a6>
 8049110:	08059534 	.word	0x08059534
 8049114:	08059634 	.word	0x08059634
 8049118:	08058644 	.word	0x08058644
 804911c:	08059668 	.word	0x08059668
 8049120:	08059680 	.word	0x08059680
 8049124:	080596a0 	.word	0x080596a0
 8049128:	080596c0 	.word	0x080596c0
 804912c:	080596ec 	.word	0x080596ec
 8049130:	0805971c 	.word	0x0805971c
 8049134:	0805975c 	.word	0x0805975c
 8049138:	0805976c 	.word	0x0805976c
    last_unsent->len += oversize_used;
 804913c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 804913e:	8913      	ldrh	r3, [r2, #8]
 8049140:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8049142:	4419      	add	r1, r3
 8049144:	8111      	strh	r1, [r2, #8]
  pcb->unsent_oversize = oversize;
 8049146:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 804914a:	f8a8 3064 	strh.w	r3, [r8, #100]	; 0x64
  if (concat_p != NULL) {
 804914e:	f1b9 0f00 	cmp.w	r9, #0
 8049152:	d041      	beq.n	80491d8 <tcp_write+0x494>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 8049154:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8049156:	2b00      	cmp	r3, #0
 8049158:	d036      	beq.n	80491c8 <tcp_write+0x484>
    pbuf_cat(last_unsent->p, concat_p);
 804915a:	4649      	mov	r1, r9
 804915c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 804915e:	6860      	ldr	r0, [r4, #4]
 8049160:	f7fc ff86 	bl	8046070 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 8049164:	f8b9 3008 	ldrh.w	r3, [r9, #8]
 8049168:	8922      	ldrh	r2, [r4, #8]
 804916a:	4413      	add	r3, r2
 804916c:	8123      	strh	r3, [r4, #8]
  if (last_unsent == NULL) {
 804916e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8049170:	2b00      	cmp	r3, #0
 8049172:	d057      	beq.n	8049224 <tcp_write+0x4e0>
    last_unsent->next = queue;
 8049174:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8049176:	461a      	mov	r2, r3
 8049178:	9b06      	ldr	r3, [sp, #24]
 804917a:	6013      	str	r3, [r2, #0]
  pcb->snd_lbb += len;
 804917c:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
 8049180:	4453      	add	r3, sl
 8049182:	f8c8 3058 	str.w	r3, [r8, #88]	; 0x58
  pcb->snd_buf -= len;
 8049186:	f8b8 3060 	ldrh.w	r3, [r8, #96]	; 0x60
 804918a:	eba3 0a0a 	sub.w	sl, r3, sl
 804918e:	f8a8 a060 	strh.w	sl, [r8, #96]	; 0x60
  pcb->snd_queuelen = queuelen;
 8049192:	f8a8 6062 	strh.w	r6, [r8, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 8049196:	b11e      	cbz	r6, 80491a0 <tcp_write+0x45c>
    LWIP_ASSERT("tcp_write: valid queue length",
 8049198:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 804919c:	2b00      	cmp	r3, #0
 804919e:	d045      	beq.n	804922c <tcp_write+0x4e8>
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 80491a0:	2f00      	cmp	r7, #0
 80491a2:	f43f af7c 	beq.w	804909e <tcp_write+0x35a>
 80491a6:	68fb      	ldr	r3, [r7, #12]
 80491a8:	2b00      	cmp	r3, #0
 80491aa:	f43f af78 	beq.w	804909e <tcp_write+0x35a>
 80491ae:	9a07      	ldr	r2, [sp, #28]
 80491b0:	f012 0f02 	tst.w	r2, #2
 80491b4:	f47f af73 	bne.w	804909e <tcp_write+0x35a>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 80491b8:	899c      	ldrh	r4, [r3, #12]
 80491ba:	2008      	movs	r0, #8
 80491bc:	f7fc f936 	bl	804542c <lwip_htons>
 80491c0:	68fb      	ldr	r3, [r7, #12]
 80491c2:	4304      	orrs	r4, r0
 80491c4:	819c      	strh	r4, [r3, #12]
 80491c6:	e76a      	b.n	804909e <tcp_write+0x35a>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 80491c8:	4b2e      	ldr	r3, [pc, #184]	; (8049284 <tcp_write+0x540>)
 80491ca:	f240 22ba 	movw	r2, #698	; 0x2ba
 80491ce:	492e      	ldr	r1, [pc, #184]	; (8049288 <tcp_write+0x544>)
 80491d0:	482e      	ldr	r0, [pc, #184]	; (804928c <tcp_write+0x548>)
 80491d2:	f008 f80b 	bl	80511ec <printf>
 80491d6:	e7c0      	b.n	804915a <tcp_write+0x416>
  } else if (extendlen > 0) {
 80491d8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80491da:	2b00      	cmp	r3, #0
 80491dc:	d0c7      	beq.n	804916e <tcp_write+0x42a>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 80491de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80491e0:	b12b      	cbz	r3, 80491ee <tcp_write+0x4aa>
 80491e2:	685b      	ldr	r3, [r3, #4]
 80491e4:	b11b      	cbz	r3, 80491ee <tcp_write+0x4aa>
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 80491e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80491e8:	685b      	ldr	r3, [r3, #4]
 80491ea:	980c      	ldr	r0, [sp, #48]	; 0x30
 80491ec:	e00b      	b.n	8049206 <tcp_write+0x4c2>
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
 80491ee:	4b25      	ldr	r3, [pc, #148]	; (8049284 <tcp_write+0x540>)
 80491f0:	f44f 7230 	mov.w	r2, #704	; 0x2c0
 80491f4:	4926      	ldr	r1, [pc, #152]	; (8049290 <tcp_write+0x54c>)
 80491f6:	4825      	ldr	r0, [pc, #148]	; (804928c <tcp_write+0x548>)
 80491f8:	f007 fff8 	bl	80511ec <printf>
 80491fc:	e7f3      	b.n	80491e6 <tcp_write+0x4a2>
      p->tot_len += extendlen;
 80491fe:	891a      	ldrh	r2, [r3, #8]
 8049200:	4402      	add	r2, r0
 8049202:	811a      	strh	r2, [r3, #8]
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
 8049204:	460b      	mov	r3, r1
 8049206:	6819      	ldr	r1, [r3, #0]
 8049208:	2900      	cmp	r1, #0
 804920a:	d1f8      	bne.n	80491fe <tcp_write+0x4ba>
    p->tot_len += extendlen;
 804920c:	891a      	ldrh	r2, [r3, #8]
 804920e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8049210:	440a      	add	r2, r1
 8049212:	811a      	strh	r2, [r3, #8]
    p->len += extendlen;
 8049214:	895a      	ldrh	r2, [r3, #10]
 8049216:	440a      	add	r2, r1
 8049218:	815a      	strh	r2, [r3, #10]
    last_unsent->len += extendlen;
 804921a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 804921c:	8913      	ldrh	r3, [r2, #8]
 804921e:	440b      	add	r3, r1
 8049220:	8113      	strh	r3, [r2, #8]
 8049222:	e7a4      	b.n	804916e <tcp_write+0x42a>
    pcb->unsent = queue;
 8049224:	9b06      	ldr	r3, [sp, #24]
 8049226:	f8c8 3068 	str.w	r3, [r8, #104]	; 0x68
 804922a:	e7a7      	b.n	804917c <tcp_write+0x438>
    LWIP_ASSERT("tcp_write: valid queue length",
 804922c:	f8d8 3068 	ldr.w	r3, [r8, #104]	; 0x68
 8049230:	2b00      	cmp	r3, #0
 8049232:	d1b5      	bne.n	80491a0 <tcp_write+0x45c>
 8049234:	4b13      	ldr	r3, [pc, #76]	; (8049284 <tcp_write+0x540>)
 8049236:	f44f 723b 	mov.w	r2, #748	; 0x2ec
 804923a:	4916      	ldr	r1, [pc, #88]	; (8049294 <tcp_write+0x550>)
 804923c:	4813      	ldr	r0, [pc, #76]	; (804928c <tcp_write+0x548>)
 804923e:	f007 ffd5 	bl	80511ec <printf>
 8049242:	e7ad      	b.n	80491a0 <tcp_write+0x45c>
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 8049244:	9006      	str	r0, [sp, #24]
 8049246:	e707      	b.n	8049058 <tcp_write+0x314>
 8049248:	9006      	str	r0, [sp, #24]
 804924a:	e705      	b.n	8049058 <tcp_write+0x314>
 804924c:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8049250:	e702      	b.n	8049058 <tcp_write+0x314>
 8049252:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8049256:	e6ff      	b.n	8049058 <tcp_write+0x314>
 8049258:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 804925c:	e6fc      	b.n	8049058 <tcp_write+0x314>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 804925e:	4b09      	ldr	r3, [pc, #36]	; (8049284 <tcp_write+0x540>)
 8049260:	f240 3201 	movw	r2, #769	; 0x301
 8049264:	490b      	ldr	r1, [pc, #44]	; (8049294 <tcp_write+0x550>)
 8049266:	4809      	ldr	r0, [pc, #36]	; (804928c <tcp_write+0x548>)
 8049268:	f007 ffc0 	bl	80511ec <printf>
  return ERR_MEM;
 804926c:	f04f 33ff 	mov.w	r3, #4294967295
 8049270:	930a      	str	r3, [sp, #40]	; 0x28
 8049272:	e714      	b.n	804909e <tcp_write+0x35a>
 8049274:	f04f 33ff 	mov.w	r3, #4294967295
 8049278:	930a      	str	r3, [sp, #40]	; 0x28
 804927a:	e710      	b.n	804909e <tcp_write+0x35a>
 804927c:	f04f 33ff 	mov.w	r3, #4294967295
 8049280:	930a      	str	r3, [sp, #40]	; 0x28
 8049282:	e70c      	b.n	804909e <tcp_write+0x35a>
 8049284:	08059534 	.word	0x08059534
 8049288:	08059780 	.word	0x08059780
 804928c:	08058644 	.word	0x08058644
 8049290:	080597b8 	.word	0x080597b8
 8049294:	080597f0 	.word	0x080597f0

08049298 <tcp_enqueue_flags>:
{
 8049298:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 804929c:	b083      	sub	sp, #12
 804929e:	4604      	mov	r4, r0
 80492a0:	460d      	mov	r5, r1
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 80492a2:	f011 0703 	ands.w	r7, r1, #3
 80492a6:	d052      	beq.n	804934e <tcp_enqueue_flags+0xb6>
  if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
 80492a8:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 80492ac:	2b08      	cmp	r3, #8
 80492ae:	d902      	bls.n	80492b6 <tcp_enqueue_flags+0x1e>
 80492b0:	f015 0f01 	tst.w	r5, #1
 80492b4:	d053      	beq.n	804935e <tcp_enqueue_flags+0xc6>
  if (flags & TCP_SYN) {
 80492b6:	f015 0802 	ands.w	r8, r5, #2
 80492ba:	d001      	beq.n	80492c0 <tcp_enqueue_flags+0x28>
    optflags = TF_SEG_OPTS_MSS;
 80492bc:	f04f 0801 	mov.w	r8, #1
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 80492c0:	ea4f 0688 	mov.w	r6, r8, lsl #2
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 80492c4:	f006 0604 	and.w	r6, r6, #4
 80492c8:	2200      	movs	r2, #0
 80492ca:	4631      	mov	r1, r6
 80492cc:	4610      	mov	r0, r2
 80492ce:	f7fc fd47 	bl	8045d60 <pbuf_alloc>
 80492d2:	4681      	mov	r9, r0
 80492d4:	2800      	cmp	r0, #0
 80492d6:	d049      	beq.n	804936c <tcp_enqueue_flags+0xd4>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 80492d8:	8943      	ldrh	r3, [r0, #10]
 80492da:	429e      	cmp	r6, r3
 80492dc:	d84d      	bhi.n	804937a <tcp_enqueue_flags+0xe2>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 80492de:	f8cd 8000 	str.w	r8, [sp]
 80492e2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80492e4:	462a      	mov	r2, r5
 80492e6:	4649      	mov	r1, r9
 80492e8:	4620      	mov	r0, r4
 80492ea:	f7ff fc27 	bl	8048b3c <tcp_create_segment>
 80492ee:	4606      	mov	r6, r0
 80492f0:	2800      	cmp	r0, #0
 80492f2:	d04a      	beq.n	804938a <tcp_enqueue_flags+0xf2>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 80492f4:	68c3      	ldr	r3, [r0, #12]
 80492f6:	f013 0f03 	tst.w	r3, #3
 80492fa:	d14d      	bne.n	8049398 <tcp_enqueue_flags+0x100>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 80492fc:	8933      	ldrh	r3, [r6, #8]
 80492fe:	2b00      	cmp	r3, #0
 8049300:	d152      	bne.n	80493a8 <tcp_enqueue_flags+0x110>
  if (pcb->unsent == NULL) {
 8049302:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8049304:	2b00      	cmp	r3, #0
 8049306:	d057      	beq.n	80493b8 <tcp_enqueue_flags+0x120>
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 8049308:	461a      	mov	r2, r3
 804930a:	681b      	ldr	r3, [r3, #0]
 804930c:	2b00      	cmp	r3, #0
 804930e:	d1fb      	bne.n	8049308 <tcp_enqueue_flags+0x70>
    useg->next = seg;
 8049310:	6016      	str	r6, [r2, #0]
  pcb->unsent_oversize = 0;
 8049312:	2300      	movs	r3, #0
 8049314:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 8049318:	b117      	cbz	r7, 8049320 <tcp_enqueue_flags+0x88>
    pcb->snd_lbb++;
 804931a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 804931c:	3301      	adds	r3, #1
 804931e:	65a3      	str	r3, [r4, #88]	; 0x58
  if (flags & TCP_FIN) {
 8049320:	f015 0f01 	tst.w	r5, #1
 8049324:	d003      	beq.n	804932e <tcp_enqueue_flags+0x96>
    pcb->flags |= TF_FIN;
 8049326:	7ea3      	ldrb	r3, [r4, #26]
 8049328:	f043 0320 	orr.w	r3, r3, #32
 804932c:	76a3      	strb	r3, [r4, #26]
  pcb->snd_queuelen += pbuf_clen(seg->p);
 804932e:	6870      	ldr	r0, [r6, #4]
 8049330:	f7fc fe7e 	bl	8046030 <pbuf_clen>
 8049334:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
 8049338:	4418      	add	r0, r3
 804933a:	b280      	uxth	r0, r0
 804933c:	f8a4 0062 	strh.w	r0, [r4, #98]	; 0x62
  if (pcb->snd_queuelen != 0) {
 8049340:	2800      	cmp	r0, #0
 8049342:	d048      	beq.n	80493d6 <tcp_enqueue_flags+0x13e>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 8049344:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8049346:	2b00      	cmp	r3, #0
 8049348:	d038      	beq.n	80493bc <tcp_enqueue_flags+0x124>
  return ERR_OK;
 804934a:	2000      	movs	r0, #0
 804934c:	e044      	b.n	80493d8 <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 804934e:	4b24      	ldr	r3, [pc, #144]	; (80493e0 <tcp_enqueue_flags+0x148>)
 8049350:	f240 321a 	movw	r2, #794	; 0x31a
 8049354:	4923      	ldr	r1, [pc, #140]	; (80493e4 <tcp_enqueue_flags+0x14c>)
 8049356:	4824      	ldr	r0, [pc, #144]	; (80493e8 <tcp_enqueue_flags+0x150>)
 8049358:	f007 ff48 	bl	80511ec <printf>
 804935c:	e7a4      	b.n	80492a8 <tcp_enqueue_flags+0x10>
    pcb->flags |= TF_NAGLEMEMERR;
 804935e:	7ea3      	ldrb	r3, [r4, #26]
 8049360:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8049364:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 8049366:	f04f 30ff 	mov.w	r0, #4294967295
 804936a:	e035      	b.n	80493d8 <tcp_enqueue_flags+0x140>
    pcb->flags |= TF_NAGLEMEMERR;
 804936c:	7ea3      	ldrb	r3, [r4, #26]
 804936e:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8049372:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 8049374:	f04f 30ff 	mov.w	r0, #4294967295
 8049378:	e02e      	b.n	80493d8 <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 804937a:	4b19      	ldr	r3, [pc, #100]	; (80493e0 <tcp_enqueue_flags+0x148>)
 804937c:	f44f 7250 	mov.w	r2, #832	; 0x340
 8049380:	491a      	ldr	r1, [pc, #104]	; (80493ec <tcp_enqueue_flags+0x154>)
 8049382:	4819      	ldr	r0, [pc, #100]	; (80493e8 <tcp_enqueue_flags+0x150>)
 8049384:	f007 ff32 	bl	80511ec <printf>
 8049388:	e7a9      	b.n	80492de <tcp_enqueue_flags+0x46>
    pcb->flags |= TF_NAGLEMEMERR;
 804938a:	7ea3      	ldrb	r3, [r4, #26]
 804938c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8049390:	76a3      	strb	r3, [r4, #26]
    return ERR_MEM;
 8049392:	f04f 30ff 	mov.w	r0, #4294967295
 8049396:	e01f      	b.n	80493d8 <tcp_enqueue_flags+0x140>
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
 8049398:	4b11      	ldr	r3, [pc, #68]	; (80493e0 <tcp_enqueue_flags+0x148>)
 804939a:	f240 3249 	movw	r2, #841	; 0x349
 804939e:	4914      	ldr	r1, [pc, #80]	; (80493f0 <tcp_enqueue_flags+0x158>)
 80493a0:	4811      	ldr	r0, [pc, #68]	; (80493e8 <tcp_enqueue_flags+0x150>)
 80493a2:	f007 ff23 	bl	80511ec <printf>
 80493a6:	e7a9      	b.n	80492fc <tcp_enqueue_flags+0x64>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 80493a8:	4b0d      	ldr	r3, [pc, #52]	; (80493e0 <tcp_enqueue_flags+0x148>)
 80493aa:	f240 324a 	movw	r2, #842	; 0x34a
 80493ae:	4911      	ldr	r1, [pc, #68]	; (80493f4 <tcp_enqueue_flags+0x15c>)
 80493b0:	480d      	ldr	r0, [pc, #52]	; (80493e8 <tcp_enqueue_flags+0x150>)
 80493b2:	f007 ff1b 	bl	80511ec <printf>
 80493b6:	e7a4      	b.n	8049302 <tcp_enqueue_flags+0x6a>
    pcb->unsent = seg;
 80493b8:	66a6      	str	r6, [r4, #104]	; 0x68
 80493ba:	e7aa      	b.n	8049312 <tcp_enqueue_flags+0x7a>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 80493bc:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80493be:	b10b      	cbz	r3, 80493c4 <tcp_enqueue_flags+0x12c>
  return ERR_OK;
 80493c0:	2000      	movs	r0, #0
 80493c2:	e009      	b.n	80493d8 <tcp_enqueue_flags+0x140>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 80493c4:	4b06      	ldr	r3, [pc, #24]	; (80493e0 <tcp_enqueue_flags+0x148>)
 80493c6:	f44f 725b 	mov.w	r2, #876	; 0x36c
 80493ca:	490b      	ldr	r1, [pc, #44]	; (80493f8 <tcp_enqueue_flags+0x160>)
 80493cc:	4806      	ldr	r0, [pc, #24]	; (80493e8 <tcp_enqueue_flags+0x150>)
 80493ce:	f007 ff0d 	bl	80511ec <printf>
  return ERR_OK;
 80493d2:	2000      	movs	r0, #0
 80493d4:	e000      	b.n	80493d8 <tcp_enqueue_flags+0x140>
 80493d6:	2000      	movs	r0, #0
}
 80493d8:	b003      	add	sp, #12
 80493da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80493de:	bf00      	nop
 80493e0:	08059534 	.word	0x08059534
 80493e4:	08059810 	.word	0x08059810
 80493e8:	08058644 	.word	0x08058644
 80493ec:	08059868 	.word	0x08059868
 80493f0:	080598a4 	.word	0x080598a4
 80493f4:	080598bc 	.word	0x080598bc
 80493f8:	080598e8 	.word	0x080598e8

080493fc <tcp_send_fin>:
{
 80493fc:	b570      	push	{r4, r5, r6, lr}
 80493fe:	4605      	mov	r5, r0
  if (pcb->unsent != NULL) {
 8049400:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8049402:	b153      	cbz	r3, 804941a <tcp_send_fin+0x1e>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 8049404:	461c      	mov	r4, r3
 8049406:	681b      	ldr	r3, [r3, #0]
 8049408:	2b00      	cmp	r3, #0
 804940a:	d1fb      	bne.n	8049404 <tcp_send_fin+0x8>
    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 804940c:	68e3      	ldr	r3, [r4, #12]
 804940e:	8998      	ldrh	r0, [r3, #12]
 8049410:	f7fc f80c 	bl	804542c <lwip_htons>
 8049414:	f010 0f07 	tst.w	r0, #7
 8049418:	d004      	beq.n	8049424 <tcp_send_fin+0x28>
  return tcp_enqueue_flags(pcb, TCP_FIN);
 804941a:	2101      	movs	r1, #1
 804941c:	4628      	mov	r0, r5
 804941e:	f7ff ff3b 	bl	8049298 <tcp_enqueue_flags>
}
 8049422:	bd70      	pop	{r4, r5, r6, pc}
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 8049424:	68e3      	ldr	r3, [r4, #12]
 8049426:	899e      	ldrh	r6, [r3, #12]
 8049428:	2001      	movs	r0, #1
 804942a:	f7fb ffff 	bl	804542c <lwip_htons>
 804942e:	68e3      	ldr	r3, [r4, #12]
 8049430:	4306      	orrs	r6, r0
 8049432:	819e      	strh	r6, [r3, #12]
      pcb->flags |= TF_FIN;
 8049434:	7eab      	ldrb	r3, [r5, #26]
 8049436:	f043 0320 	orr.w	r3, r3, #32
 804943a:	76ab      	strb	r3, [r5, #26]
      return ERR_OK;
 804943c:	2000      	movs	r0, #0
 804943e:	e7f0      	b.n	8049422 <tcp_send_fin+0x26>

08049440 <tcp_send_empty_ack>:
{
 8049440:	b570      	push	{r4, r5, r6, lr}
 8049442:	b084      	sub	sp, #16
 8049444:	4604      	mov	r4, r0
  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
 8049446:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8049448:	f7fb fff3 	bl	8045432 <lwip_htonl>
 804944c:	4603      	mov	r3, r0
 804944e:	2200      	movs	r2, #0
 8049450:	4611      	mov	r1, r2
 8049452:	4620      	mov	r0, r4
 8049454:	f7ff fbce 	bl	8048bf4 <tcp_output_alloc_header>
  if (p == NULL) {
 8049458:	b1e0      	cbz	r0, 8049494 <tcp_send_empty_ack+0x54>
 804945a:	4606      	mov	r6, r0
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 804945c:	1d25      	adds	r5, r4, #4
 804945e:	4628      	mov	r0, r5
 8049460:	f001 fa24 	bl	804a8ac <ip4_route>
  if (netif == NULL) {
 8049464:	b1e8      	cbz	r0, 80494a2 <tcp_send_empty_ack+0x62>
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
 8049466:	9002      	str	r0, [sp, #8]
 8049468:	2306      	movs	r3, #6
 804946a:	9301      	str	r3, [sp, #4]
 804946c:	7a63      	ldrb	r3, [r4, #9]
 804946e:	9300      	str	r3, [sp, #0]
 8049470:	7aa3      	ldrb	r3, [r4, #10]
 8049472:	462a      	mov	r2, r5
 8049474:	4621      	mov	r1, r4
 8049476:	4630      	mov	r0, r6
 8049478:	f001 fba0 	bl	804abbc <ip4_output_if>
 804947c:	4605      	mov	r5, r0
  pbuf_free(p);
 804947e:	4630      	mov	r0, r6
 8049480:	f7fc fc0a 	bl	8045c98 <pbuf_free>
  if (err != ERR_OK) {
 8049484:	b185      	cbz	r5, 80494a8 <tcp_send_empty_ack+0x68>
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 8049486:	7ea3      	ldrb	r3, [r4, #26]
 8049488:	f043 0303 	orr.w	r3, r3, #3
 804948c:	76a3      	strb	r3, [r4, #26]
}
 804948e:	4628      	mov	r0, r5
 8049490:	b004      	add	sp, #16
 8049492:	bd70      	pop	{r4, r5, r6, pc}
    pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
 8049494:	7ea3      	ldrb	r3, [r4, #26]
 8049496:	f043 0303 	orr.w	r3, r3, #3
 804949a:	76a3      	strb	r3, [r4, #26]
    return ERR_BUF;
 804949c:	f06f 0501 	mvn.w	r5, #1
 80494a0:	e7f5      	b.n	804948e <tcp_send_empty_ack+0x4e>
    err = ERR_RTE;
 80494a2:	f06f 0503 	mvn.w	r5, #3
 80494a6:	e7ea      	b.n	804947e <tcp_send_empty_ack+0x3e>
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80494a8:	7ea3      	ldrb	r3, [r4, #26]
 80494aa:	f023 0303 	bic.w	r3, r3, #3
 80494ae:	76a3      	strb	r3, [r4, #26]
 80494b0:	e7ed      	b.n	804948e <tcp_send_empty_ack+0x4e>
	...

080494b4 <tcp_output>:
{
 80494b4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80494b8:	4605      	mov	r5, r0
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 80494ba:	7d03      	ldrb	r3, [r0, #20]
 80494bc:	2b01      	cmp	r3, #1
 80494be:	d054      	beq.n	804956a <tcp_output+0xb6>
  if (tcp_input_pcb == pcb) {
 80494c0:	4b9b      	ldr	r3, [pc, #620]	; (8049730 <tcp_output+0x27c>)
 80494c2:	681b      	ldr	r3, [r3, #0]
 80494c4:	42ab      	cmp	r3, r5
 80494c6:	f000 812b 	beq.w	8049720 <tcp_output+0x26c>
  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 80494ca:	f8b5 9048 	ldrh.w	r9, [r5, #72]	; 0x48
 80494ce:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
 80494d2:	4599      	cmp	r9, r3
 80494d4:	bf28      	it	cs
 80494d6:	4699      	movcs	r9, r3
 80494d8:	46c8      	mov	r8, r9
  seg = pcb->unsent;
 80494da:	6eac      	ldr	r4, [r5, #104]	; 0x68
  if (pcb->flags & TF_ACK_NOW &&
 80494dc:	7eab      	ldrb	r3, [r5, #26]
 80494de:	f013 0f02 	tst.w	r3, #2
 80494e2:	d00b      	beq.n	80494fc <tcp_output+0x48>
 80494e4:	2c00      	cmp	r4, #0
 80494e6:	d048      	beq.n	804957a <tcp_output+0xc6>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 80494e8:	68e3      	ldr	r3, [r4, #12]
 80494ea:	6858      	ldr	r0, [r3, #4]
 80494ec:	f7fb ffa1 	bl	8045432 <lwip_htonl>
 80494f0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80494f2:	1ac3      	subs	r3, r0, r3
 80494f4:	8922      	ldrh	r2, [r4, #8]
 80494f6:	4413      	add	r3, r2
     (seg == NULL ||
 80494f8:	454b      	cmp	r3, r9
 80494fa:	d83e      	bhi.n	804957a <tcp_output+0xc6>
  useg = pcb->unacked;
 80494fc:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  if (useg != NULL) {
 80494fe:	2b00      	cmp	r3, #0
 8049500:	d040      	beq.n	8049584 <tcp_output+0xd0>
    for (; useg->next != NULL; useg = useg->next);
 8049502:	461e      	mov	r6, r3
 8049504:	681b      	ldr	r3, [r3, #0]
 8049506:	2b00      	cmp	r3, #0
 8049508:	d1fb      	bne.n	8049502 <tcp_output+0x4e>
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 804950a:	1d28      	adds	r0, r5, #4
 804950c:	f001 f9ce 	bl	804a8ac <ip4_route>
  if (netif == NULL) {
 8049510:	4607      	mov	r7, r0
 8049512:	2800      	cmp	r0, #0
 8049514:	f000 8106 	beq.w	8049724 <tcp_output+0x270>
  if (ip_addr_isany(&pcb->local_ip)) {
 8049518:	b10d      	cbz	r5, 804951e <tcp_output+0x6a>
 804951a:	682b      	ldr	r3, [r5, #0]
 804951c:	b92b      	cbnz	r3, 804952a <tcp_output+0x76>
    if (local_ip == NULL) {
 804951e:	f117 0f04 	cmn.w	r7, #4
 8049522:	f000 8102 	beq.w	804972a <tcp_output+0x276>
    ip_addr_copy(pcb->local_ip, *local_ip);
 8049526:	687b      	ldr	r3, [r7, #4]
 8049528:	602b      	str	r3, [r5, #0]
  if (seg != NULL &&
 804952a:	2c00      	cmp	r4, #0
 804952c:	f000 8089 	beq.w	8049642 <tcp_output+0x18e>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 8049530:	68e3      	ldr	r3, [r4, #12]
 8049532:	6858      	ldr	r0, [r3, #4]
 8049534:	f7fb ff7d 	bl	8045432 <lwip_htonl>
 8049538:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 804953a:	1ac3      	subs	r3, r0, r3
 804953c:	8922      	ldrh	r2, [r4, #8]
 804953e:	4413      	add	r3, r2
  if (seg != NULL &&
 8049540:	454b      	cmp	r3, r9
 8049542:	d97e      	bls.n	8049642 <tcp_output+0x18e>
      lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
 8049544:	f1b9 0f00 	cmp.w	r9, #0
 8049548:	d07b      	beq.n	8049642 <tcp_output+0x18e>
      wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
 804954a:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
 804954e:	4599      	cmp	r9, r3
 8049550:	d177      	bne.n	8049642 <tcp_output+0x18e>
 8049552:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 8049554:	2b00      	cmp	r3, #0
 8049556:	d174      	bne.n	8049642 <tcp_output+0x18e>
    if (pcb->persist_backoff == 0) {
 8049558:	f895 3095 	ldrb.w	r3, [r5, #149]	; 0x95
 804955c:	bb5b      	cbnz	r3, 80495b6 <tcp_output+0x102>
      pcb->persist_cnt = 0;
 804955e:	f885 3094 	strb.w	r3, [r5, #148]	; 0x94
      pcb->persist_backoff = 1;
 8049562:	2301      	movs	r3, #1
 8049564:	f885 3095 	strb.w	r3, [r5, #149]	; 0x95
    goto output_done;
 8049568:	e025      	b.n	80495b6 <tcp_output+0x102>
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 804956a:	4b72      	ldr	r3, [pc, #456]	; (8049734 <tcp_output+0x280>)
 804956c:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 8049570:	4971      	ldr	r1, [pc, #452]	; (8049738 <tcp_output+0x284>)
 8049572:	4872      	ldr	r0, [pc, #456]	; (804973c <tcp_output+0x288>)
 8049574:	f007 fe3a 	bl	80511ec <printf>
 8049578:	e7a2      	b.n	80494c0 <tcp_output+0xc>
     return tcp_send_empty_ack(pcb);
 804957a:	4628      	mov	r0, r5
 804957c:	f7ff ff60 	bl	8049440 <tcp_send_empty_ack>
 8049580:	4603      	mov	r3, r0
 8049582:	e021      	b.n	80495c8 <tcp_output+0x114>
  useg = pcb->unacked;
 8049584:	461e      	mov	r6, r3
 8049586:	e7c0      	b.n	804950a <tcp_output+0x56>
    LWIP_ASSERT("RST not expected here!",
 8049588:	4b6a      	ldr	r3, [pc, #424]	; (8049734 <tcp_output+0x280>)
 804958a:	f240 4245 	movw	r2, #1093	; 0x445
 804958e:	496c      	ldr	r1, [pc, #432]	; (8049740 <tcp_output+0x28c>)
 8049590:	486a      	ldr	r0, [pc, #424]	; (804973c <tcp_output+0x288>)
 8049592:	f007 fe2b 	bl	80511ec <printf>
 8049596:	e067      	b.n	8049668 <tcp_output+0x1b4>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8049598:	8911      	ldrh	r1, [r2, #8]
 804959a:	8e6a      	ldrh	r2, [r5, #50]	; 0x32
 804959c:	4291      	cmp	r1, r2
 804959e:	d26f      	bcs.n	8049680 <tcp_output+0x1cc>
 80495a0:	f8b5 2060 	ldrh.w	r2, [r5, #96]	; 0x60
 80495a4:	2a00      	cmp	r2, #0
 80495a6:	d06b      	beq.n	8049680 <tcp_output+0x1cc>
 80495a8:	f8b5 2062 	ldrh.w	r2, [r5, #98]	; 0x62
 80495ac:	2a08      	cmp	r2, #8
 80495ae:	d867      	bhi.n	8049680 <tcp_output+0x1cc>
 80495b0:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 80495b4:	d164      	bne.n	8049680 <tcp_output+0x1cc>
  if (pcb->unsent == NULL) {
 80495b6:	6eab      	ldr	r3, [r5, #104]	; 0x68
 80495b8:	2b00      	cmp	r3, #0
 80495ba:	f000 80ae 	beq.w	804971a <tcp_output+0x266>
  pcb->flags &= ~TF_NAGLEMEMERR;
 80495be:	7eab      	ldrb	r3, [r5, #26]
 80495c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80495c4:	76ab      	strb	r3, [r5, #26]
  return ERR_OK;
 80495c6:	2300      	movs	r3, #0
}
 80495c8:	4618      	mov	r0, r3
 80495ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 80495ce:	68e3      	ldr	r3, [r4, #12]
 80495d0:	f8b3 900c 	ldrh.w	r9, [r3, #12]
 80495d4:	2010      	movs	r0, #16
 80495d6:	f7fb ff29 	bl	804542c <lwip_htons>
 80495da:	68e3      	ldr	r3, [r4, #12]
 80495dc:	ea49 0900 	orr.w	r9, r9, r0
 80495e0:	f8a3 900c 	strh.w	r9, [r3, #12]
 80495e4:	e04f      	b.n	8049686 <tcp_output+0x1d2>
      pcb->flags |= TF_NAGLEMEMERR;
 80495e6:	7eaa      	ldrb	r2, [r5, #26]
 80495e8:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80495ec:	76aa      	strb	r2, [r5, #26]
      return err;
 80495ee:	e7eb      	b.n	80495c8 <tcp_output+0x114>
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80495f0:	2000      	movs	r0, #0
 80495f2:	e068      	b.n	80496c6 <tcp_output+0x212>
      pcb->snd_nxt = snd_nxt;
 80495f4:	64e8      	str	r0, [r5, #76]	; 0x4c
 80495f6:	e06c      	b.n	80496d2 <tcp_output+0x21e>
    if (TCP_TCPLEN(seg) > 0) {
 80495f8:	2300      	movs	r3, #0
 80495fa:	e074      	b.n	80496e6 <tcp_output+0x232>
        pcb->unacked = seg;
 80495fc:	66ec      	str	r4, [r5, #108]	; 0x6c
        useg = seg;
 80495fe:	4626      	mov	r6, r4
 8049600:	e01e      	b.n	8049640 <tcp_output+0x18c>
          struct tcp_seg **cur_seg = &(pcb->unacked);
 8049602:	f105 0a6c 	add.w	sl, r5, #108	; 0x6c
          while (*cur_seg &&
 8049606:	f8da 3000 	ldr.w	r3, [sl]
 804960a:	b183      	cbz	r3, 804962e <tcp_output+0x17a>
            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 804960c:	68db      	ldr	r3, [r3, #12]
 804960e:	6858      	ldr	r0, [r3, #4]
 8049610:	f7fb ff0f 	bl	8045432 <lwip_htonl>
 8049614:	4681      	mov	r9, r0
 8049616:	68e3      	ldr	r3, [r4, #12]
 8049618:	6858      	ldr	r0, [r3, #4]
 804961a:	f7fb ff0a 	bl	8045432 <lwip_htonl>
 804961e:	eba9 0900 	sub.w	r9, r9, r0
          while (*cur_seg &&
 8049622:	f1b9 0f00 	cmp.w	r9, #0
 8049626:	da02      	bge.n	804962e <tcp_output+0x17a>
              cur_seg = &((*cur_seg)->next );
 8049628:	f8da a000 	ldr.w	sl, [sl]
 804962c:	e7eb      	b.n	8049606 <tcp_output+0x152>
          seg->next = (*cur_seg);
 804962e:	f8da 3000 	ldr.w	r3, [sl]
 8049632:	6023      	str	r3, [r4, #0]
          (*cur_seg) = seg;
 8049634:	f8ca 4000 	str.w	r4, [sl]
 8049638:	e002      	b.n	8049640 <tcp_output+0x18c>
      tcp_seg_free(seg);
 804963a:	4620      	mov	r0, r4
 804963c:	f7fd f810 	bl	8046660 <tcp_seg_free>
    seg = pcb->unsent;
 8049640:	6eac      	ldr	r4, [r5, #104]	; 0x68
  while (seg != NULL &&
 8049642:	2c00      	cmp	r4, #0
 8049644:	d0b7      	beq.n	80495b6 <tcp_output+0x102>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 8049646:	68e3      	ldr	r3, [r4, #12]
 8049648:	6858      	ldr	r0, [r3, #4]
 804964a:	f7fb fef2 	bl	8045432 <lwip_htonl>
 804964e:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8049650:	1ac0      	subs	r0, r0, r3
 8049652:	8923      	ldrh	r3, [r4, #8]
 8049654:	4418      	add	r0, r3
  while (seg != NULL &&
 8049656:	4540      	cmp	r0, r8
 8049658:	d8ad      	bhi.n	80495b6 <tcp_output+0x102>
    LWIP_ASSERT("RST not expected here!",
 804965a:	68e3      	ldr	r3, [r4, #12]
 804965c:	8998      	ldrh	r0, [r3, #12]
 804965e:	f7fb fee5 	bl	804542c <lwip_htons>
 8049662:	f010 0f04 	tst.w	r0, #4
 8049666:	d18f      	bne.n	8049588 <tcp_output+0xd4>
    if ((tcp_do_output_nagle(pcb) == 0) &&
 8049668:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 804966a:	b14b      	cbz	r3, 8049680 <tcp_output+0x1cc>
 804966c:	7eab      	ldrb	r3, [r5, #26]
 804966e:	f013 0f44 	tst.w	r3, #68	; 0x44
 8049672:	d105      	bne.n	8049680 <tcp_output+0x1cc>
 8049674:	6eaa      	ldr	r2, [r5, #104]	; 0x68
 8049676:	2a00      	cmp	r2, #0
 8049678:	d092      	beq.n	80495a0 <tcp_output+0xec>
 804967a:	6811      	ldr	r1, [r2, #0]
 804967c:	2900      	cmp	r1, #0
 804967e:	d08b      	beq.n	8049598 <tcp_output+0xe4>
    if (pcb->state != SYN_SENT) {
 8049680:	7d2b      	ldrb	r3, [r5, #20]
 8049682:	2b02      	cmp	r3, #2
 8049684:	d1a3      	bne.n	80495ce <tcp_output+0x11a>
    err = tcp_output_segment(seg, pcb, netif);
 8049686:	463a      	mov	r2, r7
 8049688:	4629      	mov	r1, r5
 804968a:	4620      	mov	r0, r4
 804968c:	f7ff fafc 	bl	8048c88 <tcp_output_segment>
    if (err != ERR_OK) {
 8049690:	4603      	mov	r3, r0
 8049692:	2800      	cmp	r0, #0
 8049694:	d1a7      	bne.n	80495e6 <tcp_output+0x132>
    pcb->unsent = seg->next;
 8049696:	6823      	ldr	r3, [r4, #0]
 8049698:	66ab      	str	r3, [r5, #104]	; 0x68
    if (pcb->state != SYN_SENT) {
 804969a:	7d2b      	ldrb	r3, [r5, #20]
 804969c:	2b02      	cmp	r3, #2
 804969e:	d003      	beq.n	80496a8 <tcp_output+0x1f4>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 80496a0:	7eab      	ldrb	r3, [r5, #26]
 80496a2:	f023 0303 	bic.w	r3, r3, #3
 80496a6:	76ab      	strb	r3, [r5, #26]
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 80496a8:	68e3      	ldr	r3, [r4, #12]
 80496aa:	6858      	ldr	r0, [r3, #4]
 80496ac:	f7fb fec1 	bl	8045432 <lwip_htonl>
 80496b0:	4681      	mov	r9, r0
 80496b2:	f8b4 a008 	ldrh.w	sl, [r4, #8]
 80496b6:	68e3      	ldr	r3, [r4, #12]
 80496b8:	8998      	ldrh	r0, [r3, #12]
 80496ba:	f7fb feb7 	bl	804542c <lwip_htons>
 80496be:	f010 0f03 	tst.w	r0, #3
 80496c2:	d095      	beq.n	80495f0 <tcp_output+0x13c>
 80496c4:	2001      	movs	r0, #1
 80496c6:	4450      	add	r0, sl
 80496c8:	4448      	add	r0, r9
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 80496ca:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 80496cc:	1a1b      	subs	r3, r3, r0
 80496ce:	2b00      	cmp	r3, #0
 80496d0:	db90      	blt.n	80495f4 <tcp_output+0x140>
    if (TCP_TCPLEN(seg) > 0) {
 80496d2:	f8b4 9008 	ldrh.w	r9, [r4, #8]
 80496d6:	68e3      	ldr	r3, [r4, #12]
 80496d8:	8998      	ldrh	r0, [r3, #12]
 80496da:	f7fb fea7 	bl	804542c <lwip_htons>
 80496de:	f010 0f03 	tst.w	r0, #3
 80496e2:	d089      	beq.n	80495f8 <tcp_output+0x144>
 80496e4:	2301      	movs	r3, #1
 80496e6:	eb19 0f03 	cmn.w	r9, r3
 80496ea:	d0a6      	beq.n	804963a <tcp_output+0x186>
      seg->next = NULL;
 80496ec:	2300      	movs	r3, #0
 80496ee:	6023      	str	r3, [r4, #0]
      if (pcb->unacked == NULL) {
 80496f0:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 80496f2:	2b00      	cmp	r3, #0
 80496f4:	d082      	beq.n	80495fc <tcp_output+0x148>
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
 80496f6:	68e3      	ldr	r3, [r4, #12]
 80496f8:	6858      	ldr	r0, [r3, #4]
 80496fa:	f7fb fe9a 	bl	8045432 <lwip_htonl>
 80496fe:	4681      	mov	r9, r0
 8049700:	68f3      	ldr	r3, [r6, #12]
 8049702:	6858      	ldr	r0, [r3, #4]
 8049704:	f7fb fe95 	bl	8045432 <lwip_htonl>
 8049708:	eba9 0900 	sub.w	r9, r9, r0
 804970c:	f1b9 0f00 	cmp.w	r9, #0
 8049710:	f6ff af77 	blt.w	8049602 <tcp_output+0x14e>
          useg->next = seg;
 8049714:	6034      	str	r4, [r6, #0]
          useg = useg->next;
 8049716:	4626      	mov	r6, r4
 8049718:	e792      	b.n	8049640 <tcp_output+0x18c>
    pcb->unsent_oversize = 0;
 804971a:	f8a5 3064 	strh.w	r3, [r5, #100]	; 0x64
 804971e:	e74e      	b.n	80495be <tcp_output+0x10a>
    return ERR_OK;
 8049720:	2300      	movs	r3, #0
 8049722:	e751      	b.n	80495c8 <tcp_output+0x114>
    return ERR_RTE;
 8049724:	f06f 0303 	mvn.w	r3, #3
 8049728:	e74e      	b.n	80495c8 <tcp_output+0x114>
      return ERR_RTE;
 804972a:	f06f 0303 	mvn.w	r3, #3
 804972e:	e74b      	b.n	80495c8 <tcp_output+0x114>
 8049730:	200089b0 	.word	0x200089b0
 8049734:	08059534 	.word	0x08059534
 8049738:	08059910 	.word	0x08059910
 804973c:	08058644 	.word	0x08058644
 8049740:	08059938 	.word	0x08059938

08049744 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 8049744:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8049748:	b085      	sub	sp, #20
 804974a:	4680      	mov	r8, r0
 804974c:	460f      	mov	r7, r1
 804974e:	4691      	mov	r9, r2
 8049750:	461d      	mov	r5, r3
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  struct netif *netif;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 8049752:	2200      	movs	r2, #0
 8049754:	2114      	movs	r1, #20
 8049756:	2001      	movs	r0, #1
 8049758:	f7fc fb02 	bl	8045d60 <pbuf_alloc>
  if (p == NULL) {
 804975c:	b3b0      	cbz	r0, 80497cc <tcp_rst+0x88>
 804975e:	4606      	mov	r6, r0
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 8049760:	8943      	ldrh	r3, [r0, #10]
 8049762:	2b13      	cmp	r3, #19
 8049764:	d935      	bls.n	80497d2 <tcp_rst+0x8e>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 8049766:	6874      	ldr	r4, [r6, #4]
  tcphdr->src = lwip_htons(local_port);
 8049768:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
 804976c:	f7fb fe5e 	bl	804542c <lwip_htons>
 8049770:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = lwip_htons(remote_port);
 8049772:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 8049776:	f7fb fe59 	bl	804542c <lwip_htons>
 804977a:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = lwip_htonl(seqno);
 804977c:	4640      	mov	r0, r8
 804977e:	f7fb fe58 	bl	8045432 <lwip_htonl>
 8049782:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = lwip_htonl(ackno);
 8049784:	4638      	mov	r0, r7
 8049786:	f7fb fe54 	bl	8045432 <lwip_htonl>
 804978a:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 804978c:	f245 0014 	movw	r0, #20500	; 0x5014
 8049790:	f7fb fe4c 	bl	804542c <lwip_htons>
 8049794:	81a0      	strh	r0, [r4, #12]
#if LWIP_WND_SCALE
  tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  tcphdr->wnd = PP_HTONS(TCP_WND);
 8049796:	2300      	movs	r3, #0
 8049798:	2208      	movs	r2, #8
 804979a:	73a2      	strb	r2, [r4, #14]
 804979c:	2260      	movs	r2, #96	; 0x60
 804979e:	73e2      	strb	r2, [r4, #15]
#endif
  tcphdr->chksum = 0;
 80497a0:	7423      	strb	r3, [r4, #16]
 80497a2:	7463      	strb	r3, [r4, #17]
  tcphdr->urgp = 0;
 80497a4:	74a3      	strb	r3, [r4, #18]
 80497a6:	74e3      	strb	r3, [r4, #19]

  TCP_STATS_INC(tcp.xmit);
  MIB2_STATS_INC(mib2.tcpoutrsts);

  netif = ip_route(local_ip, remote_ip);
 80497a8:	4628      	mov	r0, r5
 80497aa:	f001 f87f 	bl	804a8ac <ip4_route>
  if (netif != NULL) {
 80497ae:	b150      	cbz	r0, 80497c6 <tcp_rst+0x82>
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
                                        local_ip, remote_ip);
    }
#endif
    /* Send output with hardcoded TTL/HL since we have no access to the pcb */
    ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
 80497b0:	9002      	str	r0, [sp, #8]
 80497b2:	2306      	movs	r3, #6
 80497b4:	9301      	str	r3, [sp, #4]
 80497b6:	2300      	movs	r3, #0
 80497b8:	9300      	str	r3, [sp, #0]
 80497ba:	23ff      	movs	r3, #255	; 0xff
 80497bc:	462a      	mov	r2, r5
 80497be:	4649      	mov	r1, r9
 80497c0:	4630      	mov	r0, r6
 80497c2:	f001 f9fb 	bl	804abbc <ip4_output_if>
  }
  pbuf_free(p);
 80497c6:	4630      	mov	r0, r6
 80497c8:	f7fc fa66 	bl	8045c98 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 80497cc:	b005      	add	sp, #20
 80497ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 80497d2:	4b04      	ldr	r3, [pc, #16]	; (80497e4 <tcp_rst+0xa0>)
 80497d4:	f240 524c 	movw	r2, #1356	; 0x54c
 80497d8:	4903      	ldr	r1, [pc, #12]	; (80497e8 <tcp_rst+0xa4>)
 80497da:	4804      	ldr	r0, [pc, #16]	; (80497ec <tcp_rst+0xa8>)
 80497dc:	f007 fd06 	bl	80511ec <printf>
 80497e0:	e7c1      	b.n	8049766 <tcp_rst+0x22>
 80497e2:	bf00      	nop
 80497e4:	08059534 	.word	0x08059534
 80497e8:	08059604 	.word	0x08059604
 80497ec:	08058644 	.word	0x08058644

080497f0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 80497f0:	b508      	push	{r3, lr}
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 80497f2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80497f4:	b1a3      	cbz	r3, 8049820 <tcp_rexmit_rto+0x30>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 80497f6:	461a      	mov	r2, r3
 80497f8:	681b      	ldr	r3, [r3, #0]
 80497fa:	2b00      	cmp	r3, #0
 80497fc:	d1fb      	bne.n	80497f6 <tcp_rexmit_rto+0x6>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 80497fe:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8049800:	6013      	str	r3, [r2, #0]
  if (pcb->unsent == NULL) {
    pcb->unsent_oversize = seg->oversize_left;
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 8049802:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8049804:	6683      	str	r3, [r0, #104]	; 0x68
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 8049806:	2300      	movs	r3, #0
 8049808:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
 804980a:	f890 3042 	ldrb.w	r3, [r0, #66]	; 0x42
 804980e:	2bff      	cmp	r3, #255	; 0xff
 8049810:	d002      	beq.n	8049818 <tcp_rexmit_rto+0x28>
    ++pcb->nrtx;
 8049812:	3301      	adds	r3, #1
 8049814:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  }

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 8049818:	2300      	movs	r3, #0
 804981a:	6343      	str	r3, [r0, #52]	; 0x34

  /* Do the actual retransmission */
  tcp_output(pcb);
 804981c:	f7ff fe4a 	bl	80494b4 <tcp_output>
}
 8049820:	bd08      	pop	{r3, pc}

08049822 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 8049822:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 8049824:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
 8049826:	b316      	cbz	r6, 804986e <tcp_rexmit+0x4c>
 8049828:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 804982a:	6833      	ldr	r3, [r6, #0]
 804982c:	66c3      	str	r3, [r0, #108]	; 0x6c

  cur_seg = &(pcb->unsent);
 804982e:	f100 0568 	add.w	r5, r0, #104	; 0x68
  while (*cur_seg &&
 8049832:	682b      	ldr	r3, [r5, #0]
 8049834:	b16b      	cbz	r3, 8049852 <tcp_rexmit+0x30>
    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
 8049836:	68db      	ldr	r3, [r3, #12]
 8049838:	6858      	ldr	r0, [r3, #4]
 804983a:	f7fb fdfa 	bl	8045432 <lwip_htonl>
 804983e:	4604      	mov	r4, r0
 8049840:	68f3      	ldr	r3, [r6, #12]
 8049842:	6858      	ldr	r0, [r3, #4]
 8049844:	f7fb fdf5 	bl	8045432 <lwip_htonl>
 8049848:	1a24      	subs	r4, r4, r0
  while (*cur_seg &&
 804984a:	2c00      	cmp	r4, #0
 804984c:	da01      	bge.n	8049852 <tcp_rexmit+0x30>
      cur_seg = &((*cur_seg)->next );
 804984e:	682d      	ldr	r5, [r5, #0]
 8049850:	e7ef      	b.n	8049832 <tcp_rexmit+0x10>
  }
  seg->next = *cur_seg;
 8049852:	682b      	ldr	r3, [r5, #0]
 8049854:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 8049856:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 8049858:	6833      	ldr	r3, [r6, #0]
 804985a:	b14b      	cbz	r3, 8049870 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
 804985c:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 8049860:	2bff      	cmp	r3, #255	; 0xff
 8049862:	d002      	beq.n	804986a <tcp_rexmit+0x48>
    ++pcb->nrtx;
 8049864:	3301      	adds	r3, #1
 8049866:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 804986a:	2300      	movs	r3, #0
 804986c:	637b      	str	r3, [r7, #52]	; 0x34

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 804986e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pcb->unsent_oversize = 0;
 8049870:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 8049874:	e7f2      	b.n	804985c <tcp_rexmit+0x3a>

08049876 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 8049876:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8049878:	b33b      	cbz	r3, 80498ca <tcp_rexmit_fast+0x54>
{
 804987a:	b510      	push	{r4, lr}
 804987c:	4604      	mov	r4, r0
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 804987e:	7e83      	ldrb	r3, [r0, #26]
 8049880:	f013 0f04 	tst.w	r3, #4
 8049884:	d000      	beq.n	8049888 <tcp_rexmit_fast+0x12>
    pcb->flags |= TF_INFR;

    /* Reset the retransmission timer to prevent immediate rto retransmissions */
    pcb->rtime = 0;
  }
}
 8049886:	bd10      	pop	{r4, pc}
    tcp_rexmit(pcb);
 8049888:	f7ff ffcb 	bl	8049822 <tcp_rexmit>
    pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
 804988c:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
 8049890:	f8b4 2048 	ldrh.w	r2, [r4, #72]	; 0x48
 8049894:	4293      	cmp	r3, r2
 8049896:	bf28      	it	cs
 8049898:	4613      	movcs	r3, r2
 804989a:	085b      	lsrs	r3, r3, #1
 804989c:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    if (pcb->ssthresh < (2U * pcb->mss)) {
 80498a0:	8e62      	ldrh	r2, [r4, #50]	; 0x32
 80498a2:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
 80498a6:	d202      	bcs.n	80498ae <tcp_rexmit_fast+0x38>
      pcb->ssthresh = 2*pcb->mss;
 80498a8:	0053      	lsls	r3, r2, #1
 80498aa:	f8a4 304a 	strh.w	r3, [r4, #74]	; 0x4a
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 80498ae:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
 80498b2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80498b6:	441a      	add	r2, r3
 80498b8:	f8a4 2048 	strh.w	r2, [r4, #72]	; 0x48
    pcb->flags |= TF_INFR;
 80498bc:	7ea3      	ldrb	r3, [r4, #26]
 80498be:	f043 0304 	orr.w	r3, r3, #4
 80498c2:	76a3      	strb	r3, [r4, #26]
    pcb->rtime = 0;
 80498c4:	2300      	movs	r3, #0
 80498c6:	8623      	strh	r3, [r4, #48]	; 0x30
}
 80498c8:	e7dd      	b.n	8049886 <tcp_rexmit_fast+0x10>
 80498ca:	4770      	bx	lr

080498cc <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
 80498cc:	b570      	push	{r4, r5, r6, lr}
 80498ce:	b084      	sub	sp, #16
 80498d0:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
 80498d2:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 80498d4:	3801      	subs	r0, #1
 80498d6:	f7fb fdac 	bl	8045432 <lwip_htonl>
 80498da:	4603      	mov	r3, r0
 80498dc:	2200      	movs	r2, #0
 80498de:	4611      	mov	r1, r2
 80498e0:	4620      	mov	r0, r4
 80498e2:	f7ff f987 	bl	8048bf4 <tcp_output_alloc_header>
  if (p == NULL) {
 80498e6:	b1d0      	cbz	r0, 804991e <tcp_keepalive+0x52>
 80498e8:	4605      	mov	r5, r0
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
  }
  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 80498ea:	1d26      	adds	r6, r4, #4
 80498ec:	4630      	mov	r0, r6
 80498ee:	f000 ffdd 	bl	804a8ac <ip4_route>
  if (netif == NULL) {
 80498f2:	b188      	cbz	r0, 8049918 <tcp_keepalive+0x4c>
#endif /* CHECKSUM_GEN_TCP */
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
 80498f4:	9002      	str	r0, [sp, #8]
 80498f6:	2306      	movs	r3, #6
 80498f8:	9301      	str	r3, [sp, #4]
 80498fa:	2300      	movs	r3, #0
 80498fc:	9300      	str	r3, [sp, #0]
 80498fe:	7aa3      	ldrb	r3, [r4, #10]
 8049900:	4632      	mov	r2, r6
 8049902:	4621      	mov	r1, r4
 8049904:	4628      	mov	r0, r5
 8049906:	f001 f959 	bl	804abbc <ip4_output_if>
 804990a:	4604      	mov	r4, r0
    NETIF_SET_HWADDRHINT(netif, NULL);
  }
  pbuf_free(p);
 804990c:	4628      	mov	r0, r5
 804990e:	f7fc f9c3 	bl	8045c98 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 8049912:	4620      	mov	r0, r4
 8049914:	b004      	add	sp, #16
 8049916:	bd70      	pop	{r4, r5, r6, pc}
    err = ERR_RTE;
 8049918:	f06f 0403 	mvn.w	r4, #3
 804991c:	e7f6      	b.n	804990c <tcp_keepalive+0x40>
    return ERR_MEM;
 804991e:	f04f 34ff 	mov.w	r4, #4294967295
 8049922:	e7f6      	b.n	8049912 <tcp_keepalive+0x46>

08049924 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 8049924:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8049928:	b084      	sub	sp, #16
 804992a:	4604      	mov	r4, r0
  LWIP_DEBUGF(TCP_DEBUG,
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  seg = pcb->unacked;
 804992c:	6ec5      	ldr	r5, [r0, #108]	; 0x6c

  if (seg == NULL) {
 804992e:	b16d      	cbz	r5, 804994c <tcp_zero_window_probe+0x28>
    seg = pcb->unsent;
  }
  if (seg == NULL) {
 8049930:	2d00      	cmp	r5, #0
 8049932:	d05c      	beq.n	80499ee <tcp_zero_window_probe+0xca>
    /* nothing to send, zero window probe not needed */
    return ERR_OK;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8049934:	68eb      	ldr	r3, [r5, #12]
 8049936:	8998      	ldrh	r0, [r3, #12]
 8049938:	f7fb fd78 	bl	804542c <lwip_htons>
 804993c:	f010 0f01 	tst.w	r0, #1
 8049940:	d006      	beq.n	8049950 <tcp_zero_window_probe+0x2c>
 8049942:	892b      	ldrh	r3, [r5, #8]
 8049944:	2b00      	cmp	r3, #0
 8049946:	d040      	beq.n	80499ca <tcp_zero_window_probe+0xa6>
 8049948:	2200      	movs	r2, #0
 804994a:	e002      	b.n	8049952 <tcp_zero_window_probe+0x2e>
    seg = pcb->unsent;
 804994c:	6e85      	ldr	r5, [r0, #104]	; 0x68
 804994e:	e7ef      	b.n	8049930 <tcp_zero_window_probe+0xc>
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 8049950:	2200      	movs	r2, #0
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 8049952:	f002 06ff 	and.w	r6, r2, #255	; 0xff

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 8049956:	68eb      	ldr	r3, [r5, #12]
 8049958:	685b      	ldr	r3, [r3, #4]
 804995a:	f082 0201 	eor.w	r2, r2, #1
 804995e:	2100      	movs	r1, #0
 8049960:	4620      	mov	r0, r4
 8049962:	f7ff f947 	bl	8048bf4 <tcp_output_alloc_header>
  if (p == NULL) {
 8049966:	4607      	mov	r7, r0
 8049968:	2800      	cmp	r0, #0
 804996a:	d042      	beq.n	80499f2 <tcp_zero_window_probe+0xce>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 804996c:	f8d0 8004 	ldr.w	r8, [r0, #4]

  if (is_fin) {
 8049970:	b36e      	cbz	r6, 80499ce <tcp_zero_window_probe+0xaa>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 8049972:	f8b8 600c 	ldrh.w	r6, [r8, #12]
 8049976:	f426 567c 	bic.w	r6, r6, #16128	; 0x3f00
 804997a:	b2b6      	uxth	r6, r6
 804997c:	2011      	movs	r0, #17
 804997e:	f7fb fd55 	bl	804542c <lwip_htons>
 8049982:	4306      	orrs	r6, r0
 8049984:	f8a8 600c 	strh.w	r6, [r8, #12]
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
 8049988:	68eb      	ldr	r3, [r5, #12]
 804998a:	6858      	ldr	r0, [r3, #4]
 804998c:	f7fb fd51 	bl	8045432 <lwip_htonl>
 8049990:	3001      	adds	r0, #1
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 8049992:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8049994:	1a1b      	subs	r3, r3, r0
 8049996:	2b00      	cmp	r3, #0
 8049998:	db24      	blt.n	80499e4 <tcp_zero_window_probe+0xc0>
    pcb->snd_nxt = snd_nxt;
  }

  netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
 804999a:	1d25      	adds	r5, r4, #4
 804999c:	4628      	mov	r0, r5
 804999e:	f000 ff85 	bl	804a8ac <ip4_route>
  if (netif == NULL) {
 80499a2:	b308      	cbz	r0, 80499e8 <tcp_zero_window_probe+0xc4>
#endif
    TCP_STATS_INC(tcp.xmit);

    /* Send output to IP */
    NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
    err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
 80499a4:	9002      	str	r0, [sp, #8]
 80499a6:	2306      	movs	r3, #6
 80499a8:	9301      	str	r3, [sp, #4]
 80499aa:	2300      	movs	r3, #0
 80499ac:	9300      	str	r3, [sp, #0]
 80499ae:	7aa3      	ldrb	r3, [r4, #10]
 80499b0:	462a      	mov	r2, r5
 80499b2:	4621      	mov	r1, r4
 80499b4:	4638      	mov	r0, r7
 80499b6:	f001 f901 	bl	804abbc <ip4_output_if>
 80499ba:	4604      	mov	r4, r0
      0, IP_PROTO_TCP, netif);
    NETIF_SET_HWADDRHINT(netif, NULL);
  }

  pbuf_free(p);
 80499bc:	4638      	mov	r0, r7
 80499be:	f7fc f96b 	bl	8045c98 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
}
 80499c2:	4620      	mov	r0, r4
 80499c4:	b004      	add	sp, #16
 80499c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 80499ca:	2201      	movs	r2, #1
 80499cc:	e7c1      	b.n	8049952 <tcp_zero_window_probe+0x2e>
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 80499ce:	6868      	ldr	r0, [r5, #4]
 80499d0:	8903      	ldrh	r3, [r0, #8]
 80499d2:	892a      	ldrh	r2, [r5, #8]
 80499d4:	1a9b      	subs	r3, r3, r2
 80499d6:	b29b      	uxth	r3, r3
 80499d8:	2201      	movs	r2, #1
 80499da:	f108 0114 	add.w	r1, r8, #20
 80499de:	f7fc fc19 	bl	8046214 <pbuf_copy_partial>
 80499e2:	e7d1      	b.n	8049988 <tcp_zero_window_probe+0x64>
    pcb->snd_nxt = snd_nxt;
 80499e4:	64e0      	str	r0, [r4, #76]	; 0x4c
 80499e6:	e7d8      	b.n	804999a <tcp_zero_window_probe+0x76>
    err = ERR_RTE;
 80499e8:	f06f 0403 	mvn.w	r4, #3
 80499ec:	e7e6      	b.n	80499bc <tcp_zero_window_probe+0x98>
    return ERR_OK;
 80499ee:	2400      	movs	r4, #0
 80499f0:	e7e7      	b.n	80499c2 <tcp_zero_window_probe+0x9e>
    return ERR_MEM;
 80499f2:	f04f 34ff 	mov.w	r4, #4294967295
 80499f6:	e7e4      	b.n	80499c2 <tcp_zero_window_probe+0x9e>

080499f8 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 80499f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80499fc:	4605      	mov	r5, r0
 80499fe:	4688      	mov	r8, r1
 8049a00:	4617      	mov	r7, r2
  struct sys_timeo *timeout, *t;
  u32_t now, diff;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 8049a02:	2006      	movs	r0, #6
 8049a04:	f7fb ff7a 	bl	80458fc <memp_malloc>
  if (timeout == NULL) {
 8049a08:	b1d0      	cbz	r0, 8049a40 <sys_timeout+0x48>
 8049a0a:	4604      	mov	r4, r0
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }

  now = sys_now();
 8049a0c:	f002 f884 	bl	804bb18 <sys_now>
  if (next_timeout == NULL) {
 8049a10:	4b20      	ldr	r3, [pc, #128]	; (8049a94 <sys_timeout+0x9c>)
 8049a12:	681e      	ldr	r6, [r3, #0]
 8049a14:	b1de      	cbz	r6, 8049a4e <sys_timeout+0x56>
    diff = 0;
    timeouts_last_time = now;
  } else {
    diff = now - timeouts_last_time;
 8049a16:	4b1f      	ldr	r3, [pc, #124]	; (8049a94 <sys_timeout+0x9c>)
 8049a18:	685b      	ldr	r3, [r3, #4]
 8049a1a:	1ac3      	subs	r3, r0, r3
  }

  timeout->next = NULL;
 8049a1c:	2200      	movs	r2, #0
 8049a1e:	6022      	str	r2, [r4, #0]
  timeout->h = handler;
 8049a20:	f8c4 8008 	str.w	r8, [r4, #8]
  timeout->arg = arg;
 8049a24:	60e7      	str	r7, [r4, #12]
  timeout->time = msecs + diff;
 8049a26:	442b      	add	r3, r5
 8049a28:	6063      	str	r3, [r4, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 8049a2a:	b19e      	cbz	r6, 8049a54 <sys_timeout+0x5c>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 8049a2c:	6870      	ldr	r0, [r6, #4]
 8049a2e:	42a8      	cmp	r0, r5
 8049a30:	d921      	bls.n	8049a76 <sys_timeout+0x7e>
    next_timeout->time -= msecs;
 8049a32:	1b40      	subs	r0, r0, r5
 8049a34:	6070      	str	r0, [r6, #4]
    timeout->next = next_timeout;
 8049a36:	6026      	str	r6, [r4, #0]
    next_timeout = timeout;
 8049a38:	4b16      	ldr	r3, [pc, #88]	; (8049a94 <sys_timeout+0x9c>)
 8049a3a:	601c      	str	r4, [r3, #0]
        t->next = timeout;
        break;
      }
    }
  }
}
 8049a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 8049a40:	4b15      	ldr	r3, [pc, #84]	; (8049a98 <sys_timeout+0xa0>)
 8049a42:	22d4      	movs	r2, #212	; 0xd4
 8049a44:	4915      	ldr	r1, [pc, #84]	; (8049a9c <sys_timeout+0xa4>)
 8049a46:	4816      	ldr	r0, [pc, #88]	; (8049aa0 <sys_timeout+0xa8>)
 8049a48:	f007 fbd0 	bl	80511ec <printf>
    return;
 8049a4c:	e7f6      	b.n	8049a3c <sys_timeout+0x44>
    timeouts_last_time = now;
 8049a4e:	6058      	str	r0, [r3, #4]
    diff = 0;
 8049a50:	2300      	movs	r3, #0
 8049a52:	e7e3      	b.n	8049a1c <sys_timeout+0x24>
    next_timeout = timeout;
 8049a54:	4b0f      	ldr	r3, [pc, #60]	; (8049a94 <sys_timeout+0x9c>)
 8049a56:	601c      	str	r4, [r3, #0]
    return;
 8049a58:	e7f0      	b.n	8049a3c <sys_timeout+0x44>
        if (t->next != NULL) {
 8049a5a:	b131      	cbz	r1, 8049a6a <sys_timeout+0x72>
          t->next->time -= timeout->time;
 8049a5c:	6848      	ldr	r0, [r1, #4]
 8049a5e:	1ac3      	subs	r3, r0, r3
 8049a60:	604b      	str	r3, [r1, #4]
        timeout->next = t->next;
 8049a62:	6813      	ldr	r3, [r2, #0]
 8049a64:	6023      	str	r3, [r4, #0]
        t->next = timeout;
 8049a66:	6014      	str	r4, [r2, #0]
        break;
 8049a68:	e7e8      	b.n	8049a3c <sys_timeout+0x44>
        } else if (timeout->time > msecs) {
 8049a6a:	42ab      	cmp	r3, r5
 8049a6c:	d9f9      	bls.n	8049a62 <sys_timeout+0x6a>
          timeout->time = msecs + next_timeout->time;
 8049a6e:	6873      	ldr	r3, [r6, #4]
 8049a70:	441d      	add	r5, r3
 8049a72:	6065      	str	r5, [r4, #4]
 8049a74:	e7f5      	b.n	8049a62 <sys_timeout+0x6a>
    for (t = next_timeout; t != NULL; t = t->next) {
 8049a76:	4632      	mov	r2, r6
 8049a78:	2a00      	cmp	r2, #0
 8049a7a:	d0df      	beq.n	8049a3c <sys_timeout+0x44>
      timeout->time -= t->time;
 8049a7c:	6851      	ldr	r1, [r2, #4]
 8049a7e:	6863      	ldr	r3, [r4, #4]
 8049a80:	1a5b      	subs	r3, r3, r1
 8049a82:	6063      	str	r3, [r4, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 8049a84:	6811      	ldr	r1, [r2, #0]
 8049a86:	2900      	cmp	r1, #0
 8049a88:	d0e7      	beq.n	8049a5a <sys_timeout+0x62>
 8049a8a:	6848      	ldr	r0, [r1, #4]
 8049a8c:	4283      	cmp	r3, r0
 8049a8e:	d3e4      	bcc.n	8049a5a <sys_timeout+0x62>
    for (t = next_timeout; t != NULL; t = t->next) {
 8049a90:	460a      	mov	r2, r1
 8049a92:	e7f1      	b.n	8049a78 <sys_timeout+0x80>
 8049a94:	20004300 	.word	0x20004300
 8049a98:	08059950 	.word	0x08059950
 8049a9c:	08059984 	.word	0x08059984
 8049aa0:	08058644 	.word	0x08058644

08049aa4 <tcp_timer_needed>:
{
 8049aa4:	b508      	push	{r3, lr}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8049aa6:	4b0a      	ldr	r3, [pc, #40]	; (8049ad0 <tcp_timer_needed+0x2c>)
 8049aa8:	689b      	ldr	r3, [r3, #8]
 8049aaa:	b953      	cbnz	r3, 8049ac2 <tcp_timer_needed+0x1e>
 8049aac:	4b09      	ldr	r3, [pc, #36]	; (8049ad4 <tcp_timer_needed+0x30>)
 8049aae:	681b      	ldr	r3, [r3, #0]
 8049ab0:	b143      	cbz	r3, 8049ac4 <tcp_timer_needed+0x20>
    tcpip_tcp_timer_active = 1;
 8049ab2:	4b07      	ldr	r3, [pc, #28]	; (8049ad0 <tcp_timer_needed+0x2c>)
 8049ab4:	2201      	movs	r2, #1
 8049ab6:	609a      	str	r2, [r3, #8]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8049ab8:	2200      	movs	r2, #0
 8049aba:	4907      	ldr	r1, [pc, #28]	; (8049ad8 <tcp_timer_needed+0x34>)
 8049abc:	20fa      	movs	r0, #250	; 0xfa
 8049abe:	f7ff ff9b 	bl	80499f8 <sys_timeout>
}
 8049ac2:	bd08      	pop	{r3, pc}
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 8049ac4:	4b05      	ldr	r3, [pc, #20]	; (8049adc <tcp_timer_needed+0x38>)
 8049ac6:	681b      	ldr	r3, [r3, #0]
 8049ac8:	2b00      	cmp	r3, #0
 8049aca:	d1f2      	bne.n	8049ab2 <tcp_timer_needed+0xe>
 8049acc:	e7f9      	b.n	8049ac2 <tcp_timer_needed+0x1e>
 8049ace:	bf00      	nop
 8049ad0:	20004300 	.word	0x20004300
 8049ad4:	2000899c 	.word	0x2000899c
 8049ad8:	08049ae1 	.word	0x08049ae1
 8049adc:	200089ac 	.word	0x200089ac

08049ae0 <tcpip_tcp_timer>:
{
 8049ae0:	b508      	push	{r3, lr}
  tcp_tmr();
 8049ae2:	f7fd fa07 	bl	8046ef4 <tcp_tmr>
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8049ae6:	4b08      	ldr	r3, [pc, #32]	; (8049b08 <tcpip_tcp_timer+0x28>)
 8049ae8:	681b      	ldr	r3, [r3, #0]
 8049aea:	b12b      	cbz	r3, 8049af8 <tcpip_tcp_timer+0x18>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 8049aec:	2200      	movs	r2, #0
 8049aee:	4907      	ldr	r1, [pc, #28]	; (8049b0c <tcpip_tcp_timer+0x2c>)
 8049af0:	20fa      	movs	r0, #250	; 0xfa
 8049af2:	f7ff ff81 	bl	80499f8 <sys_timeout>
}
 8049af6:	bd08      	pop	{r3, pc}
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 8049af8:	4b05      	ldr	r3, [pc, #20]	; (8049b10 <tcpip_tcp_timer+0x30>)
 8049afa:	681b      	ldr	r3, [r3, #0]
 8049afc:	2b00      	cmp	r3, #0
 8049afe:	d1f5      	bne.n	8049aec <tcpip_tcp_timer+0xc>
    tcpip_tcp_timer_active = 0;
 8049b00:	4b04      	ldr	r3, [pc, #16]	; (8049b14 <tcpip_tcp_timer+0x34>)
 8049b02:	2200      	movs	r2, #0
 8049b04:	609a      	str	r2, [r3, #8]
}
 8049b06:	e7f6      	b.n	8049af6 <tcpip_tcp_timer+0x16>
 8049b08:	2000899c 	.word	0x2000899c
 8049b0c:	08049ae1 	.word	0x08049ae1
 8049b10:	200089ac 	.word	0x200089ac
 8049b14:	20004300 	.word	0x20004300

08049b18 <sys_timeouts_init>:
{
 8049b18:	b510      	push	{r4, lr}
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8049b1a:	2401      	movs	r4, #1
 8049b1c:	e008      	b.n	8049b30 <sys_timeouts_init+0x18>
    sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
 8049b1e:	4b08      	ldr	r3, [pc, #32]	; (8049b40 <sys_timeouts_init+0x28>)
 8049b20:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
 8049b24:	4907      	ldr	r1, [pc, #28]	; (8049b44 <sys_timeouts_init+0x2c>)
 8049b26:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
 8049b2a:	f7ff ff65 	bl	80499f8 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
 8049b2e:	3401      	adds	r4, #1
 8049b30:	2c02      	cmp	r4, #2
 8049b32:	d9f4      	bls.n	8049b1e <sys_timeouts_init+0x6>
  timeouts_last_time = sys_now();
 8049b34:	f001 fff0 	bl	804bb18 <sys_now>
 8049b38:	4b03      	ldr	r3, [pc, #12]	; (8049b48 <sys_timeouts_init+0x30>)
 8049b3a:	6058      	str	r0, [r3, #4]
}
 8049b3c:	bd10      	pop	{r4, pc}
 8049b3e:	bf00      	nop
 8049b40:	080585b4 	.word	0x080585b4
 8049b44:	08049b4d 	.word	0x08049b4d
 8049b48:	20004300 	.word	0x20004300

08049b4c <cyclic_timer>:
{
 8049b4c:	b510      	push	{r4, lr}
 8049b4e:	4604      	mov	r4, r0
  cyclic->handler();
 8049b50:	6843      	ldr	r3, [r0, #4]
 8049b52:	4798      	blx	r3
  sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
 8049b54:	4622      	mov	r2, r4
 8049b56:	4902      	ldr	r1, [pc, #8]	; (8049b60 <cyclic_timer+0x14>)
 8049b58:	6820      	ldr	r0, [r4, #0]
 8049b5a:	f7ff ff4d 	bl	80499f8 <sys_timeout>
}
 8049b5e:	bd10      	pop	{r4, pc}
 8049b60:	08049b4d 	.word	0x08049b4d

08049b64 <sys_check_timeouts>:
static
#endif /* !NO_SYS */
void
sys_check_timeouts(void)
{
  if (next_timeout) {
 8049b64:	4b13      	ldr	r3, [pc, #76]	; (8049bb4 <sys_check_timeouts+0x50>)
 8049b66:	681b      	ldr	r3, [r3, #0]
 8049b68:	b31b      	cbz	r3, 8049bb2 <sys_check_timeouts+0x4e>
{
 8049b6a:	b570      	push	{r4, r5, r6, lr}
    sys_timeout_handler handler;
    void *arg;
    u8_t had_one;
    u32_t now;

    now = sys_now();
 8049b6c:	f001 ffd4 	bl	804bb18 <sys_now>
    /* this cares for wraparounds */
    diff = now - timeouts_last_time;
 8049b70:	4b10      	ldr	r3, [pc, #64]	; (8049bb4 <sys_check_timeouts+0x50>)
 8049b72:	685d      	ldr	r5, [r3, #4]
 8049b74:	1b45      	subs	r5, r0, r5
    do {
      PBUF_CHECK_FREE_OOSEQ();
 8049b76:	4b10      	ldr	r3, [pc, #64]	; (8049bb8 <sys_check_timeouts+0x54>)
 8049b78:	781b      	ldrb	r3, [r3, #0]
 8049b7a:	b9b3      	cbnz	r3, 8049baa <sys_check_timeouts+0x46>
      had_one = 0;
      tmptimeout = next_timeout;
 8049b7c:	4b0d      	ldr	r3, [pc, #52]	; (8049bb4 <sys_check_timeouts+0x50>)
 8049b7e:	6819      	ldr	r1, [r3, #0]
      if (tmptimeout && (tmptimeout->time <= diff)) {
 8049b80:	b1b1      	cbz	r1, 8049bb0 <sys_check_timeouts+0x4c>
 8049b82:	684b      	ldr	r3, [r1, #4]
 8049b84:	42ab      	cmp	r3, r5
 8049b86:	d813      	bhi.n	8049bb0 <sys_check_timeouts+0x4c>
        /* timeout has expired */
        had_one = 1;
        timeouts_last_time += tmptimeout->time;
 8049b88:	4a0a      	ldr	r2, [pc, #40]	; (8049bb4 <sys_check_timeouts+0x50>)
 8049b8a:	6854      	ldr	r4, [r2, #4]
 8049b8c:	441c      	add	r4, r3
 8049b8e:	6054      	str	r4, [r2, #4]
        diff -= tmptimeout->time;
 8049b90:	1aed      	subs	r5, r5, r3
        next_timeout = tmptimeout->next;
 8049b92:	680b      	ldr	r3, [r1, #0]
 8049b94:	6013      	str	r3, [r2, #0]
        handler = tmptimeout->h;
 8049b96:	688c      	ldr	r4, [r1, #8]
        arg = tmptimeout->arg;
 8049b98:	68ce      	ldr	r6, [r1, #12]
        if (handler != NULL) {
          LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n",
            tmptimeout->handler_name, arg));
        }
#endif /* LWIP_DEBUG_TIMERNAMES */
        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 8049b9a:	2006      	movs	r0, #6
 8049b9c:	f7fb fec8 	bl	8045930 <memp_free>
        if (handler != NULL) {
 8049ba0:	2c00      	cmp	r4, #0
 8049ba2:	d0e8      	beq.n	8049b76 <sys_check_timeouts+0x12>
#if !NO_SYS
          /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
             timeout handler function. */
          LOCK_TCPIP_CORE();
#endif /* !NO_SYS */
          handler(arg);
 8049ba4:	4630      	mov	r0, r6
 8049ba6:	47a0      	blx	r4
#endif /* !NO_SYS */
        }
        LWIP_TCPIP_THREAD_ALIVE();
      }
    /* repeat until all expired timers have been called */
    } while (had_one);
 8049ba8:	e7e5      	b.n	8049b76 <sys_check_timeouts+0x12>
      PBUF_CHECK_FREE_OOSEQ();
 8049baa:	f7fc f81b 	bl	8045be4 <pbuf_free_ooseq>
 8049bae:	e7e5      	b.n	8049b7c <sys_check_timeouts+0x18>
  }
}
 8049bb0:	bd70      	pop	{r4, r5, r6, pc}
 8049bb2:	4770      	bx	lr
 8049bb4:	20004300 	.word	0x20004300
 8049bb8:	20008994 	.word	0x20008994

08049bbc <udp_input_local_match>:
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
 8049bbc:	4613      	mov	r3, r2
 8049bbe:	b16a      	cbz	r2, 8049bdc <udp_input_local_match+0x20>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8049bc0:	b1a8      	cbz	r0, 8049bee <udp_input_local_match+0x32>
 8049bc2:	6803      	ldr	r3, [r0, #0]
 8049bc4:	b1ab      	cbz	r3, 8049bf2 <udp_input_local_match+0x36>
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8049bc6:	4a11      	ldr	r2, [pc, #68]	; (8049c0c <udp_input_local_match+0x50>)
 8049bc8:	6952      	ldr	r2, [r2, #20]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
 8049bca:	f1b2 3fff 	cmp.w	r2, #4294967295
 8049bce:	d012      	beq.n	8049bf6 <udp_input_local_match+0x3a>
           ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
 8049bd0:	6889      	ldr	r1, [r1, #8]
 8049bd2:	4053      	eors	r3, r2
          ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
 8049bd4:	420b      	tst	r3, r1
 8049bd6:	d010      	beq.n	8049bfa <udp_input_local_match+0x3e>
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
      return 1;
    }
  }

  return 0;
 8049bd8:	2000      	movs	r0, #0
 8049bda:	4770      	bx	lr
    if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
 8049bdc:	b178      	cbz	r0, 8049bfe <udp_input_local_match+0x42>
 8049bde:	6802      	ldr	r2, [r0, #0]
 8049be0:	b17a      	cbz	r2, 8049c02 <udp_input_local_match+0x46>
 8049be2:	490a      	ldr	r1, [pc, #40]	; (8049c0c <udp_input_local_match+0x50>)
 8049be4:	6949      	ldr	r1, [r1, #20]
 8049be6:	428a      	cmp	r2, r1
 8049be8:	d00d      	beq.n	8049c06 <udp_input_local_match+0x4a>
  return 0;
 8049bea:	4618      	mov	r0, r3
 8049bec:	4770      	bx	lr
          return 1;
 8049bee:	2001      	movs	r0, #1
 8049bf0:	4770      	bx	lr
 8049bf2:	2001      	movs	r0, #1
 8049bf4:	4770      	bx	lr
 8049bf6:	2001      	movs	r0, #1
 8049bf8:	4770      	bx	lr
 8049bfa:	2001      	movs	r0, #1
 8049bfc:	4770      	bx	lr
      return 1;
 8049bfe:	2001      	movs	r0, #1
 8049c00:	4770      	bx	lr
 8049c02:	2001      	movs	r0, #1
 8049c04:	4770      	bx	lr
 8049c06:	2001      	movs	r0, #1
}
 8049c08:	4770      	bx	lr
 8049c0a:	bf00      	nop
 8049c0c:	2000546c 	.word	0x2000546c

08049c10 <udp_init>:
}
 8049c10:	4770      	bx	lr
	...

08049c14 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 8049c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8049c18:	b085      	sub	sp, #20
 8049c1a:	4681      	mov	r9, r0
  PERF_START;

  UDP_STATS_INC(udp.recv);

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
 8049c1c:	8943      	ldrh	r3, [r0, #10]
 8049c1e:	2b07      	cmp	r3, #7
 8049c20:	d917      	bls.n	8049c52 <udp_input+0x3e>
 8049c22:	460f      	mov	r7, r1
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 8049c24:	6844      	ldr	r4, [r0, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
 8049c26:	4b43      	ldr	r3, [pc, #268]	; (8049d34 <udp_input+0x120>)
 8049c28:	6819      	ldr	r1, [r3, #0]
 8049c2a:	6958      	ldr	r0, [r3, #20]
 8049c2c:	f000 ffdb 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 8049c30:	4680      	mov	r8, r0

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
 8049c32:	8820      	ldrh	r0, [r4, #0]
 8049c34:	f7fb fbfa 	bl	804542c <lwip_htons>
 8049c38:	4682      	mov	sl, r0
  dest = lwip_ntohs(udphdr->dest);
 8049c3a:	8860      	ldrh	r0, [r4, #2]
 8049c3c:	f7fb fbf6 	bl	804542c <lwip_htons>
 8049c40:	4605      	mov	r5, r0
  uncon_pcb = NULL;
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049c42:	4b3d      	ldr	r3, [pc, #244]	; (8049d38 <udp_input+0x124>)
 8049c44:	681b      	ldr	r3, [r3, #0]
 8049c46:	9303      	str	r3, [sp, #12]
 8049c48:	461c      	mov	r4, r3
  uncon_pcb = NULL;
 8049c4a:	f04f 0b00 	mov.w	fp, #0
  prev = NULL;
 8049c4e:	465e      	mov	r6, fp
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049c50:	e009      	b.n	8049c66 <udp_input+0x52>
    pbuf_free(p);
 8049c52:	f7fc f821 	bl	8045c98 <pbuf_free>
  UDP_STATS_INC(udp.drop);
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
 8049c56:	b005      	add	sp, #20
 8049c58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if ((pcb->remote_port == src) &&
 8049c5c:	8aa3      	ldrh	r3, [r4, #20]
 8049c5e:	4553      	cmp	r3, sl
 8049c60:	d015      	beq.n	8049c8e <udp_input+0x7a>
    prev = pcb;
 8049c62:	4626      	mov	r6, r4
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8049c64:	68e4      	ldr	r4, [r4, #12]
 8049c66:	b1fc      	cbz	r4, 8049ca8 <udp_input+0x94>
    if ((pcb->local_port == dest) &&
 8049c68:	8a63      	ldrh	r3, [r4, #18]
 8049c6a:	42ab      	cmp	r3, r5
 8049c6c:	d1f9      	bne.n	8049c62 <udp_input+0x4e>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
 8049c6e:	4642      	mov	r2, r8
 8049c70:	4639      	mov	r1, r7
 8049c72:	4620      	mov	r0, r4
 8049c74:	f7ff ffa2 	bl	8049bbc <udp_input_local_match>
    if ((pcb->local_port == dest) &&
 8049c78:	2800      	cmp	r0, #0
 8049c7a:	d0f2      	beq.n	8049c62 <udp_input+0x4e>
      if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
 8049c7c:	7c23      	ldrb	r3, [r4, #16]
 8049c7e:	f013 0f04 	tst.w	r3, #4
 8049c82:	d1eb      	bne.n	8049c5c <udp_input+0x48>
 8049c84:	f1bb 0f00 	cmp.w	fp, #0
 8049c88:	d1e8      	bne.n	8049c5c <udp_input+0x48>
        uncon_pcb = pcb;
 8049c8a:	46a3      	mov	fp, r4
 8049c8c:	e7e6      	b.n	8049c5c <udp_input+0x48>
          (ip_addr_isany_val(pcb->remote_ip) ||
 8049c8e:	6863      	ldr	r3, [r4, #4]
      if ((pcb->remote_port == src) &&
 8049c90:	b11b      	cbz	r3, 8049c9a <udp_input+0x86>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
 8049c92:	4a28      	ldr	r2, [pc, #160]	; (8049d34 <udp_input+0x120>)
 8049c94:	6912      	ldr	r2, [r2, #16]
          (ip_addr_isany_val(pcb->remote_ip) ||
 8049c96:	4293      	cmp	r3, r2
 8049c98:	d1e3      	bne.n	8049c62 <udp_input+0x4e>
        if (prev != NULL) {
 8049c9a:	b12e      	cbz	r6, 8049ca8 <udp_input+0x94>
          prev->next = pcb->next;
 8049c9c:	68e3      	ldr	r3, [r4, #12]
 8049c9e:	60f3      	str	r3, [r6, #12]
          pcb->next = udp_pcbs;
 8049ca0:	9b03      	ldr	r3, [sp, #12]
 8049ca2:	60e3      	str	r3, [r4, #12]
          udp_pcbs = pcb;
 8049ca4:	4b24      	ldr	r3, [pc, #144]	; (8049d38 <udp_input+0x124>)
 8049ca6:	601c      	str	r4, [r3, #0]
  if (pcb == NULL) {
 8049ca8:	b18c      	cbz	r4, 8049cce <udp_input+0xba>
  if (pcb != NULL) {
 8049caa:	b194      	cbz	r4, 8049cd2 <udp_input+0xbe>
    if (pbuf_header(p, -UDP_HLEN)) {
 8049cac:	f06f 0107 	mvn.w	r1, #7
 8049cb0:	4648      	mov	r0, r9
 8049cb2:	f7fb ffe7 	bl	8045c84 <pbuf_header>
 8049cb6:	b9a8      	cbnz	r0, 8049ce4 <udp_input+0xd0>
    if (pcb != NULL) {
 8049cb8:	b31c      	cbz	r4, 8049d02 <udp_input+0xee>
      if (pcb->recv != NULL) {
 8049cba:	69a5      	ldr	r5, [r4, #24]
 8049cbc:	b1ed      	cbz	r5, 8049cfa <udp_input+0xe6>
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 8049cbe:	69e0      	ldr	r0, [r4, #28]
 8049cc0:	f8cd a000 	str.w	sl, [sp]
 8049cc4:	4b1d      	ldr	r3, [pc, #116]	; (8049d3c <udp_input+0x128>)
 8049cc6:	464a      	mov	r2, r9
 8049cc8:	4621      	mov	r1, r4
 8049cca:	47a8      	blx	r5
 8049ccc:	e7c3      	b.n	8049c56 <udp_input+0x42>
    pcb = uncon_pcb;
 8049cce:	465c      	mov	r4, fp
 8049cd0:	e7eb      	b.n	8049caa <udp_input+0x96>
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
 8049cd2:	687a      	ldr	r2, [r7, #4]
 8049cd4:	4b17      	ldr	r3, [pc, #92]	; (8049d34 <udp_input+0x120>)
 8049cd6:	695b      	ldr	r3, [r3, #20]
  if (for_us) {
 8049cd8:	429a      	cmp	r2, r3
 8049cda:	d0e7      	beq.n	8049cac <udp_input+0x98>
    pbuf_free(p);
 8049cdc:	4648      	mov	r0, r9
 8049cde:	f7fb ffdb 	bl	8045c98 <pbuf_free>
  return;
 8049ce2:	e7b8      	b.n	8049c56 <udp_input+0x42>
      LWIP_ASSERT("pbuf_header failed\n", 0);
 8049ce4:	4b16      	ldr	r3, [pc, #88]	; (8049d40 <udp_input+0x12c>)
 8049ce6:	f240 1255 	movw	r2, #341	; 0x155
 8049cea:	4916      	ldr	r1, [pc, #88]	; (8049d44 <udp_input+0x130>)
 8049cec:	4816      	ldr	r0, [pc, #88]	; (8049d48 <udp_input+0x134>)
 8049cee:	f007 fa7d 	bl	80511ec <printf>
      pbuf_free(p);
 8049cf2:	4648      	mov	r0, r9
 8049cf4:	f7fb ffd0 	bl	8045c98 <pbuf_free>
      goto end;
 8049cf8:	e7ad      	b.n	8049c56 <udp_input+0x42>
        pbuf_free(p);
 8049cfa:	4648      	mov	r0, r9
 8049cfc:	f7fb ffcc 	bl	8045c98 <pbuf_free>
        goto end;
 8049d00:	e7a9      	b.n	8049c56 <udp_input+0x42>
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
 8049d02:	f1b8 0f00 	cmp.w	r8, #0
 8049d06:	d105      	bne.n	8049d14 <udp_input+0x100>
 8049d08:	4b0a      	ldr	r3, [pc, #40]	; (8049d34 <udp_input+0x120>)
 8049d0a:	695b      	ldr	r3, [r3, #20]
 8049d0c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8049d10:	2be0      	cmp	r3, #224	; 0xe0
 8049d12:	d103      	bne.n	8049d1c <udp_input+0x108>
      pbuf_free(p);
 8049d14:	4648      	mov	r0, r9
 8049d16:	f7fb ffbf 	bl	8045c98 <pbuf_free>
 8049d1a:	e79c      	b.n	8049c56 <udp_input+0x42>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
 8049d1c:	4b05      	ldr	r3, [pc, #20]	; (8049d34 <udp_input+0x120>)
 8049d1e:	8999      	ldrh	r1, [r3, #12]
 8049d20:	3108      	adds	r1, #8
 8049d22:	b209      	sxth	r1, r1
 8049d24:	4648      	mov	r0, r9
 8049d26:	f7fb ffb2 	bl	8045c8e <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
 8049d2a:	2103      	movs	r1, #3
 8049d2c:	4648      	mov	r0, r9
 8049d2e:	f000 fdb1 	bl	804a894 <icmp_dest_unreach>
 8049d32:	e7ef      	b.n	8049d14 <udp_input+0x100>
 8049d34:	2000546c 	.word	0x2000546c
 8049d38:	200089b4 	.word	0x200089b4
 8049d3c:	2000547c 	.word	0x2000547c
 8049d40:	080599c4 	.word	0x080599c4
 8049d44:	080599f4 	.word	0x080599f4
 8049d48:	08058644 	.word	0x08058644

08049d4c <udp_netif_ip_addr_changed>:
 */
void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
{
  struct udp_pcb* upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
 8049d4c:	b1b8      	cbz	r0, 8049d7e <udp_netif_ip_addr_changed+0x32>
 8049d4e:	4602      	mov	r2, r0
 8049d50:	6803      	ldr	r3, [r0, #0]
 8049d52:	b1a3      	cbz	r3, 8049d7e <udp_netif_ip_addr_changed+0x32>
 8049d54:	b199      	cbz	r1, 8049d7e <udp_netif_ip_addr_changed+0x32>
 8049d56:	680b      	ldr	r3, [r1, #0]
 8049d58:	b18b      	cbz	r3, 8049d7e <udp_netif_ip_addr_changed+0x32>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8049d5a:	4b09      	ldr	r3, [pc, #36]	; (8049d80 <udp_netif_ip_addr_changed+0x34>)
 8049d5c:	681b      	ldr	r3, [r3, #0]
 8049d5e:	b16b      	cbz	r3, 8049d7c <udp_netif_ip_addr_changed+0x30>
{
 8049d60:	b410      	push	{r4}
 8049d62:	e001      	b.n	8049d68 <udp_netif_ip_addr_changed+0x1c>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
 8049d64:	68db      	ldr	r3, [r3, #12]
 8049d66:	b133      	cbz	r3, 8049d76 <udp_netif_ip_addr_changed+0x2a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
 8049d68:	681c      	ldr	r4, [r3, #0]
 8049d6a:	6810      	ldr	r0, [r2, #0]
 8049d6c:	4284      	cmp	r4, r0
 8049d6e:	d1f9      	bne.n	8049d64 <udp_netif_ip_addr_changed+0x18>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
 8049d70:	6808      	ldr	r0, [r1, #0]
 8049d72:	6018      	str	r0, [r3, #0]
 8049d74:	e7f6      	b.n	8049d64 <udp_netif_ip_addr_changed+0x18>
      }
    }
  }
}
 8049d76:	f85d 4b04 	ldr.w	r4, [sp], #4
 8049d7a:	4770      	bx	lr
 8049d7c:	4770      	bx	lr
 8049d7e:	4770      	bx	lr
 8049d80:	200089b4 	.word	0x200089b4

08049d84 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 8049d84:	b510      	push	{r4, lr}
 8049d86:	4604      	mov	r4, r0
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 8049d88:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 8049d8c:	4b09      	ldr	r3, [pc, #36]	; (8049db4 <etharp_free_entry+0x30>)
 8049d8e:	f853 0032 	ldr.w	r0, [r3, r2, lsl #3]
 8049d92:	b138      	cbz	r0, 8049da4 <etharp_free_entry+0x20>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 8049d94:	f7fb ff80 	bl	8045c98 <pbuf_free>
    arp_table[i].q = NULL;
 8049d98:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8049d9c:	00db      	lsls	r3, r3, #3
 8049d9e:	4a05      	ldr	r2, [pc, #20]	; (8049db4 <etharp_free_entry+0x30>)
 8049da0:	2100      	movs	r1, #0
 8049da2:	50d1      	str	r1, [r2, r3]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 8049da4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8049da8:	4802      	ldr	r0, [pc, #8]	; (8049db4 <etharp_free_entry+0x30>)
 8049daa:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
 8049dae:	2300      	movs	r3, #0
 8049db0:	7523      	strb	r3, [r4, #20]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip4_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 8049db2:	bd10      	pop	{r4, pc}
 8049db4:	2000430c 	.word	0x2000430c

08049db8 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif* netif)
{
 8049db8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8049dbc:	4606      	mov	r6, r0
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
 8049dbe:	f04f 0c00 	mov.w	ip, #0
 8049dc2:	46e3      	mov	fp, ip
 8049dc4:	46e1      	mov	r9, ip
  s8_t old_queue = ARP_TABLE_SIZE;
 8049dc6:	f04f 0e0a 	mov.w	lr, #10
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049dca:	4663      	mov	r3, ip
  s8_t empty = ARP_TABLE_SIZE;
 8049dcc:	4675      	mov	r5, lr
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 8049dce:	46f0      	mov	r8, lr
 8049dd0:	46f2      	mov	sl, lr
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049dd2:	e003      	b.n	8049ddc <etharp_find_entry+0x24>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8049dd4:	b968      	cbnz	r0, 8049df2 <etharp_find_entry+0x3a>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 8049dd6:	b25d      	sxtb	r5, r3
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 8049dd8:	3301      	adds	r3, #1
 8049dda:	b2db      	uxtb	r3, r3
 8049ddc:	2b09      	cmp	r3, #9
 8049dde:	d843      	bhi.n	8049e68 <etharp_find_entry+0xb0>
    u8_t state = arp_table[i].state;
 8049de0:	461a      	mov	r2, r3
 8049de2:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 8049de6:	4c57      	ldr	r4, [pc, #348]	; (8049f44 <etharp_find_entry+0x18c>)
 8049de8:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 8049dec:	7d00      	ldrb	r0, [r0, #20]
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 8049dee:	2d0a      	cmp	r5, #10
 8049df0:	d0f0      	beq.n	8049dd4 <etharp_find_entry+0x1c>
    } else if (state != ETHARP_STATE_EMPTY) {
 8049df2:	2800      	cmp	r0, #0
 8049df4:	d0f0      	beq.n	8049dd8 <etharp_find_entry+0x20>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
 8049df6:	b146      	cbz	r6, 8049e0a <etharp_find_entry+0x52>
 8049df8:	eb02 0742 	add.w	r7, r2, r2, lsl #1
 8049dfc:	4c51      	ldr	r4, [pc, #324]	; (8049f44 <etharp_find_entry+0x18c>)
 8049dfe:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 8049e02:	6864      	ldr	r4, [r4, #4]
 8049e04:	6837      	ldr	r7, [r6, #0]
 8049e06:	42a7      	cmp	r7, r4
 8049e08:	d00f      	beq.n	8049e2a <etharp_find_entry+0x72>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 8049e0a:	2801      	cmp	r0, #1
 8049e0c:	d00f      	beq.n	8049e2e <etharp_find_entry+0x76>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 8049e0e:	2801      	cmp	r0, #1
 8049e10:	d9e2      	bls.n	8049dd8 <etharp_find_entry+0x20>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 8049e12:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e16:	484b      	ldr	r0, [pc, #300]	; (8049f44 <etharp_find_entry+0x18c>)
 8049e18:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8049e1c:	8a52      	ldrh	r2, [r2, #18]
 8049e1e:	4562      	cmp	r2, ip
 8049e20:	d3da      	bcc.n	8049dd8 <etharp_find_entry+0x20>
            old_stable = i;
 8049e22:	fa4f f883 	sxtb.w	r8, r3
            age_stable = arp_table[i].ctime;
 8049e26:	4694      	mov	ip, r2
 8049e28:	e7d6      	b.n	8049dd8 <etharp_find_entry+0x20>
        return i;
 8049e2a:	b258      	sxtb	r0, r3
 8049e2c:	e03f      	b.n	8049eae <etharp_find_entry+0xf6>
        if (arp_table[i].q != NULL) {
 8049e2e:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 8049e32:	4c44      	ldr	r4, [pc, #272]	; (8049f44 <etharp_find_entry+0x18c>)
 8049e34:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
 8049e38:	b150      	cbz	r0, 8049e50 <etharp_find_entry+0x98>
          if (arp_table[i].ctime >= age_queue) {
 8049e3a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e3e:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8049e42:	8a52      	ldrh	r2, [r2, #18]
 8049e44:	454a      	cmp	r2, r9
 8049e46:	d3c7      	bcc.n	8049dd8 <etharp_find_entry+0x20>
            old_queue = i;
 8049e48:	fa4f fe83 	sxtb.w	lr, r3
            age_queue = arp_table[i].ctime;
 8049e4c:	4691      	mov	r9, r2
 8049e4e:	e7c3      	b.n	8049dd8 <etharp_find_entry+0x20>
          if (arp_table[i].ctime >= age_pending) {
 8049e50:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8049e54:	483b      	ldr	r0, [pc, #236]	; (8049f44 <etharp_find_entry+0x18c>)
 8049e56:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 8049e5a:	8a52      	ldrh	r2, [r2, #18]
 8049e5c:	455a      	cmp	r2, fp
 8049e5e:	d3bb      	bcc.n	8049dd8 <etharp_find_entry+0x20>
            old_pending = i;
 8049e60:	fa4f fa83 	sxtb.w	sl, r3
            age_pending = arp_table[i].ctime;
 8049e64:	4693      	mov	fp, r2
 8049e66:	e7b7      	b.n	8049dd8 <etharp_find_entry+0x20>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 8049e68:	f011 0f02 	tst.w	r1, #2
 8049e6c:	d163      	bne.n	8049f36 <etharp_find_entry+0x17e>
 8049e6e:	2d0a      	cmp	r5, #10
 8049e70:	d01f      	beq.n	8049eb2 <etharp_find_entry+0xfa>
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 8049e72:	2d09      	cmp	r5, #9
 8049e74:	dc23      	bgt.n	8049ebe <etharp_find_entry+0x106>
    i = empty;
 8049e76:	b2ed      	uxtb	r5, r5
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049e78:	2d09      	cmp	r5, #9
 8049e7a:	d84c      	bhi.n	8049f16 <etharp_find_entry+0x15e>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8049e7c:	462c      	mov	r4, r5
 8049e7e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8049e82:	4a30      	ldr	r2, [pc, #192]	; (8049f44 <etharp_find_entry+0x18c>)
 8049e84:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8049e88:	7d1b      	ldrb	r3, [r3, #20]
 8049e8a:	2b00      	cmp	r3, #0
 8049e8c:	d14b      	bne.n	8049f26 <etharp_find_entry+0x16e>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 8049e8e:	b136      	cbz	r6, 8049e9e <etharp_find_entry+0xe6>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
 8049e90:	6831      	ldr	r1, [r6, #0]
 8049e92:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8049e96:	4a2b      	ldr	r2, [pc, #172]	; (8049f44 <etharp_find_entry+0x18c>)
 8049e98:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8049e9c:	6059      	str	r1, [r3, #4]
  }
  arp_table[i].ctime = 0;
 8049e9e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8049ea2:	4b28      	ldr	r3, [pc, #160]	; (8049f44 <etharp_find_entry+0x18c>)
 8049ea4:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 8049ea8:	2300      	movs	r3, #0
 8049eaa:	8263      	strh	r3, [r4, #18]
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
#endif /* ETHARP_TABLE_MATCH_NETIF*/
  return (err_t)i;
 8049eac:	b268      	sxtb	r0, r5
}
 8049eae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 8049eb2:	f011 0f01 	tst.w	r1, #1
 8049eb6:	d1dc      	bne.n	8049e72 <etharp_find_entry+0xba>
    return (s8_t)ERR_MEM;
 8049eb8:	f04f 30ff 	mov.w	r0, #4294967295
 8049ebc:	e7f7      	b.n	8049eae <etharp_find_entry+0xf6>
    if (old_stable < ARP_TABLE_SIZE) {
 8049ebe:	f1b8 0f09 	cmp.w	r8, #9
 8049ec2:	dc14      	bgt.n	8049eee <etharp_find_entry+0x136>
      i = old_stable;
 8049ec4:	fa5f f588 	uxtb.w	r5, r8
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 8049ec8:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 8049ecc:	4b1d      	ldr	r3, [pc, #116]	; (8049f44 <etharp_find_entry+0x18c>)
 8049ece:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8049ed2:	b133      	cbz	r3, 8049ee2 <etharp_find_entry+0x12a>
 8049ed4:	4b1c      	ldr	r3, [pc, #112]	; (8049f48 <etharp_find_entry+0x190>)
 8049ed6:	f240 126f 	movw	r2, #367	; 0x16f
 8049eda:	491c      	ldr	r1, [pc, #112]	; (8049f4c <etharp_find_entry+0x194>)
 8049edc:	481c      	ldr	r0, [pc, #112]	; (8049f50 <etharp_find_entry+0x198>)
 8049ede:	f007 f985 	bl	80511ec <printf>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049ee2:	2d09      	cmp	r5, #9
 8049ee4:	d80f      	bhi.n	8049f06 <etharp_find_entry+0x14e>
    etharp_free_entry(i);
 8049ee6:	4628      	mov	r0, r5
 8049ee8:	f7ff ff4c 	bl	8049d84 <etharp_free_entry>
 8049eec:	e7c4      	b.n	8049e78 <etharp_find_entry+0xc0>
    } else if (old_pending < ARP_TABLE_SIZE) {
 8049eee:	f1ba 0f09 	cmp.w	sl, #9
 8049ef2:	dc02      	bgt.n	8049efa <etharp_find_entry+0x142>
      i = old_pending;
 8049ef4:	fa5f f58a 	uxtb.w	r5, sl
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
 8049ef8:	e7f3      	b.n	8049ee2 <etharp_find_entry+0x12a>
    } else if (old_queue < ARP_TABLE_SIZE) {
 8049efa:	f1be 0f09 	cmp.w	lr, #9
 8049efe:	dc1d      	bgt.n	8049f3c <etharp_find_entry+0x184>
      i = old_queue;
 8049f00:	fa5f f58e 	uxtb.w	r5, lr
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
 8049f04:	e7ed      	b.n	8049ee2 <etharp_find_entry+0x12a>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049f06:	4b10      	ldr	r3, [pc, #64]	; (8049f48 <etharp_find_entry+0x190>)
 8049f08:	f240 1281 	movw	r2, #385	; 0x181
 8049f0c:	4911      	ldr	r1, [pc, #68]	; (8049f54 <etharp_find_entry+0x19c>)
 8049f0e:	4810      	ldr	r0, [pc, #64]	; (8049f50 <etharp_find_entry+0x198>)
 8049f10:	f007 f96c 	bl	80511ec <printf>
 8049f14:	e7e7      	b.n	8049ee6 <etharp_find_entry+0x12e>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 8049f16:	4b0c      	ldr	r3, [pc, #48]	; (8049f48 <etharp_find_entry+0x190>)
 8049f18:	f240 1285 	movw	r2, #389	; 0x185
 8049f1c:	490d      	ldr	r1, [pc, #52]	; (8049f54 <etharp_find_entry+0x19c>)
 8049f1e:	480c      	ldr	r0, [pc, #48]	; (8049f50 <etharp_find_entry+0x198>)
 8049f20:	f007 f964 	bl	80511ec <printf>
 8049f24:	e7aa      	b.n	8049e7c <etharp_find_entry+0xc4>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 8049f26:	4b08      	ldr	r3, [pc, #32]	; (8049f48 <etharp_find_entry+0x190>)
 8049f28:	f44f 72c3 	mov.w	r2, #390	; 0x186
 8049f2c:	490a      	ldr	r1, [pc, #40]	; (8049f58 <etharp_find_entry+0x1a0>)
 8049f2e:	4808      	ldr	r0, [pc, #32]	; (8049f50 <etharp_find_entry+0x198>)
 8049f30:	f007 f95c 	bl	80511ec <printf>
 8049f34:	e7ab      	b.n	8049e8e <etharp_find_entry+0xd6>
    return (s8_t)ERR_MEM;
 8049f36:	f04f 30ff 	mov.w	r0, #4294967295
 8049f3a:	e7b8      	b.n	8049eae <etharp_find_entry+0xf6>
      return (s8_t)ERR_MEM;
 8049f3c:	f04f 30ff 	mov.w	r0, #4294967295
 8049f40:	e7b5      	b.n	8049eae <etharp_find_entry+0xf6>
 8049f42:	bf00      	nop
 8049f44:	2000430c 	.word	0x2000430c
 8049f48:	08059a38 	.word	0x08059a38
 8049f4c:	08059a70 	.word	0x08059a70
 8049f50:	08058644 	.word	0x08058644
 8049f54:	08059a88 	.word	0x08059a88
 8049f58:	08059a9c 	.word	0x08059a9c

08049f5c <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 8049f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8049f5e:	b083      	sub	sp, #12
 8049f60:	4604      	mov	r4, r0
 8049f62:	460e      	mov	r6, r1
 8049f64:	4615      	mov	r5, r2
 8049f66:	461f      	mov	r7, r3
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 8049f68:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8049f6c:	2a06      	cmp	r2, #6
 8049f6e:	d13e      	bne.n	8049fee <etharp_update_arp_entry+0x92>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
    (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
 8049f70:	2e00      	cmp	r6, #0
 8049f72:	d044      	beq.n	8049ffe <etharp_update_arp_entry+0xa2>
 8049f74:	6830      	ldr	r0, [r6, #0]
 8049f76:	2800      	cmp	r0, #0
 8049f78:	d041      	beq.n	8049ffe <etharp_update_arp_entry+0xa2>
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8049f7a:	4621      	mov	r1, r4
 8049f7c:	f000 fe33 	bl	804abe6 <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
 8049f80:	2800      	cmp	r0, #0
 8049f82:	d13c      	bne.n	8049ffe <etharp_update_arp_entry+0xa2>
      ip4_addr_ismulticast(ipaddr)) {
 8049f84:	6832      	ldr	r2, [r6, #0]
 8049f86:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
      ip4_addr_isbroadcast(ipaddr, netif) ||
 8049f8a:	2ae0      	cmp	r2, #224	; 0xe0
 8049f8c:	d037      	beq.n	8049ffe <etharp_update_arp_entry+0xa2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
 8049f8e:	4622      	mov	r2, r4
 8049f90:	4639      	mov	r1, r7
 8049f92:	4630      	mov	r0, r6
 8049f94:	f7ff ff10 	bl	8049db8 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 8049f98:	2800      	cmp	r0, #0
 8049f9a:	db26      	blt.n	8049fea <etharp_update_arp_entry+0x8e>
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 8049f9c:	4a1a      	ldr	r2, [pc, #104]	; (804a008 <etharp_update_arp_entry+0xac>)
 8049f9e:	eb00 0640 	add.w	r6, r0, r0, lsl #1
 8049fa2:	eb02 01c6 	add.w	r1, r2, r6, lsl #3
 8049fa6:	2302      	movs	r3, #2
 8049fa8:	750b      	strb	r3, [r1, #20]
  }

  /* record network interface */
  arp_table[i].netif = netif;
 8049faa:	608c      	str	r4, [r1, #8]
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 8049fac:	00f3      	lsls	r3, r6, #3
 8049fae:	3308      	adds	r3, #8
 8049fb0:	4413      	add	r3, r2
 8049fb2:	682f      	ldr	r7, [r5, #0]
 8049fb4:	605f      	str	r7, [r3, #4]
 8049fb6:	88af      	ldrh	r7, [r5, #4]
 8049fb8:	811f      	strh	r7, [r3, #8]
  /* reset time stamp */
  arp_table[i].ctime = 0;
 8049fba:	2300      	movs	r3, #0
 8049fbc:	824b      	strh	r3, [r1, #18]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
 8049fbe:	f852 6036 	ldr.w	r6, [r2, r6, lsl #3]
 8049fc2:	b1fe      	cbz	r6, 804a004 <etharp_update_arp_entry+0xa8>
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
 8049fc4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8049fc8:	00c0      	lsls	r0, r0, #3
 8049fca:	461f      	mov	r7, r3
 8049fcc:	5013      	str	r3, [r2, r0]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr, ETHTYPE_IP);
 8049fce:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8049fd2:	9300      	str	r3, [sp, #0]
 8049fd4:	462b      	mov	r3, r5
 8049fd6:	f104 0225 	add.w	r2, r4, #37	; 0x25
 8049fda:	4631      	mov	r1, r6
 8049fdc:	4620      	mov	r0, r4
 8049fde:	f001 fa5b 	bl	804b498 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
 8049fe2:	4630      	mov	r0, r6
 8049fe4:	f7fb fe58 	bl	8045c98 <pbuf_free>
  }
  return ERR_OK;
 8049fe8:	4638      	mov	r0, r7
}
 8049fea:	b003      	add	sp, #12
 8049fec:	bdf0      	pop	{r4, r5, r6, r7, pc}
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
 8049fee:	4b07      	ldr	r3, [pc, #28]	; (804a00c <etharp_update_arp_entry+0xb0>)
 8049ff0:	f240 12ab 	movw	r2, #427	; 0x1ab
 8049ff4:	4906      	ldr	r1, [pc, #24]	; (804a010 <etharp_update_arp_entry+0xb4>)
 8049ff6:	4807      	ldr	r0, [pc, #28]	; (804a014 <etharp_update_arp_entry+0xb8>)
 8049ff8:	f007 f8f8 	bl	80511ec <printf>
 8049ffc:	e7b8      	b.n	8049f70 <etharp_update_arp_entry+0x14>
    return ERR_ARG;
 8049ffe:	f06f 000f 	mvn.w	r0, #15
 804a002:	e7f2      	b.n	8049fea <etharp_update_arp_entry+0x8e>
  return ERR_OK;
 804a004:	2000      	movs	r0, #0
 804a006:	e7f0      	b.n	8049fea <etharp_update_arp_entry+0x8e>
 804a008:	2000430c 	.word	0x2000430c
 804a00c:	08059a38 	.word	0x08059a38
 804a010:	08059ac8 	.word	0x08059ac8
 804a014:	08058644 	.word	0x08058644

0804a018 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
 804a018:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804a01c:	b082      	sub	sp, #8
 804a01e:	460f      	mov	r7, r1
 804a020:	4690      	mov	r8, r2
 804a022:	461d      	mov	r5, r3
 804a024:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
  struct pbuf *p;
  err_t result = ERR_OK;
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a028:	4681      	mov	r9, r0
 804a02a:	2800      	cmp	r0, #0
 804a02c:	d041      	beq.n	804a0b2 <etharp_raw+0x9a>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
 804a02e:	2200      	movs	r2, #0
 804a030:	211c      	movs	r1, #28
 804a032:	2002      	movs	r0, #2
 804a034:	f7fb fe94 	bl	8045d60 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 804a038:	4606      	mov	r6, r0
 804a03a:	2800      	cmp	r0, #0
 804a03c:	d051      	beq.n	804a0e2 <etharp_raw+0xca>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 804a03e:	8943      	ldrh	r3, [r0, #10]
 804a040:	2b1b      	cmp	r3, #27
 804a042:	d93e      	bls.n	804a0c2 <etharp_raw+0xaa>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
 804a044:	6874      	ldr	r4, [r6, #4]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
 804a046:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 804a04a:	f7fb f9ef 	bl	804542c <lwip_htons>
 804a04e:	80e0      	strh	r0, [r4, #6]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 804a050:	f899 3024 	ldrb.w	r3, [r9, #36]	; 0x24
 804a054:	2b06      	cmp	r3, #6
 804a056:	d13c      	bne.n	804a0d2 <etharp_raw+0xba>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 804a058:	682b      	ldr	r3, [r5, #0]
 804a05a:	60a3      	str	r3, [r4, #8]
 804a05c:	88ab      	ldrh	r3, [r5, #4]
 804a05e:	81a3      	strh	r3, [r4, #12]
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 804a060:	f8da 3000 	ldr.w	r3, [sl]
 804a064:	f8c4 3012 	str.w	r3, [r4, #18]
 804a068:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 804a06c:	82e3      	strh	r3, [r4, #22]
  /* Copy struct ip4_addr2 to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 804a06e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 804a070:	681b      	ldr	r3, [r3, #0]
 804a072:	f8c4 300e 	str.w	r3, [r4, #14]
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 804a076:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 804a078:	681b      	ldr	r3, [r3, #0]
 804a07a:	61a3      	str	r3, [r4, #24]

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 804a07c:	2500      	movs	r5, #0
 804a07e:	7025      	strb	r5, [r4, #0]
 804a080:	2301      	movs	r3, #1
 804a082:	7063      	strb	r3, [r4, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 804a084:	2308      	movs	r3, #8
 804a086:	70a3      	strb	r3, [r4, #2]
 804a088:	70e5      	strb	r5, [r4, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
 804a08a:	2306      	movs	r3, #6
 804a08c:	7123      	strb	r3, [r4, #4]
  hdr->protolen = sizeof(ip4_addr_t);
 804a08e:	2304      	movs	r3, #4
 804a090:	7163      	strb	r3, [r4, #5]
  if(ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
 804a092:	f640 0306 	movw	r3, #2054	; 0x806
 804a096:	9300      	str	r3, [sp, #0]
 804a098:	4643      	mov	r3, r8
 804a09a:	463a      	mov	r2, r7
 804a09c:	4631      	mov	r1, r6
 804a09e:	4648      	mov	r0, r9
 804a0a0:	f001 f9fa 	bl	804b498 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 804a0a4:	4630      	mov	r0, r6
 804a0a6:	f7fb fdf7 	bl	8045c98 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 804a0aa:	4628      	mov	r0, r5
}
 804a0ac:	b002      	add	sp, #8
 804a0ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a0b2:	4b0d      	ldr	r3, [pc, #52]	; (804a0e8 <etharp_raw+0xd0>)
 804a0b4:	f44f 628b 	mov.w	r2, #1112	; 0x458
 804a0b8:	490c      	ldr	r1, [pc, #48]	; (804a0ec <etharp_raw+0xd4>)
 804a0ba:	480d      	ldr	r0, [pc, #52]	; (804a0f0 <etharp_raw+0xd8>)
 804a0bc:	f007 f896 	bl	80511ec <printf>
 804a0c0:	e7b5      	b.n	804a02e <etharp_raw+0x16>
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 804a0c2:	4b09      	ldr	r3, [pc, #36]	; (804a0e8 <etharp_raw+0xd0>)
 804a0c4:	f240 4263 	movw	r2, #1123	; 0x463
 804a0c8:	490a      	ldr	r1, [pc, #40]	; (804a0f4 <etharp_raw+0xdc>)
 804a0ca:	4809      	ldr	r0, [pc, #36]	; (804a0f0 <etharp_raw+0xd8>)
 804a0cc:	f007 f88e 	bl	80511ec <printf>
 804a0d0:	e7b8      	b.n	804a044 <etharp_raw+0x2c>
  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
 804a0d2:	4b05      	ldr	r3, [pc, #20]	; (804a0e8 <etharp_raw+0xd0>)
 804a0d4:	f240 426a 	movw	r2, #1130	; 0x46a
 804a0d8:	4907      	ldr	r1, [pc, #28]	; (804a0f8 <etharp_raw+0xe0>)
 804a0da:	4805      	ldr	r0, [pc, #20]	; (804a0f0 <etharp_raw+0xd8>)
 804a0dc:	f007 f886 	bl	80511ec <printf>
 804a0e0:	e7ba      	b.n	804a058 <etharp_raw+0x40>
    return ERR_MEM;
 804a0e2:	f04f 30ff 	mov.w	r0, #4294967295
 804a0e6:	e7e1      	b.n	804a0ac <etharp_raw+0x94>
 804a0e8:	08059a38 	.word	0x08059a38
 804a0ec:	08059aec 	.word	0x08059aec
 804a0f0:	08058644 	.word	0x08058644
 804a0f4:	08059afc 	.word	0x08059afc
 804a0f8:	08059b30 	.word	0x08059b30

0804a0fc <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr* hw_dst_addr)
{
 804a0fc:	b530      	push	{r4, r5, lr}
 804a0fe:	b085      	sub	sp, #20
 804a100:	4604      	mov	r4, r0
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 804a102:	f100 0325 	add.w	r3, r0, #37	; 0x25
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
 804a106:	3404      	adds	r4, #4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
 804a108:	2501      	movs	r5, #1
 804a10a:	9503      	str	r5, [sp, #12]
 804a10c:	9102      	str	r1, [sp, #8]
 804a10e:	4904      	ldr	r1, [pc, #16]	; (804a120 <etharp_request_dst+0x24>)
 804a110:	9101      	str	r1, [sp, #4]
 804a112:	9400      	str	r4, [sp, #0]
 804a114:	4619      	mov	r1, r3
 804a116:	f7ff ff7f 	bl	804a018 <etharp_raw>
                    ipaddr, ARP_REQUEST);
}
 804a11a:	b005      	add	sp, #20
 804a11c:	bd30      	pop	{r4, r5, pc}
 804a11e:	bf00      	nop
 804a120:	080585dc 	.word	0x080585dc

0804a124 <etharp_cleanup_netif>:
{
 804a124:	b538      	push	{r3, r4, r5, lr}
 804a126:	4605      	mov	r5, r0
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a128:	2400      	movs	r4, #0
 804a12a:	e001      	b.n	804a130 <etharp_cleanup_netif+0xc>
 804a12c:	3401      	adds	r4, #1
 804a12e:	b2e4      	uxtb	r4, r4
 804a130:	2c09      	cmp	r4, #9
 804a132:	d812      	bhi.n	804a15a <etharp_cleanup_netif+0x36>
    u8_t state = arp_table[i].state;
 804a134:	4620      	mov	r0, r4
 804a136:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a13a:	4a08      	ldr	r2, [pc, #32]	; (804a15c <etharp_cleanup_netif+0x38>)
 804a13c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a140:	7d1b      	ldrb	r3, [r3, #20]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 804a142:	2b00      	cmp	r3, #0
 804a144:	d0f2      	beq.n	804a12c <etharp_cleanup_netif+0x8>
 804a146:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a14a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a14e:	689b      	ldr	r3, [r3, #8]
 804a150:	42ab      	cmp	r3, r5
 804a152:	d1eb      	bne.n	804a12c <etharp_cleanup_netif+0x8>
      etharp_free_entry(i);
 804a154:	f7ff fe16 	bl	8049d84 <etharp_free_entry>
 804a158:	e7e8      	b.n	804a12c <etharp_cleanup_netif+0x8>
}
 804a15a:	bd38      	pop	{r3, r4, r5, pc}
 804a15c:	2000430c 	.word	0x2000430c

0804a160 <etharp_input>:
{
 804a160:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a164:	b086      	sub	sp, #24
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 804a166:	b1a9      	cbz	r1, 804a194 <etharp_input+0x34>
 804a168:	4604      	mov	r4, r0
 804a16a:	460e      	mov	r6, r1
  hdr = (struct etharp_hdr *)p->payload;
 804a16c:	6845      	ldr	r5, [r0, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 804a16e:	882b      	ldrh	r3, [r5, #0]
 804a170:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 804a174:	d108      	bne.n	804a188 <etharp_input+0x28>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 804a176:	792b      	ldrb	r3, [r5, #4]
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 804a178:	2b06      	cmp	r3, #6
 804a17a:	d105      	bne.n	804a188 <etharp_input+0x28>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 804a17c:	796b      	ldrb	r3, [r5, #5]
      (hdr->hwlen != ETH_HWADDR_LEN) ||
 804a17e:	2b04      	cmp	r3, #4
 804a180:	d102      	bne.n	804a188 <etharp_input+0x28>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 804a182:	886b      	ldrh	r3, [r5, #2]
      (hdr->protolen != sizeof(ip4_addr_t)) ||
 804a184:	2b08      	cmp	r3, #8
 804a186:	d00d      	beq.n	804a1a4 <etharp_input+0x44>
    pbuf_free(p);
 804a188:	4620      	mov	r0, r4
 804a18a:	f7fb fd85 	bl	8045c98 <pbuf_free>
}
 804a18e:	b006      	add	sp, #24
 804a190:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 804a194:	4b1d      	ldr	r3, [pc, #116]	; (804a20c <etharp_input+0xac>)
 804a196:	f44f 7222 	mov.w	r2, #648	; 0x288
 804a19a:	491d      	ldr	r1, [pc, #116]	; (804a210 <etharp_input+0xb0>)
 804a19c:	481d      	ldr	r0, [pc, #116]	; (804a214 <etharp_input+0xb4>)
 804a19e:	f007 f825 	bl	80511ec <printf>
 804a1a2:	e7f4      	b.n	804a18e <etharp_input+0x2e>
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 804a1a4:	f8d5 300e 	ldr.w	r3, [r5, #14]
 804a1a8:	9305      	str	r3, [sp, #20]
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 804a1aa:	69af      	ldr	r7, [r5, #24]
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 804a1ac:	684b      	ldr	r3, [r1, #4]
 804a1ae:	b983      	cbnz	r3, 804a1d2 <etharp_input+0x72>
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a1b0:	f105 0808 	add.w	r8, r5, #8
    for_us = 0;
 804a1b4:	2700      	movs	r7, #0
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a1b6:	2302      	movs	r3, #2
 804a1b8:	4642      	mov	r2, r8
 804a1ba:	a905      	add	r1, sp, #20
 804a1bc:	4630      	mov	r0, r6
 804a1be:	f7ff fecd 	bl	8049f5c <etharp_update_arp_entry>
  switch (hdr->opcode) {
 804a1c2:	88eb      	ldrh	r3, [r5, #6]
 804a1c4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 804a1c8:	d00e      	beq.n	804a1e8 <etharp_input+0x88>
  pbuf_free(p);
 804a1ca:	4620      	mov	r0, r4
 804a1cc:	f7fb fd64 	bl	8045c98 <pbuf_free>
 804a1d0:	e7dd      	b.n	804a18e <etharp_input+0x2e>
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
 804a1d2:	42bb      	cmp	r3, r7
 804a1d4:	bf14      	ite	ne
 804a1d6:	2700      	movne	r7, #0
 804a1d8:	2701      	moveq	r7, #1
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 804a1da:	f105 0808 	add.w	r8, r5, #8
 804a1de:	b10f      	cbz	r7, 804a1e4 <etharp_input+0x84>
 804a1e0:	2301      	movs	r3, #1
 804a1e2:	e7e9      	b.n	804a1b8 <etharp_input+0x58>
 804a1e4:	2302      	movs	r3, #2
 804a1e6:	e7e7      	b.n	804a1b8 <etharp_input+0x58>
    if (for_us) {
 804a1e8:	2f00      	cmp	r7, #0
 804a1ea:	d0ee      	beq.n	804a1ca <etharp_input+0x6a>
                 (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
 804a1ec:	f106 0125 	add.w	r1, r6, #37	; 0x25
                 (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
 804a1f0:	1d33      	adds	r3, r6, #4
      etharp_raw(netif,
 804a1f2:	2202      	movs	r2, #2
 804a1f4:	9203      	str	r2, [sp, #12]
 804a1f6:	aa05      	add	r2, sp, #20
 804a1f8:	9202      	str	r2, [sp, #8]
 804a1fa:	f8cd 8004 	str.w	r8, [sp, #4]
 804a1fe:	9300      	str	r3, [sp, #0]
 804a200:	460b      	mov	r3, r1
 804a202:	4642      	mov	r2, r8
 804a204:	4630      	mov	r0, r6
 804a206:	f7ff ff07 	bl	804a018 <etharp_raw>
 804a20a:	e7de      	b.n	804a1ca <etharp_input+0x6a>
 804a20c:	08059a38 	.word	0x08059a38
 804a210:	08059aec 	.word	0x08059aec
 804a214:	08058644 	.word	0x08058644

0804a218 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
 804a218:	b508      	push	{r3, lr}
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
 804a21a:	4a02      	ldr	r2, [pc, #8]	; (804a224 <etharp_request+0xc>)
 804a21c:	f7ff ff6e 	bl	804a0fc <etharp_request_dst>
}
 804a220:	bd08      	pop	{r3, pc}
 804a222:	bf00      	nop
 804a224:	080585d4 	.word	0x080585d4

0804a228 <etharp_tmr>:
{
 804a228:	b510      	push	{r4, lr}
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a22a:	2400      	movs	r4, #0
 804a22c:	e005      	b.n	804a23a <etharp_tmr+0x12>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 804a22e:	2b04      	cmp	r3, #4
 804a230:	d922      	bls.n	804a278 <etharp_tmr+0x50>
        etharp_free_entry(i);
 804a232:	f7ff fda7 	bl	8049d84 <etharp_free_entry>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 804a236:	3401      	adds	r4, #1
 804a238:	b2e4      	uxtb	r4, r4
 804a23a:	2c09      	cmp	r4, #9
 804a23c:	d83d      	bhi.n	804a2ba <etharp_tmr+0x92>
    u8_t state = arp_table[i].state;
 804a23e:	4620      	mov	r0, r4
 804a240:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a244:	00da      	lsls	r2, r3, #3
 804a246:	4b1d      	ldr	r3, [pc, #116]	; (804a2bc <etharp_tmr+0x94>)
 804a248:	4413      	add	r3, r2
 804a24a:	7d1b      	ldrb	r3, [r3, #20]
    if (state != ETHARP_STATE_EMPTY
 804a24c:	2b00      	cmp	r3, #0
 804a24e:	d0f2      	beq.n	804a236 <etharp_tmr+0xe>
      arp_table[i].ctime++;
 804a250:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a254:	00d3      	lsls	r3, r2, #3
 804a256:	4a19      	ldr	r2, [pc, #100]	; (804a2bc <etharp_tmr+0x94>)
 804a258:	441a      	add	r2, r3
 804a25a:	8a53      	ldrh	r3, [r2, #18]
 804a25c:	3301      	adds	r3, #1
 804a25e:	b29b      	uxth	r3, r3
 804a260:	8253      	strh	r3, [r2, #18]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 804a262:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 804a266:	d2e4      	bcs.n	804a232 <etharp_tmr+0xa>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 804a268:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a26c:	00d1      	lsls	r1, r2, #3
 804a26e:	4a13      	ldr	r2, [pc, #76]	; (804a2bc <etharp_tmr+0x94>)
 804a270:	440a      	add	r2, r1
 804a272:	7d12      	ldrb	r2, [r2, #20]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 804a274:	2a01      	cmp	r2, #1
 804a276:	d0da      	beq.n	804a22e <etharp_tmr+0x6>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
 804a278:	2a03      	cmp	r2, #3
 804a27a:	d00e      	beq.n	804a29a <etharp_tmr+0x72>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
 804a27c:	2a04      	cmp	r2, #4
 804a27e:	d014      	beq.n	804a2aa <etharp_tmr+0x82>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 804a280:	2a01      	cmp	r2, #1
 804a282:	d1d8      	bne.n	804a236 <etharp_tmr+0xe>
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
 804a284:	4b0d      	ldr	r3, [pc, #52]	; (804a2bc <etharp_tmr+0x94>)
 804a286:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 804a28a:	00d1      	lsls	r1, r2, #3
 804a28c:	4419      	add	r1, r3
 804a28e:	460b      	mov	r3, r1
 804a290:	3104      	adds	r1, #4
 804a292:	6898      	ldr	r0, [r3, #8]
 804a294:	f7ff ffc0 	bl	804a218 <etharp_request>
 804a298:	e7cd      	b.n	804a236 <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
 804a29a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 804a29e:	00c2      	lsls	r2, r0, #3
 804a2a0:	4b06      	ldr	r3, [pc, #24]	; (804a2bc <etharp_tmr+0x94>)
 804a2a2:	4413      	add	r3, r2
 804a2a4:	2204      	movs	r2, #4
 804a2a6:	751a      	strb	r2, [r3, #20]
 804a2a8:	e7c5      	b.n	804a236 <etharp_tmr+0xe>
        arp_table[i].state = ETHARP_STATE_STABLE;
 804a2aa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 804a2ae:	00c2      	lsls	r2, r0, #3
 804a2b0:	4b02      	ldr	r3, [pc, #8]	; (804a2bc <etharp_tmr+0x94>)
 804a2b2:	4413      	add	r3, r2
 804a2b4:	2202      	movs	r2, #2
 804a2b6:	751a      	strb	r2, [r3, #20]
 804a2b8:	e7bd      	b.n	804a236 <etharp_tmr+0xe>
}
 804a2ba:	bd10      	pop	{r4, pc}
 804a2bc:	2000430c 	.word	0x2000430c

0804a2c0 <etharp_output_to_arp_index>:
{
 804a2c0:	b570      	push	{r4, r5, r6, lr}
 804a2c2:	b082      	sub	sp, #8
 804a2c4:	4605      	mov	r5, r0
 804a2c6:	460e      	mov	r6, r1
 804a2c8:	4614      	mov	r4, r2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 804a2ca:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 804a2ce:	4b2f      	ldr	r3, [pc, #188]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a2d0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 804a2d4:	7d1b      	ldrb	r3, [r3, #20]
 804a2d6:	2b01      	cmp	r3, #1
 804a2d8:	d919      	bls.n	804a30e <etharp_output_to_arp_index+0x4e>
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
 804a2da:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a2de:	4a2b      	ldr	r2, [pc, #172]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a2e0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a2e4:	7d1b      	ldrb	r3, [r3, #20]
 804a2e6:	2b02      	cmp	r3, #2
 804a2e8:	d019      	beq.n	804a31e <etharp_output_to_arp_index+0x5e>
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
 804a2ea:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a2ee:	00db      	lsls	r3, r3, #3
 804a2f0:	3308      	adds	r3, #8
 804a2f2:	4c26      	ldr	r4, [pc, #152]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a2f4:	4423      	add	r3, r4
 804a2f6:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a2fa:	9200      	str	r2, [sp, #0]
 804a2fc:	3304      	adds	r3, #4
 804a2fe:	f105 0225 	add.w	r2, r5, #37	; 0x25
 804a302:	4631      	mov	r1, r6
 804a304:	4628      	mov	r0, r5
 804a306:	f001 f8c7 	bl	804b498 <ethernet_output>
}
 804a30a:	b002      	add	sp, #8
 804a30c:	bd70      	pop	{r4, r5, r6, pc}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 804a30e:	4b20      	ldr	r3, [pc, #128]	; (804a390 <etharp_output_to_arp_index+0xd0>)
 804a310:	f44f 723b 	mov.w	r2, #748	; 0x2ec
 804a314:	491f      	ldr	r1, [pc, #124]	; (804a394 <etharp_output_to_arp_index+0xd4>)
 804a316:	4820      	ldr	r0, [pc, #128]	; (804a398 <etharp_output_to_arp_index+0xd8>)
 804a318:	f006 ff68 	bl	80511ec <printf>
 804a31c:	e7dd      	b.n	804a2da <etharp_output_to_arp_index+0x1a>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
 804a31e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a322:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a326:	8a5b      	ldrh	r3, [r3, #18]
 804a328:	f5b3 7f8e 	cmp.w	r3, #284	; 0x11c
 804a32c:	d81b      	bhi.n	804a366 <etharp_output_to_arp_index+0xa6>
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
 804a32e:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 804a332:	d3da      	bcc.n	804a2ea <etharp_output_to_arp_index+0x2a>
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
 804a334:	4b15      	ldr	r3, [pc, #84]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a336:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 804a33a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 804a33e:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 804a342:	00d2      	lsls	r2, r2, #3
 804a344:	3208      	adds	r2, #8
 804a346:	441a      	add	r2, r3
 804a348:	3204      	adds	r2, #4
 804a34a:	3104      	adds	r1, #4
 804a34c:	4628      	mov	r0, r5
 804a34e:	f7ff fed5 	bl	804a0fc <etharp_request_dst>
 804a352:	2800      	cmp	r0, #0
 804a354:	d1c9      	bne.n	804a2ea <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 804a356:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a35a:	4a0c      	ldr	r2, [pc, #48]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a35c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a360:	2203      	movs	r2, #3
 804a362:	751a      	strb	r2, [r3, #20]
 804a364:	e7c1      	b.n	804a2ea <etharp_output_to_arp_index+0x2a>
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 804a366:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 804a36a:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 804a36e:	3104      	adds	r1, #4
 804a370:	4628      	mov	r0, r5
 804a372:	f7ff ff51 	bl	804a218 <etharp_request>
 804a376:	2800      	cmp	r0, #0
 804a378:	d1b7      	bne.n	804a2ea <etharp_output_to_arp_index+0x2a>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
 804a37a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a37e:	4a03      	ldr	r2, [pc, #12]	; (804a38c <etharp_output_to_arp_index+0xcc>)
 804a380:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a384:	2203      	movs	r2, #3
 804a386:	751a      	strb	r2, [r3, #20]
 804a388:	e7af      	b.n	804a2ea <etharp_output_to_arp_index+0x2a>
 804a38a:	bf00      	nop
 804a38c:	2000430c 	.word	0x2000430c
 804a390:	08059a38 	.word	0x08059a38
 804a394:	08059bb8 	.word	0x08059bb8
 804a398:	08058644 	.word	0x08058644

0804a39c <etharp_query>:
{
 804a39c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804a3a0:	b082      	sub	sp, #8
 804a3a2:	4606      	mov	r6, r0
 804a3a4:	460d      	mov	r5, r1
 804a3a6:	4690      	mov	r8, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 804a3a8:	f100 0925 	add.w	r9, r0, #37	; 0x25
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 804a3ac:	4601      	mov	r1, r0
 804a3ae:	6828      	ldr	r0, [r5, #0]
 804a3b0:	f000 fc19 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 804a3b4:	2800      	cmp	r0, #0
 804a3b6:	f040 80b3 	bne.w	804a520 <etharp_query+0x184>
      ip4_addr_ismulticast(ipaddr) ||
 804a3ba:	682b      	ldr	r3, [r5, #0]
 804a3bc:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
 804a3c0:	2ae0      	cmp	r2, #224	; 0xe0
 804a3c2:	f000 80b0 	beq.w	804a526 <etharp_query+0x18a>
      ip4_addr_ismulticast(ipaddr) ||
 804a3c6:	2d00      	cmp	r5, #0
 804a3c8:	f000 80b0 	beq.w	804a52c <etharp_query+0x190>
      ip4_addr_isany(ipaddr)) {
 804a3cc:	2b00      	cmp	r3, #0
 804a3ce:	f000 80b0 	beq.w	804a532 <etharp_query+0x196>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
 804a3d2:	4632      	mov	r2, r6
 804a3d4:	2101      	movs	r1, #1
 804a3d6:	4628      	mov	r0, r5
 804a3d8:	f7ff fcee 	bl	8049db8 <etharp_find_entry>
  if (i < 0) {
 804a3dc:	1e04      	subs	r4, r0, #0
 804a3de:	db5c      	blt.n	804a49a <etharp_query+0xfe>
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 804a3e0:	4627      	mov	r7, r4
 804a3e2:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a3e6:	4a56      	ldr	r2, [pc, #344]	; (804a540 <etharp_query+0x1a4>)
 804a3e8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a3ec:	7d1b      	ldrb	r3, [r3, #20]
 804a3ee:	b94b      	cbnz	r3, 804a404 <etharp_query+0x68>
    arp_table[i].state = ETHARP_STATE_PENDING;
 804a3f0:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 804a3f4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a3f8:	f04f 0a01 	mov.w	sl, #1
 804a3fc:	f883 a014 	strb.w	sl, [r3, #20]
    arp_table[i].netif = netif;
 804a400:	609e      	str	r6, [r3, #8]
 804a402:	e001      	b.n	804a408 <etharp_query+0x6c>
  int is_new_entry = 0;
 804a404:	f04f 0a00 	mov.w	sl, #0
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 804a408:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a40c:	4a4c      	ldr	r2, [pc, #304]	; (804a540 <etharp_query+0x1a4>)
 804a40e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a412:	7d1b      	ldrb	r3, [r3, #20]
 804a414:	b1b3      	cbz	r3, 804a444 <etharp_query+0xa8>
  if (is_new_entry || (q == NULL)) {
 804a416:	f1ba 0f00 	cmp.w	sl, #0
 804a41a:	d11b      	bne.n	804a454 <etharp_query+0xb8>
 804a41c:	f1b8 0f00 	cmp.w	r8, #0
 804a420:	d018      	beq.n	804a454 <etharp_query+0xb8>
  err_t result = ERR_MEM;
 804a422:	f04f 35ff 	mov.w	r5, #4294967295
  LWIP_ASSERT("q != NULL", q != NULL);
 804a426:	f1b8 0f00 	cmp.w	r8, #0
 804a42a:	d01d      	beq.n	804a468 <etharp_query+0xcc>
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 804a42c:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a430:	4a43      	ldr	r2, [pc, #268]	; (804a540 <etharp_query+0x1a4>)
 804a432:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 804a436:	7d1b      	ldrb	r3, [r3, #20]
 804a438:	2b01      	cmp	r3, #1
 804a43a:	d81d      	bhi.n	804a478 <etharp_query+0xdc>
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 804a43c:	2b01      	cmp	r3, #1
 804a43e:	d044      	beq.n	804a4ca <etharp_query+0x12e>
 804a440:	462c      	mov	r4, r5
 804a442:	e02a      	b.n	804a49a <etharp_query+0xfe>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
 804a444:	4b3f      	ldr	r3, [pc, #252]	; (804a544 <etharp_query+0x1a8>)
 804a446:	f240 32c7 	movw	r2, #967	; 0x3c7
 804a44a:	493f      	ldr	r1, [pc, #252]	; (804a548 <etharp_query+0x1ac>)
 804a44c:	483f      	ldr	r0, [pc, #252]	; (804a54c <etharp_query+0x1b0>)
 804a44e:	f006 fecd 	bl	80511ec <printf>
 804a452:	e7e0      	b.n	804a416 <etharp_query+0x7a>
    result = etharp_request(netif, ipaddr);
 804a454:	4629      	mov	r1, r5
 804a456:	4630      	mov	r0, r6
 804a458:	f7ff fede 	bl	804a218 <etharp_request>
 804a45c:	4605      	mov	r5, r0
    if (q == NULL) {
 804a45e:	f1b8 0f00 	cmp.w	r8, #0
 804a462:	d1e0      	bne.n	804a426 <etharp_query+0x8a>
      return result;
 804a464:	4604      	mov	r4, r0
 804a466:	e018      	b.n	804a49a <etharp_query+0xfe>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a468:	4b36      	ldr	r3, [pc, #216]	; (804a544 <etharp_query+0x1a8>)
 804a46a:	f240 32db 	movw	r2, #987	; 0x3db
 804a46e:	4938      	ldr	r1, [pc, #224]	; (804a550 <etharp_query+0x1b4>)
 804a470:	4836      	ldr	r0, [pc, #216]	; (804a54c <etharp_query+0x1b0>)
 804a472:	f006 febb 	bl	80511ec <printf>
 804a476:	e7d9      	b.n	804a42c <etharp_query+0x90>
    ETHARP_SET_HINT(netif, i);
 804a478:	f882 40f0 	strb.w	r4, [r2, #240]	; 0xf0
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
 804a47c:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a480:	00db      	lsls	r3, r3, #3
 804a482:	3308      	adds	r3, #8
 804a484:	4413      	add	r3, r2
 804a486:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a48a:	9200      	str	r2, [sp, #0]
 804a48c:	3304      	adds	r3, #4
 804a48e:	464a      	mov	r2, r9
 804a490:	4641      	mov	r1, r8
 804a492:	4630      	mov	r0, r6
 804a494:	f001 f800 	bl	804b498 <ethernet_output>
 804a498:	4604      	mov	r4, r0
}
 804a49a:	4620      	mov	r0, r4
 804a49c:	b002      	add	sp, #8
 804a49e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 804a4a2:	4b28      	ldr	r3, [pc, #160]	; (804a544 <etharp_query+0x1a8>)
 804a4a4:	f44f 727b 	mov.w	r2, #1004	; 0x3ec
 804a4a8:	492a      	ldr	r1, [pc, #168]	; (804a554 <etharp_query+0x1b8>)
 804a4aa:	4828      	ldr	r0, [pc, #160]	; (804a54c <etharp_query+0x1b0>)
 804a4ac:	f006 fe9e 	bl	80511ec <printf>
      if (p->type != PBUF_ROM) {
 804a4b0:	7b23      	ldrb	r3, [r4, #12]
 804a4b2:	2b01      	cmp	r3, #1
 804a4b4:	d11e      	bne.n	804a4f4 <etharp_query+0x158>
      p = p->next;
 804a4b6:	6824      	ldr	r4, [r4, #0]
    while (p) {
 804a4b8:	b14c      	cbz	r4, 804a4ce <etharp_query+0x132>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 804a4ba:	8962      	ldrh	r2, [r4, #10]
 804a4bc:	8923      	ldrh	r3, [r4, #8]
 804a4be:	429a      	cmp	r2, r3
 804a4c0:	d1f6      	bne.n	804a4b0 <etharp_query+0x114>
 804a4c2:	6823      	ldr	r3, [r4, #0]
 804a4c4:	2b00      	cmp	r3, #0
 804a4c6:	d1ec      	bne.n	804a4a2 <etharp_query+0x106>
 804a4c8:	e7f2      	b.n	804a4b0 <etharp_query+0x114>
    p = q;
 804a4ca:	4644      	mov	r4, r8
 804a4cc:	e7f4      	b.n	804a4b8 <etharp_query+0x11c>
    int copy_needed = 0;
 804a4ce:	2300      	movs	r3, #0
    if (copy_needed) {
 804a4d0:	b193      	cbz	r3, 804a4f8 <etharp_query+0x15c>
      p = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 804a4d2:	2200      	movs	r2, #0
 804a4d4:	8921      	ldrh	r1, [r4, #8]
 804a4d6:	2002      	movs	r0, #2
 804a4d8:	f7fb fc42 	bl	8045d60 <pbuf_alloc>
      if (p != NULL) {
 804a4dc:	4604      	mov	r4, r0
 804a4de:	b178      	cbz	r0, 804a500 <etharp_query+0x164>
        if (pbuf_copy(p, q) != ERR_OK) {
 804a4e0:	4641      	mov	r1, r8
 804a4e2:	f7fb fdff 	bl	80460e4 <pbuf_copy>
 804a4e6:	b158      	cbz	r0, 804a500 <etharp_query+0x164>
          pbuf_free(p);
 804a4e8:	4620      	mov	r0, r4
 804a4ea:	f7fb fbd5 	bl	8045c98 <pbuf_free>
      result = ERR_MEM;
 804a4ee:	f04f 34ff 	mov.w	r4, #4294967295
 804a4f2:	e7d2      	b.n	804a49a <etharp_query+0xfe>
        copy_needed = 1;
 804a4f4:	2301      	movs	r3, #1
 804a4f6:	e7eb      	b.n	804a4d0 <etharp_query+0x134>
      pbuf_ref(p);
 804a4f8:	4640      	mov	r0, r8
 804a4fa:	f7fb fda1 	bl	8046040 <pbuf_ref>
      p = q;
 804a4fe:	4644      	mov	r4, r8
    if (p != NULL) {
 804a500:	b1d4      	cbz	r4, 804a538 <etharp_query+0x19c>
      if (arp_table[i].q != NULL) {
 804a502:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a506:	4a0e      	ldr	r2, [pc, #56]	; (804a540 <etharp_query+0x1a4>)
 804a508:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 804a50c:	b108      	cbz	r0, 804a512 <etharp_query+0x176>
        pbuf_free(arp_table[i].q);
 804a50e:	f7fb fbc3 	bl	8045c98 <pbuf_free>
      arp_table[i].q = p;
 804a512:	eb07 0347 	add.w	r3, r7, r7, lsl #1
 804a516:	4a0a      	ldr	r2, [pc, #40]	; (804a540 <etharp_query+0x1a4>)
 804a518:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
      result = ERR_OK;
 804a51c:	2400      	movs	r4, #0
 804a51e:	e7bc      	b.n	804a49a <etharp_query+0xfe>
    return ERR_ARG;
 804a520:	f06f 040f 	mvn.w	r4, #15
 804a524:	e7b9      	b.n	804a49a <etharp_query+0xfe>
 804a526:	f06f 040f 	mvn.w	r4, #15
 804a52a:	e7b6      	b.n	804a49a <etharp_query+0xfe>
 804a52c:	f06f 040f 	mvn.w	r4, #15
 804a530:	e7b3      	b.n	804a49a <etharp_query+0xfe>
 804a532:	f06f 040f 	mvn.w	r4, #15
 804a536:	e7b0      	b.n	804a49a <etharp_query+0xfe>
      result = ERR_MEM;
 804a538:	f04f 34ff 	mov.w	r4, #4294967295
 804a53c:	e7ad      	b.n	804a49a <etharp_query+0xfe>
 804a53e:	bf00      	nop
 804a540:	2000430c 	.word	0x2000430c
 804a544:	08059a38 	.word	0x08059a38
 804a548:	08059be8 	.word	0x08059be8
 804a54c:	08058644 	.word	0x08058644
 804a550:	08059c10 	.word	0x08059c10
 804a554:	08059c1c 	.word	0x08059c1c

0804a558 <etharp_output>:
{
 804a558:	b5f0      	push	{r4, r5, r6, r7, lr}
 804a55a:	b085      	sub	sp, #20
 804a55c:	460e      	mov	r6, r1
 804a55e:	4615      	mov	r5, r2
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a560:	4607      	mov	r7, r0
 804a562:	2800      	cmp	r0, #0
 804a564:	d031      	beq.n	804a5ca <etharp_output+0x72>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a566:	2e00      	cmp	r6, #0
 804a568:	d037      	beq.n	804a5da <etharp_output+0x82>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 804a56a:	2d00      	cmp	r5, #0
 804a56c:	d03d      	beq.n	804a5ea <etharp_output+0x92>
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
 804a56e:	4639      	mov	r1, r7
 804a570:	6828      	ldr	r0, [r5, #0]
 804a572:	f000 fb38 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 804a576:	2800      	cmp	r0, #0
 804a578:	d17e      	bne.n	804a678 <etharp_output+0x120>
  } else if (ip4_addr_ismulticast(ipaddr)) {
 804a57a:	682b      	ldr	r3, [r5, #0]
 804a57c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 804a580:	2ae0      	cmp	r2, #224	; 0xe0
 804a582:	d03a      	beq.n	804a5fa <etharp_output+0xa2>
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 804a584:	687a      	ldr	r2, [r7, #4]
 804a586:	68b9      	ldr	r1, [r7, #8]
 804a588:	405a      	eors	r2, r3
 804a58a:	420a      	tst	r2, r1
 804a58c:	d009      	beq.n	804a5a2 <etharp_output+0x4a>
        !ip4_addr_islinklocal(ipaddr)) {
 804a58e:	b29b      	uxth	r3, r3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
 804a590:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 804a594:	4293      	cmp	r3, r2
 804a596:	d004      	beq.n	804a5a2 <etharp_output+0x4a>
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
 804a598:	68fb      	ldr	r3, [r7, #12]
 804a59a:	2b00      	cmp	r3, #0
 804a59c:	d078      	beq.n	804a690 <etharp_output+0x138>
            dst_addr = netif_ip4_gw(netif);
 804a59e:	f107 050c 	add.w	r5, r7, #12
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 804a5a2:	4b3d      	ldr	r3, [pc, #244]	; (804a698 <etharp_output+0x140>)
 804a5a4:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
 804a5a8:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 804a5ac:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 804a5b0:	7d1b      	ldrb	r3, [r3, #20]
 804a5b2:	2b01      	cmp	r3, #1
 804a5b4:	d958      	bls.n	804a668 <etharp_output+0x110>
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 804a5b6:	6828      	ldr	r0, [r5, #0]
 804a5b8:	460b      	mov	r3, r1
 804a5ba:	4937      	ldr	r1, [pc, #220]	; (804a698 <etharp_output+0x140>)
 804a5bc:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 804a5c0:	685b      	ldr	r3, [r3, #4]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 804a5c2:	4298      	cmp	r0, r3
 804a5c4:	d02f      	beq.n	804a626 <etharp_output+0xce>
 804a5c6:	2300      	movs	r3, #0
 804a5c8:	e034      	b.n	804a634 <etharp_output+0xdc>
  LWIP_ASSERT("netif != NULL", netif != NULL);
 804a5ca:	4b34      	ldr	r3, [pc, #208]	; (804a69c <etharp_output+0x144>)
 804a5cc:	f240 321b 	movw	r2, #795	; 0x31b
 804a5d0:	4933      	ldr	r1, [pc, #204]	; (804a6a0 <etharp_output+0x148>)
 804a5d2:	4834      	ldr	r0, [pc, #208]	; (804a6a4 <etharp_output+0x14c>)
 804a5d4:	f006 fe0a 	bl	80511ec <printf>
 804a5d8:	e7c5      	b.n	804a566 <etharp_output+0xe>
  LWIP_ASSERT("q != NULL", q != NULL);
 804a5da:	4b30      	ldr	r3, [pc, #192]	; (804a69c <etharp_output+0x144>)
 804a5dc:	f44f 7247 	mov.w	r2, #796	; 0x31c
 804a5e0:	4931      	ldr	r1, [pc, #196]	; (804a6a8 <etharp_output+0x150>)
 804a5e2:	4830      	ldr	r0, [pc, #192]	; (804a6a4 <etharp_output+0x14c>)
 804a5e4:	f006 fe02 	bl	80511ec <printf>
 804a5e8:	e7bf      	b.n	804a56a <etharp_output+0x12>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 804a5ea:	4b2c      	ldr	r3, [pc, #176]	; (804a69c <etharp_output+0x144>)
 804a5ec:	f240 321d 	movw	r2, #797	; 0x31d
 804a5f0:	492e      	ldr	r1, [pc, #184]	; (804a6ac <etharp_output+0x154>)
 804a5f2:	482c      	ldr	r0, [pc, #176]	; (804a6a4 <etharp_output+0x14c>)
 804a5f4:	f006 fdfa 	bl	80511ec <printf>
 804a5f8:	e7b9      	b.n	804a56e <etharp_output+0x16>
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
 804a5fa:	2301      	movs	r3, #1
 804a5fc:	f88d 3008 	strb.w	r3, [sp, #8]
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
 804a600:	2300      	movs	r3, #0
 804a602:	f88d 3009 	strb.w	r3, [sp, #9]
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
 804a606:	235e      	movs	r3, #94	; 0x5e
 804a608:	f88d 300a 	strb.w	r3, [sp, #10]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 804a60c:	786b      	ldrb	r3, [r5, #1]
 804a60e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 804a612:	f88d 300b 	strb.w	r3, [sp, #11]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 804a616:	78ab      	ldrb	r3, [r5, #2]
 804a618:	f88d 300c 	strb.w	r3, [sp, #12]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 804a61c:	78eb      	ldrb	r3, [r5, #3]
 804a61e:	f88d 300d 	strb.w	r3, [sp, #13]
    dest = &mcastaddr;
 804a622:	ab02      	add	r3, sp, #8
 804a624:	e029      	b.n	804a67a <etharp_output+0x122>
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 804a626:	4631      	mov	r1, r6
 804a628:	4638      	mov	r0, r7
 804a62a:	f7ff fe49 	bl	804a2c0 <etharp_output_to_arp_index>
 804a62e:	e02d      	b.n	804a68c <etharp_output+0x134>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 804a630:	3301      	adds	r3, #1
 804a632:	b25b      	sxtb	r3, r3
 804a634:	2b09      	cmp	r3, #9
 804a636:	dc19      	bgt.n	804a66c <etharp_output+0x114>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 804a638:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 804a63c:	4c16      	ldr	r4, [pc, #88]	; (804a698 <etharp_output+0x140>)
 804a63e:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 804a642:	7d02      	ldrb	r2, [r0, #20]
 804a644:	2a01      	cmp	r2, #1
 804a646:	d9f3      	bls.n	804a630 <etharp_output+0xd8>
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 804a648:	6828      	ldr	r0, [r5, #0]
 804a64a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 804a64e:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 804a652:	6852      	ldr	r2, [r2, #4]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 804a654:	4290      	cmp	r0, r2
 804a656:	d1eb      	bne.n	804a630 <etharp_output+0xd8>
        ETHARP_SET_HINT(netif, i);
 804a658:	b2da      	uxtb	r2, r3
 804a65a:	f884 20f0 	strb.w	r2, [r4, #240]	; 0xf0
        return etharp_output_to_arp_index(netif, q, i);
 804a65e:	4631      	mov	r1, r6
 804a660:	4638      	mov	r0, r7
 804a662:	f7ff fe2d 	bl	804a2c0 <etharp_output_to_arp_index>
 804a666:	e011      	b.n	804a68c <etharp_output+0x134>
 804a668:	2300      	movs	r3, #0
 804a66a:	e7e3      	b.n	804a634 <etharp_output+0xdc>
    return etharp_query(netif, dst_addr, q);
 804a66c:	4632      	mov	r2, r6
 804a66e:	4629      	mov	r1, r5
 804a670:	4638      	mov	r0, r7
 804a672:	f7ff fe93 	bl	804a39c <etharp_query>
 804a676:	e009      	b.n	804a68c <etharp_output+0x134>
    dest = (const struct eth_addr *)&ethbroadcast;
 804a678:	4b0d      	ldr	r3, [pc, #52]	; (804a6b0 <etharp_output+0x158>)
  return ethernet_output(netif, q, (struct eth_addr*)(netif->hwaddr), dest, ETHTYPE_IP);
 804a67a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 804a67e:	9200      	str	r2, [sp, #0]
 804a680:	f107 0225 	add.w	r2, r7, #37	; 0x25
 804a684:	4631      	mov	r1, r6
 804a686:	4638      	mov	r0, r7
 804a688:	f000 ff06 	bl	804b498 <ethernet_output>
}
 804a68c:	b005      	add	sp, #20
 804a68e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            return ERR_RTE;
 804a690:	f06f 0003 	mvn.w	r0, #3
 804a694:	e7fa      	b.n	804a68c <etharp_output+0x134>
 804a696:	bf00      	nop
 804a698:	2000430c 	.word	0x2000430c
 804a69c:	08059a38 	.word	0x08059a38
 804a6a0:	08059aec 	.word	0x08059aec
 804a6a4:	08058644 	.word	0x08058644
 804a6a8:	08059c10 	.word	0x08059c10
 804a6ac:	08059b98 	.word	0x08059b98
 804a6b0:	080585d4 	.word	0x080585d4

0804a6b4 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 804a6b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a6b8:	b086      	sub	sp, #24
 804a6ba:	4606      	mov	r6, r0
 804a6bc:	4688      	mov	r8, r1
 804a6be:	4617      	mov	r7, r2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 804a6c0:	2200      	movs	r2, #0
 804a6c2:	2124      	movs	r1, #36	; 0x24
 804a6c4:	2001      	movs	r0, #1
 804a6c6:	f7fb fb4b 	bl	8045d60 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 804a6ca:	b3a0      	cbz	r0, 804a736 <icmp_send_response+0x82>
 804a6cc:	4605      	mov	r5, r0
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 804a6ce:	8943      	ldrh	r3, [r0, #10]
 804a6d0:	2b23      	cmp	r3, #35	; 0x23
 804a6d2:	d933      	bls.n	804a73c <icmp_send_response+0x88>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 804a6d4:	f8d6 c004 	ldr.w	ip, [r6, #4]
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 804a6d8:	686c      	ldr	r4, [r5, #4]
  icmphdr->type = type;
 804a6da:	f884 8000 	strb.w	r8, [r4]
  icmphdr->code = code;
 804a6de:	7067      	strb	r7, [r4, #1]
  icmphdr->id = 0;
 804a6e0:	2300      	movs	r3, #0
 804a6e2:	7123      	strb	r3, [r4, #4]
 804a6e4:	7163      	strb	r3, [r4, #5]
  icmphdr->seqno = 0;
 804a6e6:	71a3      	strb	r3, [r4, #6]
 804a6e8:	71e3      	strb	r3, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 804a6ea:	686b      	ldr	r3, [r5, #4]
 804a6ec:	6872      	ldr	r2, [r6, #4]
 804a6ee:	6816      	ldr	r6, [r2, #0]
 804a6f0:	6850      	ldr	r0, [r2, #4]
 804a6f2:	6891      	ldr	r1, [r2, #8]
 804a6f4:	68d7      	ldr	r7, [r2, #12]
 804a6f6:	609e      	str	r6, [r3, #8]
 804a6f8:	60d8      	str	r0, [r3, #12]
 804a6fa:	6119      	str	r1, [r3, #16]
 804a6fc:	615f      	str	r7, [r3, #20]
 804a6fe:	6916      	ldr	r6, [r2, #16]
 804a700:	6950      	ldr	r0, [r2, #20]
 804a702:	6991      	ldr	r1, [r2, #24]
 804a704:	619e      	str	r6, [r3, #24]
 804a706:	61d8      	str	r0, [r3, #28]
 804a708:	6219      	str	r1, [r3, #32]
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
 804a70a:	f8dc 300c 	ldr.w	r3, [ip, #12]
 804a70e:	9305      	str	r3, [sp, #20]
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_src, &iphdr_dst);
  }
#else
  netif = ip4_route(&iphdr_src);
 804a710:	a805      	add	r0, sp, #20
 804a712:	f000 f8cb 	bl	804a8ac <ip4_route>
#endif
  if (netif != NULL) {
 804a716:	b158      	cbz	r0, 804a730 <icmp_send_response+0x7c>
    /* calculate checksum */
    icmphdr->chksum = 0;
 804a718:	2100      	movs	r1, #0
 804a71a:	70a1      	strb	r1, [r4, #2]
 804a71c:	70e1      	strb	r1, [r4, #3]
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
 804a71e:	9002      	str	r0, [sp, #8]
 804a720:	2301      	movs	r3, #1
 804a722:	9301      	str	r3, [sp, #4]
 804a724:	9100      	str	r1, [sp, #0]
 804a726:	23ff      	movs	r3, #255	; 0xff
 804a728:	aa05      	add	r2, sp, #20
 804a72a:	4628      	mov	r0, r5
 804a72c:	f000 fa46 	bl	804abbc <ip4_output_if>
  }
  pbuf_free(q);
 804a730:	4628      	mov	r0, r5
 804a732:	f7fb fab1 	bl	8045c98 <pbuf_free>
}
 804a736:	b006      	add	sp, #24
 804a738:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 804a73c:	4b03      	ldr	r3, [pc, #12]	; (804a74c <icmp_send_response+0x98>)
 804a73e:	f240 1261 	movw	r2, #353	; 0x161
 804a742:	4903      	ldr	r1, [pc, #12]	; (804a750 <icmp_send_response+0x9c>)
 804a744:	4803      	ldr	r0, [pc, #12]	; (804a754 <icmp_send_response+0xa0>)
 804a746:	f006 fd51 	bl	80511ec <printf>
 804a74a:	e7c3      	b.n	804a6d4 <icmp_send_response+0x20>
 804a74c:	08059c38 	.word	0x08059c38
 804a750:	08059c70 	.word	0x08059c70
 804a754:	08058644 	.word	0x08058644

0804a758 <icmp_input>:
{
 804a758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804a75c:	b084      	sub	sp, #16
 804a75e:	4605      	mov	r5, r0
  iphdr_in = ip4_current_header();
 804a760:	4b47      	ldr	r3, [pc, #284]	; (804a880 <icmp_input+0x128>)
 804a762:	689e      	ldr	r6, [r3, #8]
  hlen = IPH_HL(iphdr_in) * 4;
 804a764:	7834      	ldrb	r4, [r6, #0]
 804a766:	f004 040f 	and.w	r4, r4, #15
 804a76a:	00a4      	lsls	r4, r4, #2
  if (hlen < IP_HLEN) {
 804a76c:	2c13      	cmp	r4, #19
 804a76e:	d915      	bls.n	804a79c <icmp_input+0x44>
 804a770:	460f      	mov	r7, r1
  if (p->len < sizeof(u16_t)*2) {
 804a772:	8943      	ldrh	r3, [r0, #10]
 804a774:	2b03      	cmp	r3, #3
 804a776:	d911      	bls.n	804a79c <icmp_input+0x44>
  type = *((u8_t *)p->payload);
 804a778:	6843      	ldr	r3, [r0, #4]
 804a77a:	781b      	ldrb	r3, [r3, #0]
  switch (type) {
 804a77c:	2b08      	cmp	r3, #8
 804a77e:	d15d      	bne.n	804a83c <icmp_input+0xe4>
    if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804a780:	4b3f      	ldr	r3, [pc, #252]	; (804a880 <icmp_input+0x128>)
 804a782:	6958      	ldr	r0, [r3, #20]
 804a784:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
 804a788:	2be0      	cmp	r3, #224	; 0xe0
 804a78a:	d037      	beq.n	804a7fc <icmp_input+0xa4>
    if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
 804a78c:	4b3c      	ldr	r3, [pc, #240]	; (804a880 <icmp_input+0x128>)
 804a78e:	6819      	ldr	r1, [r3, #0]
 804a790:	f000 fa29 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 804a794:	bb90      	cbnz	r0, 804a7fc <icmp_input+0xa4>
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 804a796:	892b      	ldrh	r3, [r5, #8]
 804a798:	2b07      	cmp	r3, #7
 804a79a:	d805      	bhi.n	804a7a8 <icmp_input+0x50>
  pbuf_free(p);
 804a79c:	4628      	mov	r0, r5
 804a79e:	f7fb fa7b 	bl	8045c98 <pbuf_free>
}
 804a7a2:	b004      	add	sp, #16
 804a7a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 804a7a8:	f104 010e 	add.w	r1, r4, #14
 804a7ac:	4628      	mov	r0, r5
 804a7ae:	f7fb fa69 	bl	8045c84 <pbuf_header>
 804a7b2:	b3a8      	cbz	r0, 804a820 <icmp_input+0xc8>
      r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
 804a7b4:	8929      	ldrh	r1, [r5, #8]
 804a7b6:	4421      	add	r1, r4
 804a7b8:	2200      	movs	r2, #0
 804a7ba:	b289      	uxth	r1, r1
 804a7bc:	2002      	movs	r0, #2
 804a7be:	f7fb facf 	bl	8045d60 <pbuf_alloc>
      if (r == NULL) {
 804a7c2:	4680      	mov	r8, r0
 804a7c4:	b1d0      	cbz	r0, 804a7fc <icmp_input+0xa4>
      if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
 804a7c6:	8942      	ldrh	r2, [r0, #10]
 804a7c8:	f104 0308 	add.w	r3, r4, #8
 804a7cc:	429a      	cmp	r2, r3
 804a7ce:	d313      	bcc.n	804a7f8 <icmp_input+0xa0>
      MEMCPY(r->payload, iphdr_in, hlen);
 804a7d0:	4622      	mov	r2, r4
 804a7d2:	4631      	mov	r1, r6
 804a7d4:	6840      	ldr	r0, [r0, #4]
 804a7d6:	f006 fce7 	bl	80511a8 <memcpy>
      if (pbuf_header(r, (s16_t)-hlen)) {
 804a7da:	4261      	negs	r1, r4
 804a7dc:	4640      	mov	r0, r8
 804a7de:	f7fb fa51 	bl	8045c84 <pbuf_header>
 804a7e2:	b978      	cbnz	r0, 804a804 <icmp_input+0xac>
      if (pbuf_copy(r, p) != ERR_OK) {
 804a7e4:	4629      	mov	r1, r5
 804a7e6:	4640      	mov	r0, r8
 804a7e8:	f7fb fc7c 	bl	80460e4 <pbuf_copy>
 804a7ec:	b9a0      	cbnz	r0, 804a818 <icmp_input+0xc0>
      pbuf_free(p);
 804a7ee:	4628      	mov	r0, r5
 804a7f0:	f7fb fa52 	bl	8045c98 <pbuf_free>
      p = r;
 804a7f4:	4645      	mov	r5, r8
 804a7f6:	e01b      	b.n	804a830 <icmp_input+0xd8>
        pbuf_free(r);
 804a7f8:	f7fb fa4e 	bl	8045c98 <pbuf_free>
  pbuf_free(p);
 804a7fc:	4628      	mov	r0, r5
 804a7fe:	f7fb fa4b 	bl	8045c98 <pbuf_free>
  return;
 804a802:	e7ce      	b.n	804a7a2 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
 804a804:	4b1f      	ldr	r3, [pc, #124]	; (804a884 <icmp_input+0x12c>)
 804a806:	22af      	movs	r2, #175	; 0xaf
 804a808:	491f      	ldr	r1, [pc, #124]	; (804a888 <icmp_input+0x130>)
 804a80a:	4820      	ldr	r0, [pc, #128]	; (804a88c <icmp_input+0x134>)
 804a80c:	f006 fcee 	bl	80511ec <printf>
        pbuf_free(r);
 804a810:	4640      	mov	r0, r8
 804a812:	f7fb fa41 	bl	8045c98 <pbuf_free>
        goto icmperr;
 804a816:	e7f1      	b.n	804a7fc <icmp_input+0xa4>
        pbuf_free(r);
 804a818:	4640      	mov	r0, r8
 804a81a:	f7fb fa3d 	bl	8045c98 <pbuf_free>
        goto icmperr;
 804a81e:	e7ed      	b.n	804a7fc <icmp_input+0xa4>
      if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
 804a820:	f5c4 417f 	rsb	r1, r4, #65280	; 0xff00
 804a824:	31f2      	adds	r1, #242	; 0xf2
 804a826:	b209      	sxth	r1, r1
 804a828:	4628      	mov	r0, r5
 804a82a:	f7fb fa2b 	bl	8045c84 <pbuf_header>
 804a82e:	b948      	cbnz	r0, 804a844 <icmp_input+0xec>
    iecho = (struct icmp_echo_hdr *)p->payload;
 804a830:	686e      	ldr	r6, [r5, #4]
    if (pbuf_header(p, (s16_t)hlen)) {
 804a832:	4621      	mov	r1, r4
 804a834:	4628      	mov	r0, r5
 804a836:	f7fb fa25 	bl	8045c84 <pbuf_header>
 804a83a:	b150      	cbz	r0, 804a852 <icmp_input+0xfa>
  pbuf_free(p);
 804a83c:	4628      	mov	r0, r5
 804a83e:	f7fb fa2b 	bl	8045c98 <pbuf_free>
  return;
 804a842:	e7ae      	b.n	804a7a2 <icmp_input+0x4a>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 804a844:	4b0f      	ldr	r3, [pc, #60]	; (804a884 <icmp_input+0x12c>)
 804a846:	22c0      	movs	r2, #192	; 0xc0
 804a848:	4911      	ldr	r1, [pc, #68]	; (804a890 <icmp_input+0x138>)
 804a84a:	4810      	ldr	r0, [pc, #64]	; (804a88c <icmp_input+0x134>)
 804a84c:	f006 fcce 	bl	80511ec <printf>
        goto icmperr;
 804a850:	e7d4      	b.n	804a7fc <icmp_input+0xa4>
      struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
 804a852:	6868      	ldr	r0, [r5, #4]
      ip4_addr_copy(iphdr->src, *src);
 804a854:	490a      	ldr	r1, [pc, #40]	; (804a880 <icmp_input+0x128>)
 804a856:	694b      	ldr	r3, [r1, #20]
 804a858:	60c3      	str	r3, [r0, #12]
      ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
 804a85a:	690b      	ldr	r3, [r1, #16]
 804a85c:	6103      	str	r3, [r0, #16]
      ICMPH_TYPE_SET(iecho, ICMP_ER);
 804a85e:	2200      	movs	r2, #0
 804a860:	7032      	strb	r2, [r6, #0]
      iecho->chksum = 0;
 804a862:	70b2      	strb	r2, [r6, #2]
 804a864:	70f2      	strb	r2, [r6, #3]
      IPH_TTL_SET(iphdr, ICMP_TTL);
 804a866:	23ff      	movs	r3, #255	; 0xff
 804a868:	7203      	strb	r3, [r0, #8]
      IPH_CHKSUM_SET(iphdr, 0);
 804a86a:	7282      	strb	r2, [r0, #10]
 804a86c:	72c2      	strb	r2, [r0, #11]
      ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
 804a86e:	9702      	str	r7, [sp, #8]
 804a870:	2001      	movs	r0, #1
 804a872:	9001      	str	r0, [sp, #4]
 804a874:	9200      	str	r2, [sp, #0]
 804a876:	3114      	adds	r1, #20
 804a878:	4628      	mov	r0, r5
 804a87a:	f000 f99f 	bl	804abbc <ip4_output_if>
      if (ret != ERR_OK) {
 804a87e:	e7dd      	b.n	804a83c <icmp_input+0xe4>
 804a880:	2000546c 	.word	0x2000546c
 804a884:	08059c38 	.word	0x08059c38
 804a888:	08059c9c 	.word	0x08059c9c
 804a88c:	08058644 	.word	0x08058644
 804a890:	08059cd4 	.word	0x08059cd4

0804a894 <icmp_dest_unreach>:
{
 804a894:	b508      	push	{r3, lr}
 804a896:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_DUR, t);
 804a898:	2103      	movs	r1, #3
 804a89a:	f7ff ff0b 	bl	804a6b4 <icmp_send_response>
}
 804a89e:	bd08      	pop	{r3, pc}

0804a8a0 <icmp_time_exceeded>:
{
 804a8a0:	b508      	push	{r3, lr}
 804a8a2:	460a      	mov	r2, r1
  icmp_send_response(p, ICMP_TE, t);
 804a8a4:	210b      	movs	r1, #11
 804a8a6:	f7ff ff05 	bl	804a6b4 <icmp_send_response>
}
 804a8aa:	bd08      	pop	{r3, pc}

0804a8ac <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
 804a8ac:	b430      	push	{r4, r5}
 804a8ae:	4604      	mov	r4, r0
    return ip4_default_multicast_netif;
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 804a8b0:	4b14      	ldr	r3, [pc, #80]	; (804a904 <ip4_route+0x58>)
 804a8b2:	6818      	ldr	r0, [r3, #0]
 804a8b4:	e000      	b.n	804a8b8 <ip4_route+0xc>
 804a8b6:	6800      	ldr	r0, [r0, #0]
 804a8b8:	b1b0      	cbz	r0, 804a8e8 <ip4_route+0x3c>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
 804a8ba:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 804a8be:	f013 0f01 	tst.w	r3, #1
 804a8c2:	d0f8      	beq.n	804a8b6 <ip4_route+0xa>
 804a8c4:	f013 0f04 	tst.w	r3, #4
 804a8c8:	d0f5      	beq.n	804a8b6 <ip4_route+0xa>
 804a8ca:	6842      	ldr	r2, [r0, #4]
 804a8cc:	2a00      	cmp	r2, #0
 804a8ce:	d0f2      	beq.n	804a8b6 <ip4_route+0xa>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
 804a8d0:	6821      	ldr	r1, [r4, #0]
 804a8d2:	6885      	ldr	r5, [r0, #8]
 804a8d4:	404a      	eors	r2, r1
 804a8d6:	422a      	tst	r2, r5
 804a8d8:	d012      	beq.n	804a900 <ip4_route+0x54>
        /* return netif on which to forward IP packet */
        return netif;
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
 804a8da:	f013 0f02 	tst.w	r3, #2
 804a8de:	d1ea      	bne.n	804a8b6 <ip4_route+0xa>
 804a8e0:	68c3      	ldr	r3, [r0, #12]
 804a8e2:	4299      	cmp	r1, r3
 804a8e4:	d1e7      	bne.n	804a8b6 <ip4_route+0xa>
 804a8e6:	e00b      	b.n	804a900 <ip4_route+0x54>
  if (netif != NULL) {
    return netif;
  }
#endif

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 804a8e8:	4b07      	ldr	r3, [pc, #28]	; (804a908 <ip4_route+0x5c>)
 804a8ea:	681b      	ldr	r3, [r3, #0]
 804a8ec:	b143      	cbz	r3, 804a900 <ip4_route+0x54>
 804a8ee:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 804a8f2:	f002 0205 	and.w	r2, r2, #5
 804a8f6:	2a05      	cmp	r2, #5
 804a8f8:	d102      	bne.n	804a900 <ip4_route+0x54>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
 804a8fa:	685a      	ldr	r2, [r3, #4]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
 804a8fc:	b102      	cbz	r2, 804a900 <ip4_route+0x54>
    IP_STATS_INC(ip.rterr);
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
  }

  return netif_default;
 804a8fe:	4618      	mov	r0, r3
}
 804a900:	bc30      	pop	{r4, r5}
 804a902:	4770      	bx	lr
 804a904:	2000898c 	.word	0x2000898c
 804a908:	20008990 	.word	0x20008990

0804a90c <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
 804a90c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804a910:	4605      	mov	r5, r0

  IP_STATS_INC(ip.recv);
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 804a912:	f8d0 8004 	ldr.w	r8, [r0, #4]
  if (IPH_V(iphdr) != 4) {
 804a916:	f898 3000 	ldrb.w	r3, [r8]
 804a91a:	091a      	lsrs	r2, r3, #4
 804a91c:	2a04      	cmp	r2, #4
 804a91e:	d004      	beq.n	804a92a <ip4_input+0x1e>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
 804a920:	f7fb f9ba 	bl	8045c98 <pbuf_free>
  ip_data.current_ip_header_tot_len = 0;
  ip4_addr_set_any(ip4_current_src_addr());
  ip4_addr_set_any(ip4_current_dest_addr());

  return ERR_OK;
}
 804a924:	2000      	movs	r0, #0
 804a926:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 804a92a:	460e      	mov	r6, r1
  iphdr_hlen = IPH_HL(iphdr);
 804a92c:	f003 030f 	and.w	r3, r3, #15
  iphdr_hlen *= 4;
 804a930:	009f      	lsls	r7, r3, #2
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
 804a932:	f8b8 0002 	ldrh.w	r0, [r8, #2]
 804a936:	f7fa fd79 	bl	804542c <lwip_htons>
 804a93a:	4604      	mov	r4, r0
  if (iphdr_len < p->tot_len) {
 804a93c:	892b      	ldrh	r3, [r5, #8]
 804a93e:	4283      	cmp	r3, r0
 804a940:	d816      	bhi.n	804a970 <ip4_input+0x64>
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
 804a942:	896b      	ldrh	r3, [r5, #10]
 804a944:	42bb      	cmp	r3, r7
 804a946:	d318      	bcc.n	804a97a <ip4_input+0x6e>
 804a948:	892b      	ldrh	r3, [r5, #8]
 804a94a:	42a3      	cmp	r3, r4
 804a94c:	d315      	bcc.n	804a97a <ip4_input+0x6e>
 804a94e:	2f13      	cmp	r7, #19
 804a950:	d913      	bls.n	804a97a <ip4_input+0x6e>
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
 804a952:	f8d8 3010 	ldr.w	r3, [r8, #16]
 804a956:	4a5a      	ldr	r2, [pc, #360]	; (804aac0 <ip4_input+0x1b4>)
 804a958:	6153      	str	r3, [r2, #20]
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
 804a95a:	f8d8 100c 	ldr.w	r1, [r8, #12]
 804a95e:	6111      	str	r1, [r2, #16]
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804a960:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 804a964:	2be0      	cmp	r3, #224	; 0xe0
 804a966:	d00c      	beq.n	804a982 <ip4_input+0x76>
    netif = inp;
 804a968:	4634      	mov	r4, r6
    int first = 1;
 804a96a:	f04f 0901 	mov.w	r9, #1
 804a96e:	e016      	b.n	804a99e <ip4_input+0x92>
    pbuf_realloc(p, iphdr_len);
 804a970:	4601      	mov	r1, r0
 804a972:	4628      	mov	r0, r5
 804a974:	f7fb fae4 	bl	8045f40 <pbuf_realloc>
 804a978:	e7e3      	b.n	804a942 <ip4_input+0x36>
    pbuf_free(p);
 804a97a:	4628      	mov	r0, r5
 804a97c:	f7fb f98c 	bl	8045c98 <pbuf_free>
    return ERR_OK;
 804a980:	e7d0      	b.n	804a924 <ip4_input+0x18>
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
 804a982:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 804a986:	f013 0f01 	tst.w	r3, #1
 804a98a:	d025      	beq.n	804a9d8 <ip4_input+0xcc>
 804a98c:	6873      	ldr	r3, [r6, #4]
 804a98e:	2b00      	cmp	r3, #0
 804a990:	d167      	bne.n	804aa62 <ip4_input+0x156>
      netif = NULL;
 804a992:	2400      	movs	r4, #0
 804a994:	e021      	b.n	804a9da <ip4_input+0xce>
        netif = netif->next;
 804a996:	6824      	ldr	r4, [r4, #0]
      if (netif == inp) {
 804a998:	42b4      	cmp	r4, r6
 804a99a:	d01b      	beq.n	804a9d4 <ip4_input+0xc8>
    } while (netif != NULL);
 804a99c:	b1ec      	cbz	r4, 804a9da <ip4_input+0xce>
      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
 804a99e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804a9a2:	f013 0f01 	tst.w	r3, #1
 804a9a6:	d009      	beq.n	804a9bc <ip4_input+0xb0>
 804a9a8:	6863      	ldr	r3, [r4, #4]
 804a9aa:	b13b      	cbz	r3, 804a9bc <ip4_input+0xb0>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 804a9ac:	4a44      	ldr	r2, [pc, #272]	; (804aac0 <ip4_input+0x1b4>)
 804a9ae:	6950      	ldr	r0, [r2, #20]
 804a9b0:	4283      	cmp	r3, r0
 804a9b2:	d012      	beq.n	804a9da <ip4_input+0xce>
            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
 804a9b4:	4621      	mov	r1, r4
 804a9b6:	f000 f916 	bl	804abe6 <ip4_addr_isbroadcast_u32>
        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
 804a9ba:	b970      	cbnz	r0, 804a9da <ip4_input+0xce>
      if (first) {
 804a9bc:	f1b9 0f00 	cmp.w	r9, #0
 804a9c0:	d0e9      	beq.n	804a996 <ip4_input+0x8a>
        if (ip4_addr_isloopback(ip4_current_dest_addr())) {
 804a9c2:	4b3f      	ldr	r3, [pc, #252]	; (804aac0 <ip4_input+0x1b4>)
 804a9c4:	7d1b      	ldrb	r3, [r3, #20]
 804a9c6:	2b7f      	cmp	r3, #127	; 0x7f
 804a9c8:	d04d      	beq.n	804aa66 <ip4_input+0x15a>
        netif = netif_list;
 804a9ca:	4b3e      	ldr	r3, [pc, #248]	; (804aac4 <ip4_input+0x1b8>)
 804a9cc:	681c      	ldr	r4, [r3, #0]
        first = 0;
 804a9ce:	f04f 0900 	mov.w	r9, #0
 804a9d2:	e7e1      	b.n	804a998 <ip4_input+0x8c>
        netif = netif->next;
 804a9d4:	6824      	ldr	r4, [r4, #0]
 804a9d6:	e7e1      	b.n	804a99c <ip4_input+0x90>
      netif = NULL;
 804a9d8:	2400      	movs	r4, #0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 804a9da:	4631      	mov	r1, r6
 804a9dc:	4b38      	ldr	r3, [pc, #224]	; (804aac0 <ip4_input+0x1b4>)
 804a9de:	6918      	ldr	r0, [r3, #16]
 804a9e0:	f000 f901 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 804a9e4:	2800      	cmp	r0, #0
 804a9e6:	d140      	bne.n	804aa6a <ip4_input+0x15e>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
 804a9e8:	4b35      	ldr	r3, [pc, #212]	; (804aac0 <ip4_input+0x1b4>)
 804a9ea:	691b      	ldr	r3, [r3, #16]
 804a9ec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
 804a9f0:	2be0      	cmp	r3, #224	; 0xe0
 804a9f2:	d03a      	beq.n	804aa6a <ip4_input+0x15e>
  if (netif == NULL) {
 804a9f4:	2c00      	cmp	r4, #0
 804a9f6:	d03c      	beq.n	804aa72 <ip4_input+0x166>
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 804a9f8:	f8b8 3006 	ldrh.w	r3, [r8, #6]
 804a9fc:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 804aa00:	b29b      	uxth	r3, r3
 804aa02:	b13b      	cbz	r3, 804aa14 <ip4_input+0x108>
    p = ip4_reass(p);
 804aa04:	4628      	mov	r0, r5
 804aa06:	f000 fb2d 	bl	804b064 <ip4_reass>
    if (p == NULL) {
 804aa0a:	4605      	mov	r5, r0
 804aa0c:	2800      	cmp	r0, #0
 804aa0e:	d089      	beq.n	804a924 <ip4_input+0x18>
    iphdr = (struct ip_hdr *)p->payload;
 804aa10:	f8d0 8004 	ldr.w	r8, [r0, #4]
  ip_data.current_netif = netif;
 804aa14:	4a2a      	ldr	r2, [pc, #168]	; (804aac0 <ip4_input+0x1b4>)
 804aa16:	6014      	str	r4, [r2, #0]
  ip_data.current_input_netif = inp;
 804aa18:	6056      	str	r6, [r2, #4]
  ip_data.current_ip4_header = iphdr;
 804aa1a:	f8c2 8008 	str.w	r8, [r2, #8]
  ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
 804aa1e:	f898 3000 	ldrb.w	r3, [r8]
 804aa22:	f003 030f 	and.w	r3, r3, #15
 804aa26:	009b      	lsls	r3, r3, #2
 804aa28:	8193      	strh	r3, [r2, #12]
    pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
 804aa2a:	4279      	negs	r1, r7
 804aa2c:	4628      	mov	r0, r5
 804aa2e:	f7fb f929 	bl	8045c84 <pbuf_header>
    switch (IPH_PROTO(iphdr)) {
 804aa32:	f898 3009 	ldrb.w	r3, [r8, #9]
 804aa36:	2b06      	cmp	r3, #6
 804aa38:	d02c      	beq.n	804aa94 <ip4_input+0x188>
 804aa3a:	2b11      	cmp	r3, #17
 804aa3c:	d01d      	beq.n	804aa7a <ip4_input+0x16e>
 804aa3e:	2b01      	cmp	r3, #1
 804aa40:	d02d      	beq.n	804aa9e <ip4_input+0x192>
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 804aa42:	4621      	mov	r1, r4
 804aa44:	4b1e      	ldr	r3, [pc, #120]	; (804aac0 <ip4_input+0x1b4>)
 804aa46:	6958      	ldr	r0, [r3, #20]
 804aa48:	f000 f8cd 	bl	804abe6 <ip4_addr_isbroadcast_u32>
 804aa4c:	b928      	cbnz	r0, 804aa5a <ip4_input+0x14e>
          !ip4_addr_ismulticast(ip4_current_dest_addr())) {
 804aa4e:	4b1c      	ldr	r3, [pc, #112]	; (804aac0 <ip4_input+0x1b4>)
 804aa50:	695b      	ldr	r3, [r3, #20]
 804aa52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
 804aa56:	2be0      	cmp	r3, #224	; 0xe0
 804aa58:	d126      	bne.n	804aaa8 <ip4_input+0x19c>
      pbuf_free(p);
 804aa5a:	4628      	mov	r0, r5
 804aa5c:	f7fb f91c 	bl	8045c98 <pbuf_free>
 804aa60:	e00f      	b.n	804aa82 <ip4_input+0x176>
      netif = inp;
 804aa62:	4634      	mov	r4, r6
 804aa64:	e7b9      	b.n	804a9da <ip4_input+0xce>
          netif = NULL;
 804aa66:	2400      	movs	r4, #0
 804aa68:	e7b7      	b.n	804a9da <ip4_input+0xce>
      pbuf_free(p);
 804aa6a:	4628      	mov	r0, r5
 804aa6c:	f7fb f914 	bl	8045c98 <pbuf_free>
      return ERR_OK;
 804aa70:	e758      	b.n	804a924 <ip4_input+0x18>
    pbuf_free(p);
 804aa72:	4628      	mov	r0, r5
 804aa74:	f7fb f910 	bl	8045c98 <pbuf_free>
    return ERR_OK;
 804aa78:	e754      	b.n	804a924 <ip4_input+0x18>
      udp_input(p, inp);
 804aa7a:	4631      	mov	r1, r6
 804aa7c:	4628      	mov	r0, r5
 804aa7e:	f7ff f8c9 	bl	8049c14 <udp_input>
  ip_data.current_netif = NULL;
 804aa82:	4b0f      	ldr	r3, [pc, #60]	; (804aac0 <ip4_input+0x1b4>)
 804aa84:	2200      	movs	r2, #0
 804aa86:	601a      	str	r2, [r3, #0]
  ip_data.current_input_netif = NULL;
 804aa88:	605a      	str	r2, [r3, #4]
  ip_data.current_ip4_header = NULL;
 804aa8a:	609a      	str	r2, [r3, #8]
  ip_data.current_ip_header_tot_len = 0;
 804aa8c:	819a      	strh	r2, [r3, #12]
  ip4_addr_set_any(ip4_current_src_addr());
 804aa8e:	611a      	str	r2, [r3, #16]
  ip4_addr_set_any(ip4_current_dest_addr());
 804aa90:	615a      	str	r2, [r3, #20]
  return ERR_OK;
 804aa92:	e747      	b.n	804a924 <ip4_input+0x18>
      tcp_input(p, inp);
 804aa94:	4631      	mov	r1, r6
 804aa96:	4628      	mov	r0, r5
 804aa98:	f7fd fd58 	bl	804854c <tcp_input>
      break;
 804aa9c:	e7f1      	b.n	804aa82 <ip4_input+0x176>
      icmp_input(p, inp);
 804aa9e:	4631      	mov	r1, r6
 804aaa0:	4628      	mov	r0, r5
 804aaa2:	f7ff fe59 	bl	804a758 <icmp_input>
      break;
 804aaa6:	e7ec      	b.n	804aa82 <ip4_input+0x176>
        pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
 804aaa8:	4639      	mov	r1, r7
 804aaaa:	4628      	mov	r0, r5
 804aaac:	f7fb f8ef 	bl	8045c8e <pbuf_header_force>
        p->payload = iphdr;
 804aab0:	f8c5 8004 	str.w	r8, [r5, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 804aab4:	2102      	movs	r1, #2
 804aab6:	4628      	mov	r0, r5
 804aab8:	f7ff feec 	bl	804a894 <icmp_dest_unreach>
 804aabc:	e7cd      	b.n	804aa5a <ip4_input+0x14e>
 804aabe:	bf00      	nop
 804aac0:	2000546c 	.word	0x2000546c
 804aac4:	2000898c 	.word	0x2000898c

0804aac8 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 804aac8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 804aacc:	b083      	sub	sp, #12
 804aace:	4604      	mov	r4, r0
 804aad0:	460f      	mov	r7, r1
 804aad2:	4616      	mov	r6, r2
 804aad4:	4699      	mov	r9, r3
 804aad6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 804aada:	89c2      	ldrh	r2, [r0, #14]
 804aadc:	2a01      	cmp	r2, #1
 804aade:	d13f      	bne.n	804ab60 <ip4_output_if_src+0x98>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
 804aae0:	2e00      	cmp	r6, #0
 804aae2:	d051      	beq.n	804ab88 <ip4_output_if_src+0xc0>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 804aae4:	2114      	movs	r1, #20
 804aae6:	4620      	mov	r0, r4
 804aae8:	f7fb f8cc 	bl	8045c84 <pbuf_header>
 804aaec:	2800      	cmp	r0, #0
 804aaee:	d156      	bne.n	804ab9e <ip4_output_if_src+0xd6>
      IP_STATS_INC(ip.err);
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 804aaf0:	6865      	ldr	r5, [r4, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 804aaf2:	8963      	ldrh	r3, [r4, #10]
 804aaf4:	2b13      	cmp	r3, #19
 804aaf6:	d93b      	bls.n	804ab70 <ip4_output_if_src+0xa8>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 804aaf8:	f885 9008 	strb.w	r9, [r5, #8]
    IPH_PROTO_SET(iphdr, proto);
 804aafc:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 804ab00:	726b      	strb	r3, [r5, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
 804ab02:	6833      	ldr	r3, [r6, #0]
 804ab04:	612b      	str	r3, [r5, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 804ab06:	2345      	movs	r3, #69	; 0x45
 804ab08:	702b      	strb	r3, [r5, #0]
    IPH_TOS_SET(iphdr, tos);
 804ab0a:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 804ab0e:	706b      	strb	r3, [r5, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
 804ab10:	8920      	ldrh	r0, [r4, #8]
 804ab12:	f7fa fc8b 	bl	804542c <lwip_htons>
 804ab16:	8068      	strh	r0, [r5, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 804ab18:	2300      	movs	r3, #0
 804ab1a:	71ab      	strb	r3, [r5, #6]
 804ab1c:	71eb      	strb	r3, [r5, #7]
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
 804ab1e:	f8df 9098 	ldr.w	r9, [pc, #152]	; 804abb8 <ip4_output_if_src+0xf0>
 804ab22:	f8b9 0000 	ldrh.w	r0, [r9]
 804ab26:	f7fa fc81 	bl	804542c <lwip_htons>
 804ab2a:	80a8      	strh	r0, [r5, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 804ab2c:	f8b9 3000 	ldrh.w	r3, [r9]
 804ab30:	3301      	adds	r3, #1
 804ab32:	f8a9 3000 	strh.w	r3, [r9]

    if (src == NULL) {
 804ab36:	b31f      	cbz	r7, 804ab80 <ip4_output_if_src+0xb8>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
 804ab38:	683b      	ldr	r3, [r7, #0]
 804ab3a:	60eb      	str	r3, [r5, #12]
    else {
      IPH_CHKSUM_SET(iphdr, 0);
    }
#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 804ab3c:	2300      	movs	r3, #0
 804ab3e:	72ab      	strb	r3, [r5, #10]
 804ab40:	72eb      	strb	r3, [r5, #11]
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 804ab42:	f8b8 3022 	ldrh.w	r3, [r8, #34]	; 0x22
 804ab46:	b113      	cbz	r3, 804ab4e <ip4_output_if_src+0x86>
 804ab48:	8922      	ldrh	r2, [r4, #8]
 804ab4a:	4293      	cmp	r3, r2
 804ab4c:	d321      	bcc.n	804ab92 <ip4_output_if_src+0xca>
    return ip4_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
 804ab4e:	f8d8 3014 	ldr.w	r3, [r8, #20]
 804ab52:	4632      	mov	r2, r6
 804ab54:	4621      	mov	r1, r4
 804ab56:	4640      	mov	r0, r8
 804ab58:	4798      	blx	r3
}
 804ab5a:	b003      	add	sp, #12
 804ab5c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
 804ab60:	4b10      	ldr	r3, [pc, #64]	; (804aba4 <ip4_output_if_src+0xdc>)
 804ab62:	f240 3233 	movw	r2, #819	; 0x333
 804ab66:	4910      	ldr	r1, [pc, #64]	; (804aba8 <ip4_output_if_src+0xe0>)
 804ab68:	4810      	ldr	r0, [pc, #64]	; (804abac <ip4_output_if_src+0xe4>)
 804ab6a:	f006 fb3f 	bl	80511ec <printf>
 804ab6e:	e7b7      	b.n	804aae0 <ip4_output_if_src+0x18>
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 804ab70:	4b0c      	ldr	r3, [pc, #48]	; (804aba4 <ip4_output_if_src+0xdc>)
 804ab72:	f44f 7258 	mov.w	r2, #864	; 0x360
 804ab76:	490e      	ldr	r1, [pc, #56]	; (804abb0 <ip4_output_if_src+0xe8>)
 804ab78:	480c      	ldr	r0, [pc, #48]	; (804abac <ip4_output_if_src+0xe4>)
 804ab7a:	f006 fb37 	bl	80511ec <printf>
 804ab7e:	e7bb      	b.n	804aaf8 <ip4_output_if_src+0x30>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
 804ab80:	4b0c      	ldr	r3, [pc, #48]	; (804abb4 <ip4_output_if_src+0xec>)
 804ab82:	681b      	ldr	r3, [r3, #0]
 804ab84:	60eb      	str	r3, [r5, #12]
 804ab86:	e7d9      	b.n	804ab3c <ip4_output_if_src+0x74>
    iphdr = (struct ip_hdr *)p->payload;
 804ab88:	6863      	ldr	r3, [r4, #4]
    ip4_addr_copy(dest_addr, iphdr->dest);
 804ab8a:	691b      	ldr	r3, [r3, #16]
 804ab8c:	9301      	str	r3, [sp, #4]
    dest = &dest_addr;
 804ab8e:	ae01      	add	r6, sp, #4
 804ab90:	e7d7      	b.n	804ab42 <ip4_output_if_src+0x7a>
    return ip4_frag(p, netif, dest);
 804ab92:	4632      	mov	r2, r6
 804ab94:	4641      	mov	r1, r8
 804ab96:	4620      	mov	r0, r4
 804ab98:	f000 fb34 	bl	804b204 <ip4_frag>
 804ab9c:	e7dd      	b.n	804ab5a <ip4_output_if_src+0x92>
      return ERR_BUF;
 804ab9e:	f06f 0001 	mvn.w	r0, #1
 804aba2:	e7da      	b.n	804ab5a <ip4_output_if_src+0x92>
 804aba4:	08059d08 	.word	0x08059d08
 804aba8:	08059d3c 	.word	0x08059d3c
 804abac:	08058644 	.word	0x08058644
 804abb0:	08059d48 	.word	0x08059d48
 804abb4:	080585d0 	.word	0x080585d0
 804abb8:	200043fe 	.word	0x200043fe

0804abbc <ip4_output_if>:
{
 804abbc:	b530      	push	{r4, r5, lr}
 804abbe:	b085      	sub	sp, #20
 804abc0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  if (dest != LWIP_IP_HDRINCL) {
 804abc2:	4615      	mov	r5, r2
 804abc4:	b11a      	cbz	r2, 804abce <ip4_output_if+0x12>
    if (ip4_addr_isany(src)) {
 804abc6:	b109      	cbz	r1, 804abcc <ip4_output_if+0x10>
 804abc8:	680a      	ldr	r2, [r1, #0]
 804abca:	b902      	cbnz	r2, 804abce <ip4_output_if+0x12>
      src_used = netif_ip4_addr(netif);
 804abcc:	1d21      	adds	r1, r4, #4
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
 804abce:	9402      	str	r4, [sp, #8]
 804abd0:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
 804abd4:	9201      	str	r2, [sp, #4]
 804abd6:	f89d 2020 	ldrb.w	r2, [sp, #32]
 804abda:	9200      	str	r2, [sp, #0]
 804abdc:	462a      	mov	r2, r5
 804abde:	f7ff ff73 	bl	804aac8 <ip4_output_if_src>
}
 804abe2:	b005      	add	sp, #20
 804abe4:	bd30      	pop	{r4, r5, pc}

0804abe6 <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
 804abe6:	4603      	mov	r3, r0
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 804abe8:	1e42      	subs	r2, r0, #1
 804abea:	f112 0f03 	cmn.w	r2, #3
 804abee:	d812      	bhi.n	804ac16 <ip4_addr_isbroadcast_u32+0x30>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 804abf0:	f891 002b 	ldrb.w	r0, [r1, #43]	; 0x2b
 804abf4:	f010 0002 	ands.w	r0, r0, #2
 804abf8:	d014      	beq.n	804ac24 <ip4_addr_isbroadcast_u32+0x3e>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
 804abfa:	684a      	ldr	r2, [r1, #4]
 804abfc:	429a      	cmp	r2, r3
 804abfe:	d00c      	beq.n	804ac1a <ip4_addr_isbroadcast_u32+0x34>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
 804ac00:	6888      	ldr	r0, [r1, #8]
 804ac02:	405a      	eors	r2, r3
 804ac04:	4202      	tst	r2, r0
 804ac06:	d10a      	bne.n	804ac1e <ip4_addr_isbroadcast_u32+0x38>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
 804ac08:	43c2      	mvns	r2, r0
 804ac0a:	ea23 0300 	bic.w	r3, r3, r0
 804ac0e:	429a      	cmp	r2, r3
 804ac10:	d007      	beq.n	804ac22 <ip4_addr_isbroadcast_u32+0x3c>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 804ac12:	2000      	movs	r0, #0
 804ac14:	4770      	bx	lr
    return 1;
 804ac16:	2001      	movs	r0, #1
 804ac18:	4770      	bx	lr
    return 0;
 804ac1a:	2000      	movs	r0, #0
 804ac1c:	4770      	bx	lr
    return 0;
 804ac1e:	2000      	movs	r0, #0
 804ac20:	4770      	bx	lr
    return 1;
 804ac22:	2001      	movs	r0, #1
  }
}
 804ac24:	4770      	bx	lr
	...

0804ac28 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 804ac28:	b538      	push	{r3, r4, r5, lr}
 804ac2a:	4604      	mov	r4, r0
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 804ac2c:	4b0c      	ldr	r3, [pc, #48]	; (804ac60 <ip_reass_dequeue_datagram+0x38>)
 804ac2e:	681b      	ldr	r3, [r3, #0]
 804ac30:	4283      	cmp	r3, r0
 804ac32:	d008      	beq.n	804ac46 <ip_reass_dequeue_datagram+0x1e>
 804ac34:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 804ac36:	b151      	cbz	r1, 804ac4e <ip_reass_dequeue_datagram+0x26>
    prev->next = ipr->next;
 804ac38:	6823      	ldr	r3, [r4, #0]
 804ac3a:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
 804ac3c:	4621      	mov	r1, r4
 804ac3e:	2004      	movs	r0, #4
 804ac40:	f7fa fe76 	bl	8045930 <memp_free>
}
 804ac44:	bd38      	pop	{r3, r4, r5, pc}
    reassdatagrams = ipr->next;
 804ac46:	6802      	ldr	r2, [r0, #0]
 804ac48:	4b05      	ldr	r3, [pc, #20]	; (804ac60 <ip_reass_dequeue_datagram+0x38>)
 804ac4a:	601a      	str	r2, [r3, #0]
 804ac4c:	e7f6      	b.n	804ac3c <ip_reass_dequeue_datagram+0x14>
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 804ac4e:	4b05      	ldr	r3, [pc, #20]	; (804ac64 <ip_reass_dequeue_datagram+0x3c>)
 804ac50:	f240 1245 	movw	r2, #325	; 0x145
 804ac54:	4904      	ldr	r1, [pc, #16]	; (804ac68 <ip_reass_dequeue_datagram+0x40>)
 804ac56:	4805      	ldr	r0, [pc, #20]	; (804ac6c <ip_reass_dequeue_datagram+0x44>)
 804ac58:	f006 fac8 	bl	80511ec <printf>
 804ac5c:	e7ec      	b.n	804ac38 <ip_reass_dequeue_datagram+0x10>
 804ac5e:	bf00      	nop
 804ac60:	20004400 	.word	0x20004400
 804ac64:	08059d78 	.word	0x08059d78
 804ac68:	08059db4 	.word	0x08059db4
 804ac6c:	08058644 	.word	0x08058644

0804ac70 <ip_reass_free_complete_datagram>:
{
 804ac70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804ac74:	4680      	mov	r8, r0
 804ac76:	4689      	mov	r9, r1
  LWIP_ASSERT("prev != ipr", prev != ipr);
 804ac78:	4281      	cmp	r1, r0
 804ac7a:	d015      	beq.n	804aca8 <ip_reass_free_complete_datagram+0x38>
  if (prev != NULL) {
 804ac7c:	f1b9 0f00 	cmp.w	r9, #0
 804ac80:	d009      	beq.n	804ac96 <ip_reass_free_complete_datagram+0x26>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 804ac82:	f8d9 3000 	ldr.w	r3, [r9]
 804ac86:	4543      	cmp	r3, r8
 804ac88:	d005      	beq.n	804ac96 <ip_reass_free_complete_datagram+0x26>
 804ac8a:	4b30      	ldr	r3, [pc, #192]	; (804ad4c <ip_reass_free_complete_datagram+0xdc>)
 804ac8c:	22ad      	movs	r2, #173	; 0xad
 804ac8e:	4930      	ldr	r1, [pc, #192]	; (804ad50 <ip_reass_free_complete_datagram+0xe0>)
 804ac90:	4830      	ldr	r0, [pc, #192]	; (804ad54 <ip_reass_free_complete_datagram+0xe4>)
 804ac92:	f006 faab 	bl	80511ec <printf>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 804ac96:	f8d8 5004 	ldr.w	r5, [r8, #4]
 804ac9a:	686b      	ldr	r3, [r5, #4]
  if (iprh->start == 0) {
 804ac9c:	889a      	ldrh	r2, [r3, #4]
 804ac9e:	b152      	cbz	r2, 804acb6 <ip_reass_free_complete_datagram+0x46>
  u16_t pbufs_freed = 0;
 804aca0:	2600      	movs	r6, #0
  p = ipr->p;
 804aca2:	f8d8 5004 	ldr.w	r5, [r8, #4]
  while (p != NULL) {
 804aca6:	e02e      	b.n	804ad06 <ip_reass_free_complete_datagram+0x96>
  LWIP_ASSERT("prev != ipr", prev != ipr);
 804aca8:	4b28      	ldr	r3, [pc, #160]	; (804ad4c <ip_reass_free_complete_datagram+0xdc>)
 804acaa:	22ab      	movs	r2, #171	; 0xab
 804acac:	492a      	ldr	r1, [pc, #168]	; (804ad58 <ip_reass_free_complete_datagram+0xe8>)
 804acae:	4829      	ldr	r0, [pc, #164]	; (804ad54 <ip_reass_free_complete_datagram+0xe4>)
 804acb0:	f006 fa9c 	bl	80511ec <printf>
 804acb4:	e7e2      	b.n	804ac7c <ip_reass_free_complete_datagram+0xc>
    ipr->p = iprh->next_pbuf;
 804acb6:	681b      	ldr	r3, [r3, #0]
 804acb8:	f8c8 3004 	str.w	r3, [r8, #4]
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 804acbc:	4643      	mov	r3, r8
 804acbe:	686a      	ldr	r2, [r5, #4]
 804acc0:	f853 1f08 	ldr.w	r1, [r3, #8]!
 804acc4:	685e      	ldr	r6, [r3, #4]
 804acc6:	689c      	ldr	r4, [r3, #8]
 804acc8:	68d8      	ldr	r0, [r3, #12]
 804acca:	6011      	str	r1, [r2, #0]
 804accc:	6056      	str	r6, [r2, #4]
 804acce:	6094      	str	r4, [r2, #8]
 804acd0:	60d0      	str	r0, [r2, #12]
 804acd2:	6919      	ldr	r1, [r3, #16]
 804acd4:	6111      	str	r1, [r2, #16]
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 804acd6:	2101      	movs	r1, #1
 804acd8:	4628      	mov	r0, r5
 804acda:	f7ff fde1 	bl	804a8a0 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 804acde:	4628      	mov	r0, r5
 804ace0:	f7fb f9a6 	bl	8046030 <pbuf_clen>
 804ace4:	4606      	mov	r6, r0
    pbuf_free(p);
 804ace6:	4628      	mov	r0, r5
 804ace8:	f7fa ffd6 	bl	8045c98 <pbuf_free>
 804acec:	e7d9      	b.n	804aca2 <ip_reass_free_complete_datagram+0x32>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 804acee:	4b17      	ldr	r3, [pc, #92]	; (804ad4c <ip_reass_free_complete_datagram+0xdc>)
 804acf0:	22cc      	movs	r2, #204	; 0xcc
 804acf2:	491a      	ldr	r1, [pc, #104]	; (804ad5c <ip_reass_free_complete_datagram+0xec>)
 804acf4:	4817      	ldr	r0, [pc, #92]	; (804ad54 <ip_reass_free_complete_datagram+0xe4>)
 804acf6:	f006 fa79 	bl	80511ec <printf>
    pbufs_freed += clen;
 804acfa:	4434      	add	r4, r6
 804acfc:	b2a6      	uxth	r6, r4
    pbuf_free(pcur);
 804acfe:	4628      	mov	r0, r5
 804ad00:	f7fa ffca 	bl	8045c98 <pbuf_free>
    p = iprh->next_pbuf;
 804ad04:	463d      	mov	r5, r7
  while (p != NULL) {
 804ad06:	b155      	cbz	r5, 804ad1e <ip_reass_free_complete_datagram+0xae>
    iprh = (struct ip_reass_helper *)p->payload;
 804ad08:	686b      	ldr	r3, [r5, #4]
    p = iprh->next_pbuf;
 804ad0a:	681f      	ldr	r7, [r3, #0]
    clen = pbuf_clen(pcur);
 804ad0c:	4628      	mov	r0, r5
 804ad0e:	f7fb f98f 	bl	8046030 <pbuf_clen>
 804ad12:	4604      	mov	r4, r0
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 804ad14:	1833      	adds	r3, r6, r0
 804ad16:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 804ad1a:	dbee      	blt.n	804acfa <ip_reass_free_complete_datagram+0x8a>
 804ad1c:	e7e7      	b.n	804acee <ip_reass_free_complete_datagram+0x7e>
  ip_reass_dequeue_datagram(ipr, prev);
 804ad1e:	4649      	mov	r1, r9
 804ad20:	4640      	mov	r0, r8
 804ad22:	f7ff ff81 	bl	804ac28 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 804ad26:	4b0e      	ldr	r3, [pc, #56]	; (804ad60 <ip_reass_free_complete_datagram+0xf0>)
 804ad28:	889b      	ldrh	r3, [r3, #4]
 804ad2a:	42b3      	cmp	r3, r6
 804ad2c:	d306      	bcc.n	804ad3c <ip_reass_free_complete_datagram+0xcc>
  ip_reass_pbufcount -= pbufs_freed;
 804ad2e:	4a0c      	ldr	r2, [pc, #48]	; (804ad60 <ip_reass_free_complete_datagram+0xf0>)
 804ad30:	8893      	ldrh	r3, [r2, #4]
 804ad32:	1b9b      	subs	r3, r3, r6
 804ad34:	8093      	strh	r3, [r2, #4]
}
 804ad36:	4630      	mov	r0, r6
 804ad38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 804ad3c:	4b03      	ldr	r3, [pc, #12]	; (804ad4c <ip_reass_free_complete_datagram+0xdc>)
 804ad3e:	22d2      	movs	r2, #210	; 0xd2
 804ad40:	4908      	ldr	r1, [pc, #32]	; (804ad64 <ip_reass_free_complete_datagram+0xf4>)
 804ad42:	4804      	ldr	r0, [pc, #16]	; (804ad54 <ip_reass_free_complete_datagram+0xe4>)
 804ad44:	f006 fa52 	bl	80511ec <printf>
 804ad48:	e7f1      	b.n	804ad2e <ip_reass_free_complete_datagram+0xbe>
 804ad4a:	bf00      	nop
 804ad4c:	08059d78 	.word	0x08059d78
 804ad50:	08059ddc 	.word	0x08059ddc
 804ad54:	08058644 	.word	0x08058644
 804ad58:	08059dd0 	.word	0x08059dd0
 804ad5c:	08059df0 	.word	0x08059df0
 804ad60:	20004400 	.word	0x20004400
 804ad64:	08059e10 	.word	0x08059e10

0804ad68 <ip_reass_remove_oldest_datagram>:
{
 804ad68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804ad6c:	4606      	mov	r6, r0
 804ad6e:	4688      	mov	r8, r1
  int pbufs_freed = 0, pbufs_freed_current;
 804ad70:	2700      	movs	r7, #0
 804ad72:	e02b      	b.n	804adcc <ip_reass_remove_oldest_datagram+0x64>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 804ad74:	699a      	ldr	r2, [r3, #24]
 804ad76:	f8d6 c010 	ldr.w	ip, [r6, #16]
 804ad7a:	4562      	cmp	r2, ip
 804ad7c:	d111      	bne.n	804ada2 <ip_reass_remove_oldest_datagram+0x3a>
 804ad7e:	f8b3 c00c 	ldrh.w	ip, [r3, #12]
 804ad82:	88b2      	ldrh	r2, [r6, #4]
 804ad84:	4594      	cmp	ip, r2
 804ad86:	d10c      	bne.n	804ada2 <ip_reass_remove_oldest_datagram+0x3a>
 804ad88:	e001      	b.n	804ad8e <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 804ad8a:	4629      	mov	r1, r5
          oldest = r;
 804ad8c:	4618      	mov	r0, r3
      if (r->next != NULL) {
 804ad8e:	681a      	ldr	r2, [r3, #0]
 804ad90:	b192      	cbz	r2, 804adb8 <ip_reass_remove_oldest_datagram+0x50>
 804ad92:	461d      	mov	r5, r3
 804ad94:	4613      	mov	r3, r2
    while (r != NULL) {
 804ad96:	b18b      	cbz	r3, 804adbc <ip_reass_remove_oldest_datagram+0x54>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 804ad98:	695a      	ldr	r2, [r3, #20]
 804ad9a:	f8d6 c00c 	ldr.w	ip, [r6, #12]
 804ad9e:	4562      	cmp	r2, ip
 804ada0:	d0e8      	beq.n	804ad74 <ip_reass_remove_oldest_datagram+0xc>
        other_datagrams++;
 804ada2:	3401      	adds	r4, #1
        if (oldest == NULL) {
 804ada4:	2800      	cmp	r0, #0
 804ada6:	d0f0      	beq.n	804ad8a <ip_reass_remove_oldest_datagram+0x22>
        } else if (r->timer <= oldest->timer) {
 804ada8:	f893 c01f 	ldrb.w	ip, [r3, #31]
 804adac:	7fc2      	ldrb	r2, [r0, #31]
 804adae:	4594      	cmp	ip, r2
 804adb0:	d8ed      	bhi.n	804ad8e <ip_reass_remove_oldest_datagram+0x26>
          oldest_prev = prev;
 804adb2:	4629      	mov	r1, r5
          oldest = r;
 804adb4:	4618      	mov	r0, r3
 804adb6:	e7ea      	b.n	804ad8e <ip_reass_remove_oldest_datagram+0x26>
      if (r->next != NULL) {
 804adb8:	462b      	mov	r3, r5
 804adba:	e7ea      	b.n	804ad92 <ip_reass_remove_oldest_datagram+0x2a>
    if (oldest != NULL) {
 804adbc:	b110      	cbz	r0, 804adc4 <ip_reass_remove_oldest_datagram+0x5c>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
 804adbe:	f7ff ff57 	bl	804ac70 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 804adc2:	4407      	add	r7, r0
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 804adc4:	4547      	cmp	r7, r8
 804adc6:	da08      	bge.n	804adda <ip_reass_remove_oldest_datagram+0x72>
 804adc8:	2c01      	cmp	r4, #1
 804adca:	dd06      	ble.n	804adda <ip_reass_remove_oldest_datagram+0x72>
    r = reassdatagrams;
 804adcc:	4b04      	ldr	r3, [pc, #16]	; (804ade0 <ip_reass_remove_oldest_datagram+0x78>)
 804adce:	681b      	ldr	r3, [r3, #0]
    other_datagrams = 0;
 804add0:	2400      	movs	r4, #0
    oldest_prev = NULL;
 804add2:	4621      	mov	r1, r4
    prev = NULL;
 804add4:	4625      	mov	r5, r4
    oldest = NULL;
 804add6:	4620      	mov	r0, r4
    while (r != NULL) {
 804add8:	e7dd      	b.n	804ad96 <ip_reass_remove_oldest_datagram+0x2e>
}
 804adda:	4638      	mov	r0, r7
 804addc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804ade0:	20004400 	.word	0x20004400

0804ade4 <ip_frag_free_pbuf_custom_ref>:
}

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 804ade4:	b510      	push	{r4, lr}
  LWIP_ASSERT("p != NULL", p != NULL);
 804ade6:	4604      	mov	r4, r0
 804ade8:	b120      	cbz	r0, 804adf4 <ip_frag_free_pbuf_custom_ref+0x10>
  memp_free(MEMP_FRAG_PBUF, p);
 804adea:	4621      	mov	r1, r4
 804adec:	2005      	movs	r0, #5
 804adee:	f7fa fd9f 	bl	8045930 <memp_free>
}
 804adf2:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("p != NULL", p != NULL);
 804adf4:	4b03      	ldr	r3, [pc, #12]	; (804ae04 <ip_frag_free_pbuf_custom_ref+0x20>)
 804adf6:	f240 22ae 	movw	r2, #686	; 0x2ae
 804adfa:	4903      	ldr	r1, [pc, #12]	; (804ae08 <ip_frag_free_pbuf_custom_ref+0x24>)
 804adfc:	4803      	ldr	r0, [pc, #12]	; (804ae0c <ip_frag_free_pbuf_custom_ref+0x28>)
 804adfe:	f006 f9f5 	bl	80511ec <printf>
 804ae02:	e7f2      	b.n	804adea <ip_frag_free_pbuf_custom_ref+0x6>
 804ae04:	08059d78 	.word	0x08059d78
 804ae08:	08058938 	.word	0x08058938
 804ae0c:	08058644 	.word	0x08058644

0804ae10 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 804ae10:	b510      	push	{r4, lr}
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 804ae12:	4604      	mov	r4, r0
 804ae14:	b138      	cbz	r0, 804ae26 <ipfrag_free_pbuf_custom+0x16>
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 804ae16:	6960      	ldr	r0, [r4, #20]
 804ae18:	b108      	cbz	r0, 804ae1e <ipfrag_free_pbuf_custom+0xe>
    pbuf_free(pcr->original);
 804ae1a:	f7fa ff3d 	bl	8045c98 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 804ae1e:	4620      	mov	r0, r4
 804ae20:	f7ff ffe0 	bl	804ade4 <ip_frag_free_pbuf_custom_ref>
}
 804ae24:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
 804ae26:	4b04      	ldr	r3, [pc, #16]	; (804ae38 <ipfrag_free_pbuf_custom+0x28>)
 804ae28:	f44f 722e 	mov.w	r2, #696	; 0x2b8
 804ae2c:	4903      	ldr	r1, [pc, #12]	; (804ae3c <ipfrag_free_pbuf_custom+0x2c>)
 804ae2e:	4804      	ldr	r0, [pc, #16]	; (804ae40 <ipfrag_free_pbuf_custom+0x30>)
 804ae30:	f006 f9dc 	bl	80511ec <printf>
 804ae34:	e7ef      	b.n	804ae16 <ipfrag_free_pbuf_custom+0x6>
 804ae36:	bf00      	nop
 804ae38:	08059d78 	.word	0x08059d78
 804ae3c:	08059e2c 	.word	0x08059e2c
 804ae40:	08058644 	.word	0x08058644

0804ae44 <ip_reass_chain_frag_into_datagram_and_validate>:
{
 804ae44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 804ae48:	4681      	mov	r9, r0
 804ae4a:	4688      	mov	r8, r1
 804ae4c:	4692      	mov	sl, r2
  fraghdr = (struct ip_hdr*)new_p->payload;
 804ae4e:	684c      	ldr	r4, [r1, #4]
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 804ae50:	8860      	ldrh	r0, [r4, #2]
 804ae52:	f7fa faeb 	bl	804542c <lwip_htons>
 804ae56:	7823      	ldrb	r3, [r4, #0]
 804ae58:	f003 030f 	and.w	r3, r3, #15
 804ae5c:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
 804ae60:	b29f      	uxth	r7, r3
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 804ae62:	88e0      	ldrh	r0, [r4, #6]
 804ae64:	f7fa fae2 	bl	804542c <lwip_htons>
 804ae68:	f3c0 040c 	ubfx	r4, r0, #0, #13
 804ae6c:	00e4      	lsls	r4, r4, #3
  iprh = (struct ip_reass_helper*)new_p->payload;
 804ae6e:	f8d8 6004 	ldr.w	r6, [r8, #4]
  iprh->next_pbuf = NULL;
 804ae72:	2500      	movs	r5, #0
 804ae74:	7035      	strb	r5, [r6, #0]
 804ae76:	7075      	strb	r5, [r6, #1]
 804ae78:	70b5      	strb	r5, [r6, #2]
 804ae7a:	70f5      	strb	r5, [r6, #3]
  iprh->start = offset;
 804ae7c:	80b4      	strh	r4, [r6, #4]
  iprh->end = offset + len;
 804ae7e:	193b      	adds	r3, r7, r4
 804ae80:	b298      	uxth	r0, r3
 804ae82:	80f3      	strh	r3, [r6, #6]
  for (q = ipr->p; q != NULL;) {
 804ae84:	f8d9 1004 	ldr.w	r1, [r9, #4]
  int valid = 1;
 804ae88:	2701      	movs	r7, #1
  for (q = ipr->p; q != NULL;) {
 804ae8a:	e020      	b.n	804aece <ip_reass_chain_frag_into_datagram_and_validate+0x8a>
      iprh->next_pbuf = q;
 804ae8c:	6031      	str	r1, [r6, #0]
      if (iprh_prev != NULL) {
 804ae8e:	b1b5      	cbz	r5, 804aebe <ip_reass_chain_frag_into_datagram_and_validate+0x7a>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 804ae90:	88ea      	ldrh	r2, [r5, #6]
 804ae92:	42a2      	cmp	r2, r4
 804ae94:	d87c      	bhi.n	804af90 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
 804ae96:	889b      	ldrh	r3, [r3, #4]
 804ae98:	4298      	cmp	r0, r3
 804ae9a:	d879      	bhi.n	804af90 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
        iprh_prev->next_pbuf = new_p;
 804ae9c:	f8c5 8000 	str.w	r8, [r5]
        if (iprh_prev->end != iprh->start) {
 804aea0:	88b3      	ldrh	r3, [r6, #4]
 804aea2:	429a      	cmp	r2, r3
 804aea4:	d000      	beq.n	804aea8 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
          valid = 0;
 804aea6:	2700      	movs	r7, #0
  if (q == NULL) {
 804aea8:	b319      	cbz	r1, 804aef2 <ip_reass_chain_frag_into_datagram_and_validate+0xae>
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
 804aeaa:	f1ba 0f00 	cmp.w	sl, #0
 804aeae:	d142      	bne.n	804af36 <ip_reass_chain_frag_into_datagram_and_validate+0xf2>
 804aeb0:	f899 301e 	ldrb.w	r3, [r9, #30]
 804aeb4:	f013 0f01 	tst.w	r3, #1
 804aeb8:	d13d      	bne.n	804af36 <ip_reass_chain_frag_into_datagram_and_validate+0xf2>
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
 804aeba:	4650      	mov	r0, sl
 804aebc:	e074      	b.n	804afa8 <ip_reass_chain_frag_into_datagram_and_validate+0x164>
        if (iprh->end > iprh_tmp->start) {
 804aebe:	889b      	ldrh	r3, [r3, #4]
 804aec0:	4298      	cmp	r0, r3
 804aec2:	d865      	bhi.n	804af90 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
        ipr->p = new_p;
 804aec4:	f8c9 8004 	str.w	r8, [r9, #4]
 804aec8:	e7ee      	b.n	804aea8 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
    q = iprh_tmp->next_pbuf;
 804aeca:	6819      	ldr	r1, [r3, #0]
    iprh_prev = iprh_tmp;
 804aecc:	461d      	mov	r5, r3
  for (q = ipr->p; q != NULL;) {
 804aece:	2900      	cmp	r1, #0
 804aed0:	d0ea      	beq.n	804aea8 <ip_reass_chain_frag_into_datagram_and_validate+0x64>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 804aed2:	684b      	ldr	r3, [r1, #4]
    if (iprh->start < iprh_tmp->start) {
 804aed4:	889a      	ldrh	r2, [r3, #4]
 804aed6:	42a2      	cmp	r2, r4
 804aed8:	d8d8      	bhi.n	804ae8c <ip_reass_chain_frag_into_datagram_and_validate+0x48>
    } else if (iprh->start == iprh_tmp->start) {
 804aeda:	42a2      	cmp	r2, r4
 804aedc:	d058      	beq.n	804af90 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
    } else if (iprh->start < iprh_tmp->end) {
 804aede:	88d9      	ldrh	r1, [r3, #6]
 804aee0:	42a1      	cmp	r1, r4
 804aee2:	d855      	bhi.n	804af90 <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
      if (iprh_prev != NULL) {
 804aee4:	2d00      	cmp	r5, #0
 804aee6:	d0f0      	beq.n	804aeca <ip_reass_chain_frag_into_datagram_and_validate+0x86>
        if (iprh_prev->end != iprh_tmp->start) {
 804aee8:	88e9      	ldrh	r1, [r5, #6]
 804aeea:	428a      	cmp	r2, r1
 804aeec:	d0ed      	beq.n	804aeca <ip_reass_chain_frag_into_datagram_and_validate+0x86>
          valid = 0;
 804aeee:	2700      	movs	r7, #0
 804aef0:	e7eb      	b.n	804aeca <ip_reass_chain_frag_into_datagram_and_validate+0x86>
    if (iprh_prev != NULL) {
 804aef2:	b19d      	cbz	r5, 804af1c <ip_reass_chain_frag_into_datagram_and_validate+0xd8>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 804aef4:	88ea      	ldrh	r2, [r5, #6]
 804aef6:	88b3      	ldrh	r3, [r6, #4]
 804aef8:	429a      	cmp	r2, r3
 804aefa:	d807      	bhi.n	804af0c <ip_reass_chain_frag_into_datagram_and_validate+0xc8>
      iprh_prev->next_pbuf = new_p;
 804aefc:	f8c5 8000 	str.w	r8, [r5]
      if (iprh_prev->end != iprh->start) {
 804af00:	88ea      	ldrh	r2, [r5, #6]
 804af02:	88b3      	ldrh	r3, [r6, #4]
 804af04:	429a      	cmp	r2, r3
 804af06:	d0d0      	beq.n	804aeaa <ip_reass_chain_frag_into_datagram_and_validate+0x66>
        valid = 0;
 804af08:	2700      	movs	r7, #0
 804af0a:	e7ce      	b.n	804aeaa <ip_reass_chain_frag_into_datagram_and_validate+0x66>
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 804af0c:	4b27      	ldr	r3, [pc, #156]	; (804afac <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804af0e:	f240 12ab 	movw	r2, #427	; 0x1ab
 804af12:	4927      	ldr	r1, [pc, #156]	; (804afb0 <ip_reass_chain_frag_into_datagram_and_validate+0x16c>)
 804af14:	4827      	ldr	r0, [pc, #156]	; (804afb4 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804af16:	f006 f969 	bl	80511ec <printf>
 804af1a:	e7ef      	b.n	804aefc <ip_reass_chain_frag_into_datagram_and_validate+0xb8>
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
 804af1c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 804af20:	b133      	cbz	r3, 804af30 <ip_reass_chain_frag_into_datagram_and_validate+0xec>
 804af22:	4b22      	ldr	r3, [pc, #136]	; (804afac <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804af24:	f240 12b3 	movw	r2, #435	; 0x1b3
 804af28:	4923      	ldr	r1, [pc, #140]	; (804afb8 <ip_reass_chain_frag_into_datagram_and_validate+0x174>)
 804af2a:	4822      	ldr	r0, [pc, #136]	; (804afb4 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804af2c:	f006 f95e 	bl	80511ec <printf>
      ipr->p = new_p;
 804af30:	f8c9 8004 	str.w	r8, [r9, #4]
 804af34:	e7b9      	b.n	804aeaa <ip_reass_chain_frag_into_datagram_and_validate+0x66>
    if (valid) {
 804af36:	b34f      	cbz	r7, 804af8c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
      if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
 804af38:	f8d9 3004 	ldr.w	r3, [r9, #4]
 804af3c:	b31b      	cbz	r3, 804af86 <ip_reass_chain_frag_into_datagram_and_validate+0x142>
 804af3e:	6858      	ldr	r0, [r3, #4]
 804af40:	8883      	ldrh	r3, [r0, #4]
 804af42:	bb13      	cbnz	r3, 804af8a <ip_reass_chain_frag_into_datagram_and_validate+0x146>
        q = iprh->next_pbuf;
 804af44:	6832      	ldr	r2, [r6, #0]
        while (q != NULL) {
 804af46:	b14a      	cbz	r2, 804af5c <ip_reass_chain_frag_into_datagram_and_validate+0x118>
          iprh = (struct ip_reass_helper*)q->payload;
 804af48:	6853      	ldr	r3, [r2, #4]
          if (iprh_prev->end != iprh->start) {
 804af4a:	88f1      	ldrh	r1, [r6, #6]
 804af4c:	889a      	ldrh	r2, [r3, #4]
 804af4e:	4291      	cmp	r1, r2
 804af50:	d102      	bne.n	804af58 <ip_reass_chain_frag_into_datagram_and_validate+0x114>
          q = iprh->next_pbuf;
 804af52:	681a      	ldr	r2, [r3, #0]
          iprh = (struct ip_reass_helper*)q->payload;
 804af54:	461e      	mov	r6, r3
 804af56:	e7f6      	b.n	804af46 <ip_reass_chain_frag_into_datagram_and_validate+0x102>
 804af58:	461e      	mov	r6, r3
            valid = 0;
 804af5a:	2700      	movs	r7, #0
        if (valid) {
 804af5c:	b1b7      	cbz	r7, 804af8c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
          LWIP_ASSERT("sanity check",
 804af5e:	42b0      	cmp	r0, r6
 804af60:	d009      	beq.n	804af76 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 804af62:	6833      	ldr	r3, [r6, #0]
 804af64:	b193      	cbz	r3, 804af8c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
 804af66:	4b11      	ldr	r3, [pc, #68]	; (804afac <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804af68:	f240 12d7 	movw	r2, #471	; 0x1d7
 804af6c:	4913      	ldr	r1, [pc, #76]	; (804afbc <ip_reass_chain_frag_into_datagram_and_validate+0x178>)
 804af6e:	4811      	ldr	r0, [pc, #68]	; (804afb4 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804af70:	f006 f93c 	bl	80511ec <printf>
 804af74:	e00a      	b.n	804af8c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
          LWIP_ASSERT("sanity check",
 804af76:	4b0d      	ldr	r3, [pc, #52]	; (804afac <ip_reass_chain_frag_into_datagram_and_validate+0x168>)
 804af78:	f240 12d5 	movw	r2, #469	; 0x1d5
 804af7c:	4910      	ldr	r1, [pc, #64]	; (804afc0 <ip_reass_chain_frag_into_datagram_and_validate+0x17c>)
 804af7e:	480d      	ldr	r0, [pc, #52]	; (804afb4 <ip_reass_chain_frag_into_datagram_and_validate+0x170>)
 804af80:	f006 f934 	bl	80511ec <printf>
 804af84:	e7ed      	b.n	804af62 <ip_reass_chain_frag_into_datagram_and_validate+0x11e>
        valid = 0;
 804af86:	2700      	movs	r7, #0
 804af88:	e000      	b.n	804af8c <ip_reass_chain_frag_into_datagram_and_validate+0x148>
 804af8a:	2700      	movs	r7, #0
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
 804af8c:	4638      	mov	r0, r7
 804af8e:	e00b      	b.n	804afa8 <ip_reass_chain_frag_into_datagram_and_validate+0x164>
  ip_reass_pbufcount -= pbuf_clen(new_p);
 804af90:	4640      	mov	r0, r8
 804af92:	f7fb f84d 	bl	8046030 <pbuf_clen>
 804af96:	4a0b      	ldr	r2, [pc, #44]	; (804afc4 <ip_reass_chain_frag_into_datagram_and_validate+0x180>)
 804af98:	8893      	ldrh	r3, [r2, #4]
 804af9a:	1a1b      	subs	r3, r3, r0
 804af9c:	8093      	strh	r3, [r2, #4]
  pbuf_free(new_p);
 804af9e:	4640      	mov	r0, r8
 804afa0:	f7fa fe7a 	bl	8045c98 <pbuf_free>
  return IP_REASS_VALIDATE_PBUF_DROPPED;
 804afa4:	f04f 30ff 	mov.w	r0, #4294967295
}
 804afa8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804afac:	08059d78 	.word	0x08059d78
 804afb0:	08059e38 	.word	0x08059e38
 804afb4:	08058644 	.word	0x08058644
 804afb8:	08059e58 	.word	0x08059e58
 804afbc:	08059ea0 	.word	0x08059ea0
 804afc0:	08059e90 	.word	0x08059e90
 804afc4:	20004400 	.word	0x20004400

0804afc8 <ip_frag_alloc_pbuf_custom_ref>:
{
 804afc8:	b508      	push	{r3, lr}
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 804afca:	2005      	movs	r0, #5
 804afcc:	f7fa fc96 	bl	80458fc <memp_malloc>
}
 804afd0:	bd08      	pop	{r3, pc}
	...

0804afd4 <ip_reass_enqueue_new_datagram>:
{
 804afd4:	b570      	push	{r4, r5, r6, lr}
 804afd6:	4605      	mov	r5, r0
 804afd8:	460e      	mov	r6, r1
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 804afda:	2004      	movs	r0, #4
 804afdc:	f7fa fc8e 	bl	80458fc <memp_malloc>
  if (ipr == NULL) {
 804afe0:	4604      	mov	r4, r0
 804afe2:	b1c8      	cbz	r0, 804b018 <ip_reass_enqueue_new_datagram+0x44>
  memset(ipr, 0, sizeof(struct ip_reassdata));
 804afe4:	2300      	movs	r3, #0
 804afe6:	6063      	str	r3, [r4, #4]
 804afe8:	60a3      	str	r3, [r4, #8]
 804afea:	60e3      	str	r3, [r4, #12]
 804afec:	6123      	str	r3, [r4, #16]
 804afee:	6163      	str	r3, [r4, #20]
 804aff0:	61a3      	str	r3, [r4, #24]
 804aff2:	61e3      	str	r3, [r4, #28]
  ipr->timer = IP_REASS_MAXAGE;
 804aff4:	2303      	movs	r3, #3
 804aff6:	77e3      	strb	r3, [r4, #31]
  ipr->next = reassdatagrams;
 804aff8:	4b0e      	ldr	r3, [pc, #56]	; (804b034 <ip_reass_enqueue_new_datagram+0x60>)
 804affa:	681a      	ldr	r2, [r3, #0]
 804affc:	6022      	str	r2, [r4, #0]
  reassdatagrams = ipr;
 804affe:	601c      	str	r4, [r3, #0]
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 804b000:	682b      	ldr	r3, [r5, #0]
 804b002:	6868      	ldr	r0, [r5, #4]
 804b004:	68a9      	ldr	r1, [r5, #8]
 804b006:	68ea      	ldr	r2, [r5, #12]
 804b008:	60a3      	str	r3, [r4, #8]
 804b00a:	60e0      	str	r0, [r4, #12]
 804b00c:	6121      	str	r1, [r4, #16]
 804b00e:	6162      	str	r2, [r4, #20]
 804b010:	692b      	ldr	r3, [r5, #16]
 804b012:	61a3      	str	r3, [r4, #24]
}
 804b014:	4620      	mov	r0, r4
 804b016:	bd70      	pop	{r4, r5, r6, pc}
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 804b018:	4631      	mov	r1, r6
 804b01a:	4628      	mov	r0, r5
 804b01c:	f7ff fea4 	bl	804ad68 <ip_reass_remove_oldest_datagram>
 804b020:	42b0      	cmp	r0, r6
 804b022:	da02      	bge.n	804b02a <ip_reass_enqueue_new_datagram+0x56>
    if (ipr == NULL)
 804b024:	2c00      	cmp	r4, #0
 804b026:	d1dd      	bne.n	804afe4 <ip_reass_enqueue_new_datagram+0x10>
 804b028:	e7f4      	b.n	804b014 <ip_reass_enqueue_new_datagram+0x40>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 804b02a:	2004      	movs	r0, #4
 804b02c:	f7fa fc66 	bl	80458fc <memp_malloc>
 804b030:	4604      	mov	r4, r0
 804b032:	e7f7      	b.n	804b024 <ip_reass_enqueue_new_datagram+0x50>
 804b034:	20004400 	.word	0x20004400

0804b038 <ip_reass_tmr>:
{
 804b038:	b538      	push	{r3, r4, r5, lr}
  r = reassdatagrams;
 804b03a:	4b09      	ldr	r3, [pc, #36]	; (804b060 <ip_reass_tmr+0x28>)
 804b03c:	6818      	ldr	r0, [r3, #0]
  struct ip_reassdata *r, *prev = NULL;
 804b03e:	2400      	movs	r4, #0
  while (r != NULL) {
 804b040:	e004      	b.n	804b04c <ip_reass_tmr+0x14>
      r = r->next;
 804b042:	6805      	ldr	r5, [r0, #0]
      ip_reass_free_complete_datagram(tmp, prev);
 804b044:	4621      	mov	r1, r4
 804b046:	f7ff fe13 	bl	804ac70 <ip_reass_free_complete_datagram>
      r = r->next;
 804b04a:	4628      	mov	r0, r5
  while (r != NULL) {
 804b04c:	b138      	cbz	r0, 804b05e <ip_reass_tmr+0x26>
    if (r->timer > 0) {
 804b04e:	7fc3      	ldrb	r3, [r0, #31]
 804b050:	2b00      	cmp	r3, #0
 804b052:	d0f6      	beq.n	804b042 <ip_reass_tmr+0xa>
      r->timer--;
 804b054:	3b01      	subs	r3, #1
 804b056:	77c3      	strb	r3, [r0, #31]
      prev = r;
 804b058:	4604      	mov	r4, r0
      r = r->next;
 804b05a:	6800      	ldr	r0, [r0, #0]
 804b05c:	e7f6      	b.n	804b04c <ip_reass_tmr+0x14>
}
 804b05e:	bd38      	pop	{r3, r4, r5, pc}
 804b060:	20004400 	.word	0x20004400

0804b064 <ip4_reass>:
{
 804b064:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 804b068:	4606      	mov	r6, r0
  fraghdr = (struct ip_hdr*)p->payload;
 804b06a:	6845      	ldr	r5, [r0, #4]
  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 804b06c:	782b      	ldrb	r3, [r5, #0]
 804b06e:	f003 030f 	and.w	r3, r3, #15
 804b072:	2b05      	cmp	r3, #5
 804b074:	d126      	bne.n	804b0c4 <ip4_reass+0x60>
  offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 804b076:	88e8      	ldrh	r0, [r5, #6]
 804b078:	f7fa f9d8 	bl	804542c <lwip_htons>
 804b07c:	f3c0 070c 	ubfx	r7, r0, #0, #13
 804b080:	00ff      	lsls	r7, r7, #3
  len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 804b082:	8868      	ldrh	r0, [r5, #2]
 804b084:	f7fa f9d2 	bl	804542c <lwip_htons>
 804b088:	f895 9000 	ldrb.w	r9, [r5]
 804b08c:	f009 090f 	and.w	r9, r9, #15
 804b090:	eba0 0989 	sub.w	r9, r0, r9, lsl #2
 804b094:	fa1f f989 	uxth.w	r9, r9
  clen = pbuf_clen(p);
 804b098:	4630      	mov	r0, r6
 804b09a:	f7fa ffc9 	bl	8046030 <pbuf_clen>
 804b09e:	4680      	mov	r8, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 804b0a0:	4b57      	ldr	r3, [pc, #348]	; (804b200 <ip4_reass+0x19c>)
 804b0a2:	889b      	ldrh	r3, [r3, #4]
 804b0a4:	4403      	add	r3, r0
 804b0a6:	2b0a      	cmp	r3, #10
 804b0a8:	dc02      	bgt.n	804b0b0 <ip4_reass+0x4c>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 804b0aa:	4b55      	ldr	r3, [pc, #340]	; (804b200 <ip4_reass+0x19c>)
 804b0ac:	681c      	ldr	r4, [r3, #0]
 804b0ae:	e011      	b.n	804b0d4 <ip4_reass+0x70>
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 804b0b0:	4601      	mov	r1, r0
 804b0b2:	4628      	mov	r0, r5
 804b0b4:	f7ff fe58 	bl	804ad68 <ip_reass_remove_oldest_datagram>
 804b0b8:	b120      	cbz	r0, 804b0c4 <ip4_reass+0x60>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 804b0ba:	4b51      	ldr	r3, [pc, #324]	; (804b200 <ip4_reass+0x19c>)
 804b0bc:	889b      	ldrh	r3, [r3, #4]
 804b0be:	4443      	add	r3, r8
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 804b0c0:	2b0a      	cmp	r3, #10
 804b0c2:	ddf2      	ble.n	804b0aa <ip4_reass+0x46>
  pbuf_free(p);
 804b0c4:	4630      	mov	r0, r6
 804b0c6:	f7fa fde7 	bl	8045c98 <pbuf_free>
  return NULL;
 804b0ca:	2600      	movs	r6, #0
}
 804b0cc:	4630      	mov	r0, r6
 804b0ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 804b0d2:	6824      	ldr	r4, [r4, #0]
 804b0d4:	b15c      	cbz	r4, 804b0ee <ip4_reass+0x8a>
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 804b0d6:	6962      	ldr	r2, [r4, #20]
 804b0d8:	68eb      	ldr	r3, [r5, #12]
 804b0da:	429a      	cmp	r2, r3
 804b0dc:	d1f9      	bne.n	804b0d2 <ip4_reass+0x6e>
 804b0de:	69a2      	ldr	r2, [r4, #24]
 804b0e0:	692b      	ldr	r3, [r5, #16]
 804b0e2:	429a      	cmp	r2, r3
 804b0e4:	d1f5      	bne.n	804b0d2 <ip4_reass+0x6e>
 804b0e6:	89a2      	ldrh	r2, [r4, #12]
 804b0e8:	88ab      	ldrh	r3, [r5, #4]
 804b0ea:	429a      	cmp	r2, r3
 804b0ec:	d1f1      	bne.n	804b0d2 <ip4_reass+0x6e>
  if (ipr == NULL) {
 804b0ee:	b36c      	cbz	r4, 804b14c <ip4_reass+0xe8>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 804b0f0:	88e8      	ldrh	r0, [r5, #6]
 804b0f2:	f7fa f99b 	bl	804542c <lwip_htons>
 804b0f6:	f3c0 000c 	ubfx	r0, r0, #0, #13
 804b0fa:	b378      	cbz	r0, 804b15c <ip4_reass+0xf8>
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
 804b0fc:	88ed      	ldrh	r5, [r5, #6]
 804b0fe:	f005 0520 	and.w	r5, r5, #32
 804b102:	2d00      	cmp	r5, #0
 804b104:	bf0c      	ite	eq
 804b106:	2201      	moveq	r2, #1
 804b108:	2200      	movne	r2, #0
  if (is_last) {
 804b10a:	d108      	bne.n	804b11e <ip4_reass+0xba>
    u16_t datagram_len = (u16_t)(offset + len);
 804b10c:	eb07 0309 	add.w	r3, r7, r9
 804b110:	b29b      	uxth	r3, r3
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
 804b112:	429f      	cmp	r7, r3
 804b114:	d8d6      	bhi.n	804b0c4 <ip4_reass+0x60>
 804b116:	f64f 71eb 	movw	r1, #65515	; 0xffeb
 804b11a:	428b      	cmp	r3, r1
 804b11c:	d8d2      	bhi.n	804b0c4 <ip4_reass+0x60>
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
 804b11e:	4631      	mov	r1, r6
 804b120:	4620      	mov	r0, r4
 804b122:	f7ff fe8f 	bl	804ae44 <ip_reass_chain_frag_into_datagram_and_validate>
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
 804b126:	f1b0 3fff 	cmp.w	r0, #4294967295
 804b12a:	d0cb      	beq.n	804b0c4 <ip4_reass+0x60>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
 804b12c:	4b34      	ldr	r3, [pc, #208]	; (804b200 <ip4_reass+0x19c>)
 804b12e:	889a      	ldrh	r2, [r3, #4]
 804b130:	4490      	add	r8, r2
 804b132:	f8a3 8004 	strh.w	r8, [r3, #4]
  if (is_last) {
 804b136:	b92d      	cbnz	r5, 804b144 <ip4_reass+0xe0>
    u16_t datagram_len = (u16_t)(offset + len);
 804b138:	444f      	add	r7, r9
    ipr->datagram_len = datagram_len;
 804b13a:	83a7      	strh	r7, [r4, #28]
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 804b13c:	7fa3      	ldrb	r3, [r4, #30]
 804b13e:	f043 0301 	orr.w	r3, r3, #1
 804b142:	77a3      	strb	r3, [r4, #30]
  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
 804b144:	2801      	cmp	r0, #1
 804b146:	d01b      	beq.n	804b180 <ip4_reass+0x11c>
  return NULL;
 804b148:	2600      	movs	r6, #0
 804b14a:	e7bf      	b.n	804b0cc <ip4_reass+0x68>
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 804b14c:	4641      	mov	r1, r8
 804b14e:	4628      	mov	r0, r5
 804b150:	f7ff ff40 	bl	804afd4 <ip_reass_enqueue_new_datagram>
    if (ipr == NULL) {
 804b154:	4604      	mov	r4, r0
 804b156:	2800      	cmp	r0, #0
 804b158:	d1d0      	bne.n	804b0fc <ip4_reass+0x98>
 804b15a:	e7b3      	b.n	804b0c4 <ip4_reass+0x60>
      ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 804b15c:	89e0      	ldrh	r0, [r4, #14]
 804b15e:	f7fa f965 	bl	804542c <lwip_htons>
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
 804b162:	f3c0 000c 	ubfx	r0, r0, #0, #13
 804b166:	2800      	cmp	r0, #0
 804b168:	d0c8      	beq.n	804b0fc <ip4_reass+0x98>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 804b16a:	682b      	ldr	r3, [r5, #0]
 804b16c:	6868      	ldr	r0, [r5, #4]
 804b16e:	68a9      	ldr	r1, [r5, #8]
 804b170:	68ea      	ldr	r2, [r5, #12]
 804b172:	60a3      	str	r3, [r4, #8]
 804b174:	60e0      	str	r0, [r4, #12]
 804b176:	6121      	str	r1, [r4, #16]
 804b178:	6162      	str	r2, [r4, #20]
 804b17a:	692b      	ldr	r3, [r5, #16]
 804b17c:	61a3      	str	r3, [r4, #24]
 804b17e:	e7bd      	b.n	804b0fc <ip4_reass+0x98>
    ipr->datagram_len += IP_HLEN;
 804b180:	8ba3      	ldrh	r3, [r4, #28]
 804b182:	3314      	adds	r3, #20
 804b184:	83a3      	strh	r3, [r4, #28]
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 804b186:	6863      	ldr	r3, [r4, #4]
 804b188:	685e      	ldr	r6, [r3, #4]
 804b18a:	6835      	ldr	r5, [r6, #0]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 804b18c:	4623      	mov	r3, r4
 804b18e:	f853 2f08 	ldr.w	r2, [r3, #8]!
 804b192:	685f      	ldr	r7, [r3, #4]
 804b194:	6898      	ldr	r0, [r3, #8]
 804b196:	68d9      	ldr	r1, [r3, #12]
 804b198:	6032      	str	r2, [r6, #0]
 804b19a:	6077      	str	r7, [r6, #4]
 804b19c:	60b0      	str	r0, [r6, #8]
 804b19e:	60f1      	str	r1, [r6, #12]
 804b1a0:	691a      	ldr	r2, [r3, #16]
 804b1a2:	6132      	str	r2, [r6, #16]
    IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
 804b1a4:	8ba0      	ldrh	r0, [r4, #28]
 804b1a6:	f7fa f941 	bl	804542c <lwip_htons>
 804b1aa:	8070      	strh	r0, [r6, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 804b1ac:	2300      	movs	r3, #0
 804b1ae:	71b3      	strb	r3, [r6, #6]
 804b1b0:	71f3      	strb	r3, [r6, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 804b1b2:	72b3      	strb	r3, [r6, #10]
 804b1b4:	72f3      	strb	r3, [r6, #11]
    p = ipr->p;
 804b1b6:	6866      	ldr	r6, [r4, #4]
    while (r != NULL) {
 804b1b8:	e00a      	b.n	804b1d0 <ip4_reass+0x16c>
      iprh = (struct ip_reass_helper*)r->payload;
 804b1ba:	686f      	ldr	r7, [r5, #4]
      pbuf_header(r, -IP_HLEN);
 804b1bc:	f06f 0113 	mvn.w	r1, #19
 804b1c0:	4628      	mov	r0, r5
 804b1c2:	f7fa fd5f 	bl	8045c84 <pbuf_header>
      pbuf_cat(p, r);
 804b1c6:	4629      	mov	r1, r5
 804b1c8:	4630      	mov	r0, r6
 804b1ca:	f7fa ff51 	bl	8046070 <pbuf_cat>
      r = iprh->next_pbuf;
 804b1ce:	683d      	ldr	r5, [r7, #0]
    while (r != NULL) {
 804b1d0:	2d00      	cmp	r5, #0
 804b1d2:	d1f2      	bne.n	804b1ba <ip4_reass+0x156>
    if (ipr == reassdatagrams) {
 804b1d4:	4b0a      	ldr	r3, [pc, #40]	; (804b200 <ip4_reass+0x19c>)
 804b1d6:	6819      	ldr	r1, [r3, #0]
 804b1d8:	42a1      	cmp	r1, r4
 804b1da:	d005      	beq.n	804b1e8 <ip4_reass+0x184>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 804b1dc:	b129      	cbz	r1, 804b1ea <ip4_reass+0x186>
        if (ipr_prev->next == ipr) {
 804b1de:	680b      	ldr	r3, [r1, #0]
 804b1e0:	42a3      	cmp	r3, r4
 804b1e2:	d002      	beq.n	804b1ea <ip4_reass+0x186>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
 804b1e4:	4619      	mov	r1, r3
 804b1e6:	e7f9      	b.n	804b1dc <ip4_reass+0x178>
      ipr_prev = NULL;
 804b1e8:	4629      	mov	r1, r5
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 804b1ea:	4620      	mov	r0, r4
 804b1ec:	f7ff fd1c 	bl	804ac28 <ip_reass_dequeue_datagram>
    ip_reass_pbufcount -= pbuf_clen(p);
 804b1f0:	4630      	mov	r0, r6
 804b1f2:	f7fa ff1d 	bl	8046030 <pbuf_clen>
 804b1f6:	4a02      	ldr	r2, [pc, #8]	; (804b200 <ip4_reass+0x19c>)
 804b1f8:	8893      	ldrh	r3, [r2, #4]
 804b1fa:	1a1b      	subs	r3, r3, r0
 804b1fc:	8093      	strh	r3, [r2, #4]
    return p;
 804b1fe:	e765      	b.n	804b0cc <ip4_reass+0x68>
 804b200:	20004400 	.word	0x20004400

0804b204 <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
 804b204:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804b208:	b08d      	sub	sp, #52	; 0x34
 804b20a:	4606      	mov	r6, r0
 804b20c:	9107      	str	r1, [sp, #28]
 804b20e:	920b      	str	r2, [sp, #44]	; 0x2c
  u16_t newpbuflen = 0;
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 804b210:	8c4b      	ldrh	r3, [r1, #34]	; 0x22
 804b212:	3b14      	subs	r3, #20
 804b214:	d451      	bmi.n	804b2ba <ip4_frag+0xb6>
 804b216:	10da      	asrs	r2, r3, #3
 804b218:	9206      	str	r2, [sp, #24]
 804b21a:	f3c3 03cf 	ubfx	r3, r3, #3, #16
 804b21e:	930a      	str	r3, [sp, #40]	; 0x28
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
  u16_t tmp;

  original_iphdr = (struct ip_hdr *)p->payload;
 804b220:	f8d6 8004 	ldr.w	r8, [r6, #4]
  iphdr = original_iphdr;
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 804b224:	f898 3000 	ldrb.w	r3, [r8]
 804b228:	f003 030f 	and.w	r3, r3, #15
 804b22c:	2b05      	cmp	r3, #5
 804b22e:	d146      	bne.n	804b2be <ip4_frag+0xba>

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
 804b230:	f8b8 0006 	ldrh.w	r0, [r8, #6]
 804b234:	f7fa f8fa 	bl	804542c <lwip_htons>
  ofo = tmp & IP_OFFMASK;
 804b238:	f3c0 030c 	ubfx	r3, r0, #0, #13
 804b23c:	9305      	str	r3, [sp, #20]
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 804b23e:	f410 5300 	ands.w	r3, r0, #8192	; 0x2000
 804b242:	9302      	str	r3, [sp, #8]
 804b244:	d145      	bne.n	804b2d2 <ip4_frag+0xce>

  left = p->tot_len - IP_HLEN;
 804b246:	f8b6 9008 	ldrh.w	r9, [r6, #8]
 804b24a:	f1a9 0914 	sub.w	r9, r9, #20
 804b24e:	fa1f f389 	uxth.w	r3, r9
 804b252:	9303      	str	r3, [sp, #12]
  u16_t newpbuflen = 0;
 804b254:	9c02      	ldr	r4, [sp, #8]
  u16_t poff = IP_HLEN;
 804b256:	f04f 0a14 	mov.w	sl, #20

  while (left) {
 804b25a:	9b03      	ldr	r3, [sp, #12]
 804b25c:	2b00      	cmp	r3, #0
 804b25e:	f000 80b6 	beq.w	804b3ce <ip4_frag+0x1ca>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, nfb * 8);
 804b262:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 804b266:	00db      	lsls	r3, r3, #3
 804b268:	9a03      	ldr	r2, [sp, #12]
 804b26a:	9208      	str	r2, [sp, #32]
 804b26c:	4293      	cmp	r3, r2
 804b26e:	bfa8      	it	ge
 804b270:	4613      	movge	r3, r2
 804b272:	b29b      	uxth	r3, r3
 804b274:	9304      	str	r3, [sp, #16]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 804b276:	2200      	movs	r2, #0
 804b278:	2114      	movs	r1, #20
 804b27a:	2002      	movs	r0, #2
 804b27c:	f7fa fd70 	bl	8045d60 <pbuf_alloc>
    if (rambuf == NULL) {
 804b280:	4683      	mov	fp, r0
 804b282:	2800      	cmp	r0, #0
 804b284:	f000 80a5 	beq.w	804b3d2 <ip4_frag+0x1ce>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
 804b288:	8973      	ldrh	r3, [r6, #10]
 804b28a:	2b13      	cmp	r3, #19
 804b28c:	d92b      	bls.n	804b2e6 <ip4_frag+0xe2>
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 804b28e:	f8db 3004 	ldr.w	r3, [fp, #4]
 804b292:	f8d8 2000 	ldr.w	r2, [r8]
 804b296:	f8d8 5004 	ldr.w	r5, [r8, #4]
 804b29a:	f8d8 0008 	ldr.w	r0, [r8, #8]
 804b29e:	f8d8 100c 	ldr.w	r1, [r8, #12]
 804b2a2:	601a      	str	r2, [r3, #0]
 804b2a4:	605d      	str	r5, [r3, #4]
 804b2a6:	6098      	str	r0, [r3, #8]
 804b2a8:	60d9      	str	r1, [r3, #12]
 804b2aa:	f8d8 2010 	ldr.w	r2, [r8, #16]
 804b2ae:	611a      	str	r2, [r3, #16]
    iphdr = (struct ip_hdr *)rambuf->payload;
 804b2b0:	f8db 3004 	ldr.w	r3, [fp, #4]
 804b2b4:	9309      	str	r3, [sp, #36]	; 0x24

    left_to_copy = fragsize;
 804b2b6:	9d04      	ldr	r5, [sp, #16]
    while (left_to_copy) {
 804b2b8:	e03d      	b.n	804b336 <ip4_frag+0x132>
  const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
 804b2ba:	3307      	adds	r3, #7
 804b2bc:	e7ab      	b.n	804b216 <ip4_frag+0x12>
  LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
 804b2be:	4b46      	ldr	r3, [pc, #280]	; (804b3d8 <ip4_frag+0x1d4>)
 804b2c0:	f240 22e1 	movw	r2, #737	; 0x2e1
 804b2c4:	4945      	ldr	r1, [pc, #276]	; (804b3dc <ip4_frag+0x1d8>)
 804b2c6:	4846      	ldr	r0, [pc, #280]	; (804b3e0 <ip4_frag+0x1dc>)
 804b2c8:	f005 ff90 	bl	80511ec <printf>
 804b2cc:	f06f 0005 	mvn.w	r0, #5
 804b2d0:	e043      	b.n	804b35a <ip4_frag+0x156>
  LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
 804b2d2:	4b41      	ldr	r3, [pc, #260]	; (804b3d8 <ip4_frag+0x1d4>)
 804b2d4:	f240 22e6 	movw	r2, #742	; 0x2e6
 804b2d8:	4942      	ldr	r1, [pc, #264]	; (804b3e4 <ip4_frag+0x1e0>)
 804b2da:	4841      	ldr	r0, [pc, #260]	; (804b3e0 <ip4_frag+0x1dc>)
 804b2dc:	f005 ff86 	bl	80511ec <printf>
 804b2e0:	f06f 0005 	mvn.w	r0, #5
 804b2e4:	e039      	b.n	804b35a <ip4_frag+0x156>
    LWIP_ASSERT("this needs a pbuf in one piece!",
 804b2e6:	4b3c      	ldr	r3, [pc, #240]	; (804b3d8 <ip4_frag+0x1d4>)
 804b2e8:	f44f 7242 	mov.w	r2, #776	; 0x308
 804b2ec:	493e      	ldr	r1, [pc, #248]	; (804b3e8 <ip4_frag+0x1e4>)
 804b2ee:	483c      	ldr	r0, [pc, #240]	; (804b3e0 <ip4_frag+0x1dc>)
 804b2f0:	f005 ff7c 	bl	80511ec <printf>
 804b2f4:	e7cb      	b.n	804b28e <ip4_frag+0x8a>
      if (!newpbuflen) {
        poff = 0;
        p = p->next;
        continue;
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 804b2f6:	f7ff fe67 	bl	804afc8 <ip_frag_alloc_pbuf_custom_ref>
      if (pcr == NULL) {
 804b2fa:	4607      	mov	r7, r0
 804b2fc:	b340      	cbz	r0, 804b350 <ip4_frag+0x14c>
        pbuf_free(rambuf);
        goto memerr;
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
        (u8_t*)p->payload + poff, newpbuflen);
 804b2fe:	6873      	ldr	r3, [r6, #4]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
 804b300:	9401      	str	r4, [sp, #4]
 804b302:	4453      	add	r3, sl
 804b304:	9300      	str	r3, [sp, #0]
 804b306:	4603      	mov	r3, r0
 804b308:	2202      	movs	r2, #2
 804b30a:	4621      	mov	r1, r4
 804b30c:	2004      	movs	r0, #4
 804b30e:	f7fa fc7d 	bl	8045c0c <pbuf_alloced_custom>
      if (newpbuf == NULL) {
 804b312:	4681      	mov	r9, r0
 804b314:	b320      	cbz	r0, 804b360 <ip4_frag+0x15c>
        ip_frag_free_pbuf_custom_ref(pcr);
        pbuf_free(rambuf);
        goto memerr;
      }
      pbuf_ref(p);
 804b316:	4630      	mov	r0, r6
 804b318:	f7fa fe92 	bl	8046040 <pbuf_ref>
      pcr->original = p;
 804b31c:	617e      	str	r6, [r7, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 804b31e:	4b33      	ldr	r3, [pc, #204]	; (804b3ec <ip4_frag+0x1e8>)
 804b320:	613b      	str	r3, [r7, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 804b322:	4649      	mov	r1, r9
 804b324:	4658      	mov	r0, fp
 804b326:	f7fa fea3 	bl	8046070 <pbuf_cat>
      left_to_copy -= newpbuflen;
 804b32a:	1b2d      	subs	r5, r5, r4
 804b32c:	b2ad      	uxth	r5, r5
      if (left_to_copy) {
 804b32e:	b115      	cbz	r5, 804b336 <ip4_frag+0x132>
        poff = 0;
        p = p->next;
 804b330:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 804b332:	f8dd a008 	ldr.w	sl, [sp, #8]
    while (left_to_copy) {
 804b336:	b1e5      	cbz	r5, 804b372 <ip4_frag+0x16e>
      u16_t plen = p->len - poff;
 804b338:	8974      	ldrh	r4, [r6, #10]
 804b33a:	eba4 040a 	sub.w	r4, r4, sl
 804b33e:	b2a4      	uxth	r4, r4
      newpbuflen = LWIP_MIN(left_to_copy, plen);
 804b340:	42ac      	cmp	r4, r5
 804b342:	bf28      	it	cs
 804b344:	462c      	movcs	r4, r5
      if (!newpbuflen) {
 804b346:	2c00      	cmp	r4, #0
 804b348:	d1d5      	bne.n	804b2f6 <ip4_frag+0xf2>
        p = p->next;
 804b34a:	6836      	ldr	r6, [r6, #0]
        poff = 0;
 804b34c:	46a2      	mov	sl, r4
        continue;
 804b34e:	e7f2      	b.n	804b336 <ip4_frag+0x132>
        pbuf_free(rambuf);
 804b350:	4658      	mov	r0, fp
 804b352:	f7fa fca1 	bl	8045c98 <pbuf_free>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
 804b356:	f04f 30ff 	mov.w	r0, #4294967295
}
 804b35a:	b00d      	add	sp, #52	; 0x34
 804b35c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ip_frag_free_pbuf_custom_ref(pcr);
 804b360:	4638      	mov	r0, r7
 804b362:	f7ff fd3f 	bl	804ade4 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 804b366:	4658      	mov	r0, fp
 804b368:	f7fa fc96 	bl	8045c98 <pbuf_free>
  return ERR_MEM;
 804b36c:	f04f 30ff 	mov.w	r0, #4294967295
        goto memerr;
 804b370:	e7f3      	b.n	804b35a <ip4_frag+0x156>
    poff += newpbuflen;
 804b372:	44a2      	add	sl, r4
 804b374:	fa1f fa8a 	uxth.w	sl, sl
    last = (left <= netif->mtu - IP_HLEN);
 804b378:	9b07      	ldr	r3, [sp, #28]
 804b37a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 804b37c:	3b13      	subs	r3, #19
    tmp = (IP_OFFMASK & (ofo));
 804b37e:	9a05      	ldr	r2, [sp, #20]
 804b380:	f3c2 000c 	ubfx	r0, r2, #0, #13
    if (!last) {
 804b384:	9a08      	ldr	r2, [sp, #32]
 804b386:	429a      	cmp	r2, r3
 804b388:	db01      	blt.n	804b38e <ip4_frag+0x18a>
      tmp = tmp | IP_MF;
 804b38a:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
 804b38e:	f7fa f84d 	bl	804542c <lwip_htons>
 804b392:	9d09      	ldr	r5, [sp, #36]	; 0x24
 804b394:	80e8      	strh	r0, [r5, #6]
    IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
 804b396:	9f04      	ldr	r7, [sp, #16]
 804b398:	f107 0014 	add.w	r0, r7, #20
 804b39c:	b280      	uxth	r0, r0
 804b39e:	f7fa f845 	bl	804542c <lwip_htons>
 804b3a2:	8068      	strh	r0, [r5, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 804b3a4:	2300      	movs	r3, #0
 804b3a6:	72ab      	strb	r3, [r5, #10]
 804b3a8:	72eb      	strb	r3, [r5, #11]
    netif->output(netif, rambuf, dest);
 804b3aa:	9807      	ldr	r0, [sp, #28]
 804b3ac:	6943      	ldr	r3, [r0, #20]
 804b3ae:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 804b3b0:	4659      	mov	r1, fp
 804b3b2:	4798      	blx	r3
    pbuf_free(rambuf);
 804b3b4:	4658      	mov	r0, fp
 804b3b6:	f7fa fc6f 	bl	8045c98 <pbuf_free>
    left -= fragsize;
 804b3ba:	9b03      	ldr	r3, [sp, #12]
 804b3bc:	1bdb      	subs	r3, r3, r7
 804b3be:	b29b      	uxth	r3, r3
 804b3c0:	9303      	str	r3, [sp, #12]
    ofo += nfb;
 804b3c2:	9b05      	ldr	r3, [sp, #20]
 804b3c4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 804b3c6:	4413      	add	r3, r2
 804b3c8:	b29b      	uxth	r3, r3
 804b3ca:	9305      	str	r3, [sp, #20]
 804b3cc:	e745      	b.n	804b25a <ip4_frag+0x56>
  return ERR_OK;
 804b3ce:	2000      	movs	r0, #0
 804b3d0:	e7c3      	b.n	804b35a <ip4_frag+0x156>
  return ERR_MEM;
 804b3d2:	f04f 30ff 	mov.w	r0, #4294967295
 804b3d6:	e7c0      	b.n	804b35a <ip4_frag+0x156>
 804b3d8:	08059d78 	.word	0x08059d78
 804b3dc:	08059ec4 	.word	0x08059ec4
 804b3e0:	08058644 	.word	0x08058644
 804b3e4:	08059eec 	.word	0x08059eec
 804b3e8:	08059f08 	.word	0x08059f08
 804b3ec:	0804ae11 	.word	0x0804ae11

0804b3f0 <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 804b3f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804b3f2:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 804b3f4:	8946      	ldrh	r6, [r0, #10]
 804b3f6:	2e0e      	cmp	r6, #14
 804b3f8:	d916      	bls.n	804b428 <ethernet_input+0x38>
 804b3fa:	460d      	mov	r5, r1
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 804b3fc:	6840      	ldr	r0, [r0, #4]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0],  (unsigned)ethhdr->src.addr[1],  (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3],  (unsigned)ethhdr->src.addr[4],  (unsigned)ethhdr->src.addr[5],
     lwip_htons(ethhdr->type)));

  type = ethhdr->type;
 804b3fe:	8987      	ldrh	r7, [r0, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 804b400:	7803      	ldrb	r3, [r0, #0]
 804b402:	f013 0f01 	tst.w	r3, #1
 804b406:	d00a      	beq.n	804b41e <ethernet_input+0x2e>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
 804b408:	2b01      	cmp	r3, #1
 804b40a:	d012      	beq.n	804b432 <ethernet_input+0x42>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 804b40c:	2206      	movs	r2, #6
 804b40e:	4921      	ldr	r1, [pc, #132]	; (804b494 <ethernet_input+0xa4>)
 804b410:	f005 febc 	bl	805118c <memcmp>
 804b414:	b918      	cbnz	r0, 804b41e <ethernet_input+0x2e>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 804b416:	7b63      	ldrb	r3, [r4, #13]
 804b418:	f043 0308 	orr.w	r3, r3, #8
 804b41c:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 804b41e:	2f08      	cmp	r7, #8
 804b420:	d012      	beq.n	804b448 <ethernet_input+0x58>
 804b422:	f5b7 6fc1 	cmp.w	r7, #1544	; 0x608
 804b426:	d022      	beq.n	804b46e <ethernet_input+0x7e>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 804b428:	4620      	mov	r0, r4
 804b42a:	f7fa fc35 	bl	8045c98 <pbuf_free>
  return ERR_OK;
}
 804b42e:	2000      	movs	r0, #0
 804b430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 804b432:	7843      	ldrb	r3, [r0, #1]
 804b434:	2b00      	cmp	r3, #0
 804b436:	d1f2      	bne.n	804b41e <ethernet_input+0x2e>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
 804b438:	7883      	ldrb	r3, [r0, #2]
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
 804b43a:	2b5e      	cmp	r3, #94	; 0x5e
 804b43c:	d1ef      	bne.n	804b41e <ethernet_input+0x2e>
        p->flags |= PBUF_FLAG_LLMCAST;
 804b43e:	7b63      	ldrb	r3, [r4, #13]
 804b440:	f043 0310 	orr.w	r3, r3, #16
 804b444:	7363      	strb	r3, [r4, #13]
 804b446:	e7ea      	b.n	804b41e <ethernet_input+0x2e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 804b448:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804b44c:	f013 0f08 	tst.w	r3, #8
 804b450:	d0ea      	beq.n	804b428 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 804b452:	2e0d      	cmp	r6, #13
 804b454:	d9e8      	bls.n	804b428 <ethernet_input+0x38>
 804b456:	f06f 010d 	mvn.w	r1, #13
 804b45a:	4620      	mov	r0, r4
 804b45c:	f7fa fc12 	bl	8045c84 <pbuf_header>
 804b460:	2800      	cmp	r0, #0
 804b462:	d1e1      	bne.n	804b428 <ethernet_input+0x38>
        ip4_input(p, netif);
 804b464:	4629      	mov	r1, r5
 804b466:	4620      	mov	r0, r4
 804b468:	f7ff fa50 	bl	804a90c <ip4_input>
      break;
 804b46c:	e7df      	b.n	804b42e <ethernet_input+0x3e>
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 804b46e:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804b472:	f013 0f08 	tst.w	r3, #8
 804b476:	d0d7      	beq.n	804b428 <ethernet_input+0x38>
      if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
 804b478:	2e0d      	cmp	r6, #13
 804b47a:	d9d5      	bls.n	804b428 <ethernet_input+0x38>
 804b47c:	f06f 010d 	mvn.w	r1, #13
 804b480:	4620      	mov	r0, r4
 804b482:	f7fa fbff 	bl	8045c84 <pbuf_header>
 804b486:	2800      	cmp	r0, #0
 804b488:	d1ce      	bne.n	804b428 <ethernet_input+0x38>
        etharp_input(p, netif);
 804b48a:	4629      	mov	r1, r5
 804b48c:	4620      	mov	r0, r4
 804b48e:	f7fe fe67 	bl	804a160 <etharp_input>
      break;
 804b492:	e7cc      	b.n	804b42e <ethernet_input+0x3e>
 804b494:	080585d4 	.word	0x080585d4

0804b498 <ethernet_output>:
 */
err_t
ethernet_output(struct netif* netif, struct pbuf* p,
                const struct eth_addr* src, const struct eth_addr* dst,
                u16_t eth_type)
{
 804b498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804b49c:	4605      	mov	r5, r0
 804b49e:	460c      	mov	r4, r1
 804b4a0:	4616      	mov	r6, r2
 804b4a2:	461f      	mov	r7, r3
  struct eth_hdr* ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
 804b4a4:	f8bd 0018 	ldrh.w	r0, [sp, #24]
 804b4a8:	f7f9 ffc0 	bl	804542c <lwip_htons>
 804b4ac:	4680      	mov	r8, r0

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
 804b4ae:	210e      	movs	r1, #14
 804b4b0:	4620      	mov	r0, r4
 804b4b2:	f7fa fbe7 	bl	8045c84 <pbuf_header>
 804b4b6:	b9e8      	cbnz	r0, 804b4f4 <ethernet_output+0x5c>
      goto pbuf_header_failed;
    }
  }

  ethhdr = (struct eth_hdr*)p->payload;
 804b4b8:	6861      	ldr	r1, [r4, #4]
  ethhdr->type = eth_type_be;
 804b4ba:	f8a1 800c 	strh.w	r8, [r1, #12]
  ETHADDR32_COPY(&ethhdr->dest, dst);
 804b4be:	683b      	ldr	r3, [r7, #0]
 804b4c0:	600b      	str	r3, [r1, #0]
 804b4c2:	88bb      	ldrh	r3, [r7, #4]
 804b4c4:	808b      	strh	r3, [r1, #4]
  ETHADDR16_COPY(&ethhdr->src,  src);
 804b4c6:	6833      	ldr	r3, [r6, #0]
 804b4c8:	f8c1 3006 	str.w	r3, [r1, #6]
 804b4cc:	88b3      	ldrh	r3, [r6, #4]
 804b4ce:	814b      	strh	r3, [r1, #10]

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 804b4d0:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 804b4d4:	2b06      	cmp	r3, #6
 804b4d6:	d105      	bne.n	804b4e4 <ethernet_output+0x4c>
    (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
    ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
 804b4d8:	69ab      	ldr	r3, [r5, #24]
 804b4da:	4621      	mov	r1, r4
 804b4dc:	4628      	mov	r0, r5
 804b4de:	4798      	blx	r3
pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
    ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
  return ERR_BUF;
}
 804b4e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
 804b4e4:	4b05      	ldr	r3, [pc, #20]	; (804b4fc <ethernet_output+0x64>)
 804b4e6:	f240 122b 	movw	r2, #299	; 0x12b
 804b4ea:	4905      	ldr	r1, [pc, #20]	; (804b500 <ethernet_output+0x68>)
 804b4ec:	4805      	ldr	r0, [pc, #20]	; (804b504 <ethernet_output+0x6c>)
 804b4ee:	f005 fe7d 	bl	80511ec <printf>
 804b4f2:	e7f1      	b.n	804b4d8 <ethernet_output+0x40>
  return ERR_BUF;
 804b4f4:	f06f 0001 	mvn.w	r0, #1
 804b4f8:	e7f2      	b.n	804b4e0 <ethernet_output+0x48>
 804b4fa:	bf00      	nop
 804b4fc:	08059f28 	.word	0x08059f28
 804b500:	08059f60 	.word	0x08059f60
 804b504:	08058644 	.word	0x08058644

0804b508 <MX_ADC1_Init>:
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 804b508:	b500      	push	{lr}
 804b50a:	b085      	sub	sp, #20
  ADC_ChannelConfTypeDef sConfig = {0};
 804b50c:	2300      	movs	r3, #0
 804b50e:	9300      	str	r3, [sp, #0]
 804b510:	9301      	str	r3, [sp, #4]
 804b512:	9302      	str	r3, [sp, #8]
 804b514:	9303      	str	r3, [sp, #12]

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
 804b516:	481c      	ldr	r0, [pc, #112]	; (804b588 <MX_ADC1_Init+0x80>)
 804b518:	4a1c      	ldr	r2, [pc, #112]	; (804b58c <MX_ADC1_Init+0x84>)
 804b51a:	6002      	str	r2, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 804b51c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 804b520:	6042      	str	r2, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 804b522:	6083      	str	r3, [r0, #8]
  hadc1.Init.ScanConvMode = ENABLE;
 804b524:	2201      	movs	r2, #1
 804b526:	6102      	str	r2, [r0, #16]
  hadc1.Init.ContinuousConvMode = ENABLE;
 804b528:	7602      	strb	r2, [r0, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 804b52a:	f880 3020 	strb.w	r3, [r0, #32]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 804b52e:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 804b530:	4917      	ldr	r1, [pc, #92]	; (804b590 <MX_ADC1_Init+0x88>)
 804b532:	6281      	str	r1, [r0, #40]	; 0x28
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 804b534:	60c3      	str	r3, [r0, #12]
  hadc1.Init.NbrOfConversion = 2;
 804b536:	2102      	movs	r1, #2
 804b538:	61c1      	str	r1, [r0, #28]
  hadc1.Init.DMAContinuousRequests = ENABLE;
 804b53a:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 804b53e:	6143      	str	r3, [r0, #20]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 804b540:	f7f5 fe62 	bl	8041208 <HAL_ADC_Init>
 804b544:	b9b0      	cbnz	r0, 804b574 <MX_ADC1_Init+0x6c>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_VBAT;
 804b546:	2312      	movs	r3, #18
 804b548:	9300      	str	r3, [sp, #0]
  sConfig.Rank = 1;
 804b54a:	2301      	movs	r3, #1
 804b54c:	9301      	str	r3, [sp, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 804b54e:	2307      	movs	r3, #7
 804b550:	9302      	str	r3, [sp, #8]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 804b552:	4669      	mov	r1, sp
 804b554:	480c      	ldr	r0, [pc, #48]	; (804b588 <MX_ADC1_Init+0x80>)
 804b556:	f7f6 f8d5 	bl	8041704 <HAL_ADC_ConfigChannel>
 804b55a:	b970      	cbnz	r0, 804b57a <MX_ADC1_Init+0x72>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_3;
 804b55c:	2303      	movs	r3, #3
 804b55e:	9300      	str	r3, [sp, #0]
  sConfig.Rank = 2;
 804b560:	2302      	movs	r3, #2
 804b562:	9301      	str	r3, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 804b564:	4669      	mov	r1, sp
 804b566:	4808      	ldr	r0, [pc, #32]	; (804b588 <MX_ADC1_Init+0x80>)
 804b568:	f7f6 f8cc 	bl	8041704 <HAL_ADC_ConfigChannel>
 804b56c:	b940      	cbnz	r0, 804b580 <MX_ADC1_Init+0x78>
  {
    Error_Handler();
  }

}
 804b56e:	b005      	add	sp, #20
 804b570:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 804b574:	f002 fa44 	bl	804da00 <Error_Handler>
 804b578:	e7e5      	b.n	804b546 <MX_ADC1_Init+0x3e>
    Error_Handler();
 804b57a:	f002 fa41 	bl	804da00 <Error_Handler>
 804b57e:	e7ed      	b.n	804b55c <MX_ADC1_Init+0x54>
    Error_Handler();
 804b580:	f002 fa3e 	bl	804da00 <Error_Handler>
}
 804b584:	e7f3      	b.n	804b56e <MX_ADC1_Init+0x66>
 804b586:	bf00      	nop
 804b588:	200089b8 	.word	0x200089b8
 804b58c:	40012000 	.word	0x40012000
 804b590:	0f000001 	.word	0x0f000001

0804b594 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 804b594:	b530      	push	{r4, r5, lr}
 804b596:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804b598:	2300      	movs	r3, #0
 804b59a:	9303      	str	r3, [sp, #12]
 804b59c:	9304      	str	r3, [sp, #16]
 804b59e:	9305      	str	r3, [sp, #20]
 804b5a0:	9306      	str	r3, [sp, #24]
 804b5a2:	9307      	str	r3, [sp, #28]
  if(adcHandle->Instance==ADC1)
 804b5a4:	6802      	ldr	r2, [r0, #0]
 804b5a6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 804b5aa:	f503 3390 	add.w	r3, r3, #73728	; 0x12000
 804b5ae:	429a      	cmp	r2, r3
 804b5b0:	d001      	beq.n	804b5b6 <HAL_ADC_MspInit+0x22>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 804b5b2:	b009      	add	sp, #36	; 0x24
 804b5b4:	bd30      	pop	{r4, r5, pc}
 804b5b6:	4604      	mov	r4, r0
    __HAL_RCC_ADC1_CLK_ENABLE();
 804b5b8:	2500      	movs	r5, #0
 804b5ba:	9501      	str	r5, [sp, #4]
 804b5bc:	f503 338c 	add.w	r3, r3, #71680	; 0x11800
 804b5c0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804b5c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 804b5c6:	645a      	str	r2, [r3, #68]	; 0x44
 804b5c8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804b5ca:	f402 7280 	and.w	r2, r2, #256	; 0x100
 804b5ce:	9201      	str	r2, [sp, #4]
 804b5d0:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 804b5d2:	9502      	str	r5, [sp, #8]
 804b5d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b5d6:	f042 0201 	orr.w	r2, r2, #1
 804b5da:	631a      	str	r2, [r3, #48]	; 0x30
 804b5dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804b5de:	f003 0301 	and.w	r3, r3, #1
 804b5e2:	9302      	str	r3, [sp, #8]
 804b5e4:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = VinSys_Pin;
 804b5e6:	2308      	movs	r3, #8
 804b5e8:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 804b5ea:	2303      	movs	r3, #3
 804b5ec:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804b5ee:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(VinSys_GPIO_Port, &GPIO_InitStruct);
 804b5f0:	a903      	add	r1, sp, #12
 804b5f2:	4814      	ldr	r0, [pc, #80]	; (804b644 <HAL_ADC_MspInit+0xb0>)
 804b5f4:	f7f7 fa80 	bl	8042af8 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream4;
 804b5f8:	4813      	ldr	r0, [pc, #76]	; (804b648 <HAL_ADC_MspInit+0xb4>)
 804b5fa:	4b14      	ldr	r3, [pc, #80]	; (804b64c <HAL_ADC_MspInit+0xb8>)
 804b5fc:	6003      	str	r3, [r0, #0]
    hdma_adc1.Init.Channel = DMA_CHANNEL_0;
 804b5fe:	6045      	str	r5, [r0, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 804b600:	6085      	str	r5, [r0, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 804b602:	60c5      	str	r5, [r0, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 804b604:	f44f 6380 	mov.w	r3, #1024	; 0x400
 804b608:	6103      	str	r3, [r0, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 804b60a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 804b60e:	6143      	str	r3, [r0, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 804b610:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 804b614:	6183      	str	r3, [r0, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 804b616:	f44f 7380 	mov.w	r3, #256	; 0x100
 804b61a:	61c3      	str	r3, [r0, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 804b61c:	6205      	str	r5, [r0, #32]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 804b61e:	6245      	str	r5, [r0, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 804b620:	f7f6 fa2e 	bl	8041a80 <HAL_DMA_Init>
 804b624:	b958      	cbnz	r0, 804b63e <HAL_ADC_MspInit+0xaa>
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 804b626:	4b08      	ldr	r3, [pc, #32]	; (804b648 <HAL_ADC_MspInit+0xb4>)
 804b628:	63a3      	str	r3, [r4, #56]	; 0x38
 804b62a:	639c      	str	r4, [r3, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 7, 0);
 804b62c:	2200      	movs	r2, #0
 804b62e:	2107      	movs	r1, #7
 804b630:	2012      	movs	r0, #18
 804b632:	f7f6 f94d 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 804b636:	2012      	movs	r0, #18
 804b638:	f7f6 f97e 	bl	8041938 <HAL_NVIC_EnableIRQ>
}
 804b63c:	e7b9      	b.n	804b5b2 <HAL_ADC_MspInit+0x1e>
      Error_Handler();
 804b63e:	f002 f9df 	bl	804da00 <Error_Handler>
 804b642:	e7f0      	b.n	804b626 <HAL_ADC_MspInit+0x92>
 804b644:	40020000 	.word	0x40020000
 804b648:	20008a00 	.word	0x20008a00
 804b64c:	40026470 	.word	0x40026470

0804b650 <updateDeviceSignature>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateDeviceSignature(void)
{
 804b650:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	uint32_t u32UUID0 = 0;
	uint32_t u32UUID1 = 0;
	uint32_t u32UUID2 = 0;

	u32UUID0 = STM32_UUID[0];
 804b654:	f8df 809c 	ldr.w	r8, [pc, #156]	; 804b6f4 <updateDeviceSignature+0xa4>
 804b658:	f8d8 4000 	ldr.w	r4, [r8]
	u32UUID1 = STM32_UUID[1];
 804b65c:	4f1e      	ldr	r7, [pc, #120]	; (804b6d8 <updateDeviceSignature+0x88>)
 804b65e:	683d      	ldr	r5, [r7, #0]
	u32UUID2 = STM32_UUID[2];
 804b660:	4e1e      	ldr	r6, [pc, #120]	; (804b6dc <updateDeviceSignature+0x8c>)
 804b662:	6830      	ldr	r0, [r6, #0]

	/* Variable for production */
	gu32DeviceId = STM32_UUID[0];
 804b664:	4b1e      	ldr	r3, [pc, #120]	; (804b6e0 <updateDeviceSignature+0x90>)
 804b666:	601c      	str	r4, [r3, #0]
	/*Integer to ASCII UUID 2 */
	itoa(u32UUID2,buffuuid2,10);
 804b668:	f8df b08c 	ldr.w	fp, [pc, #140]	; 804b6f8 <updateDeviceSignature+0xa8>
 804b66c:	220a      	movs	r2, #10
 804b66e:	4659      	mov	r1, fp
 804b670:	f005 fb38 	bl	8050ce4 <itoa>
	/*Integer to ASCII UUID 1 */
	itoa(u32UUID1,buffuuid1,10);
 804b674:	f8df a084 	ldr.w	sl, [pc, #132]	; 804b6fc <updateDeviceSignature+0xac>
 804b678:	220a      	movs	r2, #10
 804b67a:	4651      	mov	r1, sl
 804b67c:	4628      	mov	r0, r5
 804b67e:	f005 fb31 	bl	8050ce4 <itoa>
	/*Integer to ASCII UUID 0 */
	itoa(u32UUID0,buffuuid0,10);
 804b682:	f8df 907c 	ldr.w	r9, [pc, #124]	; 804b700 <updateDeviceSignature+0xb0>
 804b686:	220a      	movs	r2, #10
 804b688:	4649      	mov	r1, r9
 804b68a:	4620      	mov	r0, r4
 804b68c:	f005 fb2a 	bl	8050ce4 <itoa>

	/*Integer to ASCII Flash Size */
#if (USEFLASHSIZEINDEVINFO == TRUE)
	itoa(deviceSign.u32FlashSize,buffflash,10);
 804b690:	4c14      	ldr	r4, [pc, #80]	; (804b6e4 <updateDeviceSignature+0x94>)
 804b692:	220a      	movs	r2, #10
 804b694:	4914      	ldr	r1, [pc, #80]	; (804b6e8 <updateDeviceSignature+0x98>)
 804b696:	89a0      	ldrh	r0, [r4, #12]
 804b698:	f005 fb24 	bl	8050ce4 <itoa>
#endif

	/* Append Device Info to Array */
	strcat(dinfo,buffuuid2);
 804b69c:	4d13      	ldr	r5, [pc, #76]	; (804b6ec <updateDeviceSignature+0x9c>)
 804b69e:	4659      	mov	r1, fp
 804b6a0:	4628      	mov	r0, r5
 804b6a2:	f005 fde5 	bl	8051270 <strcat>
	strcat(dinfo,buffuuid1);
 804b6a6:	4651      	mov	r1, sl
 804b6a8:	4628      	mov	r0, r5
 804b6aa:	f005 fde1 	bl	8051270 <strcat>
	strcat(dinfo,buffuuid0);
 804b6ae:	4649      	mov	r1, r9
 804b6b0:	4628      	mov	r0, r5
 804b6b2:	f005 fddd 	bl	8051270 <strcat>

#if (USEFLASHSIZEINDEVINFO == TRUE)
	strcat(dinfo,buffflash);
 804b6b6:	490c      	ldr	r1, [pc, #48]	; (804b6e8 <updateDeviceSignature+0x98>)
 804b6b8:	4628      	mov	r0, r5
 804b6ba:	f005 fdd9 	bl	8051270 <strcat>
#endif
	/* Update Structure */
	/* 96 Bit UUID */
	deviceSign.u32UUID0 = STM32_UUID[0];
 804b6be:	f8d8 3000 	ldr.w	r3, [r8]
 804b6c2:	6023      	str	r3, [r4, #0]
	deviceSign.u32UUID1 = STM32_UUID[1];
 804b6c4:	683b      	ldr	r3, [r7, #0]
 804b6c6:	6063      	str	r3, [r4, #4]
	deviceSign.u32UUID2 = STM32_UUID[2];
 804b6c8:	6833      	ldr	r3, [r6, #0]
 804b6ca:	60a3      	str	r3, [r4, #8]
	/* 16 Bit Flash Size */
	deviceSign.u32FlashSize = STM32_FLASHSIZE;
 804b6cc:	4b08      	ldr	r3, [pc, #32]	; (804b6f0 <updateDeviceSignature+0xa0>)
 804b6ce:	881b      	ldrh	r3, [r3, #0]
 804b6d0:	81a3      	strh	r3, [r4, #12]
}
 804b6d2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804b6d6:	bf00      	nop
 804b6d8:	1fff7a14 	.word	0x1fff7a14
 804b6dc:	1fff7a18 	.word	0x1fff7a18
 804b6e0:	20004408 	.word	0x20004408
 804b6e4:	20008b44 	.word	0x20008b44
 804b6e8:	20008ac4 	.word	0x20008ac4
 804b6ec:	20008a60 	.word	0x20008a60
 804b6f0:	1fff7a22 	.word	0x1fff7a22
 804b6f4:	1fff7a10 	.word	0x1fff7a10
 804b6f8:	20008b24 	.word	0x20008b24
 804b6fc:	20008ae4 	.word	0x20008ae4
 804b700:	20008b04 	.word	0x20008b04

0804b704 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 804b704:	b500      	push	{lr}
 804b706:	b083      	sub	sp, #12
  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 804b708:	2100      	movs	r1, #0
 804b70a:	9101      	str	r1, [sp, #4]
 804b70c:	4b09      	ldr	r3, [pc, #36]	; (804b734 <MX_DMA_Init+0x30>)
 804b70e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b710:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 804b714:	631a      	str	r2, [r3, #48]	; 0x30
 804b716:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804b718:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 804b71c:	9301      	str	r3, [sp, #4]
 804b71e:	9b01      	ldr	r3, [sp, #4]

  /* DMA interrupt init */
  /* DMA2_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 0, 0);
 804b720:	460a      	mov	r2, r1
 804b722:	203c      	movs	r0, #60	; 0x3c
 804b724:	f7f6 f8d4 	bl	80418d0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 804b728:	203c      	movs	r0, #60	; 0x3c
 804b72a:	f7f6 f905 	bl	8041938 <HAL_NVIC_EnableIRQ>

}
 804b72e:	b003      	add	sp, #12
 804b730:	f85d fb04 	ldr.w	pc, [sp], #4
 804b734:	40023800 	.word	0x40023800

0804b738 <assertError>:
			/* Unwanted / Undefined Error Occured
			 * System Will Halt Completely */
			//while(1);
			break;
	}
}
 804b738:	4770      	bx	lr
	...

0804b73c <low_level_input>:
 * @param netif the lwip network interface structure for this ethernetif
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
   */
static struct pbuf * low_level_input(struct netif *netif)
{
 804b73c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t payloadoffset = 0;
  uint32_t byteslefttocopy = 0;
  uint32_t i=0;

  /* get received frame */
  if (HAL_ETH_GetReceivedFrame(&heth) != HAL_OK)
 804b740:	4833      	ldr	r0, [pc, #204]	; (804b810 <low_level_input+0xd4>)
 804b742:	f7f6 fd51 	bl	80421e8 <HAL_ETH_GetReceivedFrame>
 804b746:	2800      	cmp	r0, #0
 804b748:	d15e      	bne.n	804b808 <low_level_input+0xcc>
    return NULL;

  /* Obtain the size of the packet and put it into the "len" variable. */
  len = heth.RxFrameInfos.length;
 804b74a:	4b31      	ldr	r3, [pc, #196]	; (804b810 <low_level_input+0xd4>)
 804b74c:	8f99      	ldrh	r1, [r3, #60]	; 0x3c
  buffer = (uint8_t *)heth.RxFrameInfos.buffer;
 804b74e:	f8d3 8040 	ldr.w	r8, [r3, #64]	; 0x40

  if (len > 0)
 804b752:	b979      	cbnz	r1, 804b774 <low_level_input+0x38>
  struct pbuf *p = NULL;
 804b754:	f04f 0a00 	mov.w	sl, #0
    }
  }

    /* Release descriptors to DMA */
    /* Point to first descriptor */
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 804b758:	4b2d      	ldr	r3, [pc, #180]	; (804b810 <low_level_input+0xd4>)
 804b75a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 804b75c:	2100      	movs	r1, #0
 804b75e:	4a2c      	ldr	r2, [pc, #176]	; (804b810 <low_level_input+0xd4>)
 804b760:	6b92      	ldr	r2, [r2, #56]	; 0x38
 804b762:	428a      	cmp	r2, r1
 804b764:	d93b      	bls.n	804b7de <low_level_input+0xa2>
    {
      dmarxdesc->Status |= ETH_DMARXDESC_OWN;
 804b766:	681a      	ldr	r2, [r3, #0]
 804b768:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 804b76c:	601a      	str	r2, [r3, #0]
      dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 804b76e:	68db      	ldr	r3, [r3, #12]
    for (i=0; i< heth.RxFrameInfos.SegCount; i++)
 804b770:	3101      	adds	r1, #1
 804b772:	e7f4      	b.n	804b75e <low_level_input+0x22>
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 804b774:	2203      	movs	r2, #3
 804b776:	2004      	movs	r0, #4
 804b778:	f7fa faf2 	bl	8045d60 <pbuf_alloc>
  if (p != NULL)
 804b77c:	4682      	mov	sl, r0
 804b77e:	2800      	cmp	r0, #0
 804b780:	d0ea      	beq.n	804b758 <low_level_input+0x1c>
    dmarxdesc = heth.RxFrameInfos.FSRxDesc;
 804b782:	4b23      	ldr	r3, [pc, #140]	; (804b810 <low_level_input+0xd4>)
 804b784:	6b1f      	ldr	r7, [r3, #48]	; 0x30
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 804b786:	4681      	mov	r9, r0
    bufferoffset = 0;
 804b788:	2400      	movs	r4, #0
    for(q = p; q != NULL; q = q->next)
 804b78a:	e021      	b.n	804b7d0 <low_level_input+0x94>
        memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
 804b78c:	f8d9 0004 	ldr.w	r0, [r9, #4]
 804b790:	f5c4 62be 	rsb	r2, r4, #1520	; 0x5f0
 804b794:	3204      	adds	r2, #4
 804b796:	eb08 0104 	add.w	r1, r8, r4
 804b79a:	4430      	add	r0, r6
 804b79c:	f005 fd04 	bl	80511a8 <memcpy>
        dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
 804b7a0:	68ff      	ldr	r7, [r7, #12]
        buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
 804b7a2:	f8d7 8008 	ldr.w	r8, [r7, #8]
        byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
 804b7a6:	f2a5 52f4 	subw	r2, r5, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
 804b7aa:	1b36      	subs	r6, r6, r4
 804b7ac:	f206 56f4 	addw	r6, r6, #1524	; 0x5f4
        bufferoffset = 0;
 804b7b0:	2400      	movs	r4, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 804b7b2:	18a5      	adds	r5, r4, r2
 804b7b4:	f240 53f4 	movw	r3, #1524	; 0x5f4
 804b7b8:	429d      	cmp	r5, r3
 804b7ba:	d8e7      	bhi.n	804b78c <low_level_input+0x50>
      memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
 804b7bc:	f8d9 0004 	ldr.w	r0, [r9, #4]
 804b7c0:	eb08 0104 	add.w	r1, r8, r4
 804b7c4:	4430      	add	r0, r6
 804b7c6:	f005 fcef 	bl	80511a8 <memcpy>
    for(q = p; q != NULL; q = q->next)
 804b7ca:	f8d9 9000 	ldr.w	r9, [r9]
      bufferoffset = bufferoffset + byteslefttocopy;
 804b7ce:	462c      	mov	r4, r5
    for(q = p; q != NULL; q = q->next)
 804b7d0:	f1b9 0f00 	cmp.w	r9, #0
 804b7d4:	d0c0      	beq.n	804b758 <low_level_input+0x1c>
      byteslefttocopy = q->len;
 804b7d6:	f8b9 200a 	ldrh.w	r2, [r9, #10]
      payloadoffset = 0;
 804b7da:	2600      	movs	r6, #0
      while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
 804b7dc:	e7e9      	b.n	804b7b2 <low_level_input+0x76>
    }

    /* Clear Segment_Count */
    heth.RxFrameInfos.SegCount =0;
 804b7de:	4b0c      	ldr	r3, [pc, #48]	; (804b810 <low_level_input+0xd4>)
 804b7e0:	2200      	movs	r2, #0
 804b7e2:	639a      	str	r2, [r3, #56]	; 0x38

  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
 804b7e4:	681b      	ldr	r3, [r3, #0]
 804b7e6:	f241 0214 	movw	r2, #4116	; 0x1014
 804b7ea:	589a      	ldr	r2, [r3, r2]
 804b7ec:	f012 0f80 	tst.w	r2, #128	; 0x80
 804b7f0:	d007      	beq.n	804b802 <low_level_input+0xc6>
  {
    /* Clear RBUS ETHERNET DMA flag */
    heth.Instance->DMASR = ETH_DMASR_RBUS;
 804b7f2:	f241 0214 	movw	r2, #4116	; 0x1014
 804b7f6:	2180      	movs	r1, #128	; 0x80
 804b7f8:	5099      	str	r1, [r3, r2]
    /* Resume DMA reception */
    heth.Instance->DMARPDR = 0;
 804b7fa:	f241 0208 	movw	r2, #4104	; 0x1008
 804b7fe:	2100      	movs	r1, #0
 804b800:	5099      	str	r1, [r3, r2]
  }
  return p;
}
 804b802:	4650      	mov	r0, sl
 804b804:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return NULL;
 804b808:	f04f 0a00 	mov.w	sl, #0
 804b80c:	e7f9      	b.n	804b802 <low_level_input+0xc6>
 804b80e:	bf00      	nop
 804b810:	2000a440 	.word	0x2000a440

0804b814 <low_level_output>:
{
 804b814:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804b818:	468b      	mov	fp, r1
  uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
 804b81a:	4b2c      	ldr	r3, [pc, #176]	; (804b8cc <low_level_output+0xb8>)
 804b81c:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 804b81e:	f8d6 a008 	ldr.w	sl, [r6, #8]
  bufferoffset = 0;
 804b822:	2400      	movs	r4, #0
  uint32_t framelength = 0;
 804b824:	4627      	mov	r7, r4
  for(q = p; q != NULL; q = q->next)
 804b826:	f1bb 0f00 	cmp.w	fp, #0
 804b82a:	d032      	beq.n	804b892 <low_level_output+0x7e>
      if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 804b82c:	6833      	ldr	r3, [r6, #0]
 804b82e:	2b00      	cmp	r3, #0
 804b830:	db35      	blt.n	804b89e <low_level_output+0x8a>
      byteslefttocopy = q->len;
 804b832:	f8bb 900a 	ldrh.w	r9, [fp, #10]
      payloadoffset = 0;
 804b836:	2500      	movs	r5, #0
      while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
 804b838:	eb04 0809 	add.w	r8, r4, r9
 804b83c:	f240 53f4 	movw	r3, #1524	; 0x5f4
 804b840:	4598      	cmp	r8, r3
 804b842:	d919      	bls.n	804b878 <low_level_output+0x64>
        memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
 804b844:	f8db 1004 	ldr.w	r1, [fp, #4]
 804b848:	f5c4 62be 	rsb	r2, r4, #1520	; 0x5f0
 804b84c:	3204      	adds	r2, #4
 804b84e:	4429      	add	r1, r5
 804b850:	eb0a 0004 	add.w	r0, sl, r4
 804b854:	f005 fca8 	bl	80511a8 <memcpy>
        DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
 804b858:	68f6      	ldr	r6, [r6, #12]
        if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
 804b85a:	6833      	ldr	r3, [r6, #0]
 804b85c:	2b00      	cmp	r3, #0
 804b85e:	db21      	blt.n	804b8a4 <low_level_output+0x90>
        buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
 804b860:	f8d6 a008 	ldr.w	sl, [r6, #8]
        byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
 804b864:	f2a8 59f4 	subw	r9, r8, #1524	; 0x5f4
        payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
 804b868:	1b2d      	subs	r5, r5, r4
 804b86a:	f205 55f4 	addw	r5, r5, #1524	; 0x5f4
        framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
 804b86e:	1b3f      	subs	r7, r7, r4
 804b870:	f207 57f4 	addw	r7, r7, #1524	; 0x5f4
        bufferoffset = 0;
 804b874:	2400      	movs	r4, #0
 804b876:	e7df      	b.n	804b838 <low_level_output+0x24>
      memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
 804b878:	f8db 1004 	ldr.w	r1, [fp, #4]
 804b87c:	464a      	mov	r2, r9
 804b87e:	4429      	add	r1, r5
 804b880:	eb0a 0004 	add.w	r0, sl, r4
 804b884:	f005 fc90 	bl	80511a8 <memcpy>
      framelength = framelength + byteslefttocopy;
 804b888:	444f      	add	r7, r9
  for(q = p; q != NULL; q = q->next)
 804b88a:	f8db b000 	ldr.w	fp, [fp]
      bufferoffset = bufferoffset + byteslefttocopy;
 804b88e:	4644      	mov	r4, r8
 804b890:	e7c9      	b.n	804b826 <low_level_output+0x12>
  HAL_ETH_TransmitFrame(&heth, framelength);
 804b892:	4639      	mov	r1, r7
 804b894:	480d      	ldr	r0, [pc, #52]	; (804b8cc <low_level_output+0xb8>)
 804b896:	f7f6 fc17 	bl	80420c8 <HAL_ETH_TransmitFrame>
  errval = ERR_OK;
 804b89a:	2000      	movs	r0, #0
 804b89c:	e004      	b.n	804b8a8 <low_level_output+0x94>
        errval = ERR_USE;
 804b89e:	f06f 0007 	mvn.w	r0, #7
 804b8a2:	e001      	b.n	804b8a8 <low_level_output+0x94>
          errval = ERR_USE;
 804b8a4:	f06f 0007 	mvn.w	r0, #7
  if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
 804b8a8:	4b08      	ldr	r3, [pc, #32]	; (804b8cc <low_level_output+0xb8>)
 804b8aa:	681b      	ldr	r3, [r3, #0]
 804b8ac:	f241 0214 	movw	r2, #4116	; 0x1014
 804b8b0:	589a      	ldr	r2, [r3, r2]
 804b8b2:	f012 0f20 	tst.w	r2, #32
 804b8b6:	d007      	beq.n	804b8c8 <low_level_output+0xb4>
    heth.Instance->DMASR = ETH_DMASR_TUS;
 804b8b8:	f241 0214 	movw	r2, #4116	; 0x1014
 804b8bc:	2120      	movs	r1, #32
 804b8be:	5099      	str	r1, [r3, r2]
    heth.Instance->DMATPDR = 0;
 804b8c0:	f241 0204 	movw	r2, #4100	; 0x1004
 804b8c4:	2100      	movs	r1, #0
 804b8c6:	5099      	str	r1, [r3, r2]
}
 804b8c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 804b8cc:	2000a440 	.word	0x2000a440

0804b8d0 <low_level_init>:
{
 804b8d0:	b530      	push	{r4, r5, lr}
 804b8d2:	b085      	sub	sp, #20
 804b8d4:	4604      	mov	r4, r0
  uint32_t regvalue = 0;
 804b8d6:	2300      	movs	r3, #0
 804b8d8:	9303      	str	r3, [sp, #12]
  heth.Instance = ETH;
 804b8da:	4833      	ldr	r0, [pc, #204]	; (804b9a8 <low_level_init+0xd8>)
 804b8dc:	4a33      	ldr	r2, [pc, #204]	; (804b9ac <low_level_init+0xdc>)
 804b8de:	6002      	str	r2, [r0, #0]
  heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 804b8e0:	2201      	movs	r2, #1
 804b8e2:	6042      	str	r2, [r0, #4]
  heth.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
 804b8e4:	8202      	strh	r2, [r0, #16]
  MACAddr[0] = 0x00;
 804b8e6:	f88d 3004 	strb.w	r3, [sp, #4]
  MACAddr[1] = 0x80;
 804b8ea:	2280      	movs	r2, #128	; 0x80
 804b8ec:	f88d 2005 	strb.w	r2, [sp, #5]
  MACAddr[2] = 0xE1;
 804b8f0:	22e1      	movs	r2, #225	; 0xe1
 804b8f2:	f88d 2006 	strb.w	r2, [sp, #6]
  MACAddr[3] = 0x00;
 804b8f6:	f88d 3007 	strb.w	r3, [sp, #7]
  MACAddr[4] = 0x00;
 804b8fa:	f88d 3008 	strb.w	r3, [sp, #8]
  MACAddr[5] = 0x00;
 804b8fe:	f88d 3009 	strb.w	r3, [sp, #9]
  heth.Init.MACAddr = &MACAddr[0];
 804b902:	aa01      	add	r2, sp, #4
 804b904:	6142      	str	r2, [r0, #20]
  heth.Init.RxMode = ETH_RXPOLLING_MODE;
 804b906:	6183      	str	r3, [r0, #24]
  heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 804b908:	61c3      	str	r3, [r0, #28]
  heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 804b90a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 804b90e:	6203      	str	r3, [r0, #32]
  hal_eth_init_status = HAL_ETH_Init(&heth);
 804b910:	f7f6 fd28 	bl	8042364 <HAL_ETH_Init>
  if (hal_eth_init_status == HAL_OK)
 804b914:	b928      	cbnz	r0, 804b922 <low_level_init+0x52>
    netif->flags |= NETIF_FLAG_LINK_UP;
 804b916:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804b91a:	f043 0304 	orr.w	r3, r3, #4
 804b91e:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 804b922:	4d21      	ldr	r5, [pc, #132]	; (804b9a8 <low_level_init+0xd8>)
 804b924:	2304      	movs	r3, #4
 804b926:	4a22      	ldr	r2, [pc, #136]	; (804b9b0 <low_level_init+0xe0>)
 804b928:	4922      	ldr	r1, [pc, #136]	; (804b9b4 <low_level_init+0xe4>)
 804b92a:	4628      	mov	r0, r5
 804b92c:	f7f6 fb5a 	bl	8041fe4 <HAL_ETH_DMATxDescListInit>
  HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 804b930:	2304      	movs	r3, #4
 804b932:	4a21      	ldr	r2, [pc, #132]	; (804b9b8 <low_level_init+0xe8>)
 804b934:	4921      	ldr	r1, [pc, #132]	; (804b9bc <low_level_init+0xec>)
 804b936:	4628      	mov	r0, r5
 804b938:	f7f6 fb8e 	bl	8042058 <HAL_ETH_DMARxDescListInit>
  netif->hwaddr_len = ETH_HWADDR_LEN;
 804b93c:	2306      	movs	r3, #6
 804b93e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  netif->hwaddr[0] =  heth.Init.MACAddr[0];
 804b942:	696b      	ldr	r3, [r5, #20]
 804b944:	781a      	ldrb	r2, [r3, #0]
 804b946:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
  netif->hwaddr[1] =  heth.Init.MACAddr[1];
 804b94a:	785a      	ldrb	r2, [r3, #1]
 804b94c:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
  netif->hwaddr[2] =  heth.Init.MACAddr[2];
 804b950:	789a      	ldrb	r2, [r3, #2]
 804b952:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
  netif->hwaddr[3] =  heth.Init.MACAddr[3];
 804b956:	78da      	ldrb	r2, [r3, #3]
 804b958:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
  netif->hwaddr[4] =  heth.Init.MACAddr[4];
 804b95c:	791a      	ldrb	r2, [r3, #4]
 804b95e:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
  netif->hwaddr[5] =  heth.Init.MACAddr[5];
 804b962:	795b      	ldrb	r3, [r3, #5]
 804b964:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
  netif->mtu = 1500;
 804b968:	f240 53dc 	movw	r3, #1500	; 0x5dc
 804b96c:	8463      	strh	r3, [r4, #34]	; 0x22
    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
 804b96e:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
 804b972:	f043 030a 	orr.w	r3, r3, #10
 804b976:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
  HAL_ETH_Start(&heth);
 804b97a:	4628      	mov	r0, r5
 804b97c:	f7f6 fe1e 	bl	80425bc <HAL_ETH_Start>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR, &regvalue);
 804b980:	aa03      	add	r2, sp, #12
 804b982:	211d      	movs	r1, #29
 804b984:	4628      	mov	r0, r5
 804b986:	f7f6 fc76 	bl	8042276 <HAL_ETH_ReadPHYRegister>
  regvalue |= (PHY_ISFR_INT4);
 804b98a:	9a03      	ldr	r2, [sp, #12]
 804b98c:	f042 020b 	orr.w	r2, r2, #11
 804b990:	9203      	str	r2, [sp, #12]
  HAL_ETH_WritePHYRegister(&heth, PHY_ISFR , regvalue );
 804b992:	211d      	movs	r1, #29
 804b994:	4628      	mov	r0, r5
 804b996:	f7f6 fcaa 	bl	80422ee <HAL_ETH_WritePHYRegister>
  HAL_ETH_ReadPHYRegister(&heth, PHY_ISFR , &regvalue);
 804b99a:	aa03      	add	r2, sp, #12
 804b99c:	211d      	movs	r1, #29
 804b99e:	4628      	mov	r0, r5
 804b9a0:	f7f6 fc69 	bl	8042276 <HAL_ETH_ReadPHYRegister>
}
 804b9a4:	b005      	add	sp, #20
 804b9a6:	bd30      	pop	{r4, r5, pc}
 804b9a8:	2000a440 	.word	0x2000a440
 804b9ac:	40028000 	.word	0x40028000
 804b9b0:	2000a488 	.word	0x2000a488
 804b9b4:	20008b70 	.word	0x20008b70
 804b9b8:	20008bf0 	.word	0x20008bf0
 804b9bc:	2000a3c0 	.word	0x2000a3c0

0804b9c0 <HAL_ETH_MspInit>:
{
 804b9c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 804b9c2:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804b9c4:	2300      	movs	r3, #0
 804b9c6:	9307      	str	r3, [sp, #28]
 804b9c8:	9308      	str	r3, [sp, #32]
 804b9ca:	9309      	str	r3, [sp, #36]	; 0x24
 804b9cc:	930a      	str	r3, [sp, #40]	; 0x28
 804b9ce:	930b      	str	r3, [sp, #44]	; 0x2c
  if(ethHandle->Instance==ETH)
 804b9d0:	6802      	ldr	r2, [r0, #0]
 804b9d2:	4b33      	ldr	r3, [pc, #204]	; (804baa0 <HAL_ETH_MspInit+0xe0>)
 804b9d4:	429a      	cmp	r2, r3
 804b9d6:	d001      	beq.n	804b9dc <HAL_ETH_MspInit+0x1c>
}
 804b9d8:	b00d      	add	sp, #52	; 0x34
 804b9da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_ETH_CLK_ENABLE();
 804b9dc:	2400      	movs	r4, #0
 804b9de:	9401      	str	r4, [sp, #4]
 804b9e0:	f5a3 4390 	sub.w	r3, r3, #18432	; 0x4800
 804b9e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b9e6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 804b9ea:	631a      	str	r2, [r3, #48]	; 0x30
 804b9ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b9ee:	f002 7200 	and.w	r2, r2, #33554432	; 0x2000000
 804b9f2:	9201      	str	r2, [sp, #4]
 804b9f4:	9a01      	ldr	r2, [sp, #4]
 804b9f6:	9402      	str	r4, [sp, #8]
 804b9f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804b9fa:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 804b9fe:	631a      	str	r2, [r3, #48]	; 0x30
 804ba00:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba02:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 804ba06:	9202      	str	r2, [sp, #8]
 804ba08:	9a02      	ldr	r2, [sp, #8]
 804ba0a:	9403      	str	r4, [sp, #12]
 804ba0c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba0e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 804ba12:	631a      	str	r2, [r3, #48]	; 0x30
 804ba14:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba16:	f002 6200 	and.w	r2, r2, #134217728	; 0x8000000
 804ba1a:	9203      	str	r2, [sp, #12]
 804ba1c:	9a03      	ldr	r2, [sp, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 804ba1e:	9404      	str	r4, [sp, #16]
 804ba20:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba22:	f042 0204 	orr.w	r2, r2, #4
 804ba26:	631a      	str	r2, [r3, #48]	; 0x30
 804ba28:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba2a:	f002 0204 	and.w	r2, r2, #4
 804ba2e:	9204      	str	r2, [sp, #16]
 804ba30:	9a04      	ldr	r2, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 804ba32:	9405      	str	r4, [sp, #20]
 804ba34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba36:	f042 0201 	orr.w	r2, r2, #1
 804ba3a:	631a      	str	r2, [r3, #48]	; 0x30
 804ba3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba3e:	f002 0201 	and.w	r2, r2, #1
 804ba42:	9205      	str	r2, [sp, #20]
 804ba44:	9a05      	ldr	r2, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 804ba46:	9406      	str	r4, [sp, #24]
 804ba48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ba4a:	f042 0202 	orr.w	r2, r2, #2
 804ba4e:	631a      	str	r2, [r3, #48]	; 0x30
 804ba50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804ba52:	f003 0302 	and.w	r3, r3, #2
 804ba56:	9306      	str	r3, [sp, #24]
 804ba58:	9b06      	ldr	r3, [sp, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 804ba5a:	2332      	movs	r3, #50	; 0x32
 804ba5c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804ba5e:	2702      	movs	r7, #2
 804ba60:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804ba62:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804ba64:	2603      	movs	r6, #3
 804ba66:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804ba68:	250b      	movs	r5, #11
 804ba6a:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 804ba6c:	a907      	add	r1, sp, #28
 804ba6e:	480d      	ldr	r0, [pc, #52]	; (804baa4 <HAL_ETH_MspInit+0xe4>)
 804ba70:	f7f7 f842 	bl	8042af8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 804ba74:	2386      	movs	r3, #134	; 0x86
 804ba76:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804ba78:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804ba7a:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804ba7c:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804ba7e:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 804ba80:	a907      	add	r1, sp, #28
 804ba82:	4809      	ldr	r0, [pc, #36]	; (804baa8 <HAL_ETH_MspInit+0xe8>)
 804ba84:	f7f7 f838 	bl	8042af8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
 804ba88:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 804ba8c:	9307      	str	r3, [sp, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 804ba8e:	9708      	str	r7, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 804ba90:	9409      	str	r4, [sp, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804ba92:	960a      	str	r6, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 804ba94:	950b      	str	r5, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 804ba96:	a907      	add	r1, sp, #28
 804ba98:	4804      	ldr	r0, [pc, #16]	; (804baac <HAL_ETH_MspInit+0xec>)
 804ba9a:	f7f7 f82d 	bl	8042af8 <HAL_GPIO_Init>
}
 804ba9e:	e79b      	b.n	804b9d8 <HAL_ETH_MspInit+0x18>
 804baa0:	40028000 	.word	0x40028000
 804baa4:	40020800 	.word	0x40020800
 804baa8:	40020000 	.word	0x40020000
 804baac:	40020400 	.word	0x40020400

0804bab0 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void ethernetif_input(struct netif *netif)
{
 804bab0:	b538      	push	{r3, r4, r5, lr}
 804bab2:	4604      	mov	r4, r0
  err_t err;
  struct pbuf *p;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
 804bab4:	f7ff fe42 	bl	804b73c <low_level_input>

  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
 804bab8:	b120      	cbz	r0, 804bac4 <ethernetif_input+0x14>
 804baba:	4605      	mov	r5, r0

  /* entry point to the LwIP stack */
  err = netif->input(p, netif);
 804babc:	6923      	ldr	r3, [r4, #16]
 804babe:	4621      	mov	r1, r4
 804bac0:	4798      	blx	r3

  if (err != ERR_OK)
 804bac2:	b900      	cbnz	r0, 804bac6 <ethernetif_input+0x16>
  {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    pbuf_free(p);
    p = NULL;
  }
}
 804bac4:	bd38      	pop	{r3, r4, r5, pc}
    pbuf_free(p);
 804bac6:	4628      	mov	r0, r5
 804bac8:	f7fa f8e6 	bl	8045c98 <pbuf_free>
    p = NULL;
 804bacc:	e7fa      	b.n	804bac4 <ethernetif_input+0x14>
	...

0804bad0 <ethernetif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ethernetif_init(struct netif *netif)
{
 804bad0:	b510      	push	{r4, lr}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 804bad2:	4604      	mov	r4, r0
 804bad4:	b170      	cbz	r0, 804baf4 <ethernetif_init+0x24>
#if LWIP_NETIF_HOSTNAME
  /* Initialize interface hostname */
  netif->hostname = "lwip";
#endif /* LWIP_NETIF_HOSTNAME */

  netif->name[0] = IFNAME0;
 804bad6:	2373      	movs	r3, #115	; 0x73
 804bad8:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  netif->name[1] = IFNAME1;
 804badc:	2374      	movs	r3, #116	; 0x74
 804bade:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
   * is available...) */

#if LWIP_IPV4
#if LWIP_ARP || LWIP_ETHERNET
#if LWIP_ARP
  netif->output = etharp_output;
 804bae2:	4b08      	ldr	r3, [pc, #32]	; (804bb04 <ethernetif_init+0x34>)
 804bae4:	6163      	str	r3, [r4, #20]

#if LWIP_IPV6
  netif->output_ip6 = ethip6_output;
#endif /* LWIP_IPV6 */

  netif->linkoutput = low_level_output;
 804bae6:	4b08      	ldr	r3, [pc, #32]	; (804bb08 <ethernetif_init+0x38>)
 804bae8:	61a3      	str	r3, [r4, #24]

  /* initialize the hardware */
  low_level_init(netif);
 804baea:	4620      	mov	r0, r4
 804baec:	f7ff fef0 	bl	804b8d0 <low_level_init>

  return ERR_OK;
}
 804baf0:	2000      	movs	r0, #0
 804baf2:	bd10      	pop	{r4, pc}
  LWIP_ASSERT("netif != NULL", (netif != NULL));
 804baf4:	4b05      	ldr	r3, [pc, #20]	; (804bb0c <ethernetif_init+0x3c>)
 804baf6:	f44f 7201 	mov.w	r2, #516	; 0x204
 804bafa:	4905      	ldr	r1, [pc, #20]	; (804bb10 <ethernetif_init+0x40>)
 804bafc:	4805      	ldr	r0, [pc, #20]	; (804bb14 <ethernetif_init+0x44>)
 804bafe:	f005 fb75 	bl	80511ec <printf>
 804bb02:	e7e8      	b.n	804bad6 <ethernetif_init+0x6>
 804bb04:	0804a559 	.word	0x0804a559
 804bb08:	0804b815 	.word	0x0804b815
 804bb0c:	08059f94 	.word	0x08059f94
 804bb10:	08059aec 	.word	0x08059aec
 804bb14:	08058644 	.word	0x08058644

0804bb18 <sys_now>:
*         when LWIP_TIMERS == 1 and NO_SYS == 1
* @param  None
* @retval Time
*/
u32_t sys_now(void)
{
 804bb18:	b508      	push	{r3, lr}
  return HAL_GetTick();
 804bb1a:	f7f5 fac1 	bl	80410a0 <HAL_GetTick>
}
 804bb1e:	bd08      	pop	{r3, pc}

0804bb20 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 804bb20:	b5f0      	push	{r4, r5, r6, r7, lr}
 804bb22:	b08d      	sub	sp, #52	; 0x34

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804bb24:	2400      	movs	r4, #0
 804bb26:	9407      	str	r4, [sp, #28]
 804bb28:	9408      	str	r4, [sp, #32]
 804bb2a:	9409      	str	r4, [sp, #36]	; 0x24
 804bb2c:	940a      	str	r4, [sp, #40]	; 0x28
 804bb2e:	940b      	str	r4, [sp, #44]	; 0x2c

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 804bb30:	9401      	str	r4, [sp, #4]
 804bb32:	4b30      	ldr	r3, [pc, #192]	; (804bbf4 <MX_GPIO_Init+0xd4>)
 804bb34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb36:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 804bb3a:	631a      	str	r2, [r3, #48]	; 0x30
 804bb3c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb3e:	f002 0280 	and.w	r2, r2, #128	; 0x80
 804bb42:	9201      	str	r2, [sp, #4]
 804bb44:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 804bb46:	9402      	str	r4, [sp, #8]
 804bb48:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb4a:	f042 0204 	orr.w	r2, r2, #4
 804bb4e:	631a      	str	r2, [r3, #48]	; 0x30
 804bb50:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb52:	f002 0204 	and.w	r2, r2, #4
 804bb56:	9202      	str	r2, [sp, #8]
 804bb58:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 804bb5a:	9403      	str	r4, [sp, #12]
 804bb5c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb5e:	f042 0201 	orr.w	r2, r2, #1
 804bb62:	631a      	str	r2, [r3, #48]	; 0x30
 804bb64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb66:	f002 0201 	and.w	r2, r2, #1
 804bb6a:	9203      	str	r2, [sp, #12]
 804bb6c:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 804bb6e:	9404      	str	r4, [sp, #16]
 804bb70:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb72:	f042 0210 	orr.w	r2, r2, #16
 804bb76:	631a      	str	r2, [r3, #48]	; 0x30
 804bb78:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb7a:	f002 0210 	and.w	r2, r2, #16
 804bb7e:	9204      	str	r2, [sp, #16]
 804bb80:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 804bb82:	9405      	str	r4, [sp, #20]
 804bb84:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb86:	f042 0202 	orr.w	r2, r2, #2
 804bb8a:	631a      	str	r2, [r3, #48]	; 0x30
 804bb8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb8e:	f002 0202 	and.w	r2, r2, #2
 804bb92:	9205      	str	r2, [sp, #20]
 804bb94:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 804bb96:	9406      	str	r4, [sp, #24]
 804bb98:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804bb9a:	f042 0208 	orr.w	r2, r2, #8
 804bb9e:	631a      	str	r2, [r3, #48]	; 0x30
 804bba0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804bba2:	f003 0308 	and.w	r3, r3, #8
 804bba6:	9306      	str	r3, [sp, #24]
 804bba8:	9b06      	ldr	r3, [sp, #24]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, MB_DE_Pin|MB_RE_Pin, GPIO_PIN_RESET);
 804bbaa:	4f13      	ldr	r7, [pc, #76]	; (804bbf8 <MX_GPIO_Init+0xd8>)
 804bbac:	4622      	mov	r2, r4
 804bbae:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
 804bbb2:	4638      	mov	r0, r7
 804bbb4:	f7f7 f892 	bl	8042cdc <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LED_1_Pin|HEARTBEAT_Pin|LED_3_Pin|LED_2_Pin
 804bbb8:	4d10      	ldr	r5, [pc, #64]	; (804bbfc <MX_GPIO_Init+0xdc>)
 804bbba:	4622      	mov	r2, r4
 804bbbc:	f44f 611e 	mov.w	r1, #2528	; 0x9e0
 804bbc0:	4628      	mov	r0, r5
 804bbc2:	f7f7 f88b 	bl	8042cdc <HAL_GPIO_WritePin>
                          |GSM_PWR_KEY_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : PEPin PEPin */
  GPIO_InitStruct.Pin = MB_DE_Pin|MB_RE_Pin;
 804bbc6:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 804bbca:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 804bbcc:	2601      	movs	r6, #1
 804bbce:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bbd0:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 804bbd2:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 804bbd4:	a907      	add	r1, sp, #28
 804bbd6:	4638      	mov	r0, r7
 804bbd8:	f7f6 ff8e 	bl	8042af8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PDPin PDPin PDPin PDPin
                           PDPin */
  GPIO_InitStruct.Pin = LED_1_Pin|HEARTBEAT_Pin|LED_3_Pin|LED_2_Pin
 804bbdc:	f44f 631e 	mov.w	r3, #2528	; 0x9e0
 804bbe0:	9307      	str	r3, [sp, #28]
                          |GSM_PWR_KEY_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 804bbe2:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 804bbe4:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 804bbe6:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 804bbe8:	a907      	add	r1, sp, #28
 804bbea:	4628      	mov	r0, r5
 804bbec:	f7f6 ff84 	bl	8042af8 <HAL_GPIO_Init>

}
 804bbf0:	b00d      	add	sp, #52	; 0x34
 804bbf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804bbf4:	40023800 	.word	0x40023800
 804bbf8:	40021000 	.word	0x40021000
 804bbfc:	40020c00 	.word	0x40020c00

0804bc00 <initGSMSIM868>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void initGSMSIM868(void)
{
 804bc00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* Init Buffers */

	memset(gsmInstance.agpsLocationData, GSM_ARRAY_INIT_CHAR, (GPS_LOCATION_ARRAY_SIZE * sizeof(char)));
 804bc04:	4c6a      	ldr	r4, [pc, #424]	; (804bdb0 <initGSMSIM868+0x1b0>)
 804bc06:	2296      	movs	r2, #150	; 0x96
 804bc08:	2100      	movs	r1, #0
 804bc0a:	4620      	mov	r0, r4
 804bc0c:	f005 fada 	bl	80511c4 <memset>
	memset(gsmInstance.agsmNetworkIP, GSM_ARRAY_INIT_CHAR, (GPRS_NETWORKIP_ARRAY_SIZE * sizeof(char)));
 804bc10:	2223      	movs	r2, #35	; 0x23
 804bc12:	2100      	movs	r1, #0
 804bc14:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 804bc18:	f005 fad4 	bl	80511c4 <memset>
	memset(gsmInstance.agsmSignalStrength, GSM_ARRAY_INIT_CHAR, (GSM_SIGSTRGTH_ARRAY_SIZE * sizeof(char)));
 804bc1c:	2500      	movs	r5, #0
 804bc1e:	f8c4 5096 	str.w	r5, [r4, #150]	; 0x96
 804bc22:	f8c4 509a 	str.w	r5, [r4, #154]	; 0x9a
 804bc26:	f8a4 509e 	strh.w	r5, [r4, #158]	; 0x9e
	memset((char *)gsmInstance.as8GSM_Response_Buff,GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(char)));
 804bc2a:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804bc2e:	4629      	mov	r1, r5
 804bc30:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804bc34:	f005 fac6 	bl	80511c4 <memset>
	memset(gsmInstance.agsmCommandResponse, DATA_UNKNOWN, sizeof(gsmInstance.agsmCommandResponse[0][0])
 804bc38:	f44f 7261 	mov.w	r2, #900	; 0x384
 804bc3c:	213f      	movs	r1, #63	; 0x3f
 804bc3e:	f104 00c3 	add.w	r0, r4, #195	; 0xc3
 804bc42:	f005 fabf 	bl	80511c4 <memset>
		   * GSM_TOTAL_COMMANDS * GSM_TOTAL_COMMANDS);
//	memset(gsmInstance.agsmHTTPRequestStatus,DATA_UNKNOWN,GSM_HTTP_RESPONSE_CODE_SIZE * sizeof(char));
	memset(gsmInstance.agsmMQTTRequestStatus,DATA_UNKNOWN,GSM_MQTT_RESPONSE_CODE_SIZE * sizeof(char));
 804bc46:	f04f 333f 	mov.w	r3, #1061109567	; 0x3f3f3f3f
 804bc4a:	f8c4 3447 	str.w	r3, [r4, #1095]	; 0x447
 804bc4e:	f8c4 344b 	str.w	r3, [r4, #1099]	; 0x44b
	memset(gsmInstance.strSystemSMS.agsmSMSRecipient,DATA_UNKNOWN,SMS_MOB_NO_LENGTH * sizeof(char));
 804bc52:	f8c4 3e45 	str.w	r3, [r4, #3653]	; 0xe45
 804bc56:	f8c4 3e49 	str.w	r3, [r4, #3657]	; 0xe49
 804bc5a:	f8c4 3e4d 	str.w	r3, [r4, #3661]	; 0xe4d
 804bc5e:	f884 3e51 	strb.w	r3, [r4, #3665]	; 0xe51
	memset(gsmInstance.strSystemSMS.agsmSMSMessageBody,0x00,SMS_MAX_MSG_LENGTH * sizeof(char));
 804bc62:	f44f 7248 	mov.w	r2, #800	; 0x320
 804bc66:	4629      	mov	r1, r5
 804bc68:	f604 6052 	addw	r0, r4, #3666	; 0xe52
 804bc6c:	f005 faaa 	bl	80511c4 <memset>
//	memset(gsmInstance.u32GSMHttpResponseCode,0x00,sizeof(char) * 3);
	memset(gsmInstance.u32GSMMQTTResponseCode,0x00,sizeof(char) * 3);
 804bc70:	f8a4 544f 	strh.w	r5, [r4, #1103]	; 0x44f
 804bc74:	f884 5451 	strb.w	r5, [r4, #1105]	; 0x451
	memset(gau8GSM_ATAPN, 0x00, (180 * sizeof(char)));
 804bc78:	4e4e      	ldr	r6, [pc, #312]	; (804bdb4 <initGSMSIM868+0x1b4>)
 804bc7a:	f04f 09b4 	mov.w	r9, #180	; 0xb4
 804bc7e:	464a      	mov	r2, r9
 804bc80:	4629      	mov	r1, r5
 804bc82:	4630      	mov	r0, r6
 804bc84:	f005 fa9e 	bl	80511c4 <memset>
	memset(gau8GSM_ATURL, 0x00, (180 * sizeof(char)));
 804bc88:	eb06 0809 	add.w	r8, r6, r9
 804bc8c:	464a      	mov	r2, r9
 804bc8e:	4629      	mov	r1, r5
 804bc90:	4640      	mov	r0, r8
 804bc92:	f005 fa97 	bl	80511c4 <memset>
	memset(gau8GSM_SMSRecepient, 0x00, ( 180 * sizeof(char)));
 804bc96:	f506 77b4 	add.w	r7, r6, #360	; 0x168
 804bc9a:	464a      	mov	r2, r9
 804bc9c:	4629      	mov	r1, r5
 804bc9e:	4638      	mov	r0, r7
 804bca0:	f005 fa90 	bl	80511c4 <memset>

	strcat((char *)gau8GSM_SMSRecepient,(char *)gau8GSM_ATCMGS);
 804bca4:	f506 7107 	add.w	r1, r6, #540	; 0x21c
 804bca8:	4638      	mov	r0, r7
 804bcaa:	f005 fae1 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_SMSRecepient,(char *)"\"");
 804bcae:	4638      	mov	r0, r7
 804bcb0:	f7f4 fa9e 	bl	80401f0 <strlen>
 804bcb4:	4b40      	ldr	r3, [pc, #256]	; (804bdb8 <initGSMSIM868+0x1b8>)
 804bcb6:	f8b3 9000 	ldrh.w	r9, [r3]
 804bcba:	f827 9000 	strh.w	r9, [r7, r0]
	strcat((char *)gau8GSM_SMSRecepient,(char *)gau8GSM_smsto);
 804bcbe:	f506 710e 	add.w	r1, r6, #568	; 0x238
 804bcc2:	4638      	mov	r0, r7
 804bcc4:	f005 fad4 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_SMSRecepient,(char *)"\"");
 804bcc8:	4638      	mov	r0, r7
 804bcca:	f7f4 fa91 	bl	80401f0 <strlen>
 804bcce:	f827 9000 	strh.w	r9, [r7, r0]
	//strcat((char *)gau8GSM_ATAPN,(char *)gau8GSM_ATSAPRBAPN);
	strcat((char *)gau8GSM_ATAPN,(char *)"\"");
 804bcd2:	4630      	mov	r0, r6
 804bcd4:	f7f4 fa8c 	bl	80401f0 <strlen>
 804bcd8:	f826 9000 	strh.w	r9, [r6, r0]
	strcat((char *)gau8GSM_ATAPN,(char *)gau8GSM_apn);
 804bcdc:	f506 7112 	add.w	r1, r6, #584	; 0x248
 804bce0:	4630      	mov	r0, r6
 804bce2:	f005 fac5 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATAPN,(char *)"\"");
 804bce6:	4630      	mov	r0, r6
 804bce8:	f7f4 fa82 	bl	80401f0 <strlen>
 804bcec:	f826 9000 	strh.w	r9, [r6, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_ATCMQTTCONNECT);
 804bcf0:	f506 712b 	add.w	r1, r6, #684	; 0x2ac
 804bcf4:	4640      	mov	r0, r8
 804bcf6:	f005 fabb 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804bcfa:	4640      	mov	r0, r8
 804bcfc:	f7f4 fa78 	bl	80401f0 <strlen>
 804bd00:	f828 9000 	strh.w	r9, [r8, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_url);
 804bd04:	f506 713b 	add.w	r1, r6, #748	; 0x2ec
 804bd08:	4640      	mov	r0, r8
 804bd0a:	f005 fab1 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804bd0e:	4640      	mov	r0, r8
 804bd10:	f7f4 fa6e 	bl	80401f0 <strlen>
 804bd14:	f828 9000 	strh.w	r9, [r8, r0]
	strcat(gau8GSM_ATAPN,"\r\n");
 804bd18:	4630      	mov	r0, r6
 804bd1a:	f7f4 fa69 	bl	80401f0 <strlen>
 804bd1e:	1832      	adds	r2, r6, r0
 804bd20:	4b26      	ldr	r3, [pc, #152]	; (804bdbc <initGSMSIM868+0x1bc>)
 804bd22:	f8b3 a000 	ldrh.w	sl, [r3]
 804bd26:	f893 9002 	ldrb.w	r9, [r3, #2]
 804bd2a:	f826 a000 	strh.w	sl, [r6, r0]
 804bd2e:	f882 9002 	strb.w	r9, [r2, #2]
	strcat(gau8GSM_ATURL,"\r\n");
 804bd32:	4640      	mov	r0, r8
 804bd34:	f7f4 fa5c 	bl	80401f0 <strlen>
 804bd38:	eb08 0300 	add.w	r3, r8, r0
 804bd3c:	f828 a000 	strh.w	sl, [r8, r0]
 804bd40:	f883 9002 	strb.w	r9, [r3, #2]
	strcat(gau8GSM_SMSRecepient,"\r\n");
 804bd44:	4638      	mov	r0, r7
 804bd46:	f7f4 fa53 	bl	80401f0 <strlen>
 804bd4a:	183b      	adds	r3, r7, r0
 804bd4c:	f827 a000 	strh.w	sl, [r7, r0]
 804bd50:	f883 9002 	strb.w	r9, [r3, #2]

	gsmInstance.strSystemSMS.u8NewMessage = FALSE;
 804bd54:	f241 1372 	movw	r3, #4466	; 0x1172
 804bd58:	54e5      	strb	r5, [r4, r3]
	gsmInstance.enmcurrentTask = enmGSMTASK_RESET;
 804bd5a:	f884 5e42 	strb.w	r5, [r4, #3650]	; 0xe42
	gsmInstance.enmGSMPwrState = enmGSM_PWRNOTSTARTED;
 804bd5e:	f884 5e44 	strb.w	r5, [r4, #3652]	; 0xe44
	gsmInstance.u8isConnected = FALSE;
 804bd62:	f884 5e19 	strb.w	r5, [r4, #3609]	; 0xe19
	gsmInstance.u8GSM_Response_Character_Counter = 0;
 804bd66:	f8c4 5e3c 	str.w	r5, [r4, #3644]	; 0xe3c
	gsmInstance.u8gsmRegistrationStatus = FALSE;
 804bd6a:	f884 5e17 	strb.w	r5, [r4, #3607]	; 0xe17
	gsmInstance.u8gsmSIMReadyStatus = FALSE;
 804bd6e:	f884 5e16 	strb.w	r5, [r4, #3606]	; 0xe16
	gsmInstance.u8gsmRetryCount = GSM_MAX_RETRY;
 804bd72:	2305      	movs	r3, #5
 804bd74:	f884 3e18 	strb.w	r3, [r4, #3608]	; 0xe18
	gsmInstance.u8AttemptFota = FALSE;
 804bd78:	f884 5e1b 	strb.w	r5, [r4, #3611]	; 0xe1b
	gsmInstance.u32GSMTimer = ONE_SEC;
 804bd7c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804bd80:	f8c4 3e24 	str.w	r3, [r4, #3620]	; 0xe24
	gu32GSMHangTimer = THREE_MIN;
 804bd84:	4b0e      	ldr	r3, [pc, #56]	; (804bdc0 <initGSMSIM868+0x1c0>)
 804bd86:	4a0f      	ldr	r2, [pc, #60]	; (804bdc4 <initGSMSIM868+0x1c4>)
 804bd88:	601a      	str	r2, [r3, #0]
	gsmInstance.u32GSMHeartbeatTimer = 0;
 804bd8a:	f8c4 5e30 	str.w	r5, [r4, #3632]	; 0xe30
	gsmInstance.u8IllegalMqttResponseCounter = 0;
 804bd8e:	f884 5e1e 	strb.w	r5, [r4, #3614]	; 0xe1e
	gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804bd92:	f884 5e40 	strb.w	r5, [r4, #3648]	; 0xe40
	gsmInstance.enmGSMCommand = enmGSMSTATE_ATE0;
 804bd96:	2301      	movs	r3, #1
 804bd98:	f884 3e43 	strb.w	r3, [r4, #3651]	; 0xe43
	gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804bd9c:	f884 3e41 	strb.w	r3, [r4, #3649]	; 0xe41
	gu8FlagNoTerminate = 1;
 804bda0:	f886 3382 	strb.w	r3, [r6, #898]	; 0x382

	gu32ModuleInitComplete = 0;
 804bda4:	4b08      	ldr	r3, [pc, #32]	; (804bdc8 <initGSMSIM868+0x1c8>)
 804bda6:	601d      	str	r5, [r3, #0]
	gu32FotaRquestFlag = FALSE;
 804bda8:	605d      	str	r5, [r3, #4]
}
 804bdaa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 804bdae:	bf00      	nop
 804bdb0:	2000c61c 	.word	0x2000c61c
 804bdb4:	20000010 	.word	0x20000010
 804bdb8:	08059fa8 	.word	0x08059fa8
 804bdbc:	08059fd0 	.word	0x08059fd0
 804bdc0:	200053d8 	.word	0x200053d8
 804bdc4:	0002bf20 	.word	0x0002bf20
 804bdc8:	2000440c 	.word	0x2000440c

0804bdcc <updateMqttDataLength>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateMqttDataLength()
{
 804bdcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 804bdd0:	b085      	sub	sp, #20
 804bdd2:	af00      	add	r7, sp, #0
	char * tempdata = "";
	tempdata = gsmPayload.data[gsmPayload.tail];
 804bdd4:	4a86      	ldr	r2, [pc, #536]	; (804bff0 <updateMqttDataLength+0x224>)
 804bdd6:	6853      	ldr	r3, [r2, #4]
 804bdd8:	3302      	adds	r3, #2
 804bdda:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
	char topiclen[10];
	uint8_t topiclen8 = 0;

	uint32_t payloadLength = strlen(tempdata);
 804bdde:	4630      	mov	r0, r6
 804bde0:	f7f4 fa06 	bl	80401f0 <strlen>
 804bde4:	4605      	mov	r5, r0
	char buffer[payloadLength];
 804bde6:	1dc3      	adds	r3, r0, #7
 804bde8:	f023 0307 	bic.w	r3, r3, #7
 804bdec:	ebad 0d03 	sub.w	sp, sp, r3
	memset(buffer, 0x00, (payloadLength * sizeof(char))); /* Clear Response Buffer */
 804bdf0:	4602      	mov	r2, r0
 804bdf2:	2100      	movs	r1, #0
 804bdf4:	4668      	mov	r0, sp
 804bdf6:	f005 f9e5 	bl	80511c4 <memset>

	/* Convert Integer to ASCII ( Decimal) */
	memset(gau8GSM_ATPAYLOADLENGTH, 0x00, ( 30 * sizeof(char)));
 804bdfa:	4c7e      	ldr	r4, [pc, #504]	; (804bff4 <updateMqttDataLength+0x228>)
 804bdfc:	221e      	movs	r2, #30
 804bdfe:	2100      	movs	r1, #0
 804be00:	4620      	mov	r0, r4
 804be02:	f005 f9df 	bl	80511c4 <memset>

	itoa(payloadLength,buffer,PAYLOAD_DATA_STRING_RADIX);
 804be06:	220a      	movs	r2, #10
 804be08:	4669      	mov	r1, sp
 804be0a:	4628      	mov	r0, r5
 804be0c:	f004 ff6a 	bl	8050ce4 <itoa>

	strcat((char *)gau8GSM_ATPAYLOADLENGTH,(char *)gau8GSM_ATCMQTTPAYLOAD);
 804be10:	4979      	ldr	r1, [pc, #484]	; (804bff8 <updateMqttDataLength+0x22c>)
 804be12:	4620      	mov	r0, r4
 804be14:	f005 fa2c 	bl	8051270 <strcat>

	strcat((char *)gau8GSM_ATPAYLOADLENGTH,buffer);
 804be18:	4669      	mov	r1, sp
 804be1a:	4620      	mov	r0, r4
 804be1c:	f005 fa28 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATPAYLOADLENGTH,"\r\n");
 804be20:	4620      	mov	r0, r4
 804be22:	f7f4 f9e5 	bl	80401f0 <strlen>
 804be26:	1822      	adds	r2, r4, r0
 804be28:	4b74      	ldr	r3, [pc, #464]	; (804bffc <updateMqttDataLength+0x230>)
 804be2a:	8819      	ldrh	r1, [r3, #0]
 804be2c:	789b      	ldrb	r3, [r3, #2]
 804be2e:	5221      	strh	r1, [r4, r0]
 804be30:	7093      	strb	r3, [r2, #2]


	if(strstr((char *)tempdata, (char *)",9,#"))
 804be32:	4973      	ldr	r1, [pc, #460]	; (804c000 <updateMqttDataLength+0x234>)
 804be34:	4630      	mov	r0, r6
 804be36:	f005 fa64 	bl	8051302 <strstr>
 804be3a:	2800      	cmp	r0, #0
 804be3c:	d047      	beq.n	804bece <updateMqttDataLength+0x102>
	{
		memset(topiclen, 0, sizeof(topiclen));
 804be3e:	f04f 0800 	mov.w	r8, #0
 804be42:	f8c7 8004 	str.w	r8, [r7, #4]
 804be46:	f8c7 8008 	str.w	r8, [r7, #8]
 804be4a:	f8a7 800c 	strh.w	r8, [r7, #12]
		memset(gau8GSM_ATCMQTTTOPIC, 0, sizeof(gau8GSM_ATCMQTTTOPIC) * sizeof(char));
 804be4e:	3c08      	subs	r4, #8
 804be50:	f104 0530 	add.w	r5, r4, #48	; 0x30
 804be54:	f04f 0b32 	mov.w	fp, #50	; 0x32
 804be58:	465a      	mov	r2, fp
 804be5a:	4641      	mov	r1, r8
 804be5c:	4628      	mov	r0, r5
 804be5e:	f005 f9b1 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPIC, gau8GSM_ATCMQTTCMDTOPIC);
 804be62:	4e68      	ldr	r6, [pc, #416]	; (804c004 <updateMqttDataLength+0x238>)
 804be64:	f506 7166 	add.w	r1, r6, #920	; 0x398
 804be68:	4628      	mov	r0, r5
 804be6a:	f005 fa1d 	bl	80512a8 <strcpy>
		topiclen8 = strlen(gau8MQTT_PubTopicBuffer);
 804be6e:	f506 7673 	add.w	r6, r6, #972	; 0x3cc
 804be72:	4630      	mov	r0, r6
 804be74:	f7f4 f9bc 	bl	80401f0 <strlen>
		itoa(topiclen8, topiclen, 10);
 804be78:	220a      	movs	r2, #10
 804be7a:	1d39      	adds	r1, r7, #4
 804be7c:	f004 ff32 	bl	8050ce4 <itoa>
		strcat(gau8GSM_ATCMQTTTOPIC, topiclen);
 804be80:	1d39      	adds	r1, r7, #4
 804be82:	4628      	mov	r0, r5
 804be84:	f005 f9f4 	bl	8051270 <strcat>
		strcat(gau8GSM_ATCMQTTTOPIC, "\r\n");
 804be88:	4628      	mov	r0, r5
 804be8a:	f7f4 f9b1 	bl	80401f0 <strlen>
 804be8e:	182a      	adds	r2, r5, r0
 804be90:	4b5a      	ldr	r3, [pc, #360]	; (804bffc <updateMqttDataLength+0x230>)
 804be92:	f8b3 a000 	ldrh.w	sl, [r3]
 804be96:	f893 9002 	ldrb.w	r9, [r3, #2]
 804be9a:	f825 a000 	strh.w	sl, [r5, r0]
 804be9e:	f882 9002 	strb.w	r9, [r2, #2]
		memset(gau8GSM_ATCMQTTTOPICNAME, 0, sizeof(gau8GSM_ATCMQTTTOPICNAME));
 804bea2:	3464      	adds	r4, #100	; 0x64
 804bea4:	465a      	mov	r2, fp
 804bea6:	4641      	mov	r1, r8
 804bea8:	4620      	mov	r0, r4
 804beaa:	f005 f98b 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPICNAME, gau8MQTT_PubTopicBuffer);
 804beae:	4631      	mov	r1, r6
 804beb0:	4620      	mov	r0, r4
 804beb2:	f005 f9f9 	bl	80512a8 <strcpy>
		strcat(gau8GSM_ATCMQTTTOPICNAME, "\r\n");
 804beb6:	4620      	mov	r0, r4
 804beb8:	f7f4 f99a 	bl	80401f0 <strlen>
 804bebc:	1823      	adds	r3, r4, r0
 804bebe:	f824 a000 	strh.w	sl, [r4, r0]
 804bec2:	f883 9002 	strb.w	r9, [r3, #2]
		strcat(gau8GSM_ATCMQTTTOPIC, "\r\n");
		memset(gau8GSM_ATCMQTTTOPICNAME, 0, sizeof(gau8GSM_ATCMQTTTOPICNAME));
		strcpy(gau8GSM_ATCMQTTTOPICNAME, gau8MQTT_PubTopicPayload);
		strcat(gau8GSM_ATCMQTTTOPICNAME, "\r\n");
	}
}
 804bec6:	3714      	adds	r7, #20
 804bec8:	46bd      	mov	sp, r7
 804beca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	else if(strstr((char *)tempdata, (char *)"Diagnostic"))
 804bece:	494e      	ldr	r1, [pc, #312]	; (804c008 <updateMqttDataLength+0x23c>)
 804bed0:	4630      	mov	r0, r6
 804bed2:	f005 fa16 	bl	8051302 <strstr>
 804bed6:	2800      	cmp	r0, #0
 804bed8:	d044      	beq.n	804bf64 <updateMqttDataLength+0x198>
		memset(topiclen, 0, sizeof(topiclen));
 804beda:	f04f 0800 	mov.w	r8, #0
 804bede:	f8c7 8004 	str.w	r8, [r7, #4]
 804bee2:	f8c7 8008 	str.w	r8, [r7, #8]
 804bee6:	f8a7 800c 	strh.w	r8, [r7, #12]
		memset(gau8GSM_ATCMQTTTOPIC, 0, sizeof(gau8GSM_ATCMQTTTOPIC) * sizeof(char));
 804beea:	4c48      	ldr	r4, [pc, #288]	; (804c00c <updateMqttDataLength+0x240>)
 804beec:	f104 0530 	add.w	r5, r4, #48	; 0x30
 804bef0:	f04f 0b32 	mov.w	fp, #50	; 0x32
 804bef4:	465a      	mov	r2, fp
 804bef6:	4641      	mov	r1, r8
 804bef8:	4628      	mov	r0, r5
 804befa:	f005 f963 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPIC, gau8GSM_ATCMQTTCMDTOPIC);
 804befe:	4e41      	ldr	r6, [pc, #260]	; (804c004 <updateMqttDataLength+0x238>)
 804bf00:	f506 7166 	add.w	r1, r6, #920	; 0x398
 804bf04:	4628      	mov	r0, r5
 804bf06:	f005 f9cf 	bl	80512a8 <strcpy>
		topiclen8 = strlen(gau8MQTT_PubTopicDiagnostic);
 804bf0a:	f506 7678 	add.w	r6, r6, #992	; 0x3e0
 804bf0e:	4630      	mov	r0, r6
 804bf10:	f7f4 f96e 	bl	80401f0 <strlen>
		itoa(topiclen8, topiclen, 10);
 804bf14:	220a      	movs	r2, #10
 804bf16:	1d39      	adds	r1, r7, #4
 804bf18:	f004 fee4 	bl	8050ce4 <itoa>
		strcat(gau8GSM_ATCMQTTTOPIC, topiclen);
 804bf1c:	1d39      	adds	r1, r7, #4
 804bf1e:	4628      	mov	r0, r5
 804bf20:	f005 f9a6 	bl	8051270 <strcat>
		strcat(gau8GSM_ATCMQTTTOPIC, "\r\n");
 804bf24:	4628      	mov	r0, r5
 804bf26:	f7f4 f963 	bl	80401f0 <strlen>
 804bf2a:	182a      	adds	r2, r5, r0
 804bf2c:	4b33      	ldr	r3, [pc, #204]	; (804bffc <updateMqttDataLength+0x230>)
 804bf2e:	f8b3 a000 	ldrh.w	sl, [r3]
 804bf32:	f893 9002 	ldrb.w	r9, [r3, #2]
 804bf36:	f825 a000 	strh.w	sl, [r5, r0]
 804bf3a:	f882 9002 	strb.w	r9, [r2, #2]
		memset(gau8GSM_ATCMQTTTOPICNAME, 0, sizeof(gau8GSM_ATCMQTTTOPICNAME));
 804bf3e:	3464      	adds	r4, #100	; 0x64
 804bf40:	465a      	mov	r2, fp
 804bf42:	4641      	mov	r1, r8
 804bf44:	4620      	mov	r0, r4
 804bf46:	f005 f93d 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPICNAME, gau8MQTT_PubTopicDiagnostic);
 804bf4a:	4631      	mov	r1, r6
 804bf4c:	4620      	mov	r0, r4
 804bf4e:	f005 f9ab 	bl	80512a8 <strcpy>
		strcat(gau8GSM_ATCMQTTTOPICNAME, "\r\n");
 804bf52:	4620      	mov	r0, r4
 804bf54:	f7f4 f94c 	bl	80401f0 <strlen>
 804bf58:	1823      	adds	r3, r4, r0
 804bf5a:	f824 a000 	strh.w	sl, [r4, r0]
 804bf5e:	f883 9002 	strb.w	r9, [r3, #2]
 804bf62:	e7b0      	b.n	804bec6 <updateMqttDataLength+0xfa>
		memset(topiclen, 0, sizeof(topiclen));
 804bf64:	f04f 0800 	mov.w	r8, #0
 804bf68:	f8c7 8004 	str.w	r8, [r7, #4]
 804bf6c:	f8c7 8008 	str.w	r8, [r7, #8]
 804bf70:	f8a7 800c 	strh.w	r8, [r7, #12]
		memset(gau8GSM_ATCMQTTTOPIC, 0, sizeof(gau8GSM_ATCMQTTTOPIC) * sizeof(char));
 804bf74:	4c25      	ldr	r4, [pc, #148]	; (804c00c <updateMqttDataLength+0x240>)
 804bf76:	f104 0530 	add.w	r5, r4, #48	; 0x30
 804bf7a:	f04f 0b32 	mov.w	fp, #50	; 0x32
 804bf7e:	465a      	mov	r2, fp
 804bf80:	4641      	mov	r1, r8
 804bf82:	4628      	mov	r0, r5
 804bf84:	f005 f91e 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPIC, gau8GSM_ATCMQTTCMDTOPIC);
 804bf88:	4e1e      	ldr	r6, [pc, #120]	; (804c004 <updateMqttDataLength+0x238>)
 804bf8a:	f506 7166 	add.w	r1, r6, #920	; 0x398
 804bf8e:	4628      	mov	r0, r5
 804bf90:	f005 f98a 	bl	80512a8 <strcpy>
		topiclen8 = strlen(gau8MQTT_PubTopicPayload);
 804bf94:	f506 767e 	add.w	r6, r6, #1016	; 0x3f8
 804bf98:	4630      	mov	r0, r6
 804bf9a:	f7f4 f929 	bl	80401f0 <strlen>
		itoa(topiclen8, topiclen, 10);
 804bf9e:	220a      	movs	r2, #10
 804bfa0:	1d39      	adds	r1, r7, #4
 804bfa2:	f004 fe9f 	bl	8050ce4 <itoa>
		strcat(gau8GSM_ATCMQTTTOPIC, topiclen);
 804bfa6:	1d39      	adds	r1, r7, #4
 804bfa8:	4628      	mov	r0, r5
 804bfaa:	f005 f961 	bl	8051270 <strcat>
		strcat(gau8GSM_ATCMQTTTOPIC, "\r\n");
 804bfae:	4628      	mov	r0, r5
 804bfb0:	f7f4 f91e 	bl	80401f0 <strlen>
 804bfb4:	182a      	adds	r2, r5, r0
 804bfb6:	4b11      	ldr	r3, [pc, #68]	; (804bffc <updateMqttDataLength+0x230>)
 804bfb8:	f8b3 a000 	ldrh.w	sl, [r3]
 804bfbc:	f893 9002 	ldrb.w	r9, [r3, #2]
 804bfc0:	f825 a000 	strh.w	sl, [r5, r0]
 804bfc4:	f882 9002 	strb.w	r9, [r2, #2]
		memset(gau8GSM_ATCMQTTTOPICNAME, 0, sizeof(gau8GSM_ATCMQTTTOPICNAME));
 804bfc8:	3464      	adds	r4, #100	; 0x64
 804bfca:	465a      	mov	r2, fp
 804bfcc:	4641      	mov	r1, r8
 804bfce:	4620      	mov	r0, r4
 804bfd0:	f005 f8f8 	bl	80511c4 <memset>
		strcpy(gau8GSM_ATCMQTTTOPICNAME, gau8MQTT_PubTopicPayload);
 804bfd4:	4631      	mov	r1, r6
 804bfd6:	4620      	mov	r0, r4
 804bfd8:	f005 f966 	bl	80512a8 <strcpy>
		strcat(gau8GSM_ATCMQTTTOPICNAME, "\r\n");
 804bfdc:	4620      	mov	r0, r4
 804bfde:	f7f4 f907 	bl	80401f0 <strlen>
 804bfe2:	1823      	adds	r3, r4, r0
 804bfe4:	f824 a000 	strh.w	sl, [r4, r0]
 804bfe8:	f883 9002 	strb.w	r9, [r3, #2]
}
 804bfec:	e76b      	b.n	804bec6 <updateMqttDataLength+0xfa>
 804bfee:	bf00      	nop
 804bff0:	2000d790 	.word	0x2000d790
 804bff4:	20004414 	.word	0x20004414
 804bff8:	20000394 	.word	0x20000394
 804bffc:	08059fd0 	.word	0x08059fd0
 804c000:	08059fac 	.word	0x08059fac
 804c004:	20000010 	.word	0x20000010
 804c008:	08059fb4 	.word	0x08059fb4
 804c00c:	2000440c 	.word	0x2000440c

0804c010 <sendSystemConfigurationSMS>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void sendSystemConfigurationSMS(void)
{
 804c010:	b5f0      	push	{r4, r5, r6, r7, lr}
 804c012:	b089      	sub	sp, #36	; 0x24
	/* Tor Signature */
	strcpy(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)KLOUDQ_SIGNATURE);
 804c014:	4c92      	ldr	r4, [pc, #584]	; (804c260 <sendSystemConfigurationSMS+0x250>)
 804c016:	4d93      	ldr	r5, [pc, #588]	; (804c264 <sendSystemConfigurationSMS+0x254>)
 804c018:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804c01a:	6020      	str	r0, [r4, #0]
 804c01c:	6061      	str	r1, [r4, #4]
 804c01e:	60a2      	str	r2, [r4, #8]
 804c020:	60e3      	str	r3, [r4, #12]
 804c022:	882a      	ldrh	r2, [r5, #0]
 804c024:	78ab      	ldrb	r3, [r5, #2]
 804c026:	8222      	strh	r2, [r4, #16]
 804c028:	74a3      	strb	r3, [r4, #18]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Config: \r\n");
 804c02a:	4620      	mov	r0, r4
 804c02c:	f7f4 f8e0 	bl	80401f0 <strlen>
 804c030:	4602      	mov	r2, r0
 804c032:	1905      	adds	r5, r0, r4
 804c034:	4b8c      	ldr	r3, [pc, #560]	; (804c268 <sendSystemConfigurationSMS+0x258>)
 804c036:	cb03      	ldmia	r3!, {r0, r1}
 804c038:	5110      	str	r0, [r2, r4]
 804c03a:	6069      	str	r1, [r5, #4]
 804c03c:	881a      	ldrh	r2, [r3, #0]
 804c03e:	789b      	ldrb	r3, [r3, #2]
 804c040:	812a      	strh	r2, [r5, #8]
 804c042:	72ab      	strb	r3, [r5, #10]
	/*Tor Version */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Version: \r\n");
 804c044:	4620      	mov	r0, r4
 804c046:	f7f4 f8d3 	bl	80401f0 <strlen>
 804c04a:	4605      	mov	r5, r0
 804c04c:	1906      	adds	r6, r0, r4
 804c04e:	4b87      	ldr	r3, [pc, #540]	; (804c26c <sendSystemConfigurationSMS+0x25c>)
 804c050:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c052:	5128      	str	r0, [r5, r4]
 804c054:	6071      	str	r1, [r6, #4]
 804c056:	60b2      	str	r2, [r6, #8]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)MODEL_NUMBER);
 804c058:	4620      	mov	r0, r4
 804c05a:	f7f4 f8c9 	bl	80401f0 <strlen>
 804c05e:	4603      	mov	r3, r0
 804c060:	1905      	adds	r5, r0, r4
 804c062:	4a83      	ldr	r2, [pc, #524]	; (804c270 <sendSystemConfigurationSMS+0x260>)
 804c064:	ca03      	ldmia	r2!, {r0, r1}
 804c066:	5118      	str	r0, [r3, r4]
 804c068:	6069      	str	r1, [r5, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c06a:	4620      	mov	r0, r4
 804c06c:	f7f4 f8c0 	bl	80401f0 <strlen>
 804c070:	1902      	adds	r2, r0, r4
 804c072:	4b80      	ldr	r3, [pc, #512]	; (804c274 <sendSystemConfigurationSMS+0x264>)
 804c074:	881e      	ldrh	r6, [r3, #0]
 804c076:	789d      	ldrb	r5, [r3, #2]
 804c078:	5306      	strh	r6, [r0, r4]
 804c07a:	7095      	strb	r5, [r2, #2]
	/* Tor Device Id */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Id: ");
 804c07c:	4620      	mov	r0, r4
 804c07e:	f7f4 f8b7 	bl	80401f0 <strlen>
 804c082:	4603      	mov	r3, r0
 804c084:	1901      	adds	r1, r0, r4
 804c086:	4a7c      	ldr	r2, [pc, #496]	; (804c278 <sendSystemConfigurationSMS+0x268>)
 804c088:	6810      	ldr	r0, [r2, #0]
 804c08a:	5118      	str	r0, [r3, r4]
 804c08c:	7913      	ldrb	r3, [r2, #4]
 804c08e:	710b      	strb	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid2);
 804c090:	497a      	ldr	r1, [pc, #488]	; (804c27c <sendSystemConfigurationSMS+0x26c>)
 804c092:	4620      	mov	r0, r4
 804c094:	f005 f8ec 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid1);
 804c098:	4979      	ldr	r1, [pc, #484]	; (804c280 <sendSystemConfigurationSMS+0x270>)
 804c09a:	4620      	mov	r0, r4
 804c09c:	f005 f8e8 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,buffuuid0);
 804c0a0:	4978      	ldr	r1, [pc, #480]	; (804c284 <sendSystemConfigurationSMS+0x274>)
 804c0a2:	4620      	mov	r0, r4
 804c0a4:	f005 f8e4 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c0a8:	4620      	mov	r0, r4
 804c0aa:	f7f4 f8a1 	bl	80401f0 <strlen>
 804c0ae:	1903      	adds	r3, r0, r4
 804c0b0:	5306      	strh	r6, [r0, r4]
 804c0b2:	709d      	strb	r5, [r3, #2]
	/* Tor Signal Strength in RSSI */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"RSSI: ");
 804c0b4:	4620      	mov	r0, r4
 804c0b6:	f7f4 f89b 	bl	80401f0 <strlen>
 804c0ba:	4603      	mov	r3, r0
 804c0bc:	1901      	adds	r1, r0, r4
 804c0be:	4a72      	ldr	r2, [pc, #456]	; (804c288 <sendSystemConfigurationSMS+0x278>)
 804c0c0:	6810      	ldr	r0, [r2, #0]
 804c0c2:	5118      	str	r0, [r3, r4]
 804c0c4:	8890      	ldrh	r0, [r2, #4]
 804c0c6:	7993      	ldrb	r3, [r2, #6]
 804c0c8:	8088      	strh	r0, [r1, #4]
 804c0ca:	718b      	strb	r3, [r1, #6]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agsmSignalStrength);
 804c0cc:	f6a4 51bc 	subw	r1, r4, #3516	; 0xdbc
 804c0d0:	4620      	mov	r0, r4
 804c0d2:	f005 f8cd 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c0d6:	4620      	mov	r0, r4
 804c0d8:	f7f4 f88a 	bl	80401f0 <strlen>
 804c0dc:	1903      	adds	r3, r0, r4
 804c0de:	5306      	strh	r6, [r0, r4]
 804c0e0:	709d      	strb	r5, [r3, #2]
	/* Tor Network IP , if connected */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"IP: ");
 804c0e2:	4620      	mov	r0, r4
 804c0e4:	f7f4 f884 	bl	80401f0 <strlen>
 804c0e8:	4603      	mov	r3, r0
 804c0ea:	1901      	adds	r1, r0, r4
 804c0ec:	4a67      	ldr	r2, [pc, #412]	; (804c28c <sendSystemConfigurationSMS+0x27c>)
 804c0ee:	6810      	ldr	r0, [r2, #0]
 804c0f0:	5118      	str	r0, [r3, r4]
 804c0f2:	7913      	ldrb	r3, [r2, #4]
 804c0f4:	710b      	strb	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agsmNetworkIP);
 804c0f6:	f6a4 51b2 	subw	r1, r4, #3506	; 0xdb2
 804c0fa:	4620      	mov	r0, r4
 804c0fc:	f005 f8b8 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c100:	4620      	mov	r0, r4
 804c102:	f7f4 f875 	bl	80401f0 <strlen>
 804c106:	1903      	adds	r3, r0, r4
 804c108:	5306      	strh	r6, [r0, r4]
 804c10a:	709d      	strb	r5, [r3, #2]
	/* Tor Network APN */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"APN: ");
 804c10c:	4620      	mov	r0, r4
 804c10e:	f7f4 f86f 	bl	80401f0 <strlen>
 804c112:	4603      	mov	r3, r0
 804c114:	1901      	adds	r1, r0, r4
 804c116:	4a5e      	ldr	r2, [pc, #376]	; (804c290 <sendSystemConfigurationSMS+0x280>)
 804c118:	6810      	ldr	r0, [r2, #0]
 804c11a:	5118      	str	r0, [r3, r4]
 804c11c:	8893      	ldrh	r3, [r2, #4]
 804c11e:	808b      	strh	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gau8GSM_apn);
 804c120:	4f5c      	ldr	r7, [pc, #368]	; (804c294 <sendSystemConfigurationSMS+0x284>)
 804c122:	f507 7112 	add.w	r1, r7, #584	; 0x248
 804c126:	4620      	mov	r0, r4
 804c128:	f005 f8a2 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c12c:	4620      	mov	r0, r4
 804c12e:	f7f4 f85f 	bl	80401f0 <strlen>
 804c132:	1903      	adds	r3, r0, r4
 804c134:	5306      	strh	r6, [r0, r4]
 804c136:	709d      	strb	r5, [r3, #2]
	/* Tor Server URL */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"URL: ");
 804c138:	4620      	mov	r0, r4
 804c13a:	f7f4 f859 	bl	80401f0 <strlen>
 804c13e:	4603      	mov	r3, r0
 804c140:	1901      	adds	r1, r0, r4
 804c142:	4a55      	ldr	r2, [pc, #340]	; (804c298 <sendSystemConfigurationSMS+0x288>)
 804c144:	6810      	ldr	r0, [r2, #0]
 804c146:	5118      	str	r0, [r3, r4]
 804c148:	8893      	ldrh	r3, [r2, #4]
 804c14a:	808b      	strh	r3, [r1, #4]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gau8GSM_url);
 804c14c:	f507 713b 	add.w	r1, r7, #748	; 0x2ec
 804c150:	4620      	mov	r0, r4
 804c152:	f005 f88d 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c156:	4620      	mov	r0, r4
 804c158:	f7f4 f84a 	bl	80401f0 <strlen>
 804c15c:	1903      	adds	r3, r0, r4
 804c15e:	5306      	strh	r6, [r0, r4]
 804c160:	709d      	strb	r5, [r3, #2]

	/* Tor Upload Frequency */
	char ontime[10];
	char offtime[10];
	itoa(gsmInstance.u32ONPayloadUploadFreq,ontime,10);
 804c162:	f6a4 6752 	subw	r7, r4, #3666	; 0xe52
 804c166:	220a      	movs	r2, #10
 804c168:	a905      	add	r1, sp, #20
 804c16a:	f854 0c2a 	ldr.w	r0, [r4, #-42]
 804c16e:	f004 fdb9 	bl	8050ce4 <itoa>
	itoa(gsmInstance.u32OFFPayloadUploadFreq,offtime,10);
 804c172:	220a      	movs	r2, #10
 804c174:	a902      	add	r1, sp, #8
 804c176:	f854 0c26 	ldr.w	r0, [r4, #-38]
 804c17a:	f004 fdb3 	bl	8050ce4 <itoa>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Up Freq ON: ");
 804c17e:	4620      	mov	r0, r4
 804c180:	f7f4 f836 	bl	80401f0 <strlen>
 804c184:	4684      	mov	ip, r0
 804c186:	eb00 0e04 	add.w	lr, r0, r4
 804c18a:	4b44      	ldr	r3, [pc, #272]	; (804c29c <sendSystemConfigurationSMS+0x28c>)
 804c18c:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c18e:	f84c 0004 	str.w	r0, [ip, r4]
 804c192:	f8ce 1004 	str.w	r1, [lr, #4]
 804c196:	f8ce 2008 	str.w	r2, [lr, #8]
 804c19a:	781b      	ldrb	r3, [r3, #0]
 804c19c:	f88e 300c 	strb.w	r3, [lr, #12]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,ontime);
 804c1a0:	a905      	add	r1, sp, #20
 804c1a2:	4620      	mov	r0, r4
 804c1a4:	f005 f864 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c1a8:	4620      	mov	r0, r4
 804c1aa:	f7f4 f821 	bl	80401f0 <strlen>
 804c1ae:	1903      	adds	r3, r0, r4
 804c1b0:	5306      	strh	r6, [r0, r4]
 804c1b2:	709d      	strb	r5, [r3, #2]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Up Freq OFF: ");
 804c1b4:	4620      	mov	r0, r4
 804c1b6:	f7f4 f81b 	bl	80401f0 <strlen>
 804c1ba:	4684      	mov	ip, r0
 804c1bc:	eb00 0e04 	add.w	lr, r0, r4
 804c1c0:	4b37      	ldr	r3, [pc, #220]	; (804c2a0 <sendSystemConfigurationSMS+0x290>)
 804c1c2:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c1c4:	f84c 0004 	str.w	r0, [ip, r4]
 804c1c8:	f8ce 1004 	str.w	r1, [lr, #4]
 804c1cc:	f8ce 2008 	str.w	r2, [lr, #8]
 804c1d0:	881b      	ldrh	r3, [r3, #0]
 804c1d2:	f8ae 300c 	strh.w	r3, [lr, #12]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,offtime);
 804c1d6:	a902      	add	r1, sp, #8
 804c1d8:	4620      	mov	r0, r4
 804c1da:	f005 f849 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c1de:	4620      	mov	r0, r4
 804c1e0:	f7f4 f806 	bl	80401f0 <strlen>
 804c1e4:	1903      	adds	r3, r0, r4
 804c1e6:	5306      	strh	r6, [r0, r4]
 804c1e8:	709d      	strb	r5, [r3, #2]

	/* Last Known Location and time */
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"Location: ");
 804c1ea:	4620      	mov	r0, r4
 804c1ec:	f7f4 f800 	bl	80401f0 <strlen>
 804c1f0:	4602      	mov	r2, r0
 804c1f2:	eb00 0c04 	add.w	ip, r0, r4
 804c1f6:	4b2b      	ldr	r3, [pc, #172]	; (804c2a4 <sendSystemConfigurationSMS+0x294>)
 804c1f8:	cb03      	ldmia	r3!, {r0, r1}
 804c1fa:	5110      	str	r0, [r2, r4]
 804c1fc:	f8cc 1004 	str.w	r1, [ip, #4]
 804c200:	881a      	ldrh	r2, [r3, #0]
 804c202:	789b      	ldrb	r3, [r3, #2]
 804c204:	f8ac 2008 	strh.w	r2, [ip, #8]
 804c208:	f88c 300a 	strb.w	r3, [ip, #10]
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,gsmInstance.agpsLocationData);
 804c20c:	4639      	mov	r1, r7
 804c20e:	4620      	mov	r0, r4
 804c210:	f005 f82e 	bl	8051270 <strcat>
	strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\r\n");
 804c214:	4620      	mov	r0, r4
 804c216:	f7f3 ffeb 	bl	80401f0 <strlen>
 804c21a:	1903      	adds	r3, r0, r4
 804c21c:	5306      	strh	r6, [r0, r4]
 804c21e:	709d      	strb	r5, [r3, #2]

	/*Last MQTT Status Code */
		char mqttresp[5];
		itoa(u8LastMqttResponseCode,mqttresp,10);
 804c220:	220a      	movs	r2, #10
 804c222:	4669      	mov	r1, sp
 804c224:	4b20      	ldr	r3, [pc, #128]	; (804c2a8 <sendSystemConfigurationSMS+0x298>)
 804c226:	f8d3 0098 	ldr.w	r0, [r3, #152]	; 0x98
 804c22a:	f004 fd5b 	bl	8050ce4 <itoa>
		strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,(char *)"MQTT Code : ");
 804c22e:	4620      	mov	r0, r4
 804c230:	f7f3 ffde 	bl	80401f0 <strlen>
 804c234:	4605      	mov	r5, r0
 804c236:	1906      	adds	r6, r0, r4
 804c238:	4b1c      	ldr	r3, [pc, #112]	; (804c2ac <sendSystemConfigurationSMS+0x29c>)
 804c23a:	cb07      	ldmia	r3!, {r0, r1, r2}
 804c23c:	5128      	str	r0, [r5, r4]
 804c23e:	6071      	str	r1, [r6, #4]
 804c240:	60b2      	str	r2, [r6, #8]
 804c242:	781b      	ldrb	r3, [r3, #0]
 804c244:	7333      	strb	r3, [r6, #12]
		strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,mqttresp);
 804c246:	4669      	mov	r1, sp
 804c248:	4620      	mov	r0, r4
 804c24a:	f005 f811 	bl	8051270 <strcat>
		strcat(gsmInstance.strSystemSMS.agsmSMSMessageBody,"\n");
 804c24e:	4620      	mov	r0, r4
 804c250:	f7f3 ffce 	bl	80401f0 <strlen>
 804c254:	4b16      	ldr	r3, [pc, #88]	; (804c2b0 <sendSystemConfigurationSMS+0x2a0>)
 804c256:	881b      	ldrh	r3, [r3, #0]
 804c258:	5223      	strh	r3, [r4, r0]
}
 804c25a:	b009      	add	sp, #36	; 0x24
 804c25c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804c25e:	bf00      	nop
 804c260:	2000d46e 	.word	0x2000d46e
 804c264:	08059fc0 	.word	0x08059fc0
 804c268:	08059fd4 	.word	0x08059fd4
 804c26c:	08059fe0 	.word	0x08059fe0
 804c270:	08059fec 	.word	0x08059fec
 804c274:	08059fd0 	.word	0x08059fd0
 804c278:	08059ff4 	.word	0x08059ff4
 804c27c:	20008b24 	.word	0x20008b24
 804c280:	20008ae4 	.word	0x20008ae4
 804c284:	20008b04 	.word	0x20008b04
 804c288:	08059ffc 	.word	0x08059ffc
 804c28c:	0805a004 	.word	0x0805a004
 804c290:	0805a00c 	.word	0x0805a00c
 804c294:	20000010 	.word	0x20000010
 804c298:	0805a014 	.word	0x0805a014
 804c29c:	0805a01c 	.word	0x0805a01c
 804c2a0:	0805a02c 	.word	0x0805a02c
 804c2a4:	0805a03c 	.word	0x0805a03c
 804c2a8:	2000440c 	.word	0x2000440c
 804c2ac:	0805a048 	.word	0x0805a048
 804c2b0:	0805a0d8 	.word	0x0805a0d8

0804c2b4 <syncrtcwithNetworkTime>:
uint32_t gu32Date = 0;
uint32_t gu32Hours = 0;
uint32_t gu32Minutes = 0;
uint32_t gu32Seconds = 0;
void syncrtcwithNetworkTime(void)
{
 804c2b4:	b570      	push	{r4, r5, r6, lr}

//	if(gu32TimeSyncFlag == 1)
//		return;

	gu32Year = (((gau8GSM_TimeStamp[0]-'0') * 10) + (gau8GSM_TimeStamp[1]-'0'));
 804c2b6:	4b40      	ldr	r3, [pc, #256]	; (804c3b8 <syncrtcwithNetworkTime+0x104>)
 804c2b8:	f893 040c 	ldrb.w	r0, [r3, #1036]	; 0x40c
 804c2bc:	3830      	subs	r0, #48	; 0x30
 804c2be:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 804c2c2:	f893 240d 	ldrb.w	r2, [r3, #1037]	; 0x40d
 804c2c6:	3a30      	subs	r2, #48	; 0x30
 804c2c8:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 804c2cc:	4c3b      	ldr	r4, [pc, #236]	; (804c3bc <syncrtcwithNetworkTime+0x108>)
 804c2ce:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
	gu32Month = (((gau8GSM_TimeStamp[3]-'0') * 10) + (gau8GSM_TimeStamp[4]-'0'));
 804c2d2:	f893 240f 	ldrb.w	r2, [r3, #1039]	; 0x40f
 804c2d6:	3a30      	subs	r2, #48	; 0x30
 804c2d8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c2dc:	f893 1410 	ldrb.w	r1, [r3, #1040]	; 0x410
 804c2e0:	3930      	subs	r1, #48	; 0x30
 804c2e2:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c2e6:	f8c4 20a4 	str.w	r2, [r4, #164]	; 0xa4
	gu32Date = (((gau8GSM_TimeStamp[6]-'0') * 10) + (gau8GSM_TimeStamp[7]-'0'));
 804c2ea:	f893 2412 	ldrb.w	r2, [r3, #1042]	; 0x412
 804c2ee:	3a30      	subs	r2, #48	; 0x30
 804c2f0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c2f4:	f893 1413 	ldrb.w	r1, [r3, #1043]	; 0x413
 804c2f8:	3930      	subs	r1, #48	; 0x30
 804c2fa:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c2fe:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8

	gu32Hours = (((gau8GSM_TimeStamp[9]-'0') * 10) + (gau8GSM_TimeStamp[10]-'0'));
 804c302:	f893 2415 	ldrb.w	r2, [r3, #1045]	; 0x415
 804c306:	3a30      	subs	r2, #48	; 0x30
 804c308:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c30c:	f893 1416 	ldrb.w	r1, [r3, #1046]	; 0x416
 804c310:	3930      	subs	r1, #48	; 0x30
 804c312:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c316:	f8c4 20ac 	str.w	r2, [r4, #172]	; 0xac
	gu32Minutes = (((gau8GSM_TimeStamp[12]-'0') * 10) + (gau8GSM_TimeStamp[13]-'0'));
 804c31a:	f893 2418 	ldrb.w	r2, [r3, #1048]	; 0x418
 804c31e:	3a30      	subs	r2, #48	; 0x30
 804c320:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c324:	f893 1419 	ldrb.w	r1, [r3, #1049]	; 0x419
 804c328:	3930      	subs	r1, #48	; 0x30
 804c32a:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 804c32e:	f8c4 20b0 	str.w	r2, [r4, #176]	; 0xb0
	gu32Seconds = (((gau8GSM_TimeStamp[15]-'0') * 10) + (gau8GSM_TimeStamp[16]-'0'));
 804c332:	f893 241b 	ldrb.w	r2, [r3, #1051]	; 0x41b
 804c336:	3a30      	subs	r2, #48	; 0x30
 804c338:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804c33c:	f893 341c 	ldrb.w	r3, [r3, #1052]	; 0x41c
 804c340:	3b30      	subs	r3, #48	; 0x30
 804c342:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 804c346:	f8c4 20b4 	str.w	r2, [r4, #180]	; 0xb4

	SDate1.Year = DecimalToBCD(gu32Year);
 804c34a:	f004 fb25 	bl	8050998 <DecimalToBCD>
 804c34e:	4d1c      	ldr	r5, [pc, #112]	; (804c3c0 <syncrtcwithNetworkTime+0x10c>)
 804c350:	70e8      	strb	r0, [r5, #3]
	SDate1.Month = DecimalToBCD(gu32Month);
 804c352:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
 804c356:	f004 fb1f 	bl	8050998 <DecimalToBCD>
 804c35a:	7068      	strb	r0, [r5, #1]
	SDate1.Date = DecimalToBCD(gu32Date);
 804c35c:	f8d4 00a8 	ldr.w	r0, [r4, #168]	; 0xa8
 804c360:	f004 fb1a 	bl	8050998 <DecimalToBCD>
 804c364:	70a8      	strb	r0, [r5, #2]
	STime1.Hours = DecimalToBCD(gu32Hours);
 804c366:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 804c36a:	f004 fb15 	bl	8050998 <DecimalToBCD>
 804c36e:	4e15      	ldr	r6, [pc, #84]	; (804c3c4 <syncrtcwithNetworkTime+0x110>)
 804c370:	7030      	strb	r0, [r6, #0]
	STime1.Minutes = DecimalToBCD(gu32Minutes);
 804c372:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
 804c376:	f004 fb0f 	bl	8050998 <DecimalToBCD>
 804c37a:	7070      	strb	r0, [r6, #1]
	STime1.Seconds = DecimalToBCD(gu32Seconds);
 804c37c:	f8d4 00b4 	ldr.w	r0, [r4, #180]	; 0xb4
 804c380:	f004 fb0a 	bl	8050998 <DecimalToBCD>
 804c384:	70b0      	strb	r0, [r6, #2]

	strTimeUpdate.u32RefTimeHH = gu32Hours;
 804c386:	4b10      	ldr	r3, [pc, #64]	; (804c3c8 <syncrtcwithNetworkTime+0x114>)
 804c388:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 804c38c:	601a      	str	r2, [r3, #0]
	strTimeUpdate.u32RefTimeMin = gu32Minutes;
 804c38e:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 804c392:	605a      	str	r2, [r3, #4]
	strTimeUpdate.u32RefTimeSec = gu32Seconds;
 804c394:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 804c398:	609a      	str	r2, [r3, #8]

	/* Update/ Set RTC Structure */
	HAL_RTC_SetTime(&hrtc,&STime1,RTC_FORMAT_BCD);
 804c39a:	4c0c      	ldr	r4, [pc, #48]	; (804c3cc <syncrtcwithNetworkTime+0x118>)
 804c39c:	2201      	movs	r2, #1
 804c39e:	4631      	mov	r1, r6
 804c3a0:	4620      	mov	r0, r4
 804c3a2:	f7f8 fa59 	bl	8044858 <HAL_RTC_SetTime>
	HAL_RTC_SetDate(&hrtc,&SDate1,RTC_FORMAT_BCD);
 804c3a6:	2201      	movs	r2, #1
 804c3a8:	4629      	mov	r1, r5
 804c3aa:	4620      	mov	r0, r4
 804c3ac:	f7f8 fad3 	bl	8044956 <HAL_RTC_SetDate>

	/* Network Time Sync complete (Indicator) */
	gu32TimeSyncFlag = 1;
 804c3b0:	4b07      	ldr	r3, [pc, #28]	; (804c3d0 <syncrtcwithNetworkTime+0x11c>)
 804c3b2:	2201      	movs	r2, #1
 804c3b4:	601a      	str	r2, [r3, #0]
}
 804c3b6:	bd70      	pop	{r4, r5, r6, pc}
 804c3b8:	20000010 	.word	0x20000010
 804c3bc:	2000440c 	.word	0x2000440c
 804c3c0:	200051f0 	.word	0x200051f0
 804c3c4:	200051dc 	.word	0x200051dc
 804c3c8:	20005338 	.word	0x20005338
 804c3cc:	2000f5b8 	.word	0x2000f5b8
 804c3d0:	20005334 	.word	0x20005334

0804c3d4 <restoreHTTPURLforData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void restoreHTTPURLforData(void)
{
 804c3d4:	b570      	push	{r4, r5, r6, lr}
	strcpy((char *)gau8GSM_ATURL,(char *)gau8GSM_ATCMQTTCONNECT);
 804c3d6:	4d10      	ldr	r5, [pc, #64]	; (804c418 <restoreHTTPURLforData+0x44>)
 804c3d8:	f105 04b4 	add.w	r4, r5, #180	; 0xb4
 804c3dc:	f505 712b 	add.w	r1, r5, #684	; 0x2ac
 804c3e0:	4620      	mov	r0, r4
 804c3e2:	f004 ff61 	bl	80512a8 <strcpy>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c3e6:	4620      	mov	r0, r4
 804c3e8:	f7f3 ff02 	bl	80401f0 <strlen>
 804c3ec:	4b0b      	ldr	r3, [pc, #44]	; (804c41c <restoreHTTPURLforData+0x48>)
 804c3ee:	881e      	ldrh	r6, [r3, #0]
 804c3f0:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8GSM_url);
 804c3f2:	f505 713b 	add.w	r1, r5, #748	; 0x2ec
 804c3f6:	4620      	mov	r0, r4
 804c3f8:	f004 ff3a 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c3fc:	4620      	mov	r0, r4
 804c3fe:	f7f3 fef7 	bl	80401f0 <strlen>
 804c402:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,"\r\n");
 804c404:	4620      	mov	r0, r4
 804c406:	f7f3 fef3 	bl	80401f0 <strlen>
 804c40a:	1822      	adds	r2, r4, r0
 804c40c:	4b04      	ldr	r3, [pc, #16]	; (804c420 <restoreHTTPURLforData+0x4c>)
 804c40e:	8819      	ldrh	r1, [r3, #0]
 804c410:	789b      	ldrb	r3, [r3, #2]
 804c412:	5221      	strh	r1, [r4, r0]
 804c414:	7093      	strb	r3, [r2, #2]
}
 804c416:	bd70      	pop	{r4, r5, r6, pc}
 804c418:	20000010 	.word	0x20000010
 804c41c:	08059fa8 	.word	0x08059fa8
 804c420:	08059fd0 	.word	0x08059fd0

0804c424 <updateNetworkAPN>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateNetworkAPN(void)
{
 804c424:	b570      	push	{r4, r5, r6, lr}
	memset(gau8GSM_NewSetAPN, 0x00, sizeof(gau8GSM_NewSetAPN) * sizeof(char));
 804c426:	4c12      	ldr	r4, [pc, #72]	; (804c470 <updateNetworkAPN+0x4c>)
 804c428:	2232      	movs	r2, #50	; 0x32
 804c42a:	2100      	movs	r1, #0
 804c42c:	4620      	mov	r0, r4
 804c42e:	f004 fec9 	bl	80511c4 <memset>
	//gau8GSM_NewSetAPN
	strcpy((char *)gau8GSM_NewSetAPN,(char *)gau8GSM_ATSETAPN);
 804c432:	4e10      	ldr	r6, [pc, #64]	; (804c474 <updateNetworkAPN+0x50>)
 804c434:	f206 51f4 	addw	r1, r6, #1524	; 0x5f4
 804c438:	4620      	mov	r0, r4
 804c43a:	f004 ff35 	bl	80512a8 <strcpy>
	strcat((char *)gau8GSM_NewSetAPN,(char *)"\"");
 804c43e:	4620      	mov	r0, r4
 804c440:	f7f3 fed6 	bl	80401f0 <strlen>
 804c444:	4b0c      	ldr	r3, [pc, #48]	; (804c478 <updateNetworkAPN+0x54>)
 804c446:	881d      	ldrh	r5, [r3, #0]
 804c448:	5225      	strh	r5, [r4, r0]
	strcat((char *)gau8GSM_NewSetAPN,(char *)gau8GSM4G_apn);
 804c44a:	f506 61c1 	add.w	r1, r6, #1544	; 0x608
 804c44e:	4620      	mov	r0, r4
 804c450:	f004 ff0e 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_NewSetAPN,(char *)"\"");
 804c454:	4620      	mov	r0, r4
 804c456:	f7f3 fecb 	bl	80401f0 <strlen>
 804c45a:	5225      	strh	r5, [r4, r0]
	strcat((char *)gau8GSM_NewSetAPN,"\r\n");
 804c45c:	4620      	mov	r0, r4
 804c45e:	f7f3 fec7 	bl	80401f0 <strlen>
 804c462:	1822      	adds	r2, r4, r0
 804c464:	4b05      	ldr	r3, [pc, #20]	; (804c47c <updateNetworkAPN+0x58>)
 804c466:	8819      	ldrh	r1, [r3, #0]
 804c468:	789b      	ldrb	r3, [r3, #2]
 804c46a:	5221      	strh	r1, [r4, r0]
 804c46c:	7093      	strb	r3, [r2, #2]
}
 804c46e:	bd70      	pop	{r4, r5, r6, pc}
 804c470:	200044c4 	.word	0x200044c4
 804c474:	20000010 	.word	0x20000010
 804c478:	08059fa8 	.word	0x08059fa8
 804c47c:	08059fd0 	.word	0x08059fd0

0804c480 <updateHTTPReadLength>:
*******************************************************************************/
#define FOTAFILECHUNKSIZEBYTES	(1024)
uint32_t updateHTTPReadLength(uint32_t ConfigFileSizeBytes)
{

	if(ConfigFileSizeBytes != 0)
 804c480:	2800      	cmp	r0, #0
 804c482:	f000 8094 	beq.w	804c5ae <updateHTTPReadLength+0x12e>
{
 804c486:	b570      	push	{r4, r5, r6, lr}
	{
		/* Start of File */
		if(u32ConfigFileBaseAddress == 0)
 804c488:	4a49      	ldr	r2, [pc, #292]	; (804c5b0 <updateHTTPReadLength+0x130>)
 804c48a:	f8d2 20ec 	ldr.w	r2, [r2, #236]	; 0xec
 804c48e:	2a00      	cmp	r2, #0
 804c490:	d047      	beq.n	804c522 <updateHTTPReadLength+0xa2>
			u32ConfigFileRemainingBytes = (ConfigFileSizeBytes % FOTAFILECHUNKSIZEBYTES);
			itoa(FOTAFILECHUNKSIZEBYTES,ConfigbufferChunkBytes,PAYLOAD_DATA_STRING_RADIX);
			itoa(u32ConfigFileRemainingBytes,bufferRemBytes,PAYLOAD_DATA_STRING_RADIX);
		}

		strcpy(gau8GSM_ATHTTPREAD,(char *)"AT+HTTPREAD=");
 804c492:	4d48      	ldr	r5, [pc, #288]	; (804c5b4 <updateHTTPReadLength+0x134>)
 804c494:	4b48      	ldr	r3, [pc, #288]	; (804c5b8 <updateHTTPReadLength+0x138>)
 804c496:	f205 647c 	addw	r4, r5, #1660	; 0x67c
 804c49a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 804c49c:	c407      	stmia	r4!, {r0, r1, r2}
 804c49e:	7023      	strb	r3, [r4, #0]
		memset(buffer,0x00,sizeof(char) * sizeof(buffer));
 804c4a0:	f505 62d3 	add.w	r2, r5, #1688	; 0x698
 804c4a4:	2300      	movs	r3, #0
 804c4a6:	f8c5 3698 	str.w	r3, [r5, #1688]	; 0x698
 804c4aa:	f8a5 369c 	strh.w	r3, [r5, #1692]	; 0x69c

		if(u32ConfigFileBaseAddress < u32ConfigFileChunkCounter)
 804c4ae:	4b40      	ldr	r3, [pc, #256]	; (804c5b0 <updateHTTPReadLength+0x130>)
 804c4b0:	f8d3 40ec 	ldr.w	r4, [r3, #236]	; 0xec
 804c4b4:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
 804c4b8:	4284      	cmp	r4, r0
 804c4ba:	d34a      	bcc.n	804c552 <updateHTTPReadLength+0xd2>
			return 2;
		}
		else
		{
//			itoa(u32ConfigFileChunkCounter * 2000,buffer,PAYLOAD_DATA_STRING_RADIX);
			itoa(u32ConfigFileChunkCounter * FOTAFILECHUNKSIZEBYTES,buffer,PAYLOAD_DATA_STRING_RADIX);
 804c4bc:	4d3d      	ldr	r5, [pc, #244]	; (804c5b4 <updateHTTPReadLength+0x134>)
 804c4be:	f505 66d3 	add.w	r6, r5, #1688	; 0x698
 804c4c2:	220a      	movs	r2, #10
 804c4c4:	4631      	mov	r1, r6
 804c4c6:	4090      	lsls	r0, r2
 804c4c8:	f004 fc0c 	bl	8050ce4 <itoa>
			strcat(gau8GSM_ATHTTPREAD,(char *)buffer);
 804c4cc:	f205 647c 	addw	r4, r5, #1660	; 0x67c
 804c4d0:	4631      	mov	r1, r6
 804c4d2:	4620      	mov	r0, r4
 804c4d4:	f004 fecc 	bl	8051270 <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)",");
 804c4d8:	4620      	mov	r0, r4
 804c4da:	f7f3 fe89 	bl	80401f0 <strlen>
 804c4de:	4b37      	ldr	r3, [pc, #220]	; (804c5bc <updateHTTPReadLength+0x13c>)
 804c4e0:	881b      	ldrh	r3, [r3, #0]
 804c4e2:	5223      	strh	r3, [r4, r0]
			strcat(gau8GSM_ATHTTPREAD,(char *)bufferRemBytes); /* Byte(s) Chunk to read*/
 804c4e4:	f205 6174 	addw	r1, r5, #1652	; 0x674
 804c4e8:	4620      	mov	r0, r4
 804c4ea:	f004 fec1 	bl	8051270 <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)"\r\n");
 804c4ee:	4620      	mov	r0, r4
 804c4f0:	f7f3 fe7e 	bl	80401f0 <strlen>
 804c4f4:	1822      	adds	r2, r4, r0
 804c4f6:	4b32      	ldr	r3, [pc, #200]	; (804c5c0 <updateHTTPReadLength+0x140>)
 804c4f8:	8819      	ldrh	r1, [r3, #0]
 804c4fa:	789b      	ldrb	r3, [r3, #2]
 804c4fc:	5221      	strh	r1, [r4, r0]
 804c4fe:	7093      	strb	r3, [r2, #2]
			gsmInstance.gu32RemoteConfigSizeinBytes = u32ConfigFileRemainingBytes;
 804c500:	4b2b      	ldr	r3, [pc, #172]	; (804c5b0 <updateHTTPReadLength+0x130>)
 804c502:	f8d3 10f4 	ldr.w	r1, [r3, #244]	; 0xf4
 804c506:	4a2f      	ldr	r2, [pc, #188]	; (804c5c4 <updateHTTPReadLength+0x144>)
 804c508:	f8c2 1e34 	str.w	r1, [r2, #3636]	; 0xe34
			u32ConfigFileBaseAddress = 0;
 804c50c:	2200      	movs	r2, #0
 804c50e:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
			u32ConfigFileChunkCounter = 0;
 804c512:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
			u32ConfigFileRemainingBytes = 0;
 804c516:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
			u32ConfigFileReadComplete = 1;
 804c51a:	2001      	movs	r0, #1
 804c51c:	f8c3 00f8 	str.w	r0, [r3, #248]	; 0xf8
			return 1;
		}
	}
	else
		return 0;
}
 804c520:	bd70      	pop	{r4, r5, r6, pc}
			u32ConfigFileChunkCounter = (ConfigFileSizeBytes / FOTAFILECHUNKSIZEBYTES);
 804c522:	0a82      	lsrs	r2, r0, #10
 804c524:	4c22      	ldr	r4, [pc, #136]	; (804c5b0 <updateHTTPReadLength+0x130>)
 804c526:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
			u32ConfigFileRemainingBytes = (ConfigFileSizeBytes % FOTAFILECHUNKSIZEBYTES);
 804c52a:	f3c0 0309 	ubfx	r3, r0, #0, #10
 804c52e:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
			itoa(FOTAFILECHUNKSIZEBYTES,ConfigbufferChunkBytes,PAYLOAD_DATA_STRING_RADIX);
 804c532:	4d20      	ldr	r5, [pc, #128]	; (804c5b4 <updateHTTPReadLength+0x134>)
 804c534:	220a      	movs	r2, #10
 804c536:	f205 616c 	addw	r1, r5, #1644	; 0x66c
 804c53a:	f44f 6080 	mov.w	r0, #1024	; 0x400
 804c53e:	f004 fbd1 	bl	8050ce4 <itoa>
			itoa(u32ConfigFileRemainingBytes,bufferRemBytes,PAYLOAD_DATA_STRING_RADIX);
 804c542:	220a      	movs	r2, #10
 804c544:	f205 6174 	addw	r1, r5, #1652	; 0x674
 804c548:	f8d4 00f4 	ldr.w	r0, [r4, #244]	; 0xf4
 804c54c:	f004 fbca 	bl	8050ce4 <itoa>
 804c550:	e79f      	b.n	804c492 <updateHTTPReadLength+0x12>
			itoa((u32ConfigFileBaseAddress * FOTAFILECHUNKSIZEBYTES),buffer,PAYLOAD_DATA_STRING_RADIX);
 804c552:	4616      	mov	r6, r2
 804c554:	220a      	movs	r2, #10
 804c556:	4631      	mov	r1, r6
 804c558:	fa04 f002 	lsl.w	r0, r4, r2
 804c55c:	f004 fbc2 	bl	8050ce4 <itoa>
			strcat(gau8GSM_ATHTTPREAD,(char *)buffer);
 804c560:	f205 647c 	addw	r4, r5, #1660	; 0x67c
 804c564:	4631      	mov	r1, r6
 804c566:	4620      	mov	r0, r4
 804c568:	f004 fe82 	bl	8051270 <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)",");
 804c56c:	4620      	mov	r0, r4
 804c56e:	f7f3 fe3f 	bl	80401f0 <strlen>
 804c572:	4b12      	ldr	r3, [pc, #72]	; (804c5bc <updateHTTPReadLength+0x13c>)
 804c574:	881b      	ldrh	r3, [r3, #0]
 804c576:	5223      	strh	r3, [r4, r0]
			strcat(gau8GSM_ATHTTPREAD,(char *)ConfigbufferChunkBytes); /* Byte(s) Chunk to read*/
 804c578:	f205 616c 	addw	r1, r5, #1644	; 0x66c
 804c57c:	4620      	mov	r0, r4
 804c57e:	f004 fe77 	bl	8051270 <strcat>
			strcat(gau8GSM_ATHTTPREAD,(char *)"\r\n");
 804c582:	4620      	mov	r0, r4
 804c584:	f7f3 fe34 	bl	80401f0 <strlen>
 804c588:	1822      	adds	r2, r4, r0
 804c58a:	4b0d      	ldr	r3, [pc, #52]	; (804c5c0 <updateHTTPReadLength+0x140>)
 804c58c:	8819      	ldrh	r1, [r3, #0]
 804c58e:	789b      	ldrb	r3, [r3, #2]
 804c590:	5221      	strh	r1, [r4, r0]
 804c592:	7093      	strb	r3, [r2, #2]
			u32ConfigFileBaseAddress++;
 804c594:	4a06      	ldr	r2, [pc, #24]	; (804c5b0 <updateHTTPReadLength+0x130>)
 804c596:	f8d2 30ec 	ldr.w	r3, [r2, #236]	; 0xec
 804c59a:	3301      	adds	r3, #1
 804c59c:	f8c2 30ec 	str.w	r3, [r2, #236]	; 0xec
			gsmInstance.gu32RemoteConfigSizeinBytes = FOTAFILECHUNKSIZEBYTES;
 804c5a0:	4b08      	ldr	r3, [pc, #32]	; (804c5c4 <updateHTTPReadLength+0x144>)
 804c5a2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804c5a6:	f8c3 2e34 	str.w	r2, [r3, #3636]	; 0xe34
			return 2;
 804c5aa:	2002      	movs	r0, #2
 804c5ac:	e7b8      	b.n	804c520 <updateHTTPReadLength+0xa0>
}
 804c5ae:	4770      	bx	lr
 804c5b0:	2000440c 	.word	0x2000440c
 804c5b4:	20000010 	.word	0x20000010
 804c5b8:	0805a06c 	.word	0x0805a06c
 804c5bc:	0805a058 	.word	0x0805a058
 804c5c0:	08059fd0 	.word	0x08059fd0
 804c5c4:	2000c61c 	.word	0x2000c61c

0804c5c8 <initHTTPURLforFOTA>:
 Change History:
 Author           	Date                Remarks
 KloudQ Team      31-03-2020			Initial Definitions
******************************************************************************/
void initHTTPURLforFOTA(void )
{
 804c5c8:	b570      	push	{r4, r5, r6, lr}
	strcpy((char *)gau8GSM_ATURL,(char *)gau8GSM_ATCMQTTCONNECT);
 804c5ca:	4d10      	ldr	r5, [pc, #64]	; (804c60c <initHTTPURLforFOTA+0x44>)
 804c5cc:	f105 04b4 	add.w	r4, r5, #180	; 0xb4
 804c5d0:	f505 712b 	add.w	r1, r5, #684	; 0x2ac
 804c5d4:	4620      	mov	r0, r4
 804c5d6:	f004 fe67 	bl	80512a8 <strcpy>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c5da:	4620      	mov	r0, r4
 804c5dc:	f7f3 fe08 	bl	80401f0 <strlen>
 804c5e0:	4b0b      	ldr	r3, [pc, #44]	; (804c610 <initHTTPURLforFOTA+0x48>)
 804c5e2:	881e      	ldrh	r6, [r3, #0]
 804c5e4:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,(char *)gau8FotaURL);
 804c5e6:	f205 515c 	addw	r1, r5, #1372	; 0x55c
 804c5ea:	4620      	mov	r0, r4
 804c5ec:	f004 fe40 	bl	8051270 <strcat>
	strcat((char *)gau8GSM_ATURL,(char *)"\"");
 804c5f0:	4620      	mov	r0, r4
 804c5f2:	f7f3 fdfd 	bl	80401f0 <strlen>
 804c5f6:	5226      	strh	r6, [r4, r0]
	strcat((char *)gau8GSM_ATURL,"\r\n");
 804c5f8:	4620      	mov	r0, r4
 804c5fa:	f7f3 fdf9 	bl	80401f0 <strlen>
 804c5fe:	1822      	adds	r2, r4, r0
 804c600:	4b04      	ldr	r3, [pc, #16]	; (804c614 <initHTTPURLforFOTA+0x4c>)
 804c602:	8819      	ldrh	r1, [r3, #0]
 804c604:	789b      	ldrb	r3, [r3, #2]
 804c606:	5221      	strh	r1, [r4, r0]
 804c608:	7093      	strb	r3, [r2, #2]
}
 804c60a:	bd70      	pop	{r4, r5, r6, pc}
 804c60c:	20000010 	.word	0x20000010
 804c610:	08059fa8 	.word	0x08059fa8
 804c614:	08059fd0 	.word	0x08059fd0

0804c618 <Diagnostic>:
void Diagnostic(enmDiagnosticStatus DiagnosticStatus )
{
 804c618:	b508      	push	{r3, lr}
	enqueue(&gsmPayload,(char *)getDiagDataString(DiagnosticStatus));
 804c61a:	f003 f8ab 	bl	804f774 <getDiagDataString>
 804c61e:	4601      	mov	r1, r0
 804c620:	4801      	ldr	r0, [pc, #4]	; (804c628 <Diagnostic+0x10>)
 804c622:	f003 f967 	bl	804f8f4 <enqueue>
}
 804c626:	bd08      	pop	{r3, pc}
 804c628:	2000d790 	.word	0x2000d790

0804c62c <sendGSMCommand>:
{
 804c62c:	b570      	push	{r4, r5, r6, lr}
	switch (gsmInstance.enmGSMCommandResponseState)
 804c62e:	4ba5      	ldr	r3, [pc, #660]	; (804c8c4 <sendGSMCommand+0x298>)
 804c630:	f893 3e40 	ldrb.w	r3, [r3, #3648]	; 0xe40
 804c634:	b123      	cbz	r3, 804c640 <sendGSMCommand+0x14>
 804c636:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 804c63a:	2a01      	cmp	r2, #1
 804c63c:	d06a      	beq.n	804c714 <sendGSMCommand+0xe8>
}
 804c63e:	bd70      	pop	{r4, r5, r6, pc}
			if(gsmInstance.enmGSMCommandState == enmGSM_CMDSEND)
 804c640:	4ba0      	ldr	r3, [pc, #640]	; (804c8c4 <sendGSMCommand+0x298>)
 804c642:	f893 3e41 	ldrb.w	r3, [r3, #3649]	; 0xe41
 804c646:	b2db      	uxtb	r3, r3
 804c648:	2b01      	cmp	r3, #1
 804c64a:	d01b      	beq.n	804c684 <sendGSMCommand+0x58>
			else if(gsmInstance.enmGSMCommandState == enmGSM_CMDINPROCESS)
 804c64c:	4b9d      	ldr	r3, [pc, #628]	; (804c8c4 <sendGSMCommand+0x298>)
 804c64e:	f893 3e41 	ldrb.w	r3, [r3, #3649]	; 0xe41
 804c652:	b2db      	uxtb	r3, r3
 804c654:	2b02      	cmp	r3, #2
 804c656:	d15a      	bne.n	804c70e <sendGSMCommand+0xe2>
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsActiveFlag_TXE(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 804c658:	4b9b      	ldr	r3, [pc, #620]	; (804c8c8 <sendGSMCommand+0x29c>)
 804c65a:	681b      	ldr	r3, [r3, #0]
				if(!LL_USART_IsActiveFlag_TXE(UART4))
 804c65c:	f013 0f80 	tst.w	r3, #128	; 0x80
 804c660:	d0ed      	beq.n	804c63e <sendGSMCommand+0x12>
					if(u8LoopCounter < (u8CharacterCounter))
 804c662:	4a9a      	ldr	r2, [pc, #616]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c664:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
 804c668:	f8d2 2104 	ldr.w	r2, [r2, #260]	; 0x104
 804c66c:	4293      	cmp	r3, r2
 804c66e:	d236      	bcs.n	804c6de <sendGSMCommand+0xb2>
						LL_USART_TransmitData8(UART4,command[u8LoopCounter++]);
 804c670:	4a96      	ldr	r2, [pc, #600]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c672:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
 804c676:	1c58      	adds	r0, r3, #1
 804c678:	f8c2 00fc 	str.w	r0, [r2, #252]	; 0xfc
 804c67c:	5cca      	ldrb	r2, [r1, r3]
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
  USARTx->DR = Value;
 804c67e:	4b92      	ldr	r3, [pc, #584]	; (804c8c8 <sendGSMCommand+0x29c>)
 804c680:	605a      	str	r2, [r3, #4]
}
 804c682:	e7dc      	b.n	804c63e <sendGSMCommand+0x12>
				u8LoopCounter = 0;
 804c684:	4b91      	ldr	r3, [pc, #580]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c686:	2200      	movs	r2, #0
 804c688:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
				if(gsmInstance.enmGSMCommand == enmGSMSTATE_SENDDATA)
 804c68c:	4b8d      	ldr	r3, [pc, #564]	; (804c8c4 <sendGSMCommand+0x298>)
 804c68e:	f893 3e43 	ldrb.w	r3, [r3, #3651]	; 0xe43
 804c692:	2b1a      	cmp	r3, #26
 804c694:	d01a      	beq.n	804c6cc <sendGSMCommand+0xa0>
					command = gsmStateTableArray[gsmInstance.enmGSMCommand].atCommand;
 804c696:	4a8e      	ldr	r2, [pc, #568]	; (804c8d0 <sendGSMCommand+0x2a4>)
 804c698:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 804c69c:	f8d3 26a0 	ldr.w	r2, [r3, #1696]	; 0x6a0
 804c6a0:	4b8a      	ldr	r3, [pc, #552]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c6a2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
				u8CharacterCounter = strlen((const char *)command);
 804c6a6:	4c89      	ldr	r4, [pc, #548]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c6a8:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
 804c6ac:	4628      	mov	r0, r5
 804c6ae:	f7f3 fd9f 	bl	80401f0 <strlen>
 804c6b2:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
				LL_USART_TransmitData8(UART4,command[u8LoopCounter++]);
 804c6b6:	2301      	movs	r3, #1
 804c6b8:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
 804c6bc:	782a      	ldrb	r2, [r5, #0]
  USARTx->DR = Value;
 804c6be:	4b82      	ldr	r3, [pc, #520]	; (804c8c8 <sendGSMCommand+0x29c>)
 804c6c0:	605a      	str	r2, [r3, #4]
				gsmInstance.enmGSMCommandState = enmGSM_CMDINPROCESS;
 804c6c2:	4b80      	ldr	r3, [pc, #512]	; (804c8c4 <sendGSMCommand+0x298>)
 804c6c4:	2202      	movs	r2, #2
 804c6c6:	f883 2e41 	strb.w	r2, [r3, #3649]	; 0xe41
 804c6ca:	e7b8      	b.n	804c63e <sendGSMCommand+0x12>
					command = gsmPayload.data[gsmPayload.tail];
 804c6cc:	4a81      	ldr	r2, [pc, #516]	; (804c8d4 <sendGSMCommand+0x2a8>)
 804c6ce:	6853      	ldr	r3, [r2, #4]
 804c6d0:	3302      	adds	r3, #2
 804c6d2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 804c6d6:	4b7d      	ldr	r3, [pc, #500]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c6d8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 804c6dc:	e7e3      	b.n	804c6a6 <sendGSMCommand+0x7a>
						u8LoopCounter = 0;
 804c6de:	4b7b      	ldr	r3, [pc, #492]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c6e0:	2200      	movs	r2, #0
 804c6e2:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
						gu32GSMCharacterTimeout = FIVEHUNDRED_MS;
 804c6e6:	497c      	ldr	r1, [pc, #496]	; (804c8d8 <sendGSMCommand+0x2ac>)
 804c6e8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 804c6ec:	6008      	str	r0, [r1, #0]
						u8CharacterCounter = 0;
 804c6ee:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
						gsmInstance.enmGSMCommandResponseState = enmGSM_CHKRESPONSE;
 804c6f2:	4b74      	ldr	r3, [pc, #464]	; (804c8c4 <sendGSMCommand+0x298>)
 804c6f4:	2201      	movs	r2, #1
 804c6f6:	f883 2e40 	strb.w	r2, [r3, #3648]	; 0xe40
						gsmInstance.u32GSMResponseTimer = gsmStateTableArray[gsmInstance.enmGSMCommand].msTimeOut;
 804c6fa:	f893 1e43 	ldrb.w	r1, [r3, #3651]	; 0xe43
 804c6fe:	4a74      	ldr	r2, [pc, #464]	; (804c8d0 <sendGSMCommand+0x2a4>)
 804c700:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 804c704:	f8d2 26a8 	ldr.w	r2, [r2, #1704]	; 0x6a8
 804c708:	f8c3 2e38 	str.w	r2, [r3, #3640]	; 0xe38
 804c70c:	e797      	b.n	804c63e <sendGSMCommand+0x12>
				initGSMSIM868();
 804c70e:	f7ff fa77 	bl	804bc00 <initGSMSIM868>
 804c712:	e794      	b.n	804c63e <sendGSMCommand+0x12>
			if((gu32GSMCharacterTimeout == 0) && (gsmInstance.u32GSMResponseTimer != 0) && (u8GSMCharRcv == 1) && (gu32FotaFileReadTimer == 0))
 804c714:	4b70      	ldr	r3, [pc, #448]	; (804c8d8 <sendGSMCommand+0x2ac>)
 804c716:	681b      	ldr	r3, [r3, #0]
 804c718:	b93b      	cbnz	r3, 804c72a <sendGSMCommand+0xfe>
 804c71a:	4b6a      	ldr	r3, [pc, #424]	; (804c8c4 <sendGSMCommand+0x298>)
 804c71c:	f8d3 3e38 	ldr.w	r3, [r3, #3640]	; 0xe38
 804c720:	b11b      	cbz	r3, 804c72a <sendGSMCommand+0xfe>
 804c722:	4b6e      	ldr	r3, [pc, #440]	; (804c8dc <sendGSMCommand+0x2b0>)
 804c724:	681b      	ldr	r3, [r3, #0]
 804c726:	2b01      	cmp	r3, #1
 804c728:	d025      	beq.n	804c776 <sendGSMCommand+0x14a>
			else if(gsmInstance.u32GSMResponseTimer == 0)
 804c72a:	4b66      	ldr	r3, [pc, #408]	; (804c8c4 <sendGSMCommand+0x298>)
 804c72c:	f8d3 3e38 	ldr.w	r3, [r3, #3640]	; 0xe38
 804c730:	2b00      	cmp	r3, #0
 804c732:	d184      	bne.n	804c63e <sendGSMCommand+0x12>
				gsmInstance.u8gsmRetryCount--;
 804c734:	4a63      	ldr	r2, [pc, #396]	; (804c8c4 <sendGSMCommand+0x298>)
 804c736:	f892 3e18 	ldrb.w	r3, [r2, #3608]	; 0xe18
 804c73a:	3b01      	subs	r3, #1
 804c73c:	b2db      	uxtb	r3, r3
 804c73e:	f882 3e18 	strb.w	r3, [r2, #3608]	; 0xe18
				if(gsmInstance.u8gsmRetryCount == 0)
 804c742:	2b00      	cmp	r3, #0
 804c744:	f040 84cb 	bne.w	804d0de <sendGSMCommand+0xab2>
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804c748:	f202 4452 	addw	r4, r2, #1106	; 0x452
 804c74c:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804c750:	2100      	movs	r1, #0
 804c752:	4620      	mov	r0, r4
 804c754:	f004 fd36 	bl	80511c4 <memset>
					if(gsmInstance.enmcurrentTask == enmGSMTASK_UPLOADDATA)
 804c758:	f894 39f0 	ldrb.w	r3, [r4, #2544]	; 0x9f0
 804c75c:	b2db      	uxtb	r3, r3
 804c75e:	2b03      	cmp	r3, #3
 804c760:	f000 84b7 	beq.w	804d0d2 <sendGSMCommand+0xaa6>
					initGSMSIM868();
 804c764:	f7ff fa4c 	bl	804bc00 <initGSMSIM868>
				gsmInstance.u32GSMResponseTimer = 0;
 804c768:	2300      	movs	r3, #0
 804c76a:	4a56      	ldr	r2, [pc, #344]	; (804c8c4 <sendGSMCommand+0x298>)
 804c76c:	f8c2 3e38 	str.w	r3, [r2, #3640]	; 0xe38
				u8GSMCharRcv = 0;
 804c770:	4a5a      	ldr	r2, [pc, #360]	; (804c8dc <sendGSMCommand+0x2b0>)
 804c772:	6013      	str	r3, [r2, #0]
}
 804c774:	e763      	b.n	804c63e <sendGSMCommand+0x12>
			if((gu32GSMCharacterTimeout == 0) && (gsmInstance.u32GSMResponseTimer != 0) && (u8GSMCharRcv == 1) && (gu32FotaFileReadTimer == 0))
 804c776:	4b5a      	ldr	r3, [pc, #360]	; (804c8e0 <sendGSMCommand+0x2b4>)
 804c778:	681b      	ldr	r3, [r3, #0]
 804c77a:	2b00      	cmp	r3, #0
 804c77c:	d1d5      	bne.n	804c72a <sendGSMCommand+0xfe>
				if(strstr((const char *)gsmInstance.as8GSM_Response_Buff,(const char*)"http:")!=NULL)
 804c77e:	4959      	ldr	r1, [pc, #356]	; (804c8e4 <sendGSMCommand+0x2b8>)
 804c780:	4859      	ldr	r0, [pc, #356]	; (804c8e8 <sendGSMCommand+0x2bc>)
 804c782:	f004 fdbe 	bl	8051302 <strstr>
 804c786:	b378      	cbz	r0, 804c7e8 <sendGSMCommand+0x1bc>
					const char *SOF = strstr((const char *)gsmInstance.as8GSM_Response_Buff, "$,");
 804c788:	4958      	ldr	r1, [pc, #352]	; (804c8ec <sendGSMCommand+0x2c0>)
 804c78a:	4857      	ldr	r0, [pc, #348]	; (804c8e8 <sendGSMCommand+0x2bc>)
 804c78c:	f004 fdb9 	bl	8051302 <strstr>
					if(SOF != NULL)
 804c790:	4604      	mov	r4, r0
 804c792:	b328      	cbz	r0, 804c7e0 <sendGSMCommand+0x1b4>
						const char *EOFF = strstr((const char *)gsmInstance.as8GSM_Response_Buff, "@");
 804c794:	2140      	movs	r1, #64	; 0x40
 804c796:	4854      	ldr	r0, [pc, #336]	; (804c8e8 <sendGSMCommand+0x2bc>)
 804c798:	f004 fd79 	bl	805128e <strchr>
						if(EOFF != NULL)
 804c79c:	4605      	mov	r5, r0
 804c79e:	b1d0      	cbz	r0, 804c7d6 <sendGSMCommand+0x1aa>
							if(strstr((const char *)gsmInstance.as8GSM_Response_Buff,(const char *)dinfo) != NULL)
 804c7a0:	4953      	ldr	r1, [pc, #332]	; (804c8f0 <sendGSMCommand+0x2c4>)
 804c7a2:	4851      	ldr	r0, [pc, #324]	; (804c8e8 <sendGSMCommand+0x2bc>)
 804c7a4:	f004 fdad 	bl	8051302 <strstr>
 804c7a8:	b180      	cbz	r0, 804c7cc <sendGSMCommand+0x1a0>
								const size_t mlen = EOFF - SOF;
 804c7aa:	1b2d      	subs	r5, r5, r4
								memset(gau8SUBRequest,0x00,sizeof(gau8SUBRequest));
 804c7ac:	4e51      	ldr	r6, [pc, #324]	; (804c8f4 <sendGSMCommand+0x2c8>)
 804c7ae:	2296      	movs	r2, #150	; 0x96
 804c7b0:	2100      	movs	r1, #0
 804c7b2:	4630      	mov	r0, r6
 804c7b4:	f004 fd06 	bl	80511c4 <memset>
								memcpy(gau8SUBRequest,SOF-1, (mlen+3));
 804c7b8:	1cea      	adds	r2, r5, #3
 804c7ba:	1e61      	subs	r1, r4, #1
 804c7bc:	4630      	mov	r0, r6
 804c7be:	f004 fcf3 	bl	80511a8 <memcpy>
								SUBTriggerFlag = TRUE;
 804c7c2:	4b42      	ldr	r3, [pc, #264]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c7c4:	2201      	movs	r2, #1
 804c7c6:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
 804c7ca:	e00d      	b.n	804c7e8 <sendGSMCommand+0x1bc>
								SUBTriggerFlag = FALSE;
 804c7cc:	4b3f      	ldr	r3, [pc, #252]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c7ce:	2200      	movs	r2, #0
 804c7d0:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
 804c7d4:	e008      	b.n	804c7e8 <sendGSMCommand+0x1bc>
							SUBTriggerFlag = FALSE;
 804c7d6:	4b3d      	ldr	r3, [pc, #244]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c7d8:	2200      	movs	r2, #0
 804c7da:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
 804c7de:	e003      	b.n	804c7e8 <sendGSMCommand+0x1bc>
						SUBTriggerFlag = FALSE;
 804c7e0:	4b3a      	ldr	r3, [pc, #232]	; (804c8cc <sendGSMCommand+0x2a0>)
 804c7e2:	2200      	movs	r2, #0
 804c7e4:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
						,(const char *)gsmStateTableArray[gsmInstance.enmGSMCommand].atCommandResponse) != NULL)
 804c7e8:	4836      	ldr	r0, [pc, #216]	; (804c8c4 <sendGSMCommand+0x298>)
 804c7ea:	f890 4e43 	ldrb.w	r4, [r0, #3651]	; 0xe43
				if(strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c7ee:	4b38      	ldr	r3, [pc, #224]	; (804c8d0 <sendGSMCommand+0x2a4>)
 804c7f0:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 804c7f4:	f8d3 16a4 	ldr.w	r1, [r3, #1700]	; 0x6a4
 804c7f8:	f200 4052 	addw	r0, r0, #1106	; 0x452
 804c7fc:	f004 fd81 	bl	8051302 <strstr>
 804c800:	2800      	cmp	r0, #0
 804c802:	f000 8454 	beq.w	804d0ae <sendGSMCommand+0xa82>
					switch(gsmInstance.enmGSMCommand)
 804c806:	2c2b      	cmp	r4, #43	; 0x2b
 804c808:	d831      	bhi.n	804c86e <sendGSMCommand+0x242>
 804c80a:	e8df f014 	tbh	[pc, r4, lsl #1]
 804c80e:	002c      	.short	0x002c
 804c810:	00e80056 	.word	0x00e80056
 804c814:	00960075 	.word	0x00960075
 804c818:	00a0009b 	.word	0x00a0009b
 804c81c:	00aa00a5 	.word	0x00aa00a5
 804c820:	00de00d9 	.word	0x00de00d9
 804c824:	00f200e3 	.word	0x00f200e3
 804c828:	010900f7 	.word	0x010900f7
 804c82c:	0113010e 	.word	0x0113010e
 804c830:	01270122 	.word	0x01270122
 804c834:	014d012c 	.word	0x014d012c
 804c838:	01430148 	.word	0x01430148
 804c83c:	01390134 	.word	0x01390134
 804c840:	0152013e 	.word	0x0152013e
 804c844:	01a90157 	.word	0x01a90157
 804c848:	022700ed 	.word	0x022700ed
 804c84c:	022c0222 	.word	0x022c0222
 804c850:	00300242 	.word	0x00300242
 804c854:	02600247 	.word	0x02600247
 804c858:	0265025b 	.word	0x0265025b
 804c85c:	02eb0279 	.word	0x02eb0279
 804c860:	026f026a 	.word	0x026f026a
 804c864:	0274      	.short	0x0274
							gsmInstance.u8IncrementGsmState = TRUE;
 804c866:	4b17      	ldr	r3, [pc, #92]	; (804c8c4 <sendGSMCommand+0x298>)
 804c868:	2201      	movs	r2, #1
 804c86a:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804c86e:	4b15      	ldr	r3, [pc, #84]	; (804c8c4 <sendGSMCommand+0x298>)
 804c870:	2200      	movs	r2, #0
 804c872:	f8c3 2e3c 	str.w	r2, [r3, #3644]	; 0xe3c
					gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804c876:	2101      	movs	r1, #1
 804c878:	f883 1e41 	strb.w	r1, [r3, #3649]	; 0xe41
					gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804c87c:	f883 2e40 	strb.w	r2, [r3, #3648]	; 0xe40
					gsmInstance.u8gsmRetryCount = GSM_MAX_RETRY;
 804c880:	2105      	movs	r1, #5
 804c882:	f883 1e18 	strb.w	r1, [r3, #3608]	; 0xe18
					gsmInstance.u32GSMResponseTimer = 0;
 804c886:	f8c3 2e38 	str.w	r2, [r3, #3640]	; 0xe38
					u8GSMCharRcv = 0;
 804c88a:	4914      	ldr	r1, [pc, #80]	; (804c8dc <sendGSMCommand+0x2b0>)
 804c88c:	600a      	str	r2, [r1, #0]
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804c88e:	f8c3 2e3c 	str.w	r2, [r3, #3644]	; 0xe3c
					if(gsmInstance.enmGSMCommand != enmGSMSTATE_READFILE)
 804c892:	f893 4e43 	ldrb.w	r4, [r3, #3651]	; 0xe43
 804c896:	2c28      	cmp	r4, #40	; 0x28
 804c898:	f040 8400 	bne.w	804d09c <sendGSMCommand+0xa70>
					if(gsmInstance.u8IncrementGsmState == TRUE)
 804c89c:	4b09      	ldr	r3, [pc, #36]	; (804c8c4 <sendGSMCommand+0x298>)
 804c89e:	f893 3e1c 	ldrb.w	r3, [r3, #3612]	; 0xe1c
 804c8a2:	2b01      	cmp	r3, #1
 804c8a4:	f47f aecb 	bne.w	804c63e <sendGSMCommand+0x12>
						gsmInstance.enmGSMCommand++;
 804c8a8:	4b06      	ldr	r3, [pc, #24]	; (804c8c4 <sendGSMCommand+0x298>)
 804c8aa:	3401      	adds	r4, #1
 804c8ac:	f883 4e43 	strb.w	r4, [r3, #3651]	; 0xe43
						gsmInstance.u32GSMTimer = ONE_SEC;
 804c8b0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804c8b4:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
 804c8b8:	e6c1      	b.n	804c63e <sendGSMCommand+0x12>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c8ba:	4b02      	ldr	r3, [pc, #8]	; (804c8c4 <sendGSMCommand+0x298>)
 804c8bc:	2201      	movs	r2, #1
 804c8be:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c8c2:	e7d4      	b.n	804c86e <sendGSMCommand+0x242>
 804c8c4:	2000c61c 	.word	0x2000c61c
 804c8c8:	40004c00 	.word	0x40004c00
 804c8cc:	2000440c 	.word	0x2000440c
 804c8d0:	20000010 	.word	0x20000010
 804c8d4:	2000d790 	.word	0x2000d790
 804c8d8:	200053d4 	.word	0x200053d4
 804c8dc:	200051f8 	.word	0x200051f8
 804c8e0:	200053e8 	.word	0x200053e8
 804c8e4:	0805a07c 	.word	0x0805a07c
 804c8e8:	2000ca6e 	.word	0x2000ca6e
 804c8ec:	0805a084 	.word	0x0805a084
 804c8f0:	20008a60 	.word	0x20008a60
 804c8f4:	20000980 	.word	0x20000980
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c8f8:	4ebc      	ldr	r6, [pc, #752]	; (804cbec <sendGSMCommand+0x5c0>)
 804c8fa:	49bd      	ldr	r1, [pc, #756]	; (804cbf0 <sendGSMCommand+0x5c4>)
 804c8fc:	4630      	mov	r0, r6
 804c8fe:	f004 fd00 	bl	8051302 <strstr>
 804c902:	4604      	mov	r4, r0
								memset(gau8GSM_TimeStamp,0x00,(sizeof(char ) * strlen(gau8GSM_TimeStamp)));
 804c904:	4dbb      	ldr	r5, [pc, #748]	; (804cbf4 <sendGSMCommand+0x5c8>)
 804c906:	4628      	mov	r0, r5
 804c908:	f7f3 fc72 	bl	80401f0 <strlen>
 804c90c:	4602      	mov	r2, r0
 804c90e:	2100      	movs	r1, #0
 804c910:	4628      	mov	r0, r5
 804c912:	f004 fc57 	bl	80511c4 <memset>
								memcpy( gau8GSM_TimeStamp, &strLoc[8], strlen(strtok(&strLoc[8],"\r")));
 804c916:	3408      	adds	r4, #8
 804c918:	49b7      	ldr	r1, [pc, #732]	; (804cbf8 <sendGSMCommand+0x5cc>)
 804c91a:	4620      	mov	r0, r4
 804c91c:	f005 fb3a 	bl	8051f94 <strtok>
 804c920:	f7f3 fc66 	bl	80401f0 <strlen>
 804c924:	4602      	mov	r2, r0
 804c926:	4621      	mov	r1, r4
 804c928:	4628      	mov	r0, r5
 804c92a:	f004 fc3d 	bl	80511a8 <memcpy>
								syncrtcwithNetworkTime();
 804c92e:	f7ff fcc1 	bl	804c2b4 <syncrtcwithNetworkTime>
								gsmInstance.u8IncrementGsmState = TRUE;
 804c932:	2301      	movs	r3, #1
 804c934:	f886 39ca 	strb.w	r3, [r6, #2506]	; 0x9ca
							break;
 804c938:	e799      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c93a:	4bb0      	ldr	r3, [pc, #704]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c93c:	2201      	movs	r2, #1
 804c93e:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c942:	e794      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c944:	4bad      	ldr	r3, [pc, #692]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c946:	2201      	movs	r2, #1
 804c948:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c94c:	e78f      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c94e:	4bab      	ldr	r3, [pc, #684]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c950:	2201      	movs	r2, #1
 804c952:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c956:	e78a      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c958:	4ba8      	ldr	r3, [pc, #672]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c95a:	2201      	movs	r2, #1
 804c95c:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c960:	e785      	b.n	804c86e <sendGSMCommand+0x242>
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c962:	4ca2      	ldr	r4, [pc, #648]	; (804cbec <sendGSMCommand+0x5c0>)
 804c964:	49a6      	ldr	r1, [pc, #664]	; (804cc00 <sendGSMCommand+0x5d4>)
 804c966:	4620      	mov	r0, r4
 804c968:	f004 fccb 	bl	8051302 <strstr>
								memcpy(gsmInstance.agsmSignalStrength, &strLoc[6], strlen(strtok(strLoc,"\r")));
 804c96c:	1d85      	adds	r5, r0, #6
 804c96e:	49a2      	ldr	r1, [pc, #648]	; (804cbf8 <sendGSMCommand+0x5cc>)
 804c970:	f005 fb10 	bl	8051f94 <strtok>
 804c974:	f7f3 fc3c 	bl	80401f0 <strlen>
 804c978:	4602      	mov	r2, r0
 804c97a:	4629      	mov	r1, r5
 804c97c:	f5a4 706f 	sub.w	r0, r4, #956	; 0x3bc
 804c980:	f004 fc12 	bl	80511a8 <memcpy>
								if(gsmInstance.enmcurrentTask == enmGSMTASK_ISALIVE)
 804c984:	f894 39f0 	ldrb.w	r3, [r4, #2544]	; 0x9f0
 804c988:	f2a4 4452 	subw	r4, r4, #1106	; 0x452
 804c98c:	b2db      	uxtb	r3, r3
 804c98e:	2b06      	cmp	r3, #6
 804c990:	d004      	beq.n	804c99c <sendGSMCommand+0x370>
									gsmInstance.u8IncrementGsmState = TRUE;
 804c992:	4b9a      	ldr	r3, [pc, #616]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c994:	2201      	movs	r2, #1
 804c996:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804c99a:	e768      	b.n	804c86e <sendGSMCommand+0x242>
									gsmInstance.u32GSMHeartbeatTimer = ONE_MIN;
 804c99c:	f64e 2260 	movw	r2, #60000	; 0xea60
 804c9a0:	f8c4 2e30 	str.w	r2, [r4, #3632]	; 0xe30
									gsmInstance.u32GSMTimer = FIVE_SEC;
 804c9a4:	f241 3288 	movw	r2, #5000	; 0x1388
 804c9a8:	f8c4 2e24 	str.w	r2, [r4, #3620]	; 0xe24
									gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804c9ac:	2203      	movs	r2, #3
 804c9ae:	f884 2e42 	strb.w	r2, [r4, #3650]	; 0xe42
									gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804c9b2:	2217      	movs	r2, #23
 804c9b4:	f884 2e43 	strb.w	r2, [r4, #3651]	; 0xe43
									gsmInstance.u8IncrementGsmState = FALSE;
 804c9b8:	2200      	movs	r2, #0
 804c9ba:	f884 2e1c 	strb.w	r2, [r4, #3612]	; 0xe1c
 804c9be:	e756      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9c0:	4b8e      	ldr	r3, [pc, #568]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9c2:	2201      	movs	r2, #1
 804c9c4:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9c8:	e751      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9ca:	4b8c      	ldr	r3, [pc, #560]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9cc:	2201      	movs	r2, #1
 804c9ce:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9d2:	e74c      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9d4:	4b89      	ldr	r3, [pc, #548]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9d6:	2201      	movs	r2, #1
 804c9d8:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9dc:	e747      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9de:	4b87      	ldr	r3, [pc, #540]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9e0:	2201      	movs	r2, #1
 804c9e2:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9e6:	e742      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9e8:	4b84      	ldr	r3, [pc, #528]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9ea:	2201      	movs	r2, #1
 804c9ec:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9f0:	e73d      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804c9f2:	4b82      	ldr	r3, [pc, #520]	; (804cbfc <sendGSMCommand+0x5d0>)
 804c9f4:	2201      	movs	r2, #1
 804c9f6:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804c9fa:	e738      	b.n	804c86e <sendGSMCommand+0x242>
							if(strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804c9fc:	4981      	ldr	r1, [pc, #516]	; (804cc04 <sendGSMCommand+0x5d8>)
 804c9fe:	487b      	ldr	r0, [pc, #492]	; (804cbec <sendGSMCommand+0x5c0>)
 804ca00:	f004 fc7f 	bl	8051302 <strstr>
 804ca04:	b138      	cbz	r0, 804ca16 <sendGSMCommand+0x3ea>
								gsmInstance.u8IncrementGsmState = FALSE;
 804ca06:	4b7d      	ldr	r3, [pc, #500]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca08:	2200      	movs	r2, #0
 804ca0a:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
								gsmInstance.enmGSMCommand += 2;
 804ca0e:	3402      	adds	r4, #2
 804ca10:	f883 4e43 	strb.w	r4, [r3, #3651]	; 0xe43
 804ca14:	e72b      	b.n	804c86e <sendGSMCommand+0x242>
								gsmInstance.u8IncrementGsmState = TRUE;
 804ca16:	4b79      	ldr	r3, [pc, #484]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca18:	2201      	movs	r2, #1
 804ca1a:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804ca1e:	e726      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca20:	4b76      	ldr	r3, [pc, #472]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca22:	2201      	movs	r2, #1
 804ca24:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca28:	e721      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca2a:	4b74      	ldr	r3, [pc, #464]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca2c:	2201      	movs	r2, #1
 804ca2e:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca32:	e71c      	b.n	804c86e <sendGSMCommand+0x242>
							if(gu8FlagNoTerminate == 1)
 804ca34:	4b74      	ldr	r3, [pc, #464]	; (804cc08 <sendGSMCommand+0x5dc>)
 804ca36:	f893 3382 	ldrb.w	r3, [r3, #898]	; 0x382
 804ca3a:	2b01      	cmp	r3, #1
 804ca3c:	d004      	beq.n	804ca48 <sendGSMCommand+0x41c>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca3e:	4b6f      	ldr	r3, [pc, #444]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca40:	2201      	movs	r2, #1
 804ca42:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca46:	e712      	b.n	804c86e <sendGSMCommand+0x242>
								gu8FlagNoTerminate = 0;
 804ca48:	4b6f      	ldr	r3, [pc, #444]	; (804cc08 <sendGSMCommand+0x5dc>)
 804ca4a:	2200      	movs	r2, #0
 804ca4c:	f883 2382 	strb.w	r2, [r3, #898]	; 0x382
 804ca50:	e7f5      	b.n	804ca3e <sendGSMCommand+0x412>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca52:	4b6a      	ldr	r3, [pc, #424]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca54:	2201      	movs	r2, #1
 804ca56:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca5a:	e708      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca5c:	4b67      	ldr	r3, [pc, #412]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca5e:	2201      	movs	r2, #1
 804ca60:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca64:	e703      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804ca66:	4b65      	ldr	r3, [pc, #404]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca68:	2203      	movs	r2, #3
 804ca6a:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
			                  gsmInstance.u8IncrementGsmState = TRUE;
 804ca6e:	2201      	movs	r2, #1
 804ca70:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
			                  break;
 804ca74:	e6fb      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca76:	4b61      	ldr	r3, [pc, #388]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca78:	2201      	movs	r2, #1
 804ca7a:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca7e:	e6f6      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca80:	4b5e      	ldr	r3, [pc, #376]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca82:	2201      	movs	r2, #1
 804ca84:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca88:	e6f1      	b.n	804c86e <sendGSMCommand+0x242>
								gsmInstance.u8IncrementGsmState = TRUE;
 804ca8a:	4b5c      	ldr	r3, [pc, #368]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca8c:	2201      	movs	r2, #1
 804ca8e:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
								break;
 804ca92:	e6ec      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca94:	4b59      	ldr	r3, [pc, #356]	; (804cbfc <sendGSMCommand+0x5d0>)
 804ca96:	2201      	movs	r2, #1
 804ca98:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ca9c:	e6e7      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ca9e:	4b57      	ldr	r3, [pc, #348]	; (804cbfc <sendGSMCommand+0x5d0>)
 804caa0:	2201      	movs	r2, #1
 804caa2:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804caa6:	e6e2      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804caa8:	4b54      	ldr	r3, [pc, #336]	; (804cbfc <sendGSMCommand+0x5d0>)
 804caaa:	2201      	movs	r2, #1
 804caac:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cab0:	e6dd      	b.n	804c86e <sendGSMCommand+0x242>
						gsmInstance.u8IncrementGsmState = TRUE;
 804cab2:	4b52      	ldr	r3, [pc, #328]	; (804cbfc <sendGSMCommand+0x5d0>)
 804cab4:	2201      	movs	r2, #1
 804cab6:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
						break;
 804caba:	e6d8      	b.n	804c86e <sendGSMCommand+0x242>
							char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804cabc:	4c4b      	ldr	r4, [pc, #300]	; (804cbec <sendGSMCommand+0x5c0>)
 804cabe:	4953      	ldr	r1, [pc, #332]	; (804cc0c <sendGSMCommand+0x5e0>)
 804cac0:	4620      	mov	r0, r4
 804cac2:	f004 fc1e 	bl	8051302 <strstr>
							memcpy(gsmInstance.u32GSMMQTTResponseCode, (char *)&strLoc[13], 1);
 804cac6:	7b43      	ldrb	r3, [r0, #13]
 804cac8:	f804 3c03 	strb.w	r3, [r4, #-3]
							switch(atoi(gsmInstance.u32GSMMQTTResponseCode))
 804cacc:	1ee0      	subs	r0, r4, #3
 804cace:	f004 f8c9 	bl	8050c64 <atoi>
 804cad2:	b9f8      	cbnz	r0, 804cb14 <sendGSMCommand+0x4e8>
								dequeue(&gsmPayload);
 804cad4:	484e      	ldr	r0, [pc, #312]	; (804cc10 <sendGSMCommand+0x5e4>)
 804cad6:	f002 ff2b 	bl	804f930 <dequeue>
								gsmInstance.u32GSMTimer = TWO_SEC; // Replace with Upload Frequency
 804cada:	f2a4 4052 	subw	r0, r4, #1106	; 0x452
 804cade:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 804cae2:	f8c0 3e24 	str.w	r3, [r0, #3620]	; 0xe24
								gu8MqttPayloadFlag = 0;
 804cae6:	4c4b      	ldr	r4, [pc, #300]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cae8:	2300      	movs	r3, #0
 804caea:	f884 3109 	strb.w	r3, [r4, #265]	; 0x109
								gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804caee:	2217      	movs	r2, #23
 804caf0:	f880 2e43 	strb.w	r2, [r0, #3651]	; 0xe43
								gsmInstance.u8IncrementGsmState = FALSE;
 804caf4:	f880 3e1c 	strb.w	r3, [r0, #3612]	; 0xe1c
								u8LastMqttResponseCode = atoi(gsmInstance.u32GSMMQTTResponseCode);
 804caf8:	f200 404f 	addw	r0, r0, #1103	; 0x44f
 804cafc:	f004 f8b2 	bl	8050c64 <atoi>
 804cb00:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
								HAL_GPIO_TogglePin(LED_3_GPIO_Port, LED_3_Pin);
 804cb04:	2120      	movs	r1, #32
 804cb06:	4844      	ldr	r0, [pc, #272]	; (804cc18 <sendGSMCommand+0x5ec>)
 804cb08:	f7f6 f8ee 	bl	8042ce8 <HAL_GPIO_TogglePin>
								gu32GSMRestartTimer = THREE_MIN;
 804cb0c:	4b43      	ldr	r3, [pc, #268]	; (804cc1c <sendGSMCommand+0x5f0>)
 804cb0e:	4a44      	ldr	r2, [pc, #272]	; (804cc20 <sendGSMCommand+0x5f4>)
 804cb10:	601a      	str	r2, [r3, #0]
								break;
 804cb12:	e6ac      	b.n	804c86e <sendGSMCommand+0x242>
									u8LastMqttResponseCode = atoi(gsmInstance.u32GSMMQTTResponseCode);
 804cb14:	4c43      	ldr	r4, [pc, #268]	; (804cc24 <sendGSMCommand+0x5f8>)
 804cb16:	4620      	mov	r0, r4
 804cb18:	f004 f8a4 	bl	8050c64 <atoi>
 804cb1c:	4b3d      	ldr	r3, [pc, #244]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cb1e:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
									gsmInstance.u8IllegalMqttResponseCounter++;
 804cb22:	f894 39cf 	ldrb.w	r3, [r4, #2511]	; 0x9cf
 804cb26:	3301      	adds	r3, #1
 804cb28:	b2db      	uxtb	r3, r3
 804cb2a:	f884 39cf 	strb.w	r3, [r4, #2511]	; 0x9cf
									if(gsmInstance.u8IllegalMqttResponseCounter >= MAX_MQTT_ATTEMPTS)
 804cb2e:	2b04      	cmp	r3, #4
 804cb30:	d906      	bls.n	804cb40 <sendGSMCommand+0x514>
										initGSMSIM868();
 804cb32:	f7ff f865 	bl	804bc00 <initGSMSIM868>
										gu8CheckSMS = TRUE;
 804cb36:	4b37      	ldr	r3, [pc, #220]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cb38:	2201      	movs	r2, #1
 804cb3a:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
										break;
 804cb3e:	e696      	b.n	804c86e <sendGSMCommand+0x242>
									u8LastMqttResponseCode = atoi(gsmInstance.u32GSMMQTTResponseCode);
 804cb40:	4c38      	ldr	r4, [pc, #224]	; (804cc24 <sendGSMCommand+0x5f8>)
 804cb42:	4620      	mov	r0, r4
 804cb44:	f004 f88e 	bl	8050c64 <atoi>
 804cb48:	4b32      	ldr	r3, [pc, #200]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cb4a:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
									gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cb4e:	2217      	movs	r2, #23
 804cb50:	f884 29f4 	strb.w	r2, [r4, #2548]	; 0x9f4
									gsmInstance.u32GSMResponseTimer = 0;
 804cb54:	2200      	movs	r2, #0
 804cb56:	f8c4 29e9 	str.w	r2, [r4, #2537]	; 0x9e9
									gsmInstance.u8IncrementGsmState = FALSE;
 804cb5a:	f884 29cd 	strb.w	r2, [r4, #2509]	; 0x9cd
								break;
 804cb5e:	e686      	b.n	804c86e <sendGSMCommand+0x242>
							char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804cb60:	4c22      	ldr	r4, [pc, #136]	; (804cbec <sendGSMCommand+0x5c0>)
 804cb62:	4931      	ldr	r1, [pc, #196]	; (804cc28 <sendGSMCommand+0x5fc>)
 804cb64:	4620      	mov	r0, r4
 804cb66:	f004 fbcc 	bl	8051302 <strstr>
 804cb6a:	4605      	mov	r5, r0
							memset(gsmInstance.agpsLocationData,0x00, strlen(gsmInstance.agpsLocationData));
 804cb6c:	f2a4 4452 	subw	r4, r4, #1106	; 0x452
 804cb70:	4620      	mov	r0, r4
 804cb72:	f7f3 fb3d 	bl	80401f0 <strlen>
 804cb76:	4602      	mov	r2, r0
 804cb78:	2100      	movs	r1, #0
 804cb7a:	4620      	mov	r0, r4
 804cb7c:	f004 fb22 	bl	80511c4 <memset>
							memcpy(gsmInstance.agpsLocationData, (char *)&strLoc[11], strlen(strtok(strLoc,"\r")));//strlen(strtok(strLoc,"\r\n")));
 804cb80:	f105 060b 	add.w	r6, r5, #11
 804cb84:	491c      	ldr	r1, [pc, #112]	; (804cbf8 <sendGSMCommand+0x5cc>)
 804cb86:	4628      	mov	r0, r5
 804cb88:	f005 fa04 	bl	8051f94 <strtok>
 804cb8c:	f7f3 fb30 	bl	80401f0 <strlen>
 804cb90:	4602      	mov	r2, r0
 804cb92:	4631      	mov	r1, r6
 804cb94:	4620      	mov	r0, r4
 804cb96:	f004 fb07 	bl	80511a8 <memcpy>
							gsmInstance.u8IncrementGsmState = FALSE;
 804cb9a:	2300      	movs	r3, #0
 804cb9c:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
							if(strlen(gsmInstance.agpsLocationData) < 10)
 804cba0:	4620      	mov	r0, r4
 804cba2:	f7f3 fb25 	bl	80401f0 <strlen>
 804cba6:	2809      	cmp	r0, #9
 804cba8:	d80e      	bhi.n	804cbc8 <sendGSMCommand+0x59c>
								u32GPSTimeSyncFlag = FALSE;
 804cbaa:	4b1a      	ldr	r3, [pc, #104]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cbac:	2200      	movs	r2, #0
 804cbae:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
							if(gu32ModuleInitComplete == 1)
 804cbb2:	4b18      	ldr	r3, [pc, #96]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cbb4:	681b      	ldr	r3, [r3, #0]
 804cbb6:	2b01      	cmp	r3, #1
 804cbb8:	d00b      	beq.n	804cbd2 <sendGSMCommand+0x5a6>
							else if(gu32ModuleInitComplete == 0)
 804cbba:	2b00      	cmp	r3, #0
 804cbbc:	f47f ae57 	bne.w	804c86e <sendGSMCommand+0x242>
								gu32ModuleInitComplete = 1;
 804cbc0:	4b14      	ldr	r3, [pc, #80]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cbc2:	2201      	movs	r2, #1
 804cbc4:	601a      	str	r2, [r3, #0]
 804cbc6:	e652      	b.n	804c86e <sendGSMCommand+0x242>
								u32GPSTimeSyncFlag = TRUE;
 804cbc8:	4b12      	ldr	r3, [pc, #72]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cbca:	2201      	movs	r2, #1
 804cbcc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 804cbd0:	e7ef      	b.n	804cbb2 <sendGSMCommand+0x586>
								if((gu32FotaRquestFlag == TRUE) && (isQueueEmpty(&gsmPayload) == 1))
 804cbd2:	4b10      	ldr	r3, [pc, #64]	; (804cc14 <sendGSMCommand+0x5e8>)
 804cbd4:	685b      	ldr	r3, [r3, #4]
 804cbd6:	2b01      	cmp	r3, #1
 804cbd8:	d028      	beq.n	804cc2c <sendGSMCommand+0x600>
									gsmInstance.enmGSMCommand = enmGSMSTATE_ATCSQ;
 804cbda:	4b08      	ldr	r3, [pc, #32]	; (804cbfc <sendGSMCommand+0x5d0>)
 804cbdc:	2208      	movs	r2, #8
 804cbde:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
									gsmInstance.enmcurrentTask = enmGSMTASK_ISALIVE;
 804cbe2:	2206      	movs	r2, #6
 804cbe4:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
 804cbe8:	e641      	b.n	804c86e <sendGSMCommand+0x242>
 804cbea:	bf00      	nop
 804cbec:	2000ca6e 	.word	0x2000ca6e
 804cbf0:	0805a088 	.word	0x0805a088
 804cbf4:	2000041c 	.word	0x2000041c
 804cbf8:	0805a090 	.word	0x0805a090
 804cbfc:	2000c61c 	.word	0x2000c61c
 804cc00:	0805a094 	.word	0x0805a094
 804cc04:	0805a09c 	.word	0x0805a09c
 804cc08:	20000010 	.word	0x20000010
 804cc0c:	0805a0a8 	.word	0x0805a0a8
 804cc10:	2000d790 	.word	0x2000d790
 804cc14:	2000440c 	.word	0x2000440c
 804cc18:	40020c00 	.word	0x40020c00
 804cc1c:	200038bc 	.word	0x200038bc
 804cc20:	0002bf20 	.word	0x0002bf20
 804cc24:	2000ca6b 	.word	0x2000ca6b
 804cc28:	0805a0b4 	.word	0x0805a0b4
								if((gu32FotaRquestFlag == TRUE) && (isQueueEmpty(&gsmPayload) == 1))
 804cc2c:	48c4      	ldr	r0, [pc, #784]	; (804cf40 <sendGSMCommand+0x914>)
 804cc2e:	f002 fe99 	bl	804f964 <isQueueEmpty>
 804cc32:	2801      	cmp	r0, #1
 804cc34:	d1d1      	bne.n	804cbda <sendGSMCommand+0x5ae>
									initHTTPURLforFOTA();
 804cc36:	f7ff fcc7 	bl	804c5c8 <initHTTPURLforFOTA>
									gsmInstance.enmGSMCommand = enmGSMSTATE_SETFOTAURL;
 804cc3a:	4bc2      	ldr	r3, [pc, #776]	; (804cf44 <sendGSMCommand+0x918>)
 804cc3c:	2226      	movs	r2, #38	; 0x26
 804cc3e:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
									gsmInstance.enmcurrentTask = enmGSMTASK_DOWNLOADFOTAFILE;
 804cc42:	2208      	movs	r2, #8
 804cc44:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
									SUBTriggerFlag = FALSE;
 804cc48:	4bbf      	ldr	r3, [pc, #764]	; (804cf48 <sendGSMCommand+0x91c>)
 804cc4a:	2200      	movs	r2, #0
 804cc4c:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
 804cc50:	e60d      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc52:	4bbc      	ldr	r3, [pc, #752]	; (804cf44 <sendGSMCommand+0x918>)
 804cc54:	2201      	movs	r2, #1
 804cc56:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc5a:	e608      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc5c:	4bb9      	ldr	r3, [pc, #740]	; (804cf44 <sendGSMCommand+0x918>)
 804cc5e:	2201      	movs	r2, #1
 804cc60:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc64:	e603      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u32GSMHeartbeatTimer = FIVE_SEC;
 804cc66:	4bb7      	ldr	r3, [pc, #732]	; (804cf44 <sendGSMCommand+0x918>)
 804cc68:	f241 3288 	movw	r2, #5000	; 0x1388
 804cc6c:	f8c3 2e30 	str.w	r2, [r3, #3632]	; 0xe30
							gsmInstance.u32GSMTimer = ONE_SEC;
 804cc70:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804cc74:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
							gsmInstance.enmGSMCommand = enmGSMSTATE_ATCSQ;
 804cc78:	2208      	movs	r2, #8
 804cc7a:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
							gsmInstance.enmcurrentTask = enmGSMTASK_ISALIVE;
 804cc7e:	2206      	movs	r2, #6
 804cc80:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
							gsmInstance.u8IncrementGsmState = FALSE;
 804cc84:	2200      	movs	r2, #0
 804cc86:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							gu8SendSMS = FALSE;
 804cc8a:	4baf      	ldr	r3, [pc, #700]	; (804cf48 <sendGSMCommand+0x91c>)
 804cc8c:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
							break;
 804cc90:	e5ed      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cc92:	4bac      	ldr	r3, [pc, #688]	; (804cf44 <sendGSMCommand+0x918>)
 804cc94:	2201      	movs	r2, #1
 804cc96:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cc9a:	e5e8      	b.n	804c86e <sendGSMCommand+0x242>
							sendSystemConfigurationSMS();
 804cc9c:	f7ff f9b8 	bl	804c010 <sendSystemConfigurationSMS>
							gsmInstance.enmcurrentTask = enmGSMTASK_SENDSMS;
 804cca0:	4ca8      	ldr	r4, [pc, #672]	; (804cf44 <sendGSMCommand+0x918>)
 804cca2:	2305      	movs	r3, #5
 804cca4:	f884 3e42 	strb.w	r3, [r4, #3650]	; 0xe42
							gsmInstance.enmGSMCommand = enmGSMSTATE_CMGF;
 804cca8:	231d      	movs	r3, #29
 804ccaa:	f884 3e43 	strb.w	r3, [r4, #3651]	; 0xe43
							memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804ccae:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804ccb2:	2100      	movs	r1, #0
 804ccb4:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804ccb8:	f004 fa84 	bl	80511c4 <memset>
							gsmInstance.u8IncrementGsmState = FALSE;
 804ccbc:	2300      	movs	r3, #0
 804ccbe:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
							break;
 804ccc2:	e5d4      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ccc4:	4b9f      	ldr	r3, [pc, #636]	; (804cf44 <sendGSMCommand+0x918>)
 804ccc6:	2201      	movs	r2, #1
 804ccc8:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cccc:	e5cf      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ccce:	4b9d      	ldr	r3, [pc, #628]	; (804cf44 <sendGSMCommand+0x918>)
 804ccd0:	2201      	movs	r2, #1
 804ccd2:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ccd6:	e5ca      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ccd8:	4b9a      	ldr	r3, [pc, #616]	; (804cf44 <sendGSMCommand+0x918>)
 804ccda:	2201      	movs	r2, #1
 804ccdc:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804cce0:	e5c5      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804cce2:	4b98      	ldr	r3, [pc, #608]	; (804cf44 <sendGSMCommand+0x918>)
 804cce4:	2201      	movs	r2, #1
 804cce6:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ccea:	e5c0      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ccec:	4b95      	ldr	r3, [pc, #596]	; (804cf44 <sendGSMCommand+0x918>)
 804ccee:	2201      	movs	r2, #1
 804ccf0:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ccf4:	e5bb      	b.n	804c86e <sendGSMCommand+0x242>
							gsmInstance.u8IncrementGsmState = TRUE;
 804ccf6:	4b93      	ldr	r3, [pc, #588]	; (804cf44 <sendGSMCommand+0x918>)
 804ccf8:	2201      	movs	r2, #1
 804ccfa:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
							break;
 804ccfe:	e5b6      	b.n	804c86e <sendGSMCommand+0x242>
								char * strLoc = strstr((const char *)gsmInstance.as8GSM_Response_Buff
 804cd00:	4992      	ldr	r1, [pc, #584]	; (804cf4c <sendGSMCommand+0x920>)
 804cd02:	4893      	ldr	r0, [pc, #588]	; (804cf50 <sendGSMCommand+0x924>)
 804cd04:	f004 fafd 	bl	8051302 <strstr>
								if(strLoc != NULL)
 804cd08:	4604      	mov	r4, r0
 804cd0a:	2800      	cmp	r0, #0
 804cd0c:	d04a      	beq.n	804cda4 <sendGSMCommand+0x778>
									gu32GSMHangTimer = THREE_MIN;
 804cd0e:	4b91      	ldr	r3, [pc, #580]	; (804cf54 <sendGSMCommand+0x928>)
 804cd10:	4a91      	ldr	r2, [pc, #580]	; (804cf58 <sendGSMCommand+0x92c>)
 804cd12:	601a      	str	r2, [r3, #0]
									memset(gau32RemoteConfigSizeinBytes,0x00, strlen(gau32RemoteConfigSizeinBytes));
 804cd14:	4d91      	ldr	r5, [pc, #580]	; (804cf5c <sendGSMCommand+0x930>)
 804cd16:	4628      	mov	r0, r5
 804cd18:	f7f3 fa6a 	bl	80401f0 <strlen>
 804cd1c:	4602      	mov	r2, r0
 804cd1e:	2100      	movs	r1, #0
 804cd20:	4628      	mov	r0, r5
 804cd22:	f004 fa4f 	bl	80511c4 <memset>
									memcpy(gau32RemoteConfigSizeinBytes, &strLoc[4], strlen(strtok(&strLoc[4],"\r\n")));
 804cd26:	3404      	adds	r4, #4
 804cd28:	498d      	ldr	r1, [pc, #564]	; (804cf60 <sendGSMCommand+0x934>)
 804cd2a:	4620      	mov	r0, r4
 804cd2c:	f005 f932 	bl	8051f94 <strtok>
 804cd30:	f7f3 fa5e 	bl	80401f0 <strlen>
 804cd34:	4602      	mov	r2, r0
 804cd36:	4621      	mov	r1, r4
 804cd38:	4628      	mov	r0, r5
 804cd3a:	f004 fa35 	bl	80511a8 <memcpy>
									gu32RemoteConfigSizeinBytes = strlen(gau32RemoteConfigSizeinBytes);
 804cd3e:	4628      	mov	r0, r5
 804cd40:	f7f3 fa56 	bl	80401f0 <strlen>
 804cd44:	4b80      	ldr	r3, [pc, #512]	; (804cf48 <sendGSMCommand+0x91c>)
 804cd46:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
									gsmInstance.gu32RemoteConfigSizeinBytes = atoi(gau32RemoteConfigSizeinBytes);
 804cd4a:	4628      	mov	r0, r5
 804cd4c:	f003 ff8a 	bl	8050c64 <atoi>
 804cd50:	4b7c      	ldr	r3, [pc, #496]	; (804cf44 <sendGSMCommand+0x918>)
 804cd52:	f8c3 0e34 	str.w	r0, [r3, #3636]	; 0xe34
									if((gsmInstance.gu32RemoteConfigSizeinBytes) <= ((STM32_FLASHSIZE /2) * 1000))//(MAX_RMT_CONFIG_SIZE_BYTES))
 804cd56:	4b83      	ldr	r3, [pc, #524]	; (804cf64 <sendGSMCommand+0x938>)
 804cd58:	881b      	ldrh	r3, [r3, #0]
 804cd5a:	085a      	lsrs	r2, r3, #1
 804cd5c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804cd60:	fb03 f302 	mul.w	r3, r3, r2
 804cd64:	4298      	cmp	r0, r3
 804cd66:	d80f      	bhi.n	804cd88 <sendGSMCommand+0x75c>
										gu32AttemptFota = TRUE;
 804cd68:	4b77      	ldr	r3, [pc, #476]	; (804cf48 <sendGSMCommand+0x91c>)
 804cd6a:	2201      	movs	r2, #1
 804cd6c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
										if(gsmInstance.gu32RemoteConfigSizeinBytes != 0)
 804cd70:	b130      	cbz	r0, 804cd80 <sendGSMCommand+0x754>
											updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804cd72:	f7ff fb85 	bl	804c480 <updateHTTPReadLength>
									gsmInstance.u8IncrementGsmState = TRUE;
 804cd76:	4b73      	ldr	r3, [pc, #460]	; (804cf44 <sendGSMCommand+0x918>)
 804cd78:	2201      	movs	r2, #1
 804cd7a:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804cd7e:	e576      	b.n	804c86e <sendGSMCommand+0x242>
											Diagnostic(enmDiagnostic_RX_FILE_SIZE_ERROR);
 804cd80:	2006      	movs	r0, #6
 804cd82:	f7ff fc49 	bl	804c618 <Diagnostic>
 804cd86:	e7f6      	b.n	804cd76 <sendGSMCommand+0x74a>
										gsmInstance.u8IncrementGsmState = FALSE;
 804cd88:	4c6e      	ldr	r4, [pc, #440]	; (804cf44 <sendGSMCommand+0x918>)
 804cd8a:	2300      	movs	r3, #0
 804cd8c:	f884 3e1c 	strb.w	r3, [r4, #3612]	; 0xe1c
										Diagnostic(enmDiagnostic_FILE_DONWLOAD_ERROR);
 804cd90:	2007      	movs	r0, #7
 804cd92:	f7ff fc41 	bl	804c618 <Diagnostic>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cd96:	2303      	movs	r3, #3
 804cd98:	f884 3e42 	strb.w	r3, [r4, #3650]	; 0xe42
										gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cd9c:	2317      	movs	r3, #23
 804cd9e:	f884 3e43 	strb.w	r3, [r4, #3651]	; 0xe43
 804cda2:	e7e8      	b.n	804cd76 <sendGSMCommand+0x74a>
									gsmInstance.u8IncrementGsmState = FALSE;
 804cda4:	4e67      	ldr	r6, [pc, #412]	; (804cf44 <sendGSMCommand+0x918>)
 804cda6:	2500      	movs	r5, #0
 804cda8:	f886 5e1c 	strb.w	r5, [r6, #3612]	; 0xe1c
									memset(gsmInstance.u32GSMMQTTResponseCode,0x00,sizeof(gsmInstance.u32GSMMQTTResponseCode));
 804cdac:	f8a6 544f 	strh.w	r5, [r6, #1103]	; 0x44f
 804cdb0:	f886 5451 	strb.w	r5, [r6, #1105]	; 0x451
									memcpy(gsmInstance.u32GSMMQTTResponseCode, (char *)&strLoc[4], 3);
 804cdb4:	4603      	mov	r3, r0
 804cdb6:	f833 1f04 	ldrh.w	r1, [r3, #4]!
 804cdba:	789b      	ldrb	r3, [r3, #2]
 804cdbc:	f8a6 144f 	strh.w	r1, [r6, #1103]	; 0x44f
 804cdc0:	f886 3451 	strb.w	r3, [r6, #1105]	; 0x451
									Diagnostic(enmDiagnostic_FILE_DONWLOAD_ERROR);
 804cdc4:	2007      	movs	r0, #7
 804cdc6:	f7ff fc27 	bl	804c618 <Diagnostic>
								gu32FotaRquestFlag = FALSE;
 804cdca:	4b5f      	ldr	r3, [pc, #380]	; (804cf48 <sendGSMCommand+0x91c>)
 804cdcc:	605d      	str	r5, [r3, #4]
								restoreHTTPURLforData();
 804cdce:	f7ff fb01 	bl	804c3d4 <restoreHTTPURLforData>
								gsmInstance.u8IncrementGsmState = FALSE;
 804cdd2:	f886 5e1c 	strb.w	r5, [r6, #3612]	; 0xe1c
								gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cdd6:	2303      	movs	r3, #3
 804cdd8:	f886 3e42 	strb.w	r3, [r6, #3650]	; 0xe42
								gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cddc:	2317      	movs	r3, #23
 804cdde:	f886 3e43 	strb.w	r3, [r6, #3651]	; 0xe43
 804cde2:	e544      	b.n	804c86e <sendGSMCommand+0x242>
									if(gu32OTATaskNumber == 0)
 804cde4:	4b60      	ldr	r3, [pc, #384]	; (804cf68 <sendGSMCommand+0x93c>)
 804cde6:	f8d3 3428 	ldr.w	r3, [r3, #1064]	; 0x428
 804cdea:	b14b      	cbz	r3, 804ce00 <sendGSMCommand+0x7d4>
									else if(gu32OTATaskNumber == 1)
 804cdec:	2b01      	cmp	r3, #1
 804cdee:	d030      	beq.n	804ce52 <sendGSMCommand+0x826>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cdf0:	4b54      	ldr	r3, [pc, #336]	; (804cf44 <sendGSMCommand+0x918>)
 804cdf2:	2203      	movs	r2, #3
 804cdf4:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
										gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cdf8:	2217      	movs	r2, #23
 804cdfa:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804cdfe:	e536      	b.n	804c86e <sendGSMCommand+0x242>
										char *strloc = strstr((const char *)gsmInstance.as8GSM_Response_Buff,(const char *)"(");
 804ce00:	4c53      	ldr	r4, [pc, #332]	; (804cf50 <sendGSMCommand+0x924>)
 804ce02:	2128      	movs	r1, #40	; 0x28
 804ce04:	4620      	mov	r0, r4
 804ce06:	f004 fa42 	bl	805128e <strchr>
 804ce0a:	4605      	mov	r5, r0
										memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));//
 804ce0c:	4e57      	ldr	r6, [pc, #348]	; (804cf6c <sendGSMCommand+0x940>)
 804ce0e:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804ce12:	2100      	movs	r1, #0
 804ce14:	4630      	mov	r0, r6
 804ce16:	f004 f9d5 	bl	80511c4 <memset>
										memcpy(gau8ConfigData, (char *)strloc, gsmInstance.gu32RemoteConfigSizeinBytes);
 804ce1a:	f8d4 29e2 	ldr.w	r2, [r4, #2530]	; 0x9e2
 804ce1e:	4629      	mov	r1, r5
 804ce20:	4630      	mov	r0, r6
 804ce22:	f004 f9c1 	bl	80511a8 <memcpy>
										restoreHTTPURLforData();
 804ce26:	f7ff fad5 	bl	804c3d4 <restoreHTTPURLforData>
										gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804ce2a:	2303      	movs	r3, #3
 804ce2c:	f884 39f0 	strb.w	r3, [r4, #2544]	; 0x9f0
										gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTDISC;
 804ce30:	232a      	movs	r3, #42	; 0x2a
 804ce32:	f884 39f1 	strb.w	r3, [r4, #2545]	; 0x9f1
										HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_RESET);	// LED ON
 804ce36:	2200      	movs	r2, #0
 804ce38:	f44f 7180 	mov.w	r1, #256	; 0x100
 804ce3c:	484c      	ldr	r0, [pc, #304]	; (804cf70 <sendGSMCommand+0x944>)
 804ce3e:	f7f5 ff4d 	bl	8042cdc <HAL_GPIO_WritePin>
										gsmInstance.u8IncrementGsmState = FALSE;
 804ce42:	2300      	movs	r3, #0
 804ce44:	f884 39ca 	strb.w	r3, [r4, #2506]	; 0x9ca
										gu32NewConfigAvailable = TRUE;
 804ce48:	4b3f      	ldr	r3, [pc, #252]	; (804cf48 <sendGSMCommand+0x91c>)
 804ce4a:	2201      	movs	r2, #1
 804ce4c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
 804ce50:	e50d      	b.n	804c86e <sendGSMCommand+0x242>
										if(u32ConfigFileReadComplete == 0)//u32FotaFileReadComplete
 804ce52:	4b3d      	ldr	r3, [pc, #244]	; (804cf48 <sendGSMCommand+0x91c>)
 804ce54:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 804ce58:	b163      	cbz	r3, 804ce74 <sendGSMCommand+0x848>
										else if(u32ConfigFileReadComplete == 1)
 804ce5a:	2b01      	cmp	r3, #1
 804ce5c:	f000 80aa 	beq.w	804cfb4 <sendGSMCommand+0x988>
											restoreHTTPURLforData();
 804ce60:	f7ff fab8 	bl	804c3d4 <restoreHTTPURLforData>
											gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804ce64:	4b37      	ldr	r3, [pc, #220]	; (804cf44 <sendGSMCommand+0x918>)
 804ce66:	2203      	movs	r2, #3
 804ce68:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
											gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804ce6c:	2217      	movs	r2, #23
 804ce6e:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804ce72:	e4fc      	b.n	804c86e <sendGSMCommand+0x242>
											char *ptr = strstr((const char *)&gsmInstance.as8GSM_Response_Buff,"+HTTPREAD:");
 804ce74:	4e36      	ldr	r6, [pc, #216]	; (804cf50 <sendGSMCommand+0x924>)
 804ce76:	493f      	ldr	r1, [pc, #252]	; (804cf74 <sendGSMCommand+0x948>)
 804ce78:	4630      	mov	r0, r6
 804ce7a:	f004 fa42 	bl	8051302 <strstr>
											char *ptr2 = strstr(ptr,"\n");
 804ce7e:	210a      	movs	r1, #10
 804ce80:	f004 fa05 	bl	805128e <strchr>
 804ce84:	4604      	mov	r4, r0
											memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));
 804ce86:	4d39      	ldr	r5, [pc, #228]	; (804cf6c <sendGSMCommand+0x940>)
 804ce88:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804ce8c:	2100      	movs	r1, #0
 804ce8e:	4628      	mov	r0, r5
 804ce90:	f004 f998 	bl	80511c4 <memset>
											memcpy(gau8ConfigData,(ptr2+1),gsmInstance.gu32RemoteConfigSizeinBytes);
 804ce94:	f8d6 29e2 	ldr.w	r2, [r6, #2530]	; 0x9e2
 804ce98:	1c61      	adds	r1, r4, #1
 804ce9a:	4628      	mov	r0, r5
 804ce9c:	f004 f984 	bl	80511a8 <memcpy>
											if(u32MemoryWriteCycle == FALSE)
 804cea0:	4b29      	ldr	r3, [pc, #164]	; (804cf48 <sendGSMCommand+0x91c>)
 804cea2:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 804cea6:	2b00      	cmp	r3, #0
 804cea8:	d168      	bne.n	804cf7c <sendGSMCommand+0x950>
												if(u32StartofFotaWrite == 0)
 804ceaa:	4b27      	ldr	r3, [pc, #156]	; (804cf48 <sendGSMCommand+0x91c>)
 804ceac:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 804ceb0:	b303      	cbz	r3, 804cef4 <sendGSMCommand+0x8c8>
												u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804ceb2:	2301      	movs	r3, #1
 804ceb4:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804ceb8:	492c      	ldr	r1, [pc, #176]	; (804cf6c <sendGSMCommand+0x940>)
 804ceba:	482f      	ldr	r0, [pc, #188]	; (804cf78 <sendGSMCommand+0x94c>)
 804cebc:	6800      	ldr	r0, [r0, #0]
 804cebe:	f003 fc7b 	bl	80507b8 <WriteDatatoFlash>
 804cec2:	4a21      	ldr	r2, [pc, #132]	; (804cf48 <sendGSMCommand+0x91c>)
 804cec4:	f8c2 0124 	str.w	r0, [r2, #292]	; 0x124
												if(u32FlashMemoryWriteStatus == SUCCESS)
 804cec8:	bb80      	cbnz	r0, 804cf2c <sendGSMCommand+0x900>
													u32MemoryWriteCycle = TRUE;
 804ceca:	4613      	mov	r3, r2
 804cecc:	2201      	movs	r2, #1
 804cece:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
													updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804ced2:	4c1c      	ldr	r4, [pc, #112]	; (804cf44 <sendGSMCommand+0x918>)
 804ced4:	f8d4 0e34 	ldr.w	r0, [r4, #3636]	; 0xe34
 804ced8:	f7ff fad2 	bl	804c480 <updateHTTPReadLength>
													memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t)));
 804cedc:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cee0:	2100      	movs	r1, #0
 804cee2:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804cee6:	f004 f96d 	bl	80511c4 <memset>
											gsmInstance.u8IncrementGsmState = FALSE;
 804ceea:	4b16      	ldr	r3, [pc, #88]	; (804cf44 <sendGSMCommand+0x918>)
 804ceec:	2200      	movs	r2, #0
 804ceee:	f883 2e1c 	strb.w	r2, [r3, #3612]	; 0xe1c
 804cef2:	e4bc      	b.n	804c86e <sendGSMCommand+0x242>
													FLASH_If_Init();
 804cef4:	f003 fc0a 	bl	805070c <FLASH_If_Init>
													if(FLASH_If_Erase_User(0,getNewFirmwareStorageLocation()) != FLASHIF_OK)
 804cef8:	f003 fca0 	bl	805083c <getNewFirmwareStorageLocation>
 804cefc:	4601      	mov	r1, r0
 804cefe:	2000      	movs	r0, #0
 804cf00:	f003 fc60 	bl	80507c4 <FLASH_If_Erase_User>
 804cf04:	b920      	cbnz	r0, 804cf10 <sendGSMCommand+0x8e4>
													u32StartofFotaWrite = 1;
 804cf06:	4b10      	ldr	r3, [pc, #64]	; (804cf48 <sendGSMCommand+0x91c>)
 804cf08:	2201      	movs	r2, #1
 804cf0a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
 804cf0e:	e7d0      	b.n	804ceb2 <sendGSMCommand+0x886>
														restoreHTTPURLforData();
 804cf10:	f7ff fa60 	bl	804c3d4 <restoreHTTPURLforData>
														gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cf14:	f2a6 4352 	subw	r3, r6, #1106	; 0x452
 804cf18:	2203      	movs	r2, #3
 804cf1a:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
														gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cf1e:	2217      	movs	r2, #23
 804cf20:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
														Diagnostic(enmDiagnostic_FLASH_ERRASE_ERROR);
 804cf24:	2008      	movs	r0, #8
 804cf26:	f7ff fb77 	bl	804c618 <Diagnostic>
 804cf2a:	e7ec      	b.n	804cf06 <sendGSMCommand+0x8da>
													restoreHTTPURLforData();
 804cf2c:	f7ff fa52 	bl	804c3d4 <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cf30:	4b04      	ldr	r3, [pc, #16]	; (804cf44 <sendGSMCommand+0x918>)
 804cf32:	2203      	movs	r2, #3
 804cf34:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
													gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cf38:	2217      	movs	r2, #23
 804cf3a:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804cf3e:	e7d4      	b.n	804ceea <sendGSMCommand+0x8be>
 804cf40:	2000d790 	.word	0x2000d790
 804cf44:	2000c61c 	.word	0x2000c61c
 804cf48:	2000440c 	.word	0x2000440c
 804cf4c:	0805a0c0 	.word	0x0805a0c0
 804cf50:	2000ca6e 	.word	0x2000ca6e
 804cf54:	200053d8 	.word	0x200053d8
 804cf58:	0002bf20 	.word	0x0002bf20
 804cf5c:	20000a18 	.word	0x20000a18
 804cf60:	08059fd0 	.word	0x08059fd0
 804cf64:	1fff7a22 	.word	0x1fff7a22
 804cf68:	20000010 	.word	0x20000010
 804cf6c:	2000bc58 	.word	0x2000bc58
 804cf70:	40020c00 	.word	0x40020c00
 804cf74:	0805a0c8 	.word	0x0805a0c8
 804cf78:	200052b4 	.word	0x200052b4
												u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804cf7c:	2301      	movs	r3, #1
 804cf7e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804cf82:	4960      	ldr	r1, [pc, #384]	; (804d104 <sendGSMCommand+0xad8>)
 804cf84:	4860      	ldr	r0, [pc, #384]	; (804d108 <sendGSMCommand+0xadc>)
 804cf86:	6800      	ldr	r0, [r0, #0]
 804cf88:	f003 fc16 	bl	80507b8 <WriteDatatoFlash>
 804cf8c:	4a5f      	ldr	r2, [pc, #380]	; (804d10c <sendGSMCommand+0xae0>)
 804cf8e:	f8c2 0124 	str.w	r0, [r2, #292]	; 0x124
												if(u32FlashMemoryWriteStatus == SUCCESS)
 804cf92:	b928      	cbnz	r0, 804cfa0 <sendGSMCommand+0x974>
													updateHTTPReadLength(gsmInstance.gu32RemoteConfigSizeinBytes);
 804cf94:	4b5e      	ldr	r3, [pc, #376]	; (804d110 <sendGSMCommand+0xae4>)
 804cf96:	f8d3 0e34 	ldr.w	r0, [r3, #3636]	; 0xe34
 804cf9a:	f7ff fa71 	bl	804c480 <updateHTTPReadLength>
 804cf9e:	e7a4      	b.n	804ceea <sendGSMCommand+0x8be>
													restoreHTTPURLforData();
 804cfa0:	f7ff fa18 	bl	804c3d4 <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804cfa4:	4b5a      	ldr	r3, [pc, #360]	; (804d110 <sendGSMCommand+0xae4>)
 804cfa6:	2203      	movs	r2, #3
 804cfa8:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
													gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804cfac:	2217      	movs	r2, #23
 804cfae:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804cfb2:	e79a      	b.n	804ceea <sendGSMCommand+0x8be>
											char *ptr = strstr((const char *)&gsmInstance.as8GSM_Response_Buff,"+HTTPREAD:");
 804cfb4:	4e57      	ldr	r6, [pc, #348]	; (804d114 <sendGSMCommand+0xae8>)
 804cfb6:	4958      	ldr	r1, [pc, #352]	; (804d118 <sendGSMCommand+0xaec>)
 804cfb8:	4630      	mov	r0, r6
 804cfba:	f004 f9a2 	bl	8051302 <strstr>
											char *ptr2 = strstr(ptr,"\n");
 804cfbe:	210a      	movs	r1, #10
 804cfc0:	f004 f965 	bl	805128e <strchr>
 804cfc4:	4604      	mov	r4, r0
											memset(gau8ConfigData,0x00,sizeof(gau8ConfigData));
 804cfc6:	4d4f      	ldr	r5, [pc, #316]	; (804d104 <sendGSMCommand+0xad8>)
 804cfc8:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804cfcc:	2100      	movs	r1, #0
 804cfce:	4628      	mov	r0, r5
 804cfd0:	f004 f8f8 	bl	80511c4 <memset>
											memcpy(gau8ConfigData,(ptr2+1),gsmInstance.gu32RemoteConfigSizeinBytes);
 804cfd4:	f8d6 29e2 	ldr.w	r2, [r6, #2530]	; 0x9e2
 804cfd8:	1c61      	adds	r1, r4, #1
 804cfda:	4628      	mov	r0, r5
 804cfdc:	f004 f8e4 	bl	80511a8 <memcpy>
											if(u32MemoryWriteCycle == FALSE)
 804cfe0:	4b4a      	ldr	r3, [pc, #296]	; (804d10c <sendGSMCommand+0xae0>)
 804cfe2:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 804cfe6:	b383      	cbz	r3, 804d04a <sendGSMCommand+0xa1e>
											u32FlashMemoryWriteStatus = WriteDatatoFlash(u32LastMemoryWriteLocation,(uint8_t *)gau8ConfigData,1024,1);
 804cfe8:	2301      	movs	r3, #1
 804cfea:	f44f 6280 	mov.w	r2, #1024	; 0x400
 804cfee:	4945      	ldr	r1, [pc, #276]	; (804d104 <sendGSMCommand+0xad8>)
 804cff0:	4845      	ldr	r0, [pc, #276]	; (804d108 <sendGSMCommand+0xadc>)
 804cff2:	6800      	ldr	r0, [r0, #0]
 804cff4:	f003 fbe0 	bl	80507b8 <WriteDatatoFlash>
 804cff8:	4b44      	ldr	r3, [pc, #272]	; (804d10c <sendGSMCommand+0xae0>)
 804cffa:	f8c3 0124 	str.w	r0, [r3, #292]	; 0x124
											if(flashWriteBootSection(getNewFirmwareStorageLocation()) == 0)
 804cffe:	f003 fc1d 	bl	805083c <getNewFirmwareStorageLocation>
 804d002:	f003 fc43 	bl	805088c <flashWriteBootSection>
 804d006:	2800      	cmp	r0, #0
 804d008:	d13b      	bne.n	804d082 <sendGSMCommand+0xa56>
												gu32AttemptFota =  FALSE;
 804d00a:	4b40      	ldr	r3, [pc, #256]	; (804d10c <sendGSMCommand+0xae0>)
 804d00c:	2200      	movs	r2, #0
 804d00e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
												if(u32MemoryWriteCycle == TRUE)
 804d012:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 804d016:	2b01      	cmp	r3, #1
 804d018:	d02f      	beq.n	804d07a <sendGSMCommand+0xa4e>
												gu32FotaRquestFlag = FALSE;
 804d01a:	2000      	movs	r0, #0
 804d01c:	4b3b      	ldr	r3, [pc, #236]	; (804d10c <sendGSMCommand+0xae0>)
 804d01e:	6058      	str	r0, [r3, #4]
												Diagnostic(enmDiagnostic_FOTA_SUCCESS_OK);
 804d020:	f7ff fafa 	bl	804c618 <Diagnostic>
												FOTACompleteFlag = TRUE;
 804d024:	4b3d      	ldr	r3, [pc, #244]	; (804d11c <sendGSMCommand+0xaf0>)
 804d026:	2201      	movs	r2, #1
 804d028:	701a      	strb	r2, [r3, #0]
												gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d02a:	4b39      	ldr	r3, [pc, #228]	; (804d110 <sendGSMCommand+0xae4>)
 804d02c:	2203      	movs	r2, #3
 804d02e:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
												gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804d032:	2217      	movs	r2, #23
 804d034:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
												HAL_Delay(50000);
 804d038:	f24c 3050 	movw	r0, #50000	; 0xc350
 804d03c:	f7f4 f836 	bl	80410ac <HAL_Delay>
											u32MemoryWriteCycle = TRUE;
 804d040:	4b32      	ldr	r3, [pc, #200]	; (804d10c <sendGSMCommand+0xae0>)
 804d042:	2201      	movs	r2, #1
 804d044:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 804d048:	e411      	b.n	804c86e <sendGSMCommand+0x242>
												FLASH_If_Init();
 804d04a:	f003 fb5f 	bl	805070c <FLASH_If_Init>
												u32MemoryEraseStatus = FLASH_If_Erase_User(0,getNewFirmwareStorageLocation());
 804d04e:	f003 fbf5 	bl	805083c <getNewFirmwareStorageLocation>
 804d052:	4601      	mov	r1, r0
 804d054:	2000      	movs	r0, #0
 804d056:	f003 fbb5 	bl	80507c4 <FLASH_If_Erase_User>
 804d05a:	4a2c      	ldr	r2, [pc, #176]	; (804d10c <sendGSMCommand+0xae0>)
 804d05c:	f8c2 0128 	str.w	r0, [r2, #296]	; 0x128
												if(u32MemoryEraseStatus != FLASHIF_OK)
 804d060:	2800      	cmp	r0, #0
 804d062:	d0c1      	beq.n	804cfe8 <sendGSMCommand+0x9bc>
													restoreHTTPURLforData();
 804d064:	f7ff f9b6 	bl	804c3d4 <restoreHTTPURLforData>
													gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d068:	f2a6 4352 	subw	r3, r6, #1106	; 0x452
 804d06c:	2203      	movs	r2, #3
 804d06e:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
													gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804d072:	2217      	movs	r2, #23
 804d074:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804d078:	e7b6      	b.n	804cfe8 <sendGSMCommand+0x9bc>
													u32MemoryWriteCycle = FALSE;
 804d07a:	4b24      	ldr	r3, [pc, #144]	; (804d10c <sendGSMCommand+0xae0>)
 804d07c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 804d080:	e7cb      	b.n	804d01a <sendGSMCommand+0x9ee>
												gu32FotaRquestFlag = FALSE;
 804d082:	4b22      	ldr	r3, [pc, #136]	; (804d10c <sendGSMCommand+0xae0>)
 804d084:	2200      	movs	r2, #0
 804d086:	605a      	str	r2, [r3, #4]
												restoreHTTPURLforData();
 804d088:	f7ff f9a4 	bl	804c3d4 <restoreHTTPURLforData>
												gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d08c:	4b20      	ldr	r3, [pc, #128]	; (804d110 <sendGSMCommand+0xae4>)
 804d08e:	2203      	movs	r2, #3
 804d090:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
												gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804d094:	2217      	movs	r2, #23
 804d096:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
 804d09a:	e7d1      	b.n	804d040 <sendGSMCommand+0xa14>
						memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t))); /* Clear Response Buffer */
 804d09c:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804d0a0:	2100      	movs	r1, #0
 804d0a2:	f203 4052 	addw	r0, r3, #1106	; 0x452
 804d0a6:	f004 f88d 	bl	80511c4 <memset>
 804d0aa:	f7ff bbf7 	b.w	804c89c <sendGSMCommand+0x270>
					gsmInstance.u8GSM_Response_Character_Counter = 0;
 804d0ae:	4818      	ldr	r0, [pc, #96]	; (804d110 <sendGSMCommand+0xae4>)
 804d0b0:	2400      	movs	r4, #0
 804d0b2:	f8c0 4e3c 	str.w	r4, [r0, #3644]	; 0xe3c
					gsmInstance.enmGSMCommandResponseState = enmGSM_CMDSEND;
 804d0b6:	2301      	movs	r3, #1
 804d0b8:	f880 3e40 	strb.w	r3, [r0, #3648]	; 0xe40
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR,(GSM_RESPONSE_ARRAY_SIZE * sizeof(uint8_t))); /* Clear Response Buffer */
 804d0bc:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804d0c0:	4621      	mov	r1, r4
 804d0c2:	f200 4052 	addw	r0, r0, #1106	; 0x452
 804d0c6:	f004 f87d 	bl	80511c4 <memset>
					u8GSMCharRcv = 0;
 804d0ca:	4b15      	ldr	r3, [pc, #84]	; (804d120 <sendGSMCommand+0xaf4>)
 804d0cc:	601c      	str	r4, [r3, #0]
 804d0ce:	f7ff bab6 	b.w	804c63e <sendGSMCommand+0x12>
						gu8CheckSMS = TRUE;
 804d0d2:	4b0e      	ldr	r3, [pc, #56]	; (804d10c <sendGSMCommand+0xae0>)
 804d0d4:	2201      	movs	r2, #1
 804d0d6:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
 804d0da:	f7ff bb43 	b.w	804c764 <sendGSMCommand+0x138>
					gsmInstance.enmGSMCommandState = enmGSM_CMDSEND;
 804d0de:	4c0c      	ldr	r4, [pc, #48]	; (804d110 <sendGSMCommand+0xae4>)
 804d0e0:	2301      	movs	r3, #1
 804d0e2:	f884 3e41 	strb.w	r3, [r4, #3649]	; 0xe41
					gsmInstance.enmGSMCommandResponseState = enmGSM_SENDCMD;
 804d0e6:	2100      	movs	r1, #0
 804d0e8:	f884 1e40 	strb.w	r1, [r4, #3648]	; 0xe40
					memset((char *)gsmInstance.as8GSM_Response_Buff, GSM_ARRAY_INIT_CHAR, (GSM_RESPONSE_ARRAY_SIZE));
 804d0ec:	f640 12c4 	movw	r2, #2500	; 0x9c4
 804d0f0:	f204 4052 	addw	r0, r4, #1106	; 0x452
 804d0f4:	f004 f866 	bl	80511c4 <memset>
					gsmInstance.u32GSMTimer = ONE_SEC;
 804d0f8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 804d0fc:	f8c4 3e24 	str.w	r3, [r4, #3620]	; 0xe24
 804d100:	f7ff bb32 	b.w	804c768 <sendGSMCommand+0x13c>
 804d104:	2000bc58 	.word	0x2000bc58
 804d108:	200052b4 	.word	0x200052b4
 804d10c:	2000440c 	.word	0x2000440c
 804d110:	2000c61c 	.word	0x2000c61c
 804d114:	2000ca6e 	.word	0x2000ca6e
 804d118:	0805a0c8 	.word	0x0805a0c8
 804d11c:	20004fa4 	.word	0x20004fa4
 804d120:	200051f8 	.word	0x200051f8

0804d124 <operateGSMSIM868>:
	if(gsmInstance.u32GSMTimer != 0)
 804d124:	4b97      	ldr	r3, [pc, #604]	; (804d384 <operateGSMSIM868+0x260>)
 804d126:	f8d3 3e24 	ldr.w	r3, [r3, #3620]	; 0xe24
 804d12a:	2b00      	cmp	r3, #0
 804d12c:	f040 8128 	bne.w	804d380 <operateGSMSIM868+0x25c>
{
 804d130:	b510      	push	{r4, lr}
 804d132:	f5ad 5d8b 	sub.w	sp, sp, #4448	; 0x1160
 804d136:	b082      	sub	sp, #8
	switch(gsmInstance.enmcurrentTask)
 804d138:	4b92      	ldr	r3, [pc, #584]	; (804d384 <operateGSMSIM868+0x260>)
 804d13a:	f893 3e42 	ldrb.w	r3, [r3, #3650]	; 0xe42
 804d13e:	b2db      	uxtb	r3, r3
 804d140:	2b09      	cmp	r3, #9
 804d142:	f200 811a 	bhi.w	804d37a <operateGSMSIM868+0x256>
 804d146:	e8df f013 	tbh	[pc, r3, lsl #1]
 804d14a:	000a      	.short	0x000a
 804d14c:	00b20030 	.word	0x00b20030
 804d150:	007600c5 	.word	0x007600c5
 804d154:	00640094 	.word	0x00640094
 804d158:	01030100 	.word	0x01030100
 804d15c:	0110      	.short	0x0110
			if(gsmInstance.enmGSMPwrState == enmGSM_PWRNOTSTARTED)
 804d15e:	4b89      	ldr	r3, [pc, #548]	; (804d384 <operateGSMSIM868+0x260>)
 804d160:	f893 3e44 	ldrb.w	r3, [r3, #3652]	; 0xe44
 804d164:	b19b      	cbz	r3, 804d18e <operateGSMSIM868+0x6a>
			else if(gsmInstance.enmGSMPwrState == enmGSM_PWRSTARTED)
 804d166:	2b01      	cmp	r3, #1
 804d168:	f040 80ad 	bne.w	804d2c6 <operateGSMSIM868+0x1a2>
				HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_RESET);
 804d16c:	2200      	movs	r2, #0
 804d16e:	2180      	movs	r1, #128	; 0x80
 804d170:	4885      	ldr	r0, [pc, #532]	; (804d388 <operateGSMSIM868+0x264>)
 804d172:	f7f5 fdb3 	bl	8042cdc <HAL_GPIO_WritePin>
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d176:	4b83      	ldr	r3, [pc, #524]	; (804d384 <operateGSMSIM868+0x260>)
 804d178:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d17c:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
				gsmInstance.enmcurrentTask = enmGSMTASK_INITMODULE;
 804d180:	2201      	movs	r2, #1
 804d182:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
				gsmInstance.enmGSMPwrState = enmGSM_PWRCOMPLETED;
 804d186:	2202      	movs	r2, #2
 804d188:	f883 2e44 	strb.w	r2, [r3, #3652]	; 0xe44
 804d18c:	e09b      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_SET);
 804d18e:	2201      	movs	r2, #1
 804d190:	2180      	movs	r1, #128	; 0x80
 804d192:	487d      	ldr	r0, [pc, #500]	; (804d388 <operateGSMSIM868+0x264>)
 804d194:	f7f5 fda2 	bl	8042cdc <HAL_GPIO_WritePin>
				gsmInstance.u32GSMTimer = FIVE_SEC;
 804d198:	4b7a      	ldr	r3, [pc, #488]	; (804d384 <operateGSMSIM868+0x260>)
 804d19a:	f241 3288 	movw	r2, #5000	; 0x1388
 804d19e:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
				gsmInstance.enmGSMPwrState = enmGSM_PWRSTARTED;
 804d1a2:	2201      	movs	r2, #1
 804d1a4:	f883 2e44 	strb.w	r2, [r3, #3652]	; 0xe44
 804d1a8:	e08d      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			if(gsmInstance.enmGSMCommandState == enmGSM_CMDTIMEOUT)
 804d1aa:	4b76      	ldr	r3, [pc, #472]	; (804d384 <operateGSMSIM868+0x260>)
 804d1ac:	f893 3e41 	ldrb.w	r3, [r3, #3649]	; 0xe41
 804d1b0:	b2db      	uxtb	r3, r3
 804d1b2:	2b05      	cmp	r3, #5
 804d1b4:	d011      	beq.n	804d1da <operateGSMSIM868+0xb6>
				if(gsmInstance.enmGSMCommand == enmGSMSTATE_CMQTTTOPIC)
 804d1b6:	4b73      	ldr	r3, [pc, #460]	; (804d384 <operateGSMSIM868+0x260>)
 804d1b8:	f893 3e43 	ldrb.w	r3, [r3, #3651]	; 0xe43
 804d1bc:	2b17      	cmp	r3, #23
 804d1be:	d11b      	bne.n	804d1f8 <operateGSMSIM868+0xd4>
					if(gu8CheckSMS == TRUE)
 804d1c0:	4b72      	ldr	r3, [pc, #456]	; (804d38c <operateGSMSIM868+0x268>)
 804d1c2:	f893 310a 	ldrb.w	r3, [r3, #266]	; 0x10a
 804d1c6:	2b01      	cmp	r3, #1
 804d1c8:	d00a      	beq.n	804d1e0 <operateGSMSIM868+0xbc>
						gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d1ca:	4b6e      	ldr	r3, [pc, #440]	; (804d384 <operateGSMSIM868+0x260>)
 804d1cc:	221c      	movs	r2, #28
 804d1ce:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
						gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d1d2:	2202      	movs	r2, #2
 804d1d4:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
 804d1d8:	e075      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				initGSMSIM868();
 804d1da:	f7fe fd11 	bl	804bc00 <initGSMSIM868>
 804d1de:	e072      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
						gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d1e0:	4b68      	ldr	r3, [pc, #416]	; (804d384 <operateGSMSIM868+0x260>)
 804d1e2:	2203      	movs	r2, #3
 804d1e4:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
						gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804d1e8:	2217      	movs	r2, #23
 804d1ea:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
						gu8CheckSMS = FALSE;
 804d1ee:	4b67      	ldr	r3, [pc, #412]	; (804d38c <operateGSMSIM868+0x268>)
 804d1f0:	2200      	movs	r2, #0
 804d1f2:	f883 210a 	strb.w	r2, [r3, #266]	; 0x10a
 804d1f6:	e066      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
					sendGSMCommand(gsmInstance);
 804d1f8:	4c62      	ldr	r4, [pc, #392]	; (804d384 <operateGSMSIM868+0x260>)
 804d1fa:	f241 1264 	movw	r2, #4452	; 0x1164
 804d1fe:	f104 0110 	add.w	r1, r4, #16
 804d202:	4668      	mov	r0, sp
 804d204:	f003 ffd0 	bl	80511a8 <memcpy>
 804d208:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d20c:	f7ff fa0e 	bl	804c62c <sendGSMCommand>
 804d210:	e059      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			if(gsmInstance.u32GSMHeartbeatTimer == 0)
 804d212:	4b5c      	ldr	r3, [pc, #368]	; (804d384 <operateGSMSIM868+0x260>)
 804d214:	f8d3 3e30 	ldr.w	r3, [r3, #3632]	; 0xe30
 804d218:	2b00      	cmp	r3, #0
 804d21a:	d154      	bne.n	804d2c6 <operateGSMSIM868+0x1a2>
				sendGSMCommand(gsmInstance);
 804d21c:	4c59      	ldr	r4, [pc, #356]	; (804d384 <operateGSMSIM868+0x260>)
 804d21e:	f241 1264 	movw	r2, #4452	; 0x1164
 804d222:	f104 0110 	add.w	r1, r4, #16
 804d226:	4668      	mov	r0, sp
 804d228:	f003 ffbe 	bl	80511a8 <memcpy>
 804d22c:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d230:	f7ff f9fc 	bl	804c62c <sendGSMCommand>
 804d234:	e047      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			if(gu8ReadSMS == TRUE)
 804d236:	4b55      	ldr	r3, [pc, #340]	; (804d38c <operateGSMSIM868+0x268>)
 804d238:	f893 312c 	ldrb.w	r3, [r3, #300]	; 0x12c
 804d23c:	2b01      	cmp	r3, #1
 804d23e:	d00b      	beq.n	804d258 <operateGSMSIM868+0x134>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d240:	4b50      	ldr	r3, [pc, #320]	; (804d384 <operateGSMSIM868+0x260>)
 804d242:	221c      	movs	r2, #28
 804d244:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d248:	2202      	movs	r2, #2
 804d24a:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d24e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d252:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
 804d256:	e036      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				sendGSMCommand(gsmInstance);
 804d258:	4c4a      	ldr	r4, [pc, #296]	; (804d384 <operateGSMSIM868+0x260>)
 804d25a:	f241 1264 	movw	r2, #4452	; 0x1164
 804d25e:	f104 0110 	add.w	r1, r4, #16
 804d262:	4668      	mov	r0, sp
 804d264:	f003 ffa0 	bl	80511a8 <memcpy>
 804d268:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d26c:	f7ff f9de 	bl	804c62c <sendGSMCommand>
 804d270:	e029      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			if(gu8SendSMS == TRUE)
 804d272:	4b46      	ldr	r3, [pc, #280]	; (804d38c <operateGSMSIM868+0x268>)
 804d274:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
 804d278:	2b01      	cmp	r3, #1
 804d27a:	d00b      	beq.n	804d294 <operateGSMSIM868+0x170>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d27c:	4b41      	ldr	r3, [pc, #260]	; (804d384 <operateGSMSIM868+0x260>)
 804d27e:	221c      	movs	r2, #28
 804d280:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d284:	2202      	movs	r2, #2
 804d286:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
				gsmInstance.u32GSMTimer = TWO_SEC;
 804d28a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804d28e:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
 804d292:	e018      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				sendGSMCommand(gsmInstance);
 804d294:	4c3b      	ldr	r4, [pc, #236]	; (804d384 <operateGSMSIM868+0x260>)
 804d296:	f241 1264 	movw	r2, #4452	; 0x1164
 804d29a:	f104 0110 	add.w	r1, r4, #16
 804d29e:	4668      	mov	r0, sp
 804d2a0:	f003 ff82 	bl	80511a8 <memcpy>
 804d2a4:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d2a8:	f7ff f9c0 	bl	804c62c <sendGSMCommand>
 804d2ac:	e00b      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			sendGSMCommand(gsmInstance);
 804d2ae:	4c35      	ldr	r4, [pc, #212]	; (804d384 <operateGSMSIM868+0x260>)
 804d2b0:	f241 1264 	movw	r2, #4452	; 0x1164
 804d2b4:	f104 0110 	add.w	r1, r4, #16
 804d2b8:	4668      	mov	r0, sp
 804d2ba:	f003 ff75 	bl	80511a8 <memcpy>
 804d2be:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d2c2:	f7ff f9b3 	bl	804c62c <sendGSMCommand>
	gu32GSMHangTimer = THREE_MIN;
 804d2c6:	4b32      	ldr	r3, [pc, #200]	; (804d390 <operateGSMSIM868+0x26c>)
 804d2c8:	4a32      	ldr	r2, [pc, #200]	; (804d394 <operateGSMSIM868+0x270>)
 804d2ca:	601a      	str	r2, [r3, #0]
}
 804d2cc:	f50d 5d8b 	add.w	sp, sp, #4448	; 0x1160
 804d2d0:	b002      	add	sp, #8
 804d2d2:	bd10      	pop	{r4, pc}
			if((isQueueEmpty(&gsmPayload) == FALSE )&& (gsmPayload.data[gsmPayload.tail] != NULL))
 804d2d4:	4830      	ldr	r0, [pc, #192]	; (804d398 <operateGSMSIM868+0x274>)
 804d2d6:	f002 fb45 	bl	804f964 <isQueueEmpty>
 804d2da:	bb70      	cbnz	r0, 804d33a <operateGSMSIM868+0x216>
 804d2dc:	4a2e      	ldr	r2, [pc, #184]	; (804d398 <operateGSMSIM868+0x274>)
 804d2de:	6853      	ldr	r3, [r2, #4]
 804d2e0:	3302      	adds	r3, #2
 804d2e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 804d2e6:	b343      	cbz	r3, 804d33a <operateGSMSIM868+0x216>
				if((gu8MqttPayloadFlag == 0) && (gsmInstance.enmGSMCommand == enmGSMSTATE_CMQTTTOPIC))
 804d2e8:	4b28      	ldr	r3, [pc, #160]	; (804d38c <operateGSMSIM868+0x268>)
 804d2ea:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
 804d2ee:	b923      	cbnz	r3, 804d2fa <operateGSMSIM868+0x1d6>
 804d2f0:	4a24      	ldr	r2, [pc, #144]	; (804d384 <operateGSMSIM868+0x260>)
 804d2f2:	f892 2e43 	ldrb.w	r2, [r2, #3651]	; 0xe43
 804d2f6:	2a17      	cmp	r2, #23
 804d2f8:	d013      	beq.n	804d322 <operateGSMSIM868+0x1fe>
				else if((gu8MqttPayloadFlag == 1) && (gsmInstance.enmGSMCommand == enmGSMSTATE_SENDDATA))
 804d2fa:	2b01      	cmp	r3, #1
 804d2fc:	d104      	bne.n	804d308 <operateGSMSIM868+0x1e4>
 804d2fe:	4b21      	ldr	r3, [pc, #132]	; (804d384 <operateGSMSIM868+0x260>)
 804d300:	f893 3e43 	ldrb.w	r3, [r3, #3651]	; 0xe43
 804d304:	2b1a      	cmp	r3, #26
 804d306:	d013      	beq.n	804d330 <operateGSMSIM868+0x20c>
					sendGSMCommand(gsmInstance);
 804d308:	4c1e      	ldr	r4, [pc, #120]	; (804d384 <operateGSMSIM868+0x260>)
 804d30a:	f241 1264 	movw	r2, #4452	; 0x1164
 804d30e:	f104 0110 	add.w	r1, r4, #16
 804d312:	4668      	mov	r0, sp
 804d314:	f003 ff48 	bl	80511a8 <memcpy>
 804d318:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d31c:	f7ff f986 	bl	804c62c <sendGSMCommand>
 804d320:	e7d1      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
					updateMqttDataLength();
 804d322:	f7fe fd53 	bl	804bdcc <updateMqttDataLength>
					gu8MqttPayloadFlag = 1;
 804d326:	4b19      	ldr	r3, [pc, #100]	; (804d38c <operateGSMSIM868+0x268>)
 804d328:	2201      	movs	r2, #1
 804d32a:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
 804d32e:	e7ca      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
					gu8MqttPayloadFlag = 0;
 804d330:	4b16      	ldr	r3, [pc, #88]	; (804d38c <operateGSMSIM868+0x268>)
 804d332:	2200      	movs	r2, #0
 804d334:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
 804d338:	e7c5      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				gsmInstance.enmGSMCommand = enmGSMSTATE_GPSINFO;
 804d33a:	4b12      	ldr	r3, [pc, #72]	; (804d384 <operateGSMSIM868+0x260>)
 804d33c:	221c      	movs	r2, #28
 804d33e:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
				gsmInstance.enmcurrentTask = enmGSMTASK_UPDATELOCATION;
 804d342:	2202      	movs	r2, #2
 804d344:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
 804d348:	e7bd      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			initGSMSIM868();
 804d34a:	f7fe fc59 	bl	804bc00 <initGSMSIM868>
			break;
 804d34e:	e7ba      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
				sendGSMCommand(gsmInstance);
 804d350:	4c0c      	ldr	r4, [pc, #48]	; (804d384 <operateGSMSIM868+0x260>)
 804d352:	f241 1264 	movw	r2, #4452	; 0x1164
 804d356:	f104 0110 	add.w	r1, r4, #16
 804d35a:	4668      	mov	r0, sp
 804d35c:	f003 ff24 	bl	80511a8 <memcpy>
 804d360:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 804d364:	f7ff f962 	bl	804c62c <sendGSMCommand>
			break;
 804d368:	e7ad      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			gsmInstance.enmcurrentTask = enmGSMTASK_UPLOADDATA;
 804d36a:	4b06      	ldr	r3, [pc, #24]	; (804d384 <operateGSMSIM868+0x260>)
 804d36c:	2203      	movs	r2, #3
 804d36e:	f883 2e42 	strb.w	r2, [r3, #3650]	; 0xe42
			gsmInstance.enmGSMCommand = enmGSMSTATE_CMQTTTOPIC;
 804d372:	2217      	movs	r2, #23
 804d374:	f883 2e43 	strb.w	r2, [r3, #3651]	; 0xe43
			break;
 804d378:	e7a5      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
			initGSMSIM868();
 804d37a:	f7fe fc41 	bl	804bc00 <initGSMSIM868>
			break;
 804d37e:	e7a2      	b.n	804d2c6 <operateGSMSIM868+0x1a2>
 804d380:	4770      	bx	lr
 804d382:	bf00      	nop
 804d384:	2000c61c 	.word	0x2000c61c
 804d388:	40020c00 	.word	0x40020c00
 804d38c:	2000440c 	.word	0x2000440c
 804d390:	200053d8 	.word	0x200053d8
 804d394:	0002bf20 	.word	0x0002bf20
 804d398:	2000d790 	.word	0x2000d790

0804d39c <updateMQTTClientID>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateMQTTClientID(void)
{
 804d39c:	b538      	push	{r3, r4, r5, lr}
	uint8_t dinfo_size = 0;
	dinfo_size = strlen(dinfo);
 804d39e:	4c0f      	ldr	r4, [pc, #60]	; (804d3dc <updateMQTTClientID+0x40>)
 804d3a0:	4620      	mov	r0, r4
 804d3a2:	f7f2 ff25 	bl	80401f0 <strlen>
	memset(gu8dinfo_small, 0, sizeof(gu8dinfo_small));
 804d3a6:	4d0e      	ldr	r5, [pc, #56]	; (804d3e0 <updateMQTTClientID+0x44>)
 804d3a8:	2300      	movs	r3, #0
 804d3aa:	602b      	str	r3, [r5, #0]
 804d3ac:	80ab      	strh	r3, [r5, #4]
	strncpy(gu8dinfo_small, &dinfo[dinfo_size - 5], 5);
 804d3ae:	1f41      	subs	r1, r0, #5
 804d3b0:	2205      	movs	r2, #5
 804d3b2:	4421      	add	r1, r4
 804d3b4:	4628      	mov	r0, r5
 804d3b6:	f003 ff91 	bl	80512dc <strncpy>
	strcat(gau8GSM_ATCMQTTACCQ, gu8dinfo_small);
 804d3ba:	4c0a      	ldr	r4, [pc, #40]	; (804d3e4 <updateMQTTClientID+0x48>)
 804d3bc:	4629      	mov	r1, r5
 804d3be:	4620      	mov	r0, r4
 804d3c0:	f003 ff56 	bl	8051270 <strcat>
	strcat(gau8GSM_ATCMQTTACCQ, "\",0\r\n");
 804d3c4:	4620      	mov	r0, r4
 804d3c6:	f7f2 ff13 	bl	80401f0 <strlen>
 804d3ca:	4603      	mov	r3, r0
 804d3cc:	1821      	adds	r1, r4, r0
 804d3ce:	4a06      	ldr	r2, [pc, #24]	; (804d3e8 <updateMQTTClientID+0x4c>)
 804d3d0:	6810      	ldr	r0, [r2, #0]
 804d3d2:	50e0      	str	r0, [r4, r3]
 804d3d4:	8893      	ldrh	r3, [r2, #4]
 804d3d6:	808b      	strh	r3, [r1, #4]
}
 804d3d8:	bd38      	pop	{r3, r4, r5, pc}
 804d3da:	bf00      	nop
 804d3dc:	20008a60 	.word	0x20008a60
 804d3e0:	20008b54 	.word	0x20008b54
 804d3e4:	20000a20 	.word	0x20000a20
 804d3e8:	0805a0d4 	.word	0x0805a0d4

0804d3ec <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 804d3ec:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
 804d3ee:	4813      	ldr	r0, [pc, #76]	; (804d43c <MX_I2C1_Init+0x50>)
 804d3f0:	4b13      	ldr	r3, [pc, #76]	; (804d440 <MX_I2C1_Init+0x54>)
 804d3f2:	6003      	str	r3, [r0, #0]
  hi2c1.Init.ClockSpeed = 100000;
 804d3f4:	4b13      	ldr	r3, [pc, #76]	; (804d444 <MX_I2C1_Init+0x58>)
 804d3f6:	6043      	str	r3, [r0, #4]
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
 804d3f8:	2300      	movs	r3, #0
 804d3fa:	6083      	str	r3, [r0, #8]
  hi2c1.Init.OwnAddress1 = 0;
 804d3fc:	60c3      	str	r3, [r0, #12]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 804d3fe:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 804d402:	6102      	str	r2, [r0, #16]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 804d404:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2 = 0;
 804d406:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 804d408:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 804d40a:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 804d40c:	f7f5 fe16 	bl	804303c <HAL_I2C_Init>
 804d410:	b950      	cbnz	r0, 804d428 <MX_I2C1_Init+0x3c>
  {
    Error_Handler();
  }
  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 804d412:	2100      	movs	r1, #0
 804d414:	4809      	ldr	r0, [pc, #36]	; (804d43c <MX_I2C1_Init+0x50>)
 804d416:	f7f6 fc6f 	bl	8043cf8 <HAL_I2CEx_ConfigAnalogFilter>
 804d41a:	b940      	cbnz	r0, 804d42e <MX_I2C1_Init+0x42>
  {
    Error_Handler();
  }
  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 804d41c:	2100      	movs	r1, #0
 804d41e:	4807      	ldr	r0, [pc, #28]	; (804d43c <MX_I2C1_Init+0x50>)
 804d420:	f7f6 fc8c 	bl	8043d3c <HAL_I2CEx_ConfigDigitalFilter>
 804d424:	b930      	cbnz	r0, 804d434 <MX_I2C1_Init+0x48>
  {
    Error_Handler();
  }

}
 804d426:	bd08      	pop	{r3, pc}
    Error_Handler();
 804d428:	f000 faea 	bl	804da00 <Error_Handler>
 804d42c:	e7f1      	b.n	804d412 <MX_I2C1_Init+0x26>
    Error_Handler();
 804d42e:	f000 fae7 	bl	804da00 <Error_Handler>
 804d432:	e7f3      	b.n	804d41c <MX_I2C1_Init+0x30>
    Error_Handler();
 804d434:	f000 fae4 	bl	804da00 <Error_Handler>
}
 804d438:	e7f5      	b.n	804d426 <MX_I2C1_Init+0x3a>
 804d43a:	bf00      	nop
 804d43c:	2000d7c0 	.word	0x2000d7c0
 804d440:	40005400 	.word	0x40005400
 804d444:	000186a0 	.word	0x000186a0

0804d448 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 804d448:	b530      	push	{r4, r5, lr}
 804d44a:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 804d44c:	2300      	movs	r3, #0
 804d44e:	9303      	str	r3, [sp, #12]
 804d450:	9304      	str	r3, [sp, #16]
 804d452:	9305      	str	r3, [sp, #20]
 804d454:	9306      	str	r3, [sp, #24]
 804d456:	9307      	str	r3, [sp, #28]
  if(i2cHandle->Instance==I2C1)
 804d458:	6802      	ldr	r2, [r0, #0]
 804d45a:	4b1d      	ldr	r3, [pc, #116]	; (804d4d0 <HAL_I2C_MspInit+0x88>)
 804d45c:	429a      	cmp	r2, r3
 804d45e:	d001      	beq.n	804d464 <HAL_I2C_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 804d460:	b009      	add	sp, #36	; 0x24
 804d462:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 804d464:	2400      	movs	r4, #0
 804d466:	9401      	str	r4, [sp, #4]
 804d468:	4d1a      	ldr	r5, [pc, #104]	; (804d4d4 <HAL_I2C_MspInit+0x8c>)
 804d46a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 804d46c:	f043 0302 	orr.w	r3, r3, #2
 804d470:	632b      	str	r3, [r5, #48]	; 0x30
 804d472:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 804d474:	f003 0302 	and.w	r3, r3, #2
 804d478:	9301      	str	r3, [sp, #4]
 804d47a:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 804d47c:	23c0      	movs	r3, #192	; 0xc0
 804d47e:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 804d480:	2312      	movs	r3, #18
 804d482:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 804d484:	2301      	movs	r3, #1
 804d486:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 804d488:	2303      	movs	r3, #3
 804d48a:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 804d48c:	2304      	movs	r3, #4
 804d48e:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 804d490:	a903      	add	r1, sp, #12
 804d492:	4811      	ldr	r0, [pc, #68]	; (804d4d8 <HAL_I2C_MspInit+0x90>)
 804d494:	f7f5 fb30 	bl	8042af8 <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 804d498:	9402      	str	r4, [sp, #8]
 804d49a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 804d49c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 804d4a0:	642b      	str	r3, [r5, #64]	; 0x40
 804d4a2:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 804d4a4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 804d4a8:	9302      	str	r3, [sp, #8]
 804d4aa:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 0, 0);
 804d4ac:	4622      	mov	r2, r4
 804d4ae:	4621      	mov	r1, r4
 804d4b0:	201f      	movs	r0, #31
 804d4b2:	f7f4 fa0d 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
 804d4b6:	201f      	movs	r0, #31
 804d4b8:	f7f4 fa3e 	bl	8041938 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 0, 0);
 804d4bc:	4622      	mov	r2, r4
 804d4be:	4621      	mov	r1, r4
 804d4c0:	2020      	movs	r0, #32
 804d4c2:	f7f4 fa05 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
 804d4c6:	2020      	movs	r0, #32
 804d4c8:	f7f4 fa36 	bl	8041938 <HAL_NVIC_EnableIRQ>
}
 804d4cc:	e7c8      	b.n	804d460 <HAL_I2C_MspInit+0x18>
 804d4ce:	bf00      	nop
 804d4d0:	40005400 	.word	0x40005400
 804d4d4:	40023800 	.word	0x40023800
 804d4d8:	40020400 	.word	0x40020400

0804d4dc <MX_IWDG_Init>:

IWDG_HandleTypeDef hiwdg;

/* IWDG init function */
void MX_IWDG_Init(void)
{
 804d4dc:	b508      	push	{r3, lr}

  hiwdg.Instance = IWDG;
 804d4de:	4807      	ldr	r0, [pc, #28]	; (804d4fc <MX_IWDG_Init+0x20>)
 804d4e0:	4b07      	ldr	r3, [pc, #28]	; (804d500 <MX_IWDG_Init+0x24>)
 804d4e2:	6003      	str	r3, [r0, #0]
  hiwdg.Init.Prescaler = IWDG_PRESCALER_256;
 804d4e4:	2306      	movs	r3, #6
 804d4e6:	6043      	str	r3, [r0, #4]
  hiwdg.Init.Reload = 4095;
 804d4e8:	f640 73ff 	movw	r3, #4095	; 0xfff
 804d4ec:	6083      	str	r3, [r0, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 804d4ee:	f7f6 fc46 	bl	8043d7e <HAL_IWDG_Init>
 804d4f2:	b900      	cbnz	r0, 804d4f6 <MX_IWDG_Init+0x1a>
  {
    Error_Handler();
  }

}
 804d4f4:	bd08      	pop	{r3, pc}
    Error_Handler();
 804d4f6:	f000 fa83 	bl	804da00 <Error_Handler>
}
 804d4fa:	e7fb      	b.n	804d4f4 <MX_IWDG_Init+0x18>
 804d4fc:	2000d814 	.word	0x2000d814
 804d500:	40003000 	.word	0x40003000

0804d504 <MX_LWIP_Init>:

/**
  * LwIP initialization function
  */
void MX_LWIP_Init(void)
{
 804d504:	b5f0      	push	{r4, r5, r6, r7, lr}
 804d506:	b085      	sub	sp, #20
  /* IP addresses initialization */
  IP_ADDRESS[0] = 192;
 804d508:	4f3a      	ldr	r7, [pc, #232]	; (804d5f4 <MX_LWIP_Init+0xf0>)
 804d50a:	21c0      	movs	r1, #192	; 0xc0
 804d50c:	7039      	strb	r1, [r7, #0]
  IP_ADDRESS[1] = 168;
 804d50e:	22a8      	movs	r2, #168	; 0xa8
 804d510:	707a      	strb	r2, [r7, #1]
  IP_ADDRESS[2] = 0;
 804d512:	2400      	movs	r4, #0
 804d514:	70bc      	strb	r4, [r7, #2]
  IP_ADDRESS[3] = 100;
 804d516:	2364      	movs	r3, #100	; 0x64
 804d518:	70fb      	strb	r3, [r7, #3]
  NETMASK_ADDRESS[0] = 255;
 804d51a:	4e37      	ldr	r6, [pc, #220]	; (804d5f8 <MX_LWIP_Init+0xf4>)
 804d51c:	23ff      	movs	r3, #255	; 0xff
 804d51e:	7033      	strb	r3, [r6, #0]
  NETMASK_ADDRESS[1] = 255;
 804d520:	7073      	strb	r3, [r6, #1]
  NETMASK_ADDRESS[2] = 255;
 804d522:	70b3      	strb	r3, [r6, #2]
  NETMASK_ADDRESS[3] = 0;
 804d524:	70f4      	strb	r4, [r6, #3]
  GATEWAY_ADDRESS[0] = 192;
 804d526:	4d35      	ldr	r5, [pc, #212]	; (804d5fc <MX_LWIP_Init+0xf8>)
 804d528:	7029      	strb	r1, [r5, #0]
  GATEWAY_ADDRESS[1] = 168;
 804d52a:	706a      	strb	r2, [r5, #1]
  GATEWAY_ADDRESS[2] = 0;
 804d52c:	70ac      	strb	r4, [r5, #2]
  GATEWAY_ADDRESS[3] = 1;
 804d52e:	2301      	movs	r3, #1
 804d530:	70eb      	strb	r3, [r5, #3]

  /* Initilialize the LwIP stack without RTOS */
  lwip_init();
 804d532:	f7f7 ff8a 	bl	804544a <lwip_init>

  /* IP addresses initialization without DHCP (IPv4) */
  IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
 804d536:	783a      	ldrb	r2, [r7, #0]
 804d538:	787b      	ldrb	r3, [r7, #1]
 804d53a:	041b      	lsls	r3, r3, #16
 804d53c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804d540:	78ba      	ldrb	r2, [r7, #2]
 804d542:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804d546:	78f9      	ldrb	r1, [r7, #3]
 804d548:	430b      	orrs	r3, r1
 804d54a:	021a      	lsls	r2, r3, #8
 804d54c:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804d550:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 804d554:	0a19      	lsrs	r1, r3, #8
 804d556:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 804d55a:	430a      	orrs	r2, r1
 804d55c:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804d560:	4927      	ldr	r1, [pc, #156]	; (804d600 <MX_LWIP_Init+0xfc>)
 804d562:	600b      	str	r3, [r1, #0]
  IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
 804d564:	7832      	ldrb	r2, [r6, #0]
 804d566:	7873      	ldrb	r3, [r6, #1]
 804d568:	041b      	lsls	r3, r3, #16
 804d56a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 804d56e:	78b2      	ldrb	r2, [r6, #2]
 804d570:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804d574:	78f0      	ldrb	r0, [r6, #3]
 804d576:	4303      	orrs	r3, r0
 804d578:	021a      	lsls	r2, r3, #8
 804d57a:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804d57e:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 804d582:	0a18      	lsrs	r0, r3, #8
 804d584:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 804d588:	4302      	orrs	r2, r0
 804d58a:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804d58e:	4a1d      	ldr	r2, [pc, #116]	; (804d604 <MX_LWIP_Init+0x100>)
 804d590:	6013      	str	r3, [r2, #0]
  IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
 804d592:	7828      	ldrb	r0, [r5, #0]
 804d594:	786b      	ldrb	r3, [r5, #1]
 804d596:	041b      	lsls	r3, r3, #16
 804d598:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 804d59c:	78a8      	ldrb	r0, [r5, #2]
 804d59e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 804d5a2:	78ed      	ldrb	r5, [r5, #3]
 804d5a4:	432b      	orrs	r3, r5
 804d5a6:	0218      	lsls	r0, r3, #8
 804d5a8:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
 804d5ac:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
 804d5b0:	0a1d      	lsrs	r5, r3, #8
 804d5b2:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 804d5b6:	4328      	orrs	r0, r5
 804d5b8:	ea40 6013 	orr.w	r0, r0, r3, lsr #24
 804d5bc:	4b12      	ldr	r3, [pc, #72]	; (804d608 <MX_LWIP_Init+0x104>)
 804d5be:	6018      	str	r0, [r3, #0]

  /* add the network interface (IPv4/IPv6) without RTOS */
  netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
 804d5c0:	4d12      	ldr	r5, [pc, #72]	; (804d60c <MX_LWIP_Init+0x108>)
 804d5c2:	4813      	ldr	r0, [pc, #76]	; (804d610 <MX_LWIP_Init+0x10c>)
 804d5c4:	9002      	str	r0, [sp, #8]
 804d5c6:	4813      	ldr	r0, [pc, #76]	; (804d614 <MX_LWIP_Init+0x110>)
 804d5c8:	9001      	str	r0, [sp, #4]
 804d5ca:	9400      	str	r4, [sp, #0]
 804d5cc:	4628      	mov	r0, r5
 804d5ce:	f7f8 fa2f 	bl	8045a30 <netif_add>

  /* Registers the default network interface */
  netif_set_default(&gnetif);
 804d5d2:	4628      	mov	r0, r5
 804d5d4:	f7f8 fa6e 	bl	8045ab4 <netif_set_default>

  if (netif_is_link_up(&gnetif))
 804d5d8:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
 804d5dc:	f013 0f04 	tst.w	r3, #4
 804d5e0:	d004      	beq.n	804d5ec <MX_LWIP_Init+0xe8>
  {
    /* When the netif is fully configured this function must be called */
    netif_set_up(&gnetif);
 804d5e2:	4628      	mov	r0, r5
 804d5e4:	f7f8 fa6c 	bl	8045ac0 <netif_set_up>
  }

/* USER CODE BEGIN 3 */

/* USER CODE END 3 */
}
 804d5e8:	b005      	add	sp, #20
 804d5ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    netif_set_down(&gnetif);
 804d5ec:	4807      	ldr	r0, [pc, #28]	; (804d60c <MX_LWIP_Init+0x108>)
 804d5ee:	f7f8 fa79 	bl	8045ae4 <netif_set_down>
}
 804d5f2:	e7f9      	b.n	804d5e8 <MX_LWIP_Init+0xe4>
 804d5f4:	2000d85c 	.word	0x2000d85c
 804d5f8:	2000d858 	.word	0x2000d858
 804d5fc:	2000d820 	.word	0x2000d820
 804d600:	2000d854 	.word	0x2000d854
 804d604:	2000d860 	.word	0x2000d860
 804d608:	2000d864 	.word	0x2000d864
 804d60c:	2000d824 	.word	0x2000d824
 804d610:	0804b3f1 	.word	0x0804b3f1
 804d614:	0804bad1 	.word	0x0804bad1

0804d618 <MX_LWIP_Process>:
 * Send it to the lwIP stack for handling
 * Handle timeouts if LWIP_TIMERS is set and without RTOS
 * Handle the llink status if LWIP_NETIF_LINK_CALLBACK is set and without RTOS
 */
void MX_LWIP_Process(void)
{
 804d618:	b508      	push	{r3, lr}
/* USER CODE BEGIN 4_1 */
/* USER CODE END 4_1 */
  ethernetif_input(&gnetif);
 804d61a:	4803      	ldr	r0, [pc, #12]	; (804d628 <MX_LWIP_Process+0x10>)
 804d61c:	f7fe fa48 	bl	804bab0 <ethernetif_input>

/* USER CODE BEGIN 4_2 */
/* USER CODE END 4_2 */
  /* Handle timeouts */
  sys_check_timeouts();
 804d620:	f7fc faa0 	bl	8049b64 <sys_check_timeouts>

/* USER CODE BEGIN 4_3 */
/* USER CODE END 4_3 */
}
 804d624:	bd08      	pop	{r3, pc}
 804d626:	bf00      	nop
 804d628:	2000d824 	.word	0x2000d824

0804d62c <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 804d62c:	b570      	push	{r4, r5, r6, lr}
 804d62e:	b0a0      	sub	sp, #128	; 0x80
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 804d630:	2530      	movs	r5, #48	; 0x30
 804d632:	462a      	mov	r2, r5
 804d634:	2100      	movs	r1, #0
 804d636:	a814      	add	r0, sp, #80	; 0x50
 804d638:	f003 fdc4 	bl	80511c4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 804d63c:	2400      	movs	r4, #0
 804d63e:	940f      	str	r4, [sp, #60]	; 0x3c
 804d640:	9410      	str	r4, [sp, #64]	; 0x40
 804d642:	9411      	str	r4, [sp, #68]	; 0x44
 804d644:	9412      	str	r4, [sp, #72]	; 0x48
 804d646:	9413      	str	r4, [sp, #76]	; 0x4c
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 804d648:	462a      	mov	r2, r5
 804d64a:	4621      	mov	r1, r4
 804d64c:	a803      	add	r0, sp, #12
 804d64e:	f003 fdb9 	bl	80511c4 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 804d652:	9401      	str	r4, [sp, #4]
 804d654:	4b22      	ldr	r3, [pc, #136]	; (804d6e0 <SystemClock_Config+0xb4>)
 804d656:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804d658:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 804d65c:	641a      	str	r2, [r3, #64]	; 0x40
 804d65e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804d660:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804d664:	9301      	str	r3, [sp, #4]
 804d666:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 804d668:	9402      	str	r4, [sp, #8]
 804d66a:	4b1e      	ldr	r3, [pc, #120]	; (804d6e4 <SystemClock_Config+0xb8>)
 804d66c:	681a      	ldr	r2, [r3, #0]
 804d66e:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 804d672:	601a      	str	r2, [r3, #0]
 804d674:	681b      	ldr	r3, [r3, #0]
 804d676:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 804d67a:	9302      	str	r3, [sp, #8]
 804d67c:	9b02      	ldr	r3, [sp, #8]
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 804d67e:	2309      	movs	r3, #9
 804d680:	9314      	str	r3, [sp, #80]	; 0x50
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 804d682:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 804d686:	9315      	str	r3, [sp, #84]	; 0x54
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 804d688:	2301      	movs	r3, #1
 804d68a:	9319      	str	r3, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 804d68c:	2502      	movs	r5, #2
 804d68e:	951a      	str	r5, [sp, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 804d690:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 804d694:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLM = 15;
 804d696:	260f      	movs	r6, #15
 804d698:	961c      	str	r6, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLN = 216;
 804d69a:	23d8      	movs	r3, #216	; 0xd8
 804d69c:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 804d69e:	951e      	str	r5, [sp, #120]	; 0x78
  RCC_OscInitStruct.PLL.PLLQ = 4;
 804d6a0:	2304      	movs	r3, #4
 804d6a2:	931f      	str	r3, [sp, #124]	; 0x7c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 804d6a4:	a814      	add	r0, sp, #80	; 0x50
 804d6a6:	f7f6 fbd5 	bl	8043e54 <HAL_RCC_OscConfig>
  {
    Error_Handler();
  }
  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 804d6aa:	f7f6 fb93 	bl	8043dd4 <HAL_PWREx_EnableOverDrive>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 804d6ae:	960f      	str	r6, [sp, #60]	; 0x3c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 804d6b0:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 804d6b2:	9411      	str	r4, [sp, #68]	; 0x44
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 804d6b4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 804d6b8:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 804d6ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 804d6be:	9313      	str	r3, [sp, #76]	; 0x4c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
 804d6c0:	2105      	movs	r1, #5
 804d6c2:	a80f      	add	r0, sp, #60	; 0x3c
 804d6c4:	f7f6 fde8 	bl	8044298 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 804d6c8:	2320      	movs	r3, #32
 804d6ca:	9303      	str	r3, [sp, #12]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 804d6cc:	f44f 7300 	mov.w	r3, #512	; 0x200
 804d6d0:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 804d6d2:	a803      	add	r0, sp, #12
 804d6d4:	f7f6 feb8 	bl	8044448 <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
  /** Enables the Clock Security System
  */
  HAL_RCC_EnableCSS();
 804d6d8:	f7f6 fd88 	bl	80441ec <HAL_RCC_EnableCSS>
}
 804d6dc:	b020      	add	sp, #128	; 0x80
 804d6de:	bd70      	pop	{r4, r5, r6, pc}
 804d6e0:	40023800 	.word	0x40023800
 804d6e4:	40007000 	.word	0x40007000

0804d6e8 <main>:
{
 804d6e8:	b570      	push	{r4, r5, r6, lr}
  HAL_Init();
 804d6ea:	f7f3 fcb3 	bl	8041054 <HAL_Init>
  SystemClock_Config();
 804d6ee:	f7ff ff9d 	bl	804d62c <SystemClock_Config>
  MX_GPIO_Init();
 804d6f2:	f7fe fa15 	bl	804bb20 <MX_GPIO_Init>
  MX_DMA_Init();
 804d6f6:	f7fe f805 	bl	804b704 <MX_DMA_Init>
  MX_IWDG_Init();
 804d6fa:	f7ff feef 	bl	804d4dc <MX_IWDG_Init>
  MX_TIM7_Init();
 804d6fe:	f002 fbad 	bl	804fe5c <MX_TIM7_Init>
  MX_UART4_Init();
 804d702:	f002 fbf3 	bl	804feec <MX_UART4_Init>
  MX_RTC_Init();
 804d706:	f002 f935 	bl	804f974 <MX_RTC_Init>
  MX_USART3_UART_Init();
 804d70a:	f002 fc7d 	bl	8050008 <MX_USART3_UART_Init>
  MX_ADC1_Init();
 804d70e:	f7fd fefb 	bl	804b508 <MX_ADC1_Init>
  MX_LWIP_Init();
 804d712:	f7ff fef7 	bl	804d504 <MX_LWIP_Init>
  MX_I2C1_Init();
 804d716:	f7ff fe69 	bl	804d3ec <MX_I2C1_Init>
  	updateDeviceSignature();
 804d71a:	f7fd ff99 	bl	804b650 <updateDeviceSignature>
	HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 804d71e:	4c97      	ldr	r4, [pc, #604]	; (804d97c <main+0x294>)
 804d720:	2200      	movs	r2, #0
 804d722:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d726:	4620      	mov	r0, r4
 804d728:	f7f5 fad8 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET);
 804d72c:	2201      	movs	r2, #1
 804d72e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804d732:	4620      	mov	r0, r4
 804d734:	f7f5 fad2 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_RESET);
 804d738:	f5a4 6480 	sub.w	r4, r4, #1024	; 0x400
 804d73c:	2200      	movs	r2, #0
 804d73e:	f44f 7180 	mov.w	r1, #256	; 0x100
 804d742:	4620      	mov	r0, r4
 804d744:	f7f5 faca 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_2_GPIO_Port, LED_2_Pin, GPIO_PIN_RESET);
 804d748:	2200      	movs	r2, #0
 804d74a:	2140      	movs	r1, #64	; 0x40
 804d74c:	4620      	mov	r0, r4
 804d74e:	f7f5 fac5 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LED_3_GPIO_Port, LED_3_Pin, GPIO_PIN_RESET);
 804d752:	2200      	movs	r2, #0
 804d754:	2120      	movs	r1, #32
 804d756:	4620      	mov	r0, r4
 804d758:	f7f5 fac0 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GSM_PWR_KEY_GPIO_Port,GSM_PWR_KEY_Pin,GPIO_PIN_RESET);
 804d75c:	2200      	movs	r2, #0
 804d75e:	2180      	movs	r1, #128	; 0x80
 804d760:	4620      	mov	r0, r4
 804d762:	f7f5 fabb 	bl	8042cdc <HAL_GPIO_WritePin>
	setupModbus();
 804d766:	f000 fde7 	bl	804e338 <setupModbus>
	setupModbusRTU();
 804d76a:	f000 fc4f 	bl	804e00c <setupModbusRTU>
	if(gu32UploadTimeSupply == 0)
 804d76e:	4b84      	ldr	r3, [pc, #528]	; (804d980 <main+0x298>)
 804d770:	681b      	ldr	r3, [r3, #0]
 804d772:	b913      	cbnz	r3, 804d77a <main+0x92>
		gu32UploadTimeSupply = TWO_MIN;
 804d774:	4b82      	ldr	r3, [pc, #520]	; (804d980 <main+0x298>)
 804d776:	4a83      	ldr	r2, [pc, #524]	; (804d984 <main+0x29c>)
 804d778:	601a      	str	r2, [r3, #0]
	if(gu32UploadTimeBatt == 0)
 804d77a:	4b83      	ldr	r3, [pc, #524]	; (804d988 <main+0x2a0>)
 804d77c:	681b      	ldr	r3, [r3, #0]
 804d77e:	b913      	cbnz	r3, 804d786 <main+0x9e>
		gu32UploadTimeBatt = FIVE_MIN;
 804d780:	4b81      	ldr	r3, [pc, #516]	; (804d988 <main+0x2a0>)
 804d782:	4a82      	ldr	r2, [pc, #520]	; (804d98c <main+0x2a4>)
 804d784:	601a      	str	r2, [r3, #0]
	enqueue(&gsmPayload,(char *)getSystemConfig());
 804d786:	f001 f8d1 	bl	804e92c <getSystemConfig>
 804d78a:	4601      	mov	r1, r0
 804d78c:	4880      	ldr	r0, [pc, #512]	; (804d990 <main+0x2a8>)
 804d78e:	f002 f8b1 	bl	804f8f4 <enqueue>
	HAL_GPIO_WritePin(LED_1_GPIO_Port, LED_1_Pin, GPIO_PIN_SET);	// LED OFF
 804d792:	2201      	movs	r2, #1
 804d794:	f44f 7180 	mov.w	r1, #256	; 0x100
 804d798:	487e      	ldr	r0, [pc, #504]	; (804d994 <main+0x2ac>)
 804d79a:	f7f5 fa9f 	bl	8042cdc <HAL_GPIO_WritePin>
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 804d79e:	4a7e      	ldr	r2, [pc, #504]	; (804d998 <main+0x2b0>)
 804d7a0:	68d3      	ldr	r3, [r2, #12]
 804d7a2:	f043 0320 	orr.w	r3, r3, #32
 804d7a6:	60d3      	str	r3, [r2, #12]
 804d7a8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 804d7ac:	68d3      	ldr	r3, [r2, #12]
 804d7ae:	f043 0320 	orr.w	r3, r3, #32
 804d7b2:	60d3      	str	r3, [r2, #12]
	if(HAL_TIM_Base_Start_IT(&htim7)!= HAL_OK)
 804d7b4:	4879      	ldr	r0, [pc, #484]	; (804d99c <main+0x2b4>)
 804d7b6:	f7f7 fb07 	bl	8044dc8 <HAL_TIM_Base_Start_IT>
	updateNetworkAPN();
 804d7ba:	f7fe fe33 	bl	804c424 <updateNetworkAPN>
	gu32TempPayloadQueueEnqueue = ONE_MIN;
 804d7be:	4b78      	ldr	r3, [pc, #480]	; (804d9a0 <main+0x2b8>)
 804d7c0:	f64e 2260 	movw	r2, #60000	; 0xea60
 804d7c4:	601a      	str	r2, [r3, #0]
	memset(gau8TempMBPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimit);
 804d7c6:	4b77      	ldr	r3, [pc, #476]	; (804d9a4 <main+0x2bc>)
 804d7c8:	681a      	ldr	r2, [r3, #0]
 804d7ca:	2100      	movs	r1, #0
 804d7cc:	4876      	ldr	r0, [pc, #472]	; (804d9a8 <main+0x2c0>)
 804d7ce:	f003 fcf9 	bl	80511c4 <memset>
	memset(gau8TempMBRTUPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimitRTU);
 804d7d2:	4b76      	ldr	r3, [pc, #472]	; (804d9ac <main+0x2c4>)
 804d7d4:	681a      	ldr	r2, [r3, #0]
 804d7d6:	2100      	movs	r1, #0
 804d7d8:	4875      	ldr	r0, [pc, #468]	; (804d9b0 <main+0x2c8>)
 804d7da:	f003 fcf3 	bl	80511c4 <memset>
	 gu32SystemResetTimer = THIRTY_MIN;
 804d7de:	4b75      	ldr	r3, [pc, #468]	; (804d9b4 <main+0x2cc>)
 804d7e0:	4a75      	ldr	r2, [pc, #468]	; (804d9b8 <main+0x2d0>)
 804d7e2:	601a      	str	r2, [r3, #0]
	  updateMQTTClientID();
 804d7e4:	f7ff fdda 	bl	804d39c <updateMQTTClientID>
 804d7e8:	e044      	b.n	804d874 <main+0x18c>
		mbTCPPoll();
 804d7ea:	f000 fec3 	bl	804e574 <mbTCPPoll>
		updateModbusPayload();
 804d7ee:	f000 fdcd 	bl	804e38c <updateModbusPayload>
 804d7f2:	e047      	b.n	804d884 <main+0x19c>
		modbusQueryFSM();
 804d7f4:	f000 f95a 	bl	804daac <modbusQueryFSM>
		uploadSlaveData();
 804d7f8:	f000 fb6e 	bl	804ded8 <uploadSlaveData>
 804d7fc:	e046      	b.n	804d88c <main+0x1a4>
			gu32TempPayloadQueueEnqueue = TEN_SEC;//gu32UploadTimeBatt;
 804d7fe:	4b68      	ldr	r3, [pc, #416]	; (804d9a0 <main+0x2b8>)
 804d800:	f242 7210 	movw	r2, #10000	; 0x2710
 804d804:	601a      	str	r2, [r3, #0]
 804d806:	e059      	b.n	804d8bc <main+0x1d4>
	if(gsmInstance.u32GSMTimer > FIVE_MIN)
 804d808:	4b6c      	ldr	r3, [pc, #432]	; (804d9bc <main+0x2d4>)
 804d80a:	f8d3 2e24 	ldr.w	r2, [r3, #3620]	; 0xe24
 804d80e:	4b5f      	ldr	r3, [pc, #380]	; (804d98c <main+0x2a4>)
 804d810:	429a      	cmp	r2, r3
 804d812:	d904      	bls.n	804d81e <main+0x136>
		gsmInstance.u32GSMTimer = FOUR_SEC;
 804d814:	4b69      	ldr	r3, [pc, #420]	; (804d9bc <main+0x2d4>)
 804d816:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 804d81a:	f8c3 2e24 	str.w	r2, [r3, #3620]	; 0xe24
	if(gu32GSMHangTimer == 0)
 804d81e:	4b68      	ldr	r3, [pc, #416]	; (804d9c0 <main+0x2d8>)
 804d820:	681b      	ldr	r3, [r3, #0]
 804d822:	2b00      	cmp	r3, #0
 804d824:	d055      	beq.n	804d8d2 <main+0x1ea>
	if(gu32GSMRestartTimer == 0)
 804d826:	4b67      	ldr	r3, [pc, #412]	; (804d9c4 <main+0x2dc>)
 804d828:	681b      	ldr	r3, [r3, #0]
 804d82a:	2b00      	cmp	r3, #0
 804d82c:	d054      	beq.n	804d8d8 <main+0x1f0>
	operateGSMSIM868();
 804d82e:	f7ff fc79 	bl	804d124 <operateGSMSIM868>
	if(gu32RTCUpdateTimer == 0)
 804d832:	4b65      	ldr	r3, [pc, #404]	; (804d9c8 <main+0x2e0>)
 804d834:	681b      	ldr	r3, [r3, #0]
 804d836:	b91b      	cbnz	r3, 804d840 <main+0x158>
		gu32RTCUpdateTimer = FIVE_SEC;
 804d838:	4b63      	ldr	r3, [pc, #396]	; (804d9c8 <main+0x2e0>)
 804d83a:	f241 3288 	movw	r2, #5000	; 0x1388
 804d83e:	601a      	str	r2, [r3, #0]
	 if((gu32SystemResetTimer == 0) || ((FOTACompleteFlag == TRUE) && (isQueueEmpty(&gsmPayload) == 1)))
 804d840:	4b5c      	ldr	r3, [pc, #368]	; (804d9b4 <main+0x2cc>)
 804d842:	681b      	ldr	r3, [r3, #0]
 804d844:	2b00      	cmp	r3, #0
 804d846:	d04f      	beq.n	804d8e8 <main+0x200>
 804d848:	4b60      	ldr	r3, [pc, #384]	; (804d9cc <main+0x2e4>)
 804d84a:	781b      	ldrb	r3, [r3, #0]
 804d84c:	2b00      	cmp	r3, #0
 804d84e:	d146      	bne.n	804d8de <main+0x1f6>
	  if(SUBTriggerFlag == TRUE)
 804d850:	4b5f      	ldr	r3, [pc, #380]	; (804d9d0 <main+0x2e8>)
 804d852:	781b      	ldrb	r3, [r3, #0]
 804d854:	2b01      	cmp	r3, #1
 804d856:	d048      	beq.n	804d8ea <main+0x202>
	if(gu32LedTimer == 0)
 804d858:	4b5e      	ldr	r3, [pc, #376]	; (804d9d4 <main+0x2ec>)
 804d85a:	681b      	ldr	r3, [r3, #0]
 804d85c:	2b00      	cmp	r3, #0
 804d85e:	d075      	beq.n	804d94c <main+0x264>
	if(gu32SystemResetTimer == 0 )
 804d860:	4b54      	ldr	r3, [pc, #336]	; (804d9b4 <main+0x2cc>)
 804d862:	681b      	ldr	r3, [r3, #0]
 804d864:	2b00      	cmp	r3, #0
 804d866:	f000 8088 	beq.w	804d97a <main+0x292>
	getRTCCalender();
 804d86a:	f003 f839 	bl	80508e0 <getRTCCalender>
	HAL_IWDG_Refresh(&hiwdg);
 804d86e:	485a      	ldr	r0, [pc, #360]	; (804d9d8 <main+0x2f0>)
 804d870:	f7f6 faaa 	bl	8043dc8 <HAL_IWDG_Refresh>
	MX_LWIP_Process();
 804d874:	f7ff fed0 	bl	804d618 <MX_LWIP_Process>
	updateEthLinkStatus();
 804d878:	f002 fe60 	bl	805053c <updateEthLinkStatus>
	if(gu32OperateModbusTCP == 1)
 804d87c:	4b57      	ldr	r3, [pc, #348]	; (804d9dc <main+0x2f4>)
 804d87e:	681b      	ldr	r3, [r3, #0]
 804d880:	2b01      	cmp	r3, #1
 804d882:	d0b2      	beq.n	804d7ea <main+0x102>
	if(gu32OperateModbus485 == 1)
 804d884:	4b56      	ldr	r3, [pc, #344]	; (804d9e0 <main+0x2f8>)
 804d886:	681b      	ldr	r3, [r3, #0]
 804d888:	2b01      	cmp	r3, #1
 804d88a:	d0b3      	beq.n	804d7f4 <main+0x10c>
	operateadc();
 804d88c:	f002 fcaa 	bl	80501e4 <operateadc>
	if((gu32TempPayloadQueueEnqueue == 0) && (gu32FotaRquestFlag == FALSE))
 804d890:	4b43      	ldr	r3, [pc, #268]	; (804d9a0 <main+0x2b8>)
 804d892:	681b      	ldr	r3, [r3, #0]
 804d894:	2b00      	cmp	r3, #0
 804d896:	d1b7      	bne.n	804d808 <main+0x120>
 804d898:	4b52      	ldr	r3, [pc, #328]	; (804d9e4 <main+0x2fc>)
 804d89a:	681b      	ldr	r3, [r3, #0]
 804d89c:	2b00      	cmp	r3, #0
 804d89e:	d1b3      	bne.n	804d808 <main+0x120>
		enqueue(&gsmPayload,(char *)getSystemDataString());
 804d8a0:	f001 faaa 	bl	804edf8 <getSystemDataString>
 804d8a4:	4601      	mov	r1, r0
 804d8a6:	483a      	ldr	r0, [pc, #232]	; (804d990 <main+0x2a8>)
 804d8a8:	f002 f824 	bl	804f8f4 <enqueue>
		if(gu32InputSupplySwitchedAlert == TRUE)
 804d8ac:	4b4e      	ldr	r3, [pc, #312]	; (804d9e8 <main+0x300>)
 804d8ae:	681b      	ldr	r3, [r3, #0]
 804d8b0:	2b01      	cmp	r3, #1
 804d8b2:	d0a4      	beq.n	804d7fe <main+0x116>
			gu32TempPayloadQueueEnqueue = gu32UploadTimeSupply;
 804d8b4:	4b32      	ldr	r3, [pc, #200]	; (804d980 <main+0x298>)
 804d8b6:	681a      	ldr	r2, [r3, #0]
 804d8b8:	4b39      	ldr	r3, [pc, #228]	; (804d9a0 <main+0x2b8>)
 804d8ba:	601a      	str	r2, [r3, #0]
		if(gu32TempPayloadQueueEnqueue < THIRTY_SEC)
 804d8bc:	4b38      	ldr	r3, [pc, #224]	; (804d9a0 <main+0x2b8>)
 804d8be:	681a      	ldr	r2, [r3, #0]
 804d8c0:	f247 532f 	movw	r3, #29999	; 0x752f
 804d8c4:	429a      	cmp	r2, r3
 804d8c6:	d89f      	bhi.n	804d808 <main+0x120>
			gu32TempPayloadQueueEnqueue = THIRTY_SEC;
 804d8c8:	4b35      	ldr	r3, [pc, #212]	; (804d9a0 <main+0x2b8>)
 804d8ca:	f247 5230 	movw	r2, #30000	; 0x7530
 804d8ce:	601a      	str	r2, [r3, #0]
 804d8d0:	e79a      	b.n	804d808 <main+0x120>
		initGSMSIM868();
 804d8d2:	f7fe f995 	bl	804bc00 <initGSMSIM868>
 804d8d6:	e7a6      	b.n	804d826 <main+0x13e>
		initGSMSIM868();
 804d8d8:	f7fe f992 	bl	804bc00 <initGSMSIM868>
 804d8dc:	e7a7      	b.n	804d82e <main+0x146>
	 if((gu32SystemResetTimer == 0) || ((FOTACompleteFlag == TRUE) && (isQueueEmpty(&gsmPayload) == 1)))
 804d8de:	482c      	ldr	r0, [pc, #176]	; (804d990 <main+0x2a8>)
 804d8e0:	f002 f840 	bl	804f964 <isQueueEmpty>
 804d8e4:	2801      	cmp	r0, #1
 804d8e6:	d1b3      	bne.n	804d850 <main+0x168>
		 while(1){}
 804d8e8:	e7fe      	b.n	804d8e8 <main+0x200>
		  if(strstr(gau8SUBRequest, "F,") != NULL)
 804d8ea:	4940      	ldr	r1, [pc, #256]	; (804d9ec <main+0x304>)
 804d8ec:	4840      	ldr	r0, [pc, #256]	; (804d9f0 <main+0x308>)
 804d8ee:	f003 fd08 	bl	8051302 <strstr>
 804d8f2:	b338      	cbz	r0, 804d944 <main+0x25c>
			  const char *URL = strstr(gau8SUBRequest,"http:");
 804d8f4:	4d3e      	ldr	r5, [pc, #248]	; (804d9f0 <main+0x308>)
 804d8f6:	493f      	ldr	r1, [pc, #252]	; (804d9f4 <main+0x30c>)
 804d8f8:	4628      	mov	r0, r5
 804d8fa:	f003 fd02 	bl	8051302 <strstr>
 804d8fe:	4604      	mov	r4, r0
			  const char *BIN = strstr(gau8SUBRequest,".bin");
 804d900:	493d      	ldr	r1, [pc, #244]	; (804d9f8 <main+0x310>)
 804d902:	4628      	mov	r0, r5
 804d904:	f003 fcfd 	bl	8051302 <strstr>
			  const size_t mlen = BIN - URL;
 804d908:	1b06      	subs	r6, r0, r4
			  if((URL != NULL) && (BIN != NULL))
 804d90a:	b194      	cbz	r4, 804d932 <main+0x24a>
 804d90c:	b188      	cbz	r0, 804d932 <main+0x24a>
				  memset(gau8FotaURL,0x00,sizeof(gau8FotaURL));
 804d90e:	4d3b      	ldr	r5, [pc, #236]	; (804d9fc <main+0x314>)
 804d910:	2296      	movs	r2, #150	; 0x96
 804d912:	2100      	movs	r1, #0
 804d914:	4628      	mov	r0, r5
 804d916:	f003 fc55 	bl	80511c4 <memset>
				  memcpy(gau8FotaURL,URL,mlen+4);
 804d91a:	1d32      	adds	r2, r6, #4
 804d91c:	4621      	mov	r1, r4
 804d91e:	4628      	mov	r0, r5
 804d920:	f003 fc42 	bl	80511a8 <memcpy>
				  Diagnostic(enmDiagnostic_FOTA_REQ_RX);
 804d924:	2004      	movs	r0, #4
 804d926:	f7fe fe77 	bl	804c618 <Diagnostic>
					  gu32FotaRquestFlag = TRUE;
 804d92a:	4b2e      	ldr	r3, [pc, #184]	; (804d9e4 <main+0x2fc>)
 804d92c:	2201      	movs	r2, #1
 804d92e:	601a      	str	r2, [r3, #0]
 804d930:	e002      	b.n	804d938 <main+0x250>
				  SUBTriggerFlag = FALSE;
 804d932:	4b27      	ldr	r3, [pc, #156]	; (804d9d0 <main+0x2e8>)
 804d934:	2200      	movs	r2, #0
 804d936:	701a      	strb	r2, [r3, #0]
		  memset(gau8SUBRequest,0x00,sizeof(gau8SUBRequest));
 804d938:	2296      	movs	r2, #150	; 0x96
 804d93a:	2100      	movs	r1, #0
 804d93c:	482c      	ldr	r0, [pc, #176]	; (804d9f0 <main+0x308>)
 804d93e:	f003 fc41 	bl	80511c4 <memset>
 804d942:	e789      	b.n	804d858 <main+0x170>
			  SUBTriggerFlag = FALSE;
 804d944:	4b22      	ldr	r3, [pc, #136]	; (804d9d0 <main+0x2e8>)
 804d946:	2200      	movs	r2, #0
 804d948:	701a      	strb	r2, [r3, #0]
 804d94a:	e7f5      	b.n	804d938 <main+0x250>
		HAL_GPIO_TogglePin(LED_2_GPIO_Port, LED_2_Pin);
 804d94c:	4c11      	ldr	r4, [pc, #68]	; (804d994 <main+0x2ac>)
 804d94e:	2140      	movs	r1, #64	; 0x40
 804d950:	4620      	mov	r0, r4
 804d952:	f7f5 f9c9 	bl	8042ce8 <HAL_GPIO_TogglePin>
		HAL_GPIO_TogglePin(HEARTBEAT_GPIO_Port,HEARTBEAT_Pin);
 804d956:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804d95a:	4620      	mov	r0, r4
 804d95c:	f7f5 f9c4 	bl	8042ce8 <HAL_GPIO_TogglePin>
		if(gu32InputSupplySwitchedAlert == FALSE)
 804d960:	4b21      	ldr	r3, [pc, #132]	; (804d9e8 <main+0x300>)
 804d962:	681b      	ldr	r3, [r3, #0]
 804d964:	b923      	cbnz	r3, 804d970 <main+0x288>
			gu32LedTimer = ONE_SEC;
 804d966:	4b1b      	ldr	r3, [pc, #108]	; (804d9d4 <main+0x2ec>)
 804d968:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804d96c:	601a      	str	r2, [r3, #0]
 804d96e:	e777      	b.n	804d860 <main+0x178>
			gu32LedTimer = FIVE_SEC;
 804d970:	4b18      	ldr	r3, [pc, #96]	; (804d9d4 <main+0x2ec>)
 804d972:	f241 3288 	movw	r2, #5000	; 0x1388
 804d976:	601a      	str	r2, [r3, #0]
 804d978:	e772      	b.n	804d860 <main+0x178>
		while(1); /* Forced Reset after 30 Mins or unable to upload data */
 804d97a:	e7fe      	b.n	804d97a <main+0x292>
 804d97c:	40021000 	.word	0x40021000
 804d980:	200028c4 	.word	0x200028c4
 804d984:	0001d4c0 	.word	0x0001d4c0
 804d988:	200028c8 	.word	0x200028c8
 804d98c:	000493e0 	.word	0x000493e0
 804d990:	2000d790 	.word	0x2000d790
 804d994:	40020c00 	.word	0x40020c00
 804d998:	40004800 	.word	0x40004800
 804d99c:	2000f5f8 	.word	0x2000f5f8
 804d9a0:	200053e4 	.word	0x200053e4
 804d9a4:	20004a98 	.word	0x20004a98
 804d9a8:	200022c4 	.word	0x200022c4
 804d9ac:	20004a60 	.word	0x20004a60
 804d9b0:	200016a4 	.word	0x200016a4
 804d9b4:	200038c4 	.word	0x200038c4
 804d9b8:	001b7740 	.word	0x001b7740
 804d9bc:	2000c61c 	.word	0x2000c61c
 804d9c0:	200053d8 	.word	0x200053d8
 804d9c4:	200038bc 	.word	0x200038bc
 804d9c8:	200053ec 	.word	0x200053ec
 804d9cc:	20004fa4 	.word	0x20004fa4
 804d9d0:	20004514 	.word	0x20004514
 804d9d4:	200053fc 	.word	0x200053fc
 804d9d8:	2000d814 	.word	0x2000d814
 804d9dc:	2000386c 	.word	0x2000386c
 804d9e0:	2000384c 	.word	0x2000384c
 804d9e4:	20004410 	.word	0x20004410
 804d9e8:	20005220 	.word	0x20005220
 804d9ec:	0805a168 	.word	0x0805a168
 804d9f0:	20000980 	.word	0x20000980
 804d9f4:	0805a07c 	.word	0x0805a07c
 804d9f8:	0805a16c 	.word	0x0805a16c
 804d9fc:	2000056c 	.word	0x2000056c

0804da00 <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 804da00:	4770      	bx	lr

0804da02 <modbusCRC16>:
* <hr>
*
*******************************************************************************/

uint16_t modbusCRC16(uint8_t * data , uint8_t length)
{
 804da02:	b430      	push	{r4, r5}
 804da04:	4605      	mov	r5, r0
	uint16_t crc = 0xFFFF;

	  for (int pos = 0; pos < length; pos++)
 804da06:	2400      	movs	r4, #0
	uint16_t crc = 0xFFFF;
 804da08:	f64f 70ff 	movw	r0, #65535	; 0xffff
	  for (int pos = 0; pos < length; pos++)
 804da0c:	e00b      	b.n	804da26 <modbusCRC16+0x24>
	      {
	        crc >>= 1;                    	// Shift right and XOR 0xA001
	        crc ^= 0xA001;
	      }
	      else                            	// Else LSB is not set
	        crc >>= 1;                    	// Just shift right
 804da0e:	0840      	lsrs	r0, r0, #1
	    for (int i = 8; i != 0; i--)  		// Loop over each bit
 804da10:	3b01      	subs	r3, #1
 804da12:	b13b      	cbz	r3, 804da24 <modbusCRC16+0x22>
	      if ((crc & 0x0001) != 0) 			// If the LSB is set
 804da14:	f010 0f01 	tst.w	r0, #1
 804da18:	d0f9      	beq.n	804da0e <modbusCRC16+0xc>
	        crc ^= 0xA001;
 804da1a:	f24a 0201 	movw	r2, #40961	; 0xa001
 804da1e:	ea82 0050 	eor.w	r0, r2, r0, lsr #1
 804da22:	e7f5      	b.n	804da10 <modbusCRC16+0xe>
	  for (int pos = 0; pos < length; pos++)
 804da24:	3401      	adds	r4, #1
 804da26:	42a1      	cmp	r1, r4
 804da28:	dd03      	ble.n	804da32 <modbusCRC16+0x30>
	    crc ^= (uint16_t)data[pos];         // XOR byte into least sig. byte of crc
 804da2a:	5d2b      	ldrb	r3, [r5, r4]
 804da2c:	4058      	eors	r0, r3
	    for (int i = 8; i != 0; i--)  		// Loop over each bit
 804da2e:	2308      	movs	r3, #8
 804da30:	e7ef      	b.n	804da12 <modbusCRC16+0x10>
	    }
	  }
	  return crc;
}
 804da32:	bc30      	pop	{r4, r5}
 804da34:	4770      	bx	lr
	...

0804da38 <updateModbusQueryFrameRTU>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateModbusQueryFrameRTU(strctModbusMaster *master)
{
 804da38:	b510      	push	{r4, lr}
 804da3a:	4604      	mov	r4, r0
	uint16_t crc ;
	/* Form Query Frame String */
	master->u8QueryFrame[0] = master->u8MBSlave_Address;
 804da3c:	7803      	ldrb	r3, [r0, #0]
 804da3e:	7043      	strb	r3, [r0, #1]
	master->u8QueryFrame[1] = gu32MBRTUClientFuncCode[u8MBQueryRegisterAddressCounter];
 804da40:	4b0f      	ldr	r3, [pc, #60]	; (804da80 <updateModbusQueryFrameRTU+0x48>)
 804da42:	781a      	ldrb	r2, [r3, #0]
 804da44:	4b0f      	ldr	r3, [pc, #60]	; (804da84 <updateModbusQueryFrameRTU+0x4c>)
 804da46:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 804da4a:	7081      	strb	r1, [r0, #2]
	master->u8QueryFrame[2] = ((gu32MBRTUClientAddress[u8MBQueryRegisterAddressCounter] - MB_ADDRESS_DEREF) >> 8);
 804da4c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804da50:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
 804da54:	3a01      	subs	r2, #1
 804da56:	0a12      	lsrs	r2, r2, #8
 804da58:	70c2      	strb	r2, [r0, #3]
	master->u8QueryFrame[3] = ((gu32MBRTUClientAddress[u8MBQueryRegisterAddressCounter] - MB_ADDRESS_DEREF)& 0xFF);
 804da5a:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
 804da5e:	3a01      	subs	r2, #1
 804da60:	7102      	strb	r2, [r0, #4]
	master->u8QueryFrame[4] = (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] >> 8);
 804da62:	f8d3 2258 	ldr.w	r2, [r3, #600]	; 0x258
 804da66:	0a12      	lsrs	r2, r2, #8
 804da68:	7142      	strb	r2, [r0, #5]
	master->u8QueryFrame[5] = (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] & 0xFF);
 804da6a:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
 804da6e:	7183      	strb	r3, [r0, #6]
	crc = modbusCRC16(master->u8QueryFrame , 6);
 804da70:	2106      	movs	r1, #6
 804da72:	3001      	adds	r0, #1
 804da74:	f7ff ffc5 	bl	804da02 <modbusCRC16>
	master->u8QueryFrame[6] = crc;
 804da78:	71e0      	strb	r0, [r4, #7]
	master->u8QueryFrame[7] = (crc >> 8);
 804da7a:	0a00      	lsrs	r0, r0, #8
 804da7c:	7220      	strb	r0, [r4, #8]
	/* End of Query Frame */
}
 804da7e:	bd10      	pop	{r4, pc}
 804da80:	20004598 	.word	0x20004598
 804da84:	20000ed4 	.word	0x20000ed4

0804da88 <resetModbusPort>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void resetModbusPort()
{
 804da88:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 804da8a:	4c07      	ldr	r4, [pc, #28]	; (804daa8 <resetModbusPort+0x20>)
 804da8c:	2200      	movs	r2, #0
 804da8e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804da92:	4620      	mov	r0, r4
 804da94:	f7f5 f922 	bl	8042cdc <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET);
 804da98:	2201      	movs	r2, #1
 804da9a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804da9e:	4620      	mov	r0, r4
 804daa0:	f7f5 f91c 	bl	8042cdc <HAL_GPIO_WritePin>
}
 804daa4:	bd10      	pop	{r4, pc}
 804daa6:	bf00      	nop
 804daa8:	40021000 	.word	0x40021000

0804daac <modbusQueryFSM>:
{
 804daac:	b5f0      	push	{r4, r5, r6, r7, lr}
 804daae:	b0a1      	sub	sp, #132	; 0x84
	switch(modbusState)
 804dab0:	4bb2      	ldr	r3, [pc, #712]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dab2:	785b      	ldrb	r3, [r3, #1]
 804dab4:	2b05      	cmp	r3, #5
 804dab6:	f200 8201 	bhi.w	804debc <modbusQueryFSM+0x410>
 804daba:	e8df f013 	tbh	[pc, r3, lsl #1]
 804dabe:	0006      	.short	0x0006
 804dac0:	004f01fd 	.word	0x004f01fd
 804dac4:	01cb0199 	.word	0x01cb0199
 804dac8:	0079      	.short	0x0079
			if(master.u32PollDelay == 0)
 804daca:	4bad      	ldr	r3, [pc, #692]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dacc:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 804dad0:	2b00      	cmp	r3, #0
 804dad2:	f040 81f1 	bne.w	804deb8 <modbusQueryFSM+0x40c>
				if(master.u8MBOperationStatus == 1)
 804dad6:	4baa      	ldr	r3, [pc, #680]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dad8:	f893 3521 	ldrb.w	r3, [r3, #1313]	; 0x521
 804dadc:	2b01      	cmp	r3, #1
 804dade:	f040 81eb 	bne.w	804deb8 <modbusQueryFSM+0x40c>
					HAL_GPIO_WritePin(MB_DE_GPIO_Port,MB_DE_Pin,GPIO_PIN_SET); // DE -> High
 804dae2:	4ca8      	ldr	r4, [pc, #672]	; (804dd84 <modbusQueryFSM+0x2d8>)
 804dae4:	2201      	movs	r2, #1
 804dae6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804daea:	4620      	mov	r0, r4
 804daec:	f7f5 f8f6 	bl	8042cdc <HAL_GPIO_WritePin>
					HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_SET); // ~RE -> HIGH
 804daf0:	2201      	movs	r2, #1
 804daf2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804daf6:	4620      	mov	r0, r4
 804daf8:	f7f5 f8f0 	bl	8042cdc <HAL_GPIO_WritePin>
					memset(master.u8SlaveResponseArray, 0x00, 260 * sizeof(int32_t));
 804dafc:	4ca2      	ldr	r4, [pc, #648]	; (804dd88 <modbusQueryFSM+0x2dc>)
 804dafe:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804db02:	2100      	movs	r1, #0
 804db04:	4620      	mov	r0, r4
 804db06:	f003 fb5d 	bl	80511c4 <memset>
					master.u8MBResponseCharacterCounter = 0;
 804db0a:	2200      	movs	r2, #0
 804db0c:	f884 2514 	strb.w	r2, [r4, #1300]	; 0x514
					gu8MBResponseFlag = 0;
 804db10:	4b9a      	ldr	r3, [pc, #616]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db12:	709a      	strb	r2, [r3, #2]
					if(u8MBQueryRegisterAddressCounter >= (master.u16NoRegisterstoFetch))
 804db14:	781a      	ldrb	r2, [r3, #0]
 804db16:	f8b4 3826 	ldrh.w	r3, [r4, #2086]	; 0x826
 804db1a:	429a      	cmp	r2, r3
 804db1c:	d304      	bcc.n	804db28 <modbusQueryFSM+0x7c>
						u8MBQueryRegisterAddressCounter = 0;
 804db1e:	4b97      	ldr	r3, [pc, #604]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db20:	2200      	movs	r2, #0
 804db22:	701a      	strb	r2, [r3, #0]
						gu32MBRTUDataByteCounter = 0;
 804db24:	605a      	str	r2, [r3, #4]
						break;
 804db26:	e1c7      	b.n	804deb8 <modbusQueryFSM+0x40c>
						updateModbusQueryFrameRTU(&master);
 804db28:	4c95      	ldr	r4, [pc, #596]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804db2a:	4620      	mov	r0, r4
 804db2c:	f7ff ff84 	bl	804da38 <updateModbusQueryFrameRTU>
  SET_BIT(USARTx->CR1, USART_CR1_TXEIE);
 804db30:	4b96      	ldr	r3, [pc, #600]	; (804dd8c <modbusQueryFSM+0x2e0>)
 804db32:	68da      	ldr	r2, [r3, #12]
 804db34:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 804db38:	60da      	str	r2, [r3, #12]
  SET_BIT(USARTx->CR1, USART_CR1_TCIE);
 804db3a:	68da      	ldr	r2, [r3, #12]
 804db3c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 804db40:	60da      	str	r2, [r3, #12]
					u8MBQueryCharacterCounter = 0;
 804db42:	4a8e      	ldr	r2, [pc, #568]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db44:	2100      	movs	r1, #0
 804db46:	7211      	strb	r1, [r2, #8]
					LL_USART_TransmitData8(USART3,master.u8QueryFrame[u8MBQueryCharacterCounter++]);
 804db48:	7a10      	ldrb	r0, [r2, #8]
 804db4a:	1c41      	adds	r1, r0, #1
 804db4c:	b2c9      	uxtb	r1, r1
 804db4e:	7211      	strb	r1, [r2, #8]
 804db50:	4404      	add	r4, r0
 804db52:	7861      	ldrb	r1, [r4, #1]
  USARTx->DR = Value;
 804db54:	6059      	str	r1, [r3, #4]
					modbusState = enmMODBUS_SEND_QUERY;
 804db56:	2301      	movs	r3, #1
 804db58:	7053      	strb	r3, [r2, #1]
 804db5a:	e1ad      	b.n	804deb8 <modbusQueryFSM+0x40c>
			if(master.u32PollDelay == 0)
 804db5c:	4b88      	ldr	r3, [pc, #544]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804db5e:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 804db62:	2b00      	cmp	r3, #0
 804db64:	f040 81a8 	bne.w	804deb8 <modbusQueryFSM+0x40c>
				if(gu8MBResponseFlag == 1)
 804db68:	4b84      	ldr	r3, [pc, #528]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db6a:	789b      	ldrb	r3, [r3, #2]
 804db6c:	2b01      	cmp	r3, #1
 804db6e:	d008      	beq.n	804db82 <modbusQueryFSM+0xd6>
					if(gu32ModbusResponseTimeout == 0)
 804db70:	4b82      	ldr	r3, [pc, #520]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db72:	691b      	ldr	r3, [r3, #16]
 804db74:	2b00      	cmp	r3, #0
 804db76:	f040 819f 	bne.w	804deb8 <modbusQueryFSM+0x40c>
						modbusState = enmMODBUS_RESPONSE_TIMEOUT;
 804db7a:	4b80      	ldr	r3, [pc, #512]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db7c:	2204      	movs	r2, #4
 804db7e:	705a      	strb	r2, [r3, #1]
 804db80:	e19a      	b.n	804deb8 <modbusQueryFSM+0x40c>
					if((gu32ModbusFrameEndTimer == 0) && (gu32ModbusResponseTimeout != 0))
 804db82:	4b7e      	ldr	r3, [pc, #504]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db84:	68db      	ldr	r3, [r3, #12]
 804db86:	b943      	cbnz	r3, 804db9a <modbusQueryFSM+0xee>
 804db88:	4b7c      	ldr	r3, [pc, #496]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db8a:	691b      	ldr	r3, [r3, #16]
 804db8c:	b12b      	cbz	r3, 804db9a <modbusQueryFSM+0xee>
						modbusState = enmMODBUS_PARSE_RESPONSE;
 804db8e:	4b7b      	ldr	r3, [pc, #492]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db90:	2205      	movs	r2, #5
 804db92:	705a      	strb	r2, [r3, #1]
						gu8MBResponseFlag = 0;
 804db94:	2200      	movs	r2, #0
 804db96:	709a      	strb	r2, [r3, #2]
 804db98:	e18e      	b.n	804deb8 <modbusQueryFSM+0x40c>
					else if(gu32ModbusResponseTimeout == 0)
 804db9a:	4b78      	ldr	r3, [pc, #480]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804db9c:	691b      	ldr	r3, [r3, #16]
 804db9e:	2b00      	cmp	r3, #0
 804dba0:	f040 818a 	bne.w	804deb8 <modbusQueryFSM+0x40c>
						modbusState = enmMODBUS_PARSE_RESPONSE;
 804dba4:	4b75      	ldr	r3, [pc, #468]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dba6:	2205      	movs	r2, #5
 804dba8:	705a      	strb	r2, [r3, #1]
						gu8MBResponseFlag = 0;
 804dbaa:	2200      	movs	r2, #0
 804dbac:	709a      	strb	r2, [r3, #2]
 804dbae:	e183      	b.n	804deb8 <modbusQueryFSM+0x40c>
			if(master.u8SlaveResponseArray[0] == gu32MBRTUClientFuncCode[u8MBQueryRegisterAddressCounter])
 804dbb0:	4b73      	ldr	r3, [pc, #460]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dbb2:	68de      	ldr	r6, [r3, #12]
 804dbb4:	4b71      	ldr	r3, [pc, #452]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dbb6:	781d      	ldrb	r5, [r3, #0]
 804dbb8:	462c      	mov	r4, r5
 804dbba:	4b75      	ldr	r3, [pc, #468]	; (804dd90 <modbusQueryFSM+0x2e4>)
 804dbbc:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 804dbc0:	429e      	cmp	r6, r3
 804dbc2:	d007      	beq.n	804dbd4 <modbusQueryFSM+0x128>
			else if((master.u8SlaveResponseArray[0] & 0x80) == 0x80)
 804dbc4:	f016 0f80 	tst.w	r6, #128	; 0x80
 804dbc8:	f040 8110 	bne.w	804ddec <modbusQueryFSM+0x340>
				modbusState = enmMODBUS_RETRY_QUERY;
 804dbcc:	4b6b      	ldr	r3, [pc, #428]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dbce:	2203      	movs	r2, #3
 804dbd0:	705a      	strb	r2, [r3, #1]
 804dbd2:	e104      	b.n	804ddde <modbusQueryFSM+0x332>
				uint8_t u8TempCRCArray[125]= {0};
 804dbd4:	2400      	movs	r4, #0
 804dbd6:	9400      	str	r4, [sp, #0]
 804dbd8:	2279      	movs	r2, #121	; 0x79
 804dbda:	4621      	mov	r1, r4
 804dbdc:	a801      	add	r0, sp, #4
 804dbde:	f003 faf1 	bl	80511c4 <memset>
				uint8_t u8MBNoDataBytesRx = (uint8_t)master.u8SlaveResponseArray[1];
 804dbe2:	4b67      	ldr	r3, [pc, #412]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dbe4:	691f      	ldr	r7, [r3, #16]
 804dbe6:	b2f8      	uxtb	r0, r7
				u8TempCRCArray[0]=master.u8MBSlave_Address;       // ID
 804dbe8:	781b      	ldrb	r3, [r3, #0]
 804dbea:	f88d 3000 	strb.w	r3, [sp]
				u8TempCRCArray[1]=master.u8SlaveResponseArray[0]; // FC
 804dbee:	f88d 6001 	strb.w	r6, [sp, #1]
				u8TempCRCArray[2]=master.u8SlaveResponseArray[1]; // No of Bytes
 804dbf2:	f88d 0002 	strb.w	r0, [sp, #2]
				for(u8CrcLoopCounter = 0 ; u8CrcLoopCounter < u8MBNoDataBytesRx ;u8CrcLoopCounter ++ )
 804dbf6:	4621      	mov	r1, r4
 804dbf8:	e00b      	b.n	804dc12 <modbusQueryFSM+0x166>
					u8TempCRCArray[3 + u8CrcLoopCounter] = master.u8SlaveResponseArray[2 + u8CrcLoopCounter];
 804dbfa:	1d0a      	adds	r2, r1, #4
 804dbfc:	4b60      	ldr	r3, [pc, #384]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dbfe:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804dc02:	685a      	ldr	r2, [r3, #4]
 804dc04:	1ccb      	adds	r3, r1, #3
 804dc06:	ac20      	add	r4, sp, #128	; 0x80
 804dc08:	4423      	add	r3, r4
 804dc0a:	f803 2c80 	strb.w	r2, [r3, #-128]
				for(u8CrcLoopCounter = 0 ; u8CrcLoopCounter < u8MBNoDataBytesRx ;u8CrcLoopCounter ++ )
 804dc0e:	3101      	adds	r1, #1
 804dc10:	b2c9      	uxtb	r1, r1
 804dc12:	4281      	cmp	r1, r0
 804dc14:	d3f1      	bcc.n	804dbfa <modbusQueryFSM+0x14e>
				u16TempCRC = modbusCRC16(u8TempCRCArray,3 + u8CrcLoopCounter);
 804dc16:	3103      	adds	r1, #3
 804dc18:	b2c9      	uxtb	r1, r1
 804dc1a:	4668      	mov	r0, sp
 804dc1c:	f7ff fef1 	bl	804da02 <modbusCRC16>
				uint8_t u8CRCHi = master.u8SlaveResponseArray[u8MBNoDataBytesRx + 2 ];    // CRC High Location
 804dc20:	b2ff      	uxtb	r7, r7
 804dc22:	4a57      	ldr	r2, [pc, #348]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dc24:	1d3b      	adds	r3, r7, #4
 804dc26:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 804dc2a:	791b      	ldrb	r3, [r3, #4]
				uint8_t u8CRCLow = master.u8SlaveResponseArray[u8MBNoDataBytesRx + 3];    // CRC Low Location
 804dc2c:	1d79      	adds	r1, r7, #5
 804dc2e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804dc32:	6852      	ldr	r2, [r2, #4]
				uint16_t u16ReceivedCRC =  (u8CRCLow<<8)|u8CRCHi;
 804dc34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 804dc38:	b29b      	uxth	r3, r3
				if(u16ReceivedCRC == u16TempCRC)
 804dc3a:	4298      	cmp	r0, r3
 804dc3c:	d003      	beq.n	804dc46 <modbusQueryFSM+0x19a>
					modbusState = enmMODBUS_RETRY_QUERY;
 804dc3e:	4b4f      	ldr	r3, [pc, #316]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dc40:	2203      	movs	r2, #3
 804dc42:	705a      	strb	r2, [r3, #1]
 804dc44:	e0cb      	b.n	804ddde <modbusQueryFSM+0x332>
					gu32MBRTUClientConnectedFlag = 1; /* Indicates Response Received form client in payload .*/
 804dc46:	4b4d      	ldr	r3, [pc, #308]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dc48:	2201      	movs	r2, #1
 804dc4a:	615a      	str	r2, [r3, #20]
					if(master.u8SlaveResponseArray[0] == 1)
 804dc4c:	4296      	cmp	r6, r2
 804dc4e:	d01b      	beq.n	804dc88 <modbusQueryFSM+0x1dc>
						if(u8MBNoDataBytesRx == (2 * gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter]))
 804dc50:	4b4f      	ldr	r3, [pc, #316]	; (804dd90 <modbusQueryFSM+0x2e4>)
 804dc52:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 804dc56:	f8d3 0258 	ldr.w	r0, [r3, #600]	; 0x258
 804dc5a:	ebb7 0f40 	cmp.w	r7, r0, lsl #1
 804dc5e:	d04d      	beq.n	804dcfc <modbusQueryFSM+0x250>
							gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];
 804dc60:	4a46      	ldr	r2, [pc, #280]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dc62:	6853      	ldr	r3, [r2, #4]
 804dc64:	4403      	add	r3, r0
 804dc66:	6053      	str	r3, [r2, #4]
					master.u8MBResponseStatus[u8MBQueryRegisterAddressCounter++] = 0;
 804dc68:	4c44      	ldr	r4, [pc, #272]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dc6a:	1c6b      	adds	r3, r5, #1
 804dc6c:	7023      	strb	r3, [r4, #0]
 804dc6e:	4f44      	ldr	r7, [pc, #272]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dc70:	443d      	add	r5, r7
 804dc72:	2600      	movs	r6, #0
 804dc74:	f885 6523 	strb.w	r6, [r5, #1315]	; 0x523
					resetModbusPort();
 804dc78:	f7ff ff06 	bl	804da88 <resetModbusPort>
					master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804dc7c:	4b45      	ldr	r3, [pc, #276]	; (804dd94 <modbusQueryFSM+0x2e8>)
 804dc7e:	681b      	ldr	r3, [r3, #0]
 804dc80:	f8c7 3e4c 	str.w	r3, [r7, #3660]	; 0xe4c
					modbusState = enmMODBUS_IDLE;
 804dc84:	7066      	strb	r6, [r4, #1]
 804dc86:	e0aa      	b.n	804ddde <modbusQueryFSM+0x332>
						for(LoopCounter = 0; LoopCounter < u8MBNoDataBytesRx; LoopCounter++)
 804dc88:	2100      	movs	r1, #0
 804dc8a:	428f      	cmp	r7, r1
 804dc8c:	d913      	bls.n	804dcb6 <modbusQueryFSM+0x20a>
							master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u8SlaveResponseArray[2 + LoopCounter];
 804dc8e:	4b3b      	ldr	r3, [pc, #236]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dc90:	6858      	ldr	r0, [r3, #4]
 804dc92:	4a3b      	ldr	r2, [pc, #236]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dc94:	1d0c      	adds	r4, r1, #4
 804dc96:	eb02 0484 	add.w	r4, r2, r4, lsl #2
 804dc9a:	6864      	ldr	r4, [r4, #4]
 804dc9c:	f200 268e 	addw	r6, r0, #654	; 0x28e
 804dca0:	eb02 0286 	add.w	r2, r2, r6, lsl #2
 804dca4:	6054      	str	r4, [r2, #4]
							gu32MBRTUDataStatus[gu32MBRTUDataByteCounter++] = 2;
 804dca6:	1c42      	adds	r2, r0, #1
 804dca8:	605a      	str	r2, [r3, #4]
 804dcaa:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 804dcae:	2202      	movs	r2, #2
 804dcb0:	619a      	str	r2, [r3, #24]
						for(LoopCounter = 0; LoopCounter < u8MBNoDataBytesRx; LoopCounter++)
 804dcb2:	3101      	adds	r1, #1
 804dcb4:	e7e9      	b.n	804dc8a <modbusQueryFSM+0x1de>
						if(u8MBNoDataBytesRx != gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter])
 804dcb6:	4a36      	ldr	r2, [pc, #216]	; (804dd90 <modbusQueryFSM+0x2e4>)
 804dcb8:	eb02 0285 	add.w	r2, r2, r5, lsl #2
 804dcbc:	f8d2 2258 	ldr.w	r2, [r2, #600]	; 0x258
 804dcc0:	4297      	cmp	r7, r2
 804dcc2:	d0d1      	beq.n	804dc68 <modbusQueryFSM+0x1bc>
							gu32MBRTUDataByteCounter += (gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter] - u8MBNoDataBytesRx);
 804dcc4:	1bd3      	subs	r3, r2, r7
 804dcc6:	492d      	ldr	r1, [pc, #180]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dcc8:	684a      	ldr	r2, [r1, #4]
 804dcca:	4413      	add	r3, r2
 804dccc:	604b      	str	r3, [r1, #4]
 804dcce:	e7cb      	b.n	804dc68 <modbusQueryFSM+0x1bc>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dcd0:	492b      	ldr	r1, [pc, #172]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dcd2:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 804dcd6:	f9b4 4004 	ldrsh.w	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] +256 ;
 804dcda:	3303      	adds	r3, #3
 804dcdc:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 804dce0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 804dce4:	eb03 2304 	add.w	r3, r3, r4, lsl #8
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dce8:	4c24      	ldr	r4, [pc, #144]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dcea:	6864      	ldr	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] +256 ;
 804dcec:	f503 7380 	add.w	r3, r3, #256	; 0x100
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dcf0:	f204 248e 	addw	r4, r4, #654	; 0x28e
 804dcf4:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804dcf8:	604b      	str	r3, [r1, #4]
 804dcfa:	e01f      	b.n	804dd3c <modbusQueryFSM+0x290>
							for(u32LoopCounter = 0; u32LoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32LoopCounter++)
 804dcfc:	2200      	movs	r2, #0
 804dcfe:	4290      	cmp	r0, r2
 804dd00:	d9b2      	bls.n	804dc68 <modbusQueryFSM+0x1bc>
								if((int32_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter)] < 0)
 804dd02:	3201      	adds	r2, #1
 804dd04:	0053      	lsls	r3, r2, #1
 804dd06:	1c9c      	adds	r4, r3, #2
 804dd08:	491d      	ldr	r1, [pc, #116]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dd0a:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804dd0e:	6849      	ldr	r1, [r1, #4]
 804dd10:	2900      	cmp	r1, #0
 804dd12:	dbdd      	blt.n	804dcd0 <modbusQueryFSM+0x224>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dd14:	491a      	ldr	r1, [pc, #104]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dd16:	1c9c      	adds	r4, r3, #2
 804dd18:	eb01 0484 	add.w	r4, r1, r4, lsl #2
 804dd1c:	f9b4 6004 	ldrsh.w	r6, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] ;
 804dd20:	3303      	adds	r3, #3
 804dd22:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 804dd26:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dd2a:	4c14      	ldr	r4, [pc, #80]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dd2c:	6864      	ldr	r4, [r4, #4]
																					 + (int16_t)master.u8SlaveResponseArray[2 + (2 * u32LoopCounter) + 1] ;
 804dd2e:	eb03 2306 	add.w	r3, r3, r6, lsl #8
									master.u32SlaveData[gu32MBRTUDataByteCounter] = ((int16_t)master.u8SlaveResponseArray[2 + (2* u32LoopCounter)] << 8)
 804dd32:	f204 248e 	addw	r4, r4, #654	; 0x28e
 804dd36:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804dd3a:	604b      	str	r3, [r1, #4]
								if(master.u32SlaveData[gu32MBRTUDataByteCounter] > 32768)
 804dd3c:	4b0f      	ldr	r3, [pc, #60]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dd3e:	685b      	ldr	r3, [r3, #4]
 804dd40:	f203 248e 	addw	r4, r3, #654	; 0x28e
 804dd44:	490e      	ldr	r1, [pc, #56]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dd46:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 804dd4a:	6849      	ldr	r1, [r1, #4]
 804dd4c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 804dd50:	d905      	bls.n	804dd5e <modbusQueryFSM+0x2b2>
									master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u32SlaveData[gu32MBRTUDataByteCounter] - 65536;
 804dd52:	f5a1 3180 	sub.w	r1, r1, #65536	; 0x10000
 804dd56:	4e0a      	ldr	r6, [pc, #40]	; (804dd80 <modbusQueryFSM+0x2d4>)
 804dd58:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 804dd5c:	6061      	str	r1, [r4, #4]
								gu32MBRTUDataStatus[gu32MBRTUDataByteCounter] = 0;
 804dd5e:	4907      	ldr	r1, [pc, #28]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dd60:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 804dd64:	2600      	movs	r6, #0
 804dd66:	61a6      	str	r6, [r4, #24]
								gu32MBRTUDataByteCounter++;
 804dd68:	3301      	adds	r3, #1
 804dd6a:	604b      	str	r3, [r1, #4]
								if(gu32MBRTUDataByteCounter >= gu32MBDataByteCounterLimitRTU)
 804dd6c:	f8d1 14c8 	ldr.w	r1, [r1, #1224]	; 0x4c8
 804dd70:	428b      	cmp	r3, r1
 804dd72:	d3c4      	bcc.n	804dcfe <modbusQueryFSM+0x252>
									gu32MBRTUDataByteCounter = 0;
 804dd74:	4b01      	ldr	r3, [pc, #4]	; (804dd7c <modbusQueryFSM+0x2d0>)
 804dd76:	605e      	str	r6, [r3, #4]
 804dd78:	e7c1      	b.n	804dcfe <modbusQueryFSM+0x252>
 804dd7a:	bf00      	nop
 804dd7c:	20004598 	.word	0x20004598
 804dd80:	2000d868 	.word	0x2000d868
 804dd84:	40021000 	.word	0x40021000
 804dd88:	2000d874 	.word	0x2000d874
 804dd8c:	40004800 	.word	0x40004800
 804dd90:	20000ed4 	.word	0x20000ed4
 804dd94:	200028d4 	.word	0x200028d4
					master.u32SlaveData[gu32MBRTUDataByteCounter] = master.u8SlaveResponseArray[1] ;
 804dd98:	4b4a      	ldr	r3, [pc, #296]	; (804dec4 <modbusQueryFSM+0x418>)
 804dd9a:	6859      	ldr	r1, [r3, #4]
 804dd9c:	4a4a      	ldr	r2, [pc, #296]	; (804dec8 <modbusQueryFSM+0x41c>)
 804dd9e:	6916      	ldr	r6, [r2, #16]
 804dda0:	f201 278e 	addw	r7, r1, #654	; 0x28e
 804dda4:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 804dda8:	6056      	str	r6, [r2, #4]
					gu32MBRTUDataStatus[gu32MBRTUDataByteCounter++] = 1;
 804ddaa:	1c4a      	adds	r2, r1, #1
 804ddac:	605a      	str	r2, [r3, #4]
 804ddae:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804ddb2:	2201      	movs	r2, #1
 804ddb4:	619a      	str	r2, [r3, #24]
				for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32TempLoopCounter++)
 804ddb6:	4410      	add	r0, r2
 804ddb8:	4b44      	ldr	r3, [pc, #272]	; (804decc <modbusQueryFSM+0x420>)
 804ddba:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 804ddbe:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
 804ddc2:	4283      	cmp	r3, r0
 804ddc4:	d8e8      	bhi.n	804dd98 <modbusQueryFSM+0x2ec>
				u8MBQueryRegisterAddressCounter++;
 804ddc6:	4c3f      	ldr	r4, [pc, #252]	; (804dec4 <modbusQueryFSM+0x418>)
 804ddc8:	3501      	adds	r5, #1
 804ddca:	7025      	strb	r5, [r4, #0]
				resetModbusPort();
 804ddcc:	f7ff fe5c 	bl	804da88 <resetModbusPort>
				master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804ddd0:	4b3f      	ldr	r3, [pc, #252]	; (804ded0 <modbusQueryFSM+0x424>)
 804ddd2:	681a      	ldr	r2, [r3, #0]
 804ddd4:	4b3c      	ldr	r3, [pc, #240]	; (804dec8 <modbusQueryFSM+0x41c>)
 804ddd6:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c
				modbusState = enmMODBUS_IDLE;
 804ddda:	2300      	movs	r3, #0
 804dddc:	7063      	strb	r3, [r4, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804ddde:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804dde2:	2100      	movs	r1, #0
 804dde4:	483b      	ldr	r0, [pc, #236]	; (804ded4 <modbusQueryFSM+0x428>)
 804dde6:	f003 f9ed 	bl	80511c4 <memset>
			break;
 804ddea:	e065      	b.n	804deb8 <modbusQueryFSM+0x40c>
				for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];u32TempLoopCounter++)
 804ddec:	2000      	movs	r0, #0
 804ddee:	e7e3      	b.n	804ddb8 <modbusQueryFSM+0x30c>
			if(master.u8MBNoQueryAttempts > MB_485_QUERY_RETRY_ATTEMPTS)
 804ddf0:	4b35      	ldr	r3, [pc, #212]	; (804dec8 <modbusQueryFSM+0x41c>)
 804ddf2:	f893 3522 	ldrb.w	r3, [r3, #1314]	; 0x522
 804ddf6:	2b03      	cmp	r3, #3
 804ddf8:	d927      	bls.n	804de4a <modbusQueryFSM+0x39e>
				gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter];
 804ddfa:	4b32      	ldr	r3, [pc, #200]	; (804dec4 <modbusQueryFSM+0x418>)
 804ddfc:	781a      	ldrb	r2, [r3, #0]
 804ddfe:	4933      	ldr	r1, [pc, #204]	; (804decc <modbusQueryFSM+0x420>)
 804de00:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 804de04:	f8d1 0258 	ldr.w	r0, [r1, #600]	; 0x258
 804de08:	6859      	ldr	r1, [r3, #4]
 804de0a:	4401      	add	r1, r0
 804de0c:	6059      	str	r1, [r3, #4]
				u8MBQueryRegisterAddressCounter++;
 804de0e:	3201      	adds	r2, #1
 804de10:	701a      	strb	r2, [r3, #0]
			if(u8MBQueryRegisterAddressCounter > master.u16NoRegisterstoFetch)
 804de12:	4b2c      	ldr	r3, [pc, #176]	; (804dec4 <modbusQueryFSM+0x418>)
 804de14:	781a      	ldrb	r2, [r3, #0]
 804de16:	4b2c      	ldr	r3, [pc, #176]	; (804dec8 <modbusQueryFSM+0x41c>)
 804de18:	f8b3 3832 	ldrh.w	r3, [r3, #2098]	; 0x832
 804de1c:	429a      	cmp	r2, r3
 804de1e:	d904      	bls.n	804de2a <modbusQueryFSM+0x37e>
				gu32MBRTUDataByteCounter = 0;
 804de20:	4b28      	ldr	r3, [pc, #160]	; (804dec4 <modbusQueryFSM+0x418>)
 804de22:	2200      	movs	r2, #0
 804de24:	605a      	str	r2, [r3, #4]
				u8MBQueryRegisterAddressCounter = 0;
 804de26:	701a      	strb	r2, [r3, #0]
				gu32MBRTUClientConnectedFlag = 0;
 804de28:	615a      	str	r2, [r3, #20]
			resetModbusPort();
 804de2a:	f7ff fe2d 	bl	804da88 <resetModbusPort>
			master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804de2e:	4826      	ldr	r0, [pc, #152]	; (804dec8 <modbusQueryFSM+0x41c>)
 804de30:	4b27      	ldr	r3, [pc, #156]	; (804ded0 <modbusQueryFSM+0x424>)
 804de32:	681b      	ldr	r3, [r3, #0]
 804de34:	f8c0 3e4c 	str.w	r3, [r0, #3660]	; 0xe4c
			modbusState = enmMODBUS_IDLE;
 804de38:	2100      	movs	r1, #0
 804de3a:	4b22      	ldr	r3, [pc, #136]	; (804dec4 <modbusQueryFSM+0x418>)
 804de3c:	7059      	strb	r1, [r3, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804de3e:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804de42:	300c      	adds	r0, #12
 804de44:	f003 f9be 	bl	80511c4 <memset>
			break;
 804de48:	e036      	b.n	804deb8 <modbusQueryFSM+0x40c>
				master.u8MBNoQueryAttempts++;
 804de4a:	3301      	adds	r3, #1
 804de4c:	4a1e      	ldr	r2, [pc, #120]	; (804dec8 <modbusQueryFSM+0x41c>)
 804de4e:	f882 3522 	strb.w	r3, [r2, #1314]	; 0x522
 804de52:	e7de      	b.n	804de12 <modbusQueryFSM+0x366>
			uint32_t temploopcountrt = gu32MBRTUDataByteCounter;
 804de54:	4a1b      	ldr	r2, [pc, #108]	; (804dec4 <modbusQueryFSM+0x418>)
 804de56:	6853      	ldr	r3, [r2, #4]
			gu32MBRTUDataByteCounter += gu32MBRTUClientNoofPoints[u8MBQueryRegisterAddressCounter++];
 804de58:	7810      	ldrb	r0, [r2, #0]
 804de5a:	1c44      	adds	r4, r0, #1
 804de5c:	b2e4      	uxtb	r4, r4
 804de5e:	7014      	strb	r4, [r2, #0]
 804de60:	491a      	ldr	r1, [pc, #104]	; (804decc <modbusQueryFSM+0x420>)
 804de62:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804de66:	f8d1 0258 	ldr.w	r0, [r1, #600]	; 0x258
 804de6a:	4418      	add	r0, r3
 804de6c:	6050      	str	r0, [r2, #4]
			for(iteratorrt = temploopcountrt ; iteratorrt < gu32MBRTUDataByteCounter ; iteratorrt++)
 804de6e:	e007      	b.n	804de80 <modbusQueryFSM+0x3d4>
				master.u32SlaveData[iteratorrt] = 0;
 804de70:	f203 218e 	addw	r1, r3, #654	; 0x28e
 804de74:	4a14      	ldr	r2, [pc, #80]	; (804dec8 <modbusQueryFSM+0x41c>)
 804de76:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804de7a:	2100      	movs	r1, #0
 804de7c:	6051      	str	r1, [r2, #4]
			for(iteratorrt = temploopcountrt ; iteratorrt < gu32MBRTUDataByteCounter ; iteratorrt++)
 804de7e:	3301      	adds	r3, #1
 804de80:	4298      	cmp	r0, r3
 804de82:	d8f5      	bhi.n	804de70 <modbusQueryFSM+0x3c4>
			if(u8MBQueryRegisterAddressCounter >= (master.u16NoRegisterstoFetch))
 804de84:	b2a4      	uxth	r4, r4
 804de86:	4b10      	ldr	r3, [pc, #64]	; (804dec8 <modbusQueryFSM+0x41c>)
 804de88:	f8b3 3832 	ldrh.w	r3, [r3, #2098]	; 0x832
 804de8c:	429c      	cmp	r4, r3
 804de8e:	d304      	bcc.n	804de9a <modbusQueryFSM+0x3ee>
				u8MBQueryRegisterAddressCounter = 0;
 804de90:	4b0c      	ldr	r3, [pc, #48]	; (804dec4 <modbusQueryFSM+0x418>)
 804de92:	2200      	movs	r2, #0
 804de94:	701a      	strb	r2, [r3, #0]
				gu32MBRTUClientConnectedFlag = 0;
 804de96:	615a      	str	r2, [r3, #20]
				gu32MBRTUDataByteCounter = 0;
 804de98:	605a      	str	r2, [r3, #4]
			resetModbusPort();
 804de9a:	f7ff fdf5 	bl	804da88 <resetModbusPort>
			master.u32PollDelay = gu32Modbus485PollingTime;//ONE_SEC;
 804de9e:	480a      	ldr	r0, [pc, #40]	; (804dec8 <modbusQueryFSM+0x41c>)
 804dea0:	4b0b      	ldr	r3, [pc, #44]	; (804ded0 <modbusQueryFSM+0x424>)
 804dea2:	681b      	ldr	r3, [r3, #0]
 804dea4:	f8c0 3e4c 	str.w	r3, [r0, #3660]	; 0xe4c
			modbusState = enmMODBUS_IDLE;
 804dea8:	2100      	movs	r1, #0
 804deaa:	4b06      	ldr	r3, [pc, #24]	; (804dec4 <modbusQueryFSM+0x418>)
 804deac:	7059      	strb	r1, [r3, #1]
			memset(master.u8SlaveResponseArray,0x00,sizeof(master.u8SlaveResponseArray));
 804deae:	f44f 6282 	mov.w	r2, #1040	; 0x410
 804deb2:	300c      	adds	r0, #12
 804deb4:	f003 f986 	bl	80511c4 <memset>
}
 804deb8:	b021      	add	sp, #132	; 0x84
 804deba:	bdf0      	pop	{r4, r5, r6, r7, pc}
			modbusState = enmMODBUS_IDLE;
 804debc:	4b01      	ldr	r3, [pc, #4]	; (804dec4 <modbusQueryFSM+0x418>)
 804debe:	2200      	movs	r2, #0
 804dec0:	705a      	strb	r2, [r3, #1]
}
 804dec2:	e7f9      	b.n	804deb8 <modbusQueryFSM+0x40c>
 804dec4:	20004598 	.word	0x20004598
 804dec8:	2000d868 	.word	0x2000d868
 804decc:	20000ed4 	.word	0x20000ed4
 804ded0:	200028d4 	.word	0x200028d4
 804ded4:	2000d874 	.word	0x2000d874

0804ded8 <uploadSlaveData>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void uploadSlaveData(void)
{
 804ded8:	b530      	push	{r4, r5, lr}
 804deda:	b083      	sub	sp, #12
	static int32_t value;
	char buffer[6];

//	if(master.u8MBOperationStatus == 2)
//	{
		value = master.u32SlaveData[Loopcounter];    // Signed Integer
 804dedc:	4a45      	ldr	r2, [pc, #276]	; (804dff4 <uploadSlaveData+0x11c>)
 804dede:	f8d2 44cc 	ldr.w	r4, [r2, #1228]	; 0x4cc
 804dee2:	f204 218e 	addw	r1, r4, #654	; 0x28e
 804dee6:	4b44      	ldr	r3, [pc, #272]	; (804dff8 <uploadSlaveData+0x120>)
 804dee8:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804deec:	685d      	ldr	r5, [r3, #4]
 804deee:	f8c2 54d0 	str.w	r5, [r2, #1232]	; 0x4d0
		if(Loopcounter == 0)
 804def2:	b364      	cbz	r4, 804df4e <uploadSlaveData+0x76>
		{
			memset(gau8MBPayloadStringRT, 0x00, (1100 * sizeof(char)));
		}
		if(Loopcounter < gu32MBDataByteCounterLimitRTU)
 804def4:	4b3f      	ldr	r3, [pc, #252]	; (804dff4 <uploadSlaveData+0x11c>)
 804def6:	f8d3 34c8 	ldr.w	r3, [r3, #1224]	; 0x4c8
 804defa:	429c      	cmp	r4, r3
 804defc:	d264      	bcs.n	804dfc8 <uploadSlaveData+0xf0>
		{
			/* Append Data to GSM Payload */
			if(gu32MBRTUDataStatus[Loopcounter] == 1)
 804defe:	4b3d      	ldr	r3, [pc, #244]	; (804dff4 <uploadSlaveData+0x11c>)
 804df00:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 804df04:	69a3      	ldr	r3, [r4, #24]
 804df06:	2b01      	cmp	r3, #1
 804df08:	d028      	beq.n	804df5c <uploadSlaveData+0x84>
				memset(buffer, 0x00, (6 * sizeof(char)));
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
				strcat(gau8MBPayloadStringRT,buffer);
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
			}
			else if(gu32MBRTUDataStatus[Loopcounter] == 2)
 804df0a:	2b02      	cmp	r3, #2
 804df0c:	d147      	bne.n	804df9e <uploadSlaveData+0xc6>
			{
				/* Coil Data .Represent in binary .
				 * */
				if(value < 0)
 804df0e:	2d00      	cmp	r5, #0
 804df10:	db3f      	blt.n	804df92 <uploadSlaveData+0xba>
					value += 256;

				memset(buffer, 0x00, (6 * sizeof(char)));
 804df12:	2300      	movs	r3, #0
 804df14:	9300      	str	r3, [sp, #0]
 804df16:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,10);
 804df1a:	220a      	movs	r2, #10
 804df1c:	4669      	mov	r1, sp
 804df1e:	4b35      	ldr	r3, [pc, #212]	; (804dff4 <uploadSlaveData+0x11c>)
 804df20:	f8d3 04d0 	ldr.w	r0, [r3, #1232]	; 0x4d0
 804df24:	f002 fede 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804df28:	4c34      	ldr	r4, [pc, #208]	; (804dffc <uploadSlaveData+0x124>)
 804df2a:	4669      	mov	r1, sp
 804df2c:	4620      	mov	r0, r4
 804df2e:	f003 f99f 	bl	8051270 <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804df32:	4620      	mov	r0, r4
 804df34:	f7f2 f95c 	bl	80401f0 <strlen>
 804df38:	4b31      	ldr	r3, [pc, #196]	; (804e000 <uploadSlaveData+0x128>)
 804df3a:	881b      	ldrh	r3, [r3, #0]
 804df3c:	5223      	strh	r3, [r4, r0]
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
			}
			//master.u32SlaveData[Loopcounter] = 0;
			/*Added on 20-1-2020 */
			//gu32MBRTUDataStatus[Loopcounter] = 0;
			Loopcounter++;
 804df3e:	4a2d      	ldr	r2, [pc, #180]	; (804dff4 <uploadSlaveData+0x11c>)
 804df40:	f8d2 34cc 	ldr.w	r3, [r2, #1228]	; 0x4cc
 804df44:	3301      	adds	r3, #1
 804df46:	f8c2 34cc 	str.w	r3, [r2, #1228]	; 0x4cc
			memset(gau8MBPayloadStringRT,0x00,1100 * sizeof(char));
			Loopcounter = 0;
			//gu32MBRTUDataByteCounter = 0;
		}
	//}
}
 804df4a:	b003      	add	sp, #12
 804df4c:	bd30      	pop	{r4, r5, pc}
			memset(gau8MBPayloadStringRT, 0x00, (1100 * sizeof(char)));
 804df4e:	f240 424c 	movw	r2, #1100	; 0x44c
 804df52:	2100      	movs	r1, #0
 804df54:	4829      	ldr	r0, [pc, #164]	; (804dffc <uploadSlaveData+0x124>)
 804df56:	f003 f935 	bl	80511c4 <memset>
 804df5a:	e7cb      	b.n	804def4 <uploadSlaveData+0x1c>
				strcat(gau8MBPayloadStringRT,"E");
 804df5c:	4c27      	ldr	r4, [pc, #156]	; (804dffc <uploadSlaveData+0x124>)
 804df5e:	4620      	mov	r0, r4
 804df60:	f7f2 f946 	bl	80401f0 <strlen>
 804df64:	4b27      	ldr	r3, [pc, #156]	; (804e004 <uploadSlaveData+0x12c>)
 804df66:	881b      	ldrh	r3, [r3, #0]
 804df68:	5223      	strh	r3, [r4, r0]
				memset(buffer, 0x00, (6 * sizeof(char)));
 804df6a:	2300      	movs	r3, #0
 804df6c:	9300      	str	r3, [sp, #0]
 804df6e:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
 804df72:	220a      	movs	r2, #10
 804df74:	4669      	mov	r1, sp
 804df76:	4628      	mov	r0, r5
 804df78:	f002 feb4 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804df7c:	4669      	mov	r1, sp
 804df7e:	4620      	mov	r0, r4
 804df80:	f003 f976 	bl	8051270 <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804df84:	4620      	mov	r0, r4
 804df86:	f7f2 f933 	bl	80401f0 <strlen>
 804df8a:	4b1d      	ldr	r3, [pc, #116]	; (804e000 <uploadSlaveData+0x128>)
 804df8c:	881b      	ldrh	r3, [r3, #0]
 804df8e:	5223      	strh	r3, [r4, r0]
 804df90:	e7d5      	b.n	804df3e <uploadSlaveData+0x66>
					value += 256;
 804df92:	f505 7580 	add.w	r5, r5, #256	; 0x100
 804df96:	4b17      	ldr	r3, [pc, #92]	; (804dff4 <uploadSlaveData+0x11c>)
 804df98:	f8c3 54d0 	str.w	r5, [r3, #1232]	; 0x4d0
 804df9c:	e7b9      	b.n	804df12 <uploadSlaveData+0x3a>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804df9e:	2300      	movs	r3, #0
 804dfa0:	9300      	str	r3, [sp, #0]
 804dfa2:	f8ad 3004 	strh.w	r3, [sp, #4]
				itoa(value,buffer,MB_PAYLOAD_RADIX);
 804dfa6:	220a      	movs	r2, #10
 804dfa8:	4669      	mov	r1, sp
 804dfaa:	4628      	mov	r0, r5
 804dfac:	f002 fe9a 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadStringRT,buffer);
 804dfb0:	4c12      	ldr	r4, [pc, #72]	; (804dffc <uploadSlaveData+0x124>)
 804dfb2:	4669      	mov	r1, sp
 804dfb4:	4620      	mov	r0, r4
 804dfb6:	f003 f95b 	bl	8051270 <strcat>
				strcat(gau8MBPayloadStringRT,PAYLOAD_SEPARATOR);
 804dfba:	4620      	mov	r0, r4
 804dfbc:	f7f2 f918 	bl	80401f0 <strlen>
 804dfc0:	4b0f      	ldr	r3, [pc, #60]	; (804e000 <uploadSlaveData+0x128>)
 804dfc2:	881b      	ldrh	r3, [r3, #0]
 804dfc4:	5223      	strh	r3, [r4, r0]
 804dfc6:	e7ba      	b.n	804df3e <uploadSlaveData+0x66>
			memcpy(gau8TempMBRTUPayloadString,gau8MBPayloadStringRT,sizeof(gau8MBPayloadStringRT));
 804dfc8:	480f      	ldr	r0, [pc, #60]	; (804e008 <uploadSlaveData+0x130>)
 804dfca:	f500 7461 	add.w	r4, r0, #900	; 0x384
 804dfce:	f240 454c 	movw	r5, #1100	; 0x44c
 804dfd2:	462a      	mov	r2, r5
 804dfd4:	4621      	mov	r1, r4
 804dfd6:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 804dfda:	f003 f8e5 	bl	80511a8 <memcpy>
			memset(gau8MBPayloadStringRT,0x00,1100 * sizeof(char));
 804dfde:	462a      	mov	r2, r5
 804dfe0:	2100      	movs	r1, #0
 804dfe2:	4620      	mov	r0, r4
 804dfe4:	f003 f8ee 	bl	80511c4 <memset>
			Loopcounter = 0;
 804dfe8:	4b02      	ldr	r3, [pc, #8]	; (804dff4 <uploadSlaveData+0x11c>)
 804dfea:	2200      	movs	r2, #0
 804dfec:	f8c3 24cc 	str.w	r2, [r3, #1228]	; 0x4cc
}
 804dff0:	e7ab      	b.n	804df4a <uploadSlaveData+0x72>
 804dff2:	bf00      	nop
 804dff4:	20004598 	.word	0x20004598
 804dff8:	2000d868 	.word	0x2000d868
 804dffc:	20001258 	.word	0x20001258
 804e000:	0805a058 	.word	0x0805a058
 804e004:	0805a174 	.word	0x0805a174
 804e008:	20000ed4 	.word	0x20000ed4

0804e00c <setupModbusRTU>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void setupModbusRTU(void)
{
 804e00c:	b410      	push	{r4}
	uint32_t temp = 0;
	master.u16NoRegisterstoFetch = gu32Modbus485RegisterFetch;;
 804e00e:	4b13      	ldr	r3, [pc, #76]	; (804e05c <setupModbusRTU+0x50>)
 804e010:	881c      	ldrh	r4, [r3, #0]
 804e012:	4b13      	ldr	r3, [pc, #76]	; (804e060 <setupModbusRTU+0x54>)
 804e014:	f8a3 4832 	strh.w	r4, [r3, #2098]	; 0x832
	master.u8MBSlave_Address = gu32Modbus485SlaveID;
 804e018:	4a12      	ldr	r2, [pc, #72]	; (804e064 <setupModbusRTU+0x58>)
 804e01a:	6812      	ldr	r2, [r2, #0]
 804e01c:	701a      	strb	r2, [r3, #0]
	master.u8MBOperationStatus = 1;
 804e01e:	2201      	movs	r2, #1
 804e020:	f883 2521 	strb.w	r2, [r3, #1313]	; 0x521
	master.u32PollDelay = gu32Modbus485PollingTime;
 804e024:	4a10      	ldr	r2, [pc, #64]	; (804e068 <setupModbusRTU+0x5c>)
 804e026:	6812      	ldr	r2, [r2, #0]
 804e028:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c

	for(temp = 0; temp < master.u16NoRegisterstoFetch ;temp++)
 804e02c:	2300      	movs	r3, #0
 804e02e:	429c      	cmp	r4, r3
 804e030:	d90c      	bls.n	804e04c <setupModbusRTU+0x40>
	{
		/*Calculates how many data values will be there in payload */
		gu32MBDataByteCounterLimitRTU += gu32MBRTUClientNoofPoints[temp];
 804e032:	4a0e      	ldr	r2, [pc, #56]	; (804e06c <setupModbusRTU+0x60>)
 804e034:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804e038:	f8d2 0258 	ldr.w	r0, [r2, #600]	; 0x258
 804e03c:	490c      	ldr	r1, [pc, #48]	; (804e070 <setupModbusRTU+0x64>)
 804e03e:	f8d1 24c8 	ldr.w	r2, [r1, #1224]	; 0x4c8
 804e042:	4402      	add	r2, r0
 804e044:	f8c1 24c8 	str.w	r2, [r1, #1224]	; 0x4c8
	for(temp = 0; temp < master.u16NoRegisterstoFetch ;temp++)
 804e048:	3301      	adds	r3, #1
 804e04a:	e7f0      	b.n	804e02e <setupModbusRTU+0x22>
	}
	master.u8MBNoQueryAttempts = 0;
 804e04c:	4b04      	ldr	r3, [pc, #16]	; (804e060 <setupModbusRTU+0x54>)
 804e04e:	2200      	movs	r2, #0
 804e050:	f883 2522 	strb.w	r2, [r3, #1314]	; 0x522
}
 804e054:	f85d 4b04 	ldr.w	r4, [sp], #4
 804e058:	4770      	bx	lr
 804e05a:	bf00      	nop
 804e05c:	20003854 	.word	0x20003854
 804e060:	2000d868 	.word	0x2000d868
 804e064:	20003850 	.word	0x20003850
 804e068:	200028d4 	.word	0x200028d4
 804e06c:	20000ed4 	.word	0x20000ed4
 804e070:	20004598 	.word	0x20004598

0804e074 <tcp_client_handle>:
	//uint16_t inPort = tpcb->remote_port;

	/* Extract the IP */
	//char *remIP = ipaddr_ntoa(&inIP);

	esTx = es;
 804e074:	4b01      	ldr	r3, [pc, #4]	; (804e07c <tcp_client_handle+0x8>)
 804e076:	6019      	str	r1, [r3, #0]
	pcbTx = tpcb;
 804e078:	6058      	str	r0, [r3, #4]

}
 804e07a:	4770      	bx	lr
 804e07c:	20004a78 	.word	0x20004a78

0804e080 <tcp_modbusclient_send>:
{
 804e080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e082:	4606      	mov	r6, r0
 804e084:	460f      	mov	r7, r1
  err_t wr_err = ERR_OK;
 804e086:	2500      	movs	r5, #0
  while ((wr_err == ERR_OK) &&
 804e088:	e002      	b.n	804e090 <tcp_modbusclient_send+0x10>
      pbuf_free(ptr);
 804e08a:	4620      	mov	r0, r4
 804e08c:	f7f7 fe04 	bl	8045c98 <pbuf_free>
  while ((wr_err == ERR_OK) &&
 804e090:	b9cd      	cbnz	r5, 804e0c6 <tcp_modbusclient_send+0x46>
         (es->p_tx != NULL) &&
 804e092:	68bc      	ldr	r4, [r7, #8]
  while ((wr_err == ERR_OK) &&
 804e094:	b1bc      	cbz	r4, 804e0c6 <tcp_modbusclient_send+0x46>
         (es->p_tx->len <= tcp_sndbuf(tpcb)))
 804e096:	8962      	ldrh	r2, [r4, #10]
 804e098:	f8b6 3060 	ldrh.w	r3, [r6, #96]	; 0x60
         (es->p_tx != NULL) &&
 804e09c:	429a      	cmp	r2, r3
 804e09e:	d812      	bhi.n	804e0c6 <tcp_modbusclient_send+0x46>
    wr_err = tcp_write(tpcb, ptr->payload, ptr->len, 1);
 804e0a0:	2301      	movs	r3, #1
 804e0a2:	6861      	ldr	r1, [r4, #4]
 804e0a4:	4630      	mov	r0, r6
 804e0a6:	f7fa fe4d 	bl	8048d44 <tcp_write>
    if (wr_err == ERR_OK) {
 804e0aa:	4605      	mov	r5, r0
 804e0ac:	b930      	cbnz	r0, 804e0bc <tcp_modbusclient_send+0x3c>
      es->p_tx = ptr->next;
 804e0ae:	6820      	ldr	r0, [r4, #0]
 804e0b0:	60b8      	str	r0, [r7, #8]
      if (es->p_tx != NULL) {
 804e0b2:	2800      	cmp	r0, #0
 804e0b4:	d0e9      	beq.n	804e08a <tcp_modbusclient_send+0xa>
        pbuf_ref(es->p_tx);
 804e0b6:	f7f7 ffc3 	bl	8046040 <pbuf_ref>
 804e0ba:	e7e6      	b.n	804e08a <tcp_modbusclient_send+0xa>
   } else if(wr_err == ERR_MEM) {
 804e0bc:	f1b0 3fff 	cmp.w	r0, #4294967295
 804e0c0:	d1e6      	bne.n	804e090 <tcp_modbusclient_send+0x10>
     es->p_tx = ptr;
 804e0c2:	60bc      	str	r4, [r7, #8]
 804e0c4:	e7e4      	b.n	804e090 <tcp_modbusclient_send+0x10>
}
 804e0c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0804e0c8 <tcp_modbusclient_sent>:
{
 804e0c8:	b508      	push	{r3, lr}
 804e0ca:	4603      	mov	r3, r0
  if(es->p_tx != NULL)
 804e0cc:	6882      	ldr	r2, [r0, #8]
 804e0ce:	b11a      	cbz	r2, 804e0d8 <tcp_modbusclient_sent+0x10>
 804e0d0:	4608      	mov	r0, r1
    tcp_modbusclient_send(tpcb, es);
 804e0d2:	4619      	mov	r1, r3
 804e0d4:	f7ff ffd4 	bl	804e080 <tcp_modbusclient_send>
}
 804e0d8:	2000      	movs	r0, #0
 804e0da:	bd08      	pop	{r3, pc}

0804e0dc <tcp_modbusclient_connection_close>:
{
 804e0dc:	b538      	push	{r3, r4, r5, lr}
 804e0de:	4604      	mov	r4, r0
 804e0e0:	460d      	mov	r5, r1
  tcp_recv(tpcb, NULL);
 804e0e2:	2100      	movs	r1, #0
 804e0e4:	f7f8 faea 	bl	80466bc <tcp_recv>
  tcp_sent(tpcb, NULL);
 804e0e8:	2100      	movs	r1, #0
 804e0ea:	4620      	mov	r0, r4
 804e0ec:	f7f8 fb00 	bl	80466f0 <tcp_sent>
  tcp_poll(tpcb, NULL,0);
 804e0f0:	2200      	movs	r2, #0
 804e0f2:	4611      	mov	r1, r2
 804e0f4:	4620      	mov	r0, r4
 804e0f6:	f7f8 fb2d 	bl	8046754 <tcp_poll>
  if (es != NULL) {
 804e0fa:	b115      	cbz	r5, 804e102 <tcp_modbusclient_connection_close+0x26>
    mem_free(es);
 804e0fc:	4628      	mov	r0, r5
 804e0fe:	f7f7 fa3b 	bl	8045578 <mem_free>
  tcp_close(tpcb);
 804e102:	4620      	mov	r0, r4
 804e104:	f7f8 fe62 	bl	8046dcc <tcp_close>
}
 804e108:	bd38      	pop	{r3, r4, r5, pc}

0804e10a <tcp_modbusclient_poll>:
{
 804e10a:	b508      	push	{r3, lr}
 804e10c:	460b      	mov	r3, r1
  if (es != NULL) {
 804e10e:	b188      	cbz	r0, 804e134 <tcp_modbusclient_poll+0x2a>
 804e110:	4601      	mov	r1, r0
    if (es->p_tx != NULL) {
 804e112:	6882      	ldr	r2, [r0, #8]
 804e114:	b122      	cbz	r2, 804e120 <tcp_modbusclient_poll+0x16>
      tcp_modbusclient_send(tpcb, es);
 804e116:	4618      	mov	r0, r3
 804e118:	f7ff ffb2 	bl	804e080 <tcp_modbusclient_send>
    ret_err = ERR_OK;
 804e11c:	2000      	movs	r0, #0
}
 804e11e:	bd08      	pop	{r3, pc}
      if (es->state == ES_CLOSING) {
 804e120:	7802      	ldrb	r2, [r0, #0]
 804e122:	2a03      	cmp	r2, #3
 804e124:	d001      	beq.n	804e12a <tcp_modbusclient_poll+0x20>
    ret_err = ERR_OK;
 804e126:	2000      	movs	r0, #0
 804e128:	e7f9      	b.n	804e11e <tcp_modbusclient_poll+0x14>
        tcp_modbusclient_connection_close(tpcb, es);
 804e12a:	4618      	mov	r0, r3
 804e12c:	f7ff ffd6 	bl	804e0dc <tcp_modbusclient_connection_close>
    ret_err = ERR_OK;
 804e130:	2000      	movs	r0, #0
 804e132:	e7f4      	b.n	804e11e <tcp_modbusclient_poll+0x14>
    tcp_abort(tpcb);
 804e134:	4608      	mov	r0, r1
 804e136:	f7f8 ff6b 	bl	8047010 <tcp_abort>
    ret_err = ERR_ABRT;
 804e13a:	f06f 000c 	mvn.w	r0, #12
 804e13e:	e7ee      	b.n	804e11e <tcp_modbusclient_poll+0x14>

0804e140 <tcp_modbusclient_recv>:
{
 804e140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e142:	460f      	mov	r7, r1
 804e144:	4615      	mov	r5, r2
 804e146:	461c      	mov	r4, r3
  LWIP_ASSERT("arg != NULL",arg != NULL);
 804e148:	4606      	mov	r6, r0
 804e14a:	b188      	cbz	r0, 804e170 <tcp_modbusclient_recv+0x30>
  if (p == NULL) {
 804e14c:	b1c5      	cbz	r5, 804e180 <tcp_modbusclient_recv+0x40>
  else if (err != ERR_OK) {
 804e14e:	bb3c      	cbnz	r4, 804e1a0 <tcp_modbusclient_recv+0x60>
  } else if(es->state == ES_CONNECTED) {
 804e150:	7833      	ldrb	r3, [r6, #0]
 804e152:	2b01      	cmp	r3, #1
 804e154:	d13a      	bne.n	804e1cc <tcp_modbusclient_recv+0x8c>
	  if(gu32MBClientConnectedFlag == 1)
 804e156:	4b22      	ldr	r3, [pc, #136]	; (804e1e0 <tcp_modbusclient_recv+0xa0>)
 804e158:	689b      	ldr	r3, [r3, #8]
 804e15a:	2b01      	cmp	r3, #1
 804e15c:	d025      	beq.n	804e1aa <tcp_modbusclient_recv+0x6a>
	  tcp_recved(tpcb, p->tot_len);
 804e15e:	8929      	ldrh	r1, [r5, #8]
 804e160:	4638      	mov	r0, r7
 804e162:	f7f8 fa3b 	bl	80465dc <tcp_recved>
	  pbuf_free(p);
 804e166:	4628      	mov	r0, r5
 804e168:	f7f7 fd96 	bl	8045c98 <pbuf_free>
	  ret_err = ERR_OK;
 804e16c:	4620      	mov	r0, r4
}
 804e16e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  LWIP_ASSERT("arg != NULL",arg != NULL);
 804e170:	4b1c      	ldr	r3, [pc, #112]	; (804e1e4 <tcp_modbusclient_recv+0xa4>)
 804e172:	f44f 725f 	mov.w	r2, #892	; 0x37c
 804e176:	491c      	ldr	r1, [pc, #112]	; (804e1e8 <tcp_modbusclient_recv+0xa8>)
 804e178:	481c      	ldr	r0, [pc, #112]	; (804e1ec <tcp_modbusclient_recv+0xac>)
 804e17a:	f003 f837 	bl	80511ec <printf>
 804e17e:	e7e5      	b.n	804e14c <tcp_modbusclient_recv+0xc>
    es->state = ES_CLOSING;
 804e180:	2303      	movs	r3, #3
 804e182:	7033      	strb	r3, [r6, #0]
    if (es->p_tx == NULL) {
 804e184:	68b3      	ldr	r3, [r6, #8]
 804e186:	b12b      	cbz	r3, 804e194 <tcp_modbusclient_recv+0x54>
      tcp_modbusclient_send(tpcb, es);
 804e188:	4631      	mov	r1, r6
 804e18a:	4638      	mov	r0, r7
 804e18c:	f7ff ff78 	bl	804e080 <tcp_modbusclient_send>
    ret_err = ERR_OK;
 804e190:	2000      	movs	r0, #0
 804e192:	e7ec      	b.n	804e16e <tcp_modbusclient_recv+0x2e>
       tcp_modbusclient_connection_close(tpcb, es);
 804e194:	4631      	mov	r1, r6
 804e196:	4638      	mov	r0, r7
 804e198:	f7ff ffa0 	bl	804e0dc <tcp_modbusclient_connection_close>
    ret_err = ERR_OK;
 804e19c:	2000      	movs	r0, #0
 804e19e:	e7e6      	b.n	804e16e <tcp_modbusclient_recv+0x2e>
      pbuf_free(p);
 804e1a0:	4628      	mov	r0, r5
 804e1a2:	f7f7 fd79 	bl	8045c98 <pbuf_free>
    ret_err = err;
 804e1a6:	4620      	mov	r0, r4
 804e1a8:	e7e1      	b.n	804e16e <tcp_modbusclient_recv+0x2e>
		  memcpy(strMbClient.s8SlaveResponseArray,p->payload,p->tot_len);
 804e1aa:	892a      	ldrh	r2, [r5, #8]
 804e1ac:	6869      	ldr	r1, [r5, #4]
 804e1ae:	4810      	ldr	r0, [pc, #64]	; (804e1f0 <tcp_modbusclient_recv+0xb0>)
 804e1b0:	f002 fffa 	bl	80511a8 <memcpy>
		  enmMBCurrentState = enmMB_RESPONSERECEIVED;
 804e1b4:	4b0f      	ldr	r3, [pc, #60]	; (804e1f4 <tcp_modbusclient_recv+0xb4>)
 804e1b6:	2204      	movs	r2, #4
 804e1b8:	701a      	strb	r2, [r3, #0]
		  gu32MBConnected = 1;
 804e1ba:	4b09      	ldr	r3, [pc, #36]	; (804e1e0 <tcp_modbusclient_recv+0xa0>)
 804e1bc:	2201      	movs	r2, #1
 804e1be:	60da      	str	r2, [r3, #12]
		  gu32MBOperateFlag = 1;
 804e1c0:	611a      	str	r2, [r3, #16]
		  tcp_client_handle(tpcb, es);
 804e1c2:	4631      	mov	r1, r6
 804e1c4:	4638      	mov	r0, r7
 804e1c6:	f7ff ff55 	bl	804e074 <tcp_client_handle>
 804e1ca:	e7c8      	b.n	804e15e <tcp_modbusclient_recv+0x1e>
    tcp_recved(tpcb, p->tot_len);
 804e1cc:	8929      	ldrh	r1, [r5, #8]
 804e1ce:	4638      	mov	r0, r7
 804e1d0:	f7f8 fa04 	bl	80465dc <tcp_recved>
    pbuf_free(p);
 804e1d4:	4628      	mov	r0, r5
 804e1d6:	f7f7 fd5f 	bl	8045c98 <pbuf_free>
    ret_err = ERR_OK;
 804e1da:	4620      	mov	r0, r4
 804e1dc:	e7c7      	b.n	804e16e <tcp_modbusclient_recv+0x2e>
 804e1de:	bf00      	nop
 804e1e0:	20004a78 	.word	0x20004a78
 804e1e4:	0805a178 	.word	0x0805a178
 804e1e8:	0805a18c 	.word	0x0805a18c
 804e1ec:	08058644 	.word	0x08058644
 804e1f0:	2000e844 	.word	0x2000e844
 804e1f4:	20001af0 	.word	0x20001af0

0804e1f8 <updateModbusQueryFrame>:
	strMbClient.u32QueryFrame[0] = (MB_TCP_TID >> 8);
 804e1f8:	4b1f      	ldr	r3, [pc, #124]	; (804e278 <updateModbusQueryFrame+0x80>)
 804e1fa:	2200      	movs	r2, #0
 804e1fc:	f883 2020 	strb.w	r2, [r3, #32]
	strMbClient.u32QueryFrame[1] = (MB_TCP_TID & 0xFF);
 804e200:	2103      	movs	r1, #3
 804e202:	f883 1021 	strb.w	r1, [r3, #33]	; 0x21
	strMbClient.u32QueryFrame[2] = (MB_TCP_PID >> 8);
 804e206:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
	strMbClient.u32QueryFrame[3] = (MB_TCP_PID & 0xFF);
 804e20a:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
	strMbClient.u32QueryFrame[4] = (6 >> 8);
 804e20e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	strMbClient.u32QueryFrame[5] = (6 & 0xFF);
 804e212:	2206      	movs	r2, #6
 804e214:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	strMbClient.u32QueryFrame[6] = (strMbClient.u32UnitId);
 804e218:	7b1a      	ldrb	r2, [r3, #12]
 804e21a:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	strMbClient.u32QueryFrame[7] = gu32MBTCPClientFuncCode[message_count];
 804e21e:	4a17      	ldr	r2, [pc, #92]	; (804e27c <updateModbusQueryFrame+0x84>)
 804e220:	6950      	ldr	r0, [r2, #20]
 804e222:	4917      	ldr	r1, [pc, #92]	; (804e280 <updateModbusQueryFrame+0x88>)
 804e224:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e228:	7900      	ldrb	r0, [r0, #4]
 804e22a:	f883 0027 	strb.w	r0, [r3, #39]	; 0x27
	strMbClient.u32QueryFrame[8] = ((gu32MBTCPClientAddress[message_count]- MB_ADDRESS_DEREF) >> 8);
 804e22e:	6950      	ldr	r0, [r2, #20]
 804e230:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e234:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 804e238:	3801      	subs	r0, #1
 804e23a:	f3c0 2007 	ubfx	r0, r0, #8, #8
 804e23e:	f883 0028 	strb.w	r0, [r3, #40]	; 0x28
	strMbClient.u32QueryFrame[9] = ((gu32MBTCPClientAddress[message_count]- MB_ADDRESS_DEREF)& 0xFF);
 804e242:	6950      	ldr	r0, [r2, #20]
 804e244:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e248:	f8d0 0130 	ldr.w	r0, [r0, #304]	; 0x130
 804e24c:	3801      	subs	r0, #1
 804e24e:	b2c0      	uxtb	r0, r0
 804e250:	f883 0029 	strb.w	r0, [r3, #41]	; 0x29
	strMbClient.u32QueryFrame[10] = ((gu32MBTCPClientNoofPoints[message_count]) >> 8);
 804e254:	6950      	ldr	r0, [r2, #20]
 804e256:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 804e25a:	f890 025d 	ldrb.w	r0, [r0, #605]	; 0x25d
 804e25e:	f883 002a 	strb.w	r0, [r3, #42]	; 0x2a
	strMbClient.u32QueryFrame[11] = ((gu32MBTCPClientNoofPoints[message_count])& 0xFF);
 804e262:	6950      	ldr	r0, [r2, #20]
 804e264:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e268:	f891 125c 	ldrb.w	r1, [r1, #604]	; 0x25c
 804e26c:	f883 102b 	strb.w	r1, [r3, #43]	; 0x2b
	temp++;
 804e270:	6993      	ldr	r3, [r2, #24]
 804e272:	3301      	adds	r3, #1
 804e274:	6193      	str	r3, [r2, #24]
}
 804e276:	4770      	bx	lr
 804e278:	2000e750 	.word	0x2000e750
 804e27c:	20004a78 	.word	0x20004a78
 804e280:	20001af0 	.word	0x20001af0

0804e284 <tcp_modbusclient_connected>:
{
 804e284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 804e286:	460c      	mov	r4, r1
  if (err == ERR_OK) {
 804e288:	4616      	mov	r6, r2
 804e28a:	2a00      	cmp	r2, #0
 804e28c:	d141      	bne.n	804e312 <tcp_modbusclient_connected+0x8e>
    es = (struct mbclient *)mem_malloc(sizeof(struct mbclient));
 804e28e:	200c      	movs	r0, #12
 804e290:	f7f7 fa4a 	bl	8045728 <mem_malloc>
    if (es != NULL) {
 804e294:	4605      	mov	r5, r0
 804e296:	2800      	cmp	r0, #0
 804e298:	d034      	beq.n	804e304 <tcp_modbusclient_connected+0x80>
      es->state = ES_CONNECTED;
 804e29a:	2701      	movs	r7, #1
 804e29c:	7007      	strb	r7, [r0, #0]
      es->pcb = tpcb;
 804e29e:	6044      	str	r4, [r0, #4]
      updateModbusQueryFrame();
 804e2a0:	f7ff ffaa 	bl	804e1f8 <updateModbusQueryFrame>
      gu32MBClientConnectedFlag = 1;
 804e2a4:	4b1e      	ldr	r3, [pc, #120]	; (804e320 <tcp_modbusclient_connected+0x9c>)
 804e2a6:	609f      	str	r7, [r3, #8]
      es->p_tx = pbuf_alloc(PBUF_TRANSPORT, 12 , PBUF_POOL);
 804e2a8:	2203      	movs	r2, #3
 804e2aa:	210c      	movs	r1, #12
 804e2ac:	2000      	movs	r0, #0
 804e2ae:	f7f7 fd57 	bl	8045d60 <pbuf_alloc>
 804e2b2:	60a8      	str	r0, [r5, #8]
      if (es->p_tx) {
 804e2b4:	b388      	cbz	r0, 804e31a <tcp_modbusclient_connected+0x96>
        pbuf_take(es->p_tx, (uint8_t *)strMbClient.u32QueryFrame, 12);
 804e2b6:	220c      	movs	r2, #12
 804e2b8:	491a      	ldr	r1, [pc, #104]	; (804e324 <tcp_modbusclient_connected+0xa0>)
 804e2ba:	f7f7 fff5 	bl	80462a8 <pbuf_take>
        tcp_arg(tpcb, es);
 804e2be:	4629      	mov	r1, r5
 804e2c0:	4620      	mov	r0, r4
 804e2c2:	f7f8 f9f8 	bl	80466b6 <tcp_arg>
        tcp_recv(tpcb, tcp_modbusclient_recv);
 804e2c6:	4918      	ldr	r1, [pc, #96]	; (804e328 <tcp_modbusclient_connected+0xa4>)
 804e2c8:	4620      	mov	r0, r4
 804e2ca:	f7f8 f9f7 	bl	80466bc <tcp_recv>
        tcp_sent(tpcb, tcp_modbusclient_sent);
 804e2ce:	4917      	ldr	r1, [pc, #92]	; (804e32c <tcp_modbusclient_connected+0xa8>)
 804e2d0:	4620      	mov	r0, r4
 804e2d2:	f7f8 fa0d 	bl	80466f0 <tcp_sent>
        tcp_poll(tpcb, tcp_modbusclient_poll, 1); // changed from 1 21/1/2021
 804e2d6:	463a      	mov	r2, r7
 804e2d8:	4915      	ldr	r1, [pc, #84]	; (804e330 <tcp_modbusclient_connected+0xac>)
 804e2da:	4620      	mov	r0, r4
 804e2dc:	f7f8 fa3a 	bl	8046754 <tcp_poll>
        tcp_client_handle(tpcb, es);
 804e2e0:	4629      	mov	r1, r5
 804e2e2:	4620      	mov	r0, r4
 804e2e4:	f7ff fec6 	bl	804e074 <tcp_client_handle>
        gu32MBOperateFlag = 1;
 804e2e8:	4f0d      	ldr	r7, [pc, #52]	; (804e320 <tcp_modbusclient_connected+0x9c>)
 804e2ea:	2301      	movs	r3, #1
 804e2ec:	613b      	str	r3, [r7, #16]
        enmMBCurrentState = enmMB_CONNECTED;
 804e2ee:	4b11      	ldr	r3, [pc, #68]	; (804e334 <tcp_modbusclient_connected+0xb0>)
 804e2f0:	2202      	movs	r2, #2
 804e2f2:	701a      	strb	r2, [r3, #0]
        tcp_modbusclient_send(tpcb,es);
 804e2f4:	4629      	mov	r1, r5
 804e2f6:	4620      	mov	r0, r4
 804e2f8:	f7ff fec2 	bl	804e080 <tcp_modbusclient_send>
        gu32MBTCPTimer = FIVE_SEC;
 804e2fc:	f241 3388 	movw	r3, #5000	; 0x1388
 804e300:	61fb      	str	r3, [r7, #28]
        return ERR_OK;
 804e302:	e00a      	b.n	804e31a <tcp_modbusclient_connected+0x96>
      tcp_modbusclient_connection_close(tpcb, es);
 804e304:	4601      	mov	r1, r0
 804e306:	4620      	mov	r0, r4
 804e308:	f7ff fee8 	bl	804e0dc <tcp_modbusclient_connection_close>
      return ERR_MEM;
 804e30c:	f04f 36ff 	mov.w	r6, #4294967295
 804e310:	e003      	b.n	804e31a <tcp_modbusclient_connected+0x96>
    tcp_modbusclient_connection_close(tpcb, es);
 804e312:	2100      	movs	r1, #0
 804e314:	4620      	mov	r0, r4
 804e316:	f7ff fee1 	bl	804e0dc <tcp_modbusclient_connection_close>
}
 804e31a:	4630      	mov	r0, r6
 804e31c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 804e31e:	bf00      	nop
 804e320:	20004a78 	.word	0x20004a78
 804e324:	2000e770 	.word	0x2000e770
 804e328:	0804e141 	.word	0x0804e141
 804e32c:	0804e0c9 	.word	0x0804e0c9
 804e330:	0804e10b 	.word	0x0804e10b
 804e334:	20001af0 	.word	0x20001af0

0804e338 <setupModbus>:
{
 804e338:	b410      	push	{r4}
	strMbClient.u32MBQueryCounter = 0;
 804e33a:	4a10      	ldr	r2, [pc, #64]	; (804e37c <setupModbus+0x44>)
 804e33c:	2300      	movs	r3, #0
 804e33e:	6113      	str	r3, [r2, #16]
	strMbClient.u32NoofRegConfigured = gu32Modbus485RegisterFetch;//44;
 804e340:	490f      	ldr	r1, [pc, #60]	; (804e380 <setupModbus+0x48>)
 804e342:	680c      	ldr	r4, [r1, #0]
 804e344:	f8c2 4668 	str.w	r4, [r2, #1640]	; 0x668
	for(temp = 0; temp < strMbClient.u32NoofRegConfigured ;temp++)
 804e348:	4a0e      	ldr	r2, [pc, #56]	; (804e384 <setupModbus+0x4c>)
 804e34a:	6193      	str	r3, [r2, #24]
 804e34c:	4b0d      	ldr	r3, [pc, #52]	; (804e384 <setupModbus+0x4c>)
 804e34e:	699b      	ldr	r3, [r3, #24]
 804e350:	429c      	cmp	r4, r3
 804e352:	d90b      	bls.n	804e36c <setupModbus+0x34>
		gu32MBDataByteCounterLimit += gu32MBTCPClientNoofPoints[temp];
 804e354:	4a0c      	ldr	r2, [pc, #48]	; (804e388 <setupModbus+0x50>)
 804e356:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 804e35a:	f8d2 025c 	ldr.w	r0, [r2, #604]	; 0x25c
 804e35e:	4a09      	ldr	r2, [pc, #36]	; (804e384 <setupModbus+0x4c>)
 804e360:	6a11      	ldr	r1, [r2, #32]
 804e362:	4401      	add	r1, r0
 804e364:	6211      	str	r1, [r2, #32]
	for(temp = 0; temp < strMbClient.u32NoofRegConfigured ;temp++)
 804e366:	3301      	adds	r3, #1
 804e368:	6193      	str	r3, [r2, #24]
 804e36a:	e7ef      	b.n	804e34c <setupModbus+0x14>
	strMbClient.u32MBNoQueryAttempts = 0;
 804e36c:	4b03      	ldr	r3, [pc, #12]	; (804e37c <setupModbus+0x44>)
 804e36e:	2200      	movs	r2, #0
 804e370:	609a      	str	r2, [r3, #8]
	strMbClient.u32UnitId = 1;
 804e372:	2201      	movs	r2, #1
 804e374:	60da      	str	r2, [r3, #12]
}
 804e376:	f85d 4b04 	ldr.w	r4, [sp], #4
 804e37a:	4770      	bx	lr
 804e37c:	2000e750 	.word	0x2000e750
 804e380:	20003854 	.word	0x20003854
 804e384:	20004a78 	.word	0x20004a78
 804e388:	20001af0 	.word	0x20001af0

0804e38c <updateModbusPayload>:
{
 804e38c:	b570      	push	{r4, r5, r6, lr}
		value = strMbClient.u32SlaveData[RegisterCounter];    // Signed Integer
 804e38e:	4a4a      	ldr	r2, [pc, #296]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e390:	6a54      	ldr	r4, [r2, #36]	; 0x24
 804e392:	f104 0194 	add.w	r1, r4, #148	; 0x94
 804e396:	4b49      	ldr	r3, [pc, #292]	; (804e4bc <updateModbusPayload+0x130>)
 804e398:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 804e39c:	685d      	ldr	r5, [r3, #4]
 804e39e:	6295      	str	r5, [r2, #40]	; 0x28
		if(RegisterCounter == 0)
 804e3a0:	b354      	cbz	r4, 804e3f8 <updateModbusPayload+0x6c>
		if(RegisterCounter < (gu32MBDataByteCounterLimit))
 804e3a2:	4b45      	ldr	r3, [pc, #276]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e3a4:	6a1b      	ldr	r3, [r3, #32]
 804e3a6:	429c      	cmp	r4, r3
 804e3a8:	d26a      	bcs.n	804e480 <updateModbusPayload+0xf4>
			if(gu32MBTCPDataStatus[RegisterCounter] == 1)
 804e3aa:	4b43      	ldr	r3, [pc, #268]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e3ac:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 804e3b0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 804e3b2:	2b01      	cmp	r3, #1
 804e3b4:	d027      	beq.n	804e406 <updateModbusPayload+0x7a>
			else if(gu32MBTCPDataStatus[RegisterCounter] == 2)
 804e3b6:	2b02      	cmp	r3, #2
 804e3b8:	d149      	bne.n	804e44e <updateModbusPayload+0xc2>
				if(value < 0)
 804e3ba:	2d00      	cmp	r5, #0
 804e3bc:	db42      	blt.n	804e444 <updateModbusPayload+0xb8>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e3be:	4b3e      	ldr	r3, [pc, #248]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e3c0:	f203 45dc 	addw	r5, r3, #1244	; 0x4dc
 804e3c4:	2200      	movs	r2, #0
 804e3c6:	f8c3 24dc 	str.w	r2, [r3, #1244]	; 0x4dc
 804e3ca:	f8a3 24e0 	strh.w	r2, [r3, #1248]	; 0x4e0
				itoa(value,buffer,10);	   	   				  // decimal String
 804e3ce:	220a      	movs	r2, #10
 804e3d0:	4629      	mov	r1, r5
 804e3d2:	6a98      	ldr	r0, [r3, #40]	; 0x28
 804e3d4:	f002 fc86 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e3d8:	4c39      	ldr	r4, [pc, #228]	; (804e4c0 <updateModbusPayload+0x134>)
 804e3da:	4629      	mov	r1, r5
 804e3dc:	4620      	mov	r0, r4
 804e3de:	f002 ff47 	bl	8051270 <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e3e2:	4620      	mov	r0, r4
 804e3e4:	f7f1 ff04 	bl	80401f0 <strlen>
 804e3e8:	4b36      	ldr	r3, [pc, #216]	; (804e4c4 <updateModbusPayload+0x138>)
 804e3ea:	881b      	ldrh	r3, [r3, #0]
 804e3ec:	5223      	strh	r3, [r4, r0]
			RegisterCounter++;
 804e3ee:	4a32      	ldr	r2, [pc, #200]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e3f0:	6a53      	ldr	r3, [r2, #36]	; 0x24
 804e3f2:	3301      	adds	r3, #1
 804e3f4:	6253      	str	r3, [r2, #36]	; 0x24
}
 804e3f6:	bd70      	pop	{r4, r5, r6, pc}
			memset(gau8MBPayloadString, 0x00, (1100 * sizeof(char)));
 804e3f8:	f240 424c 	movw	r2, #1100	; 0x44c
 804e3fc:	2100      	movs	r1, #0
 804e3fe:	4830      	ldr	r0, [pc, #192]	; (804e4c0 <updateModbusPayload+0x134>)
 804e400:	f002 fee0 	bl	80511c4 <memset>
 804e404:	e7cd      	b.n	804e3a2 <updateModbusPayload+0x16>
				strcat(gau8MBPayloadString,"E");
 804e406:	4c2e      	ldr	r4, [pc, #184]	; (804e4c0 <updateModbusPayload+0x134>)
 804e408:	4620      	mov	r0, r4
 804e40a:	f7f1 fef1 	bl	80401f0 <strlen>
 804e40e:	4b2e      	ldr	r3, [pc, #184]	; (804e4c8 <updateModbusPayload+0x13c>)
 804e410:	881b      	ldrh	r3, [r3, #0]
 804e412:	5223      	strh	r3, [r4, r0]
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e414:	4a28      	ldr	r2, [pc, #160]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e416:	f202 46dc 	addw	r6, r2, #1244	; 0x4dc
 804e41a:	2300      	movs	r3, #0
 804e41c:	f8c2 34dc 	str.w	r3, [r2, #1244]	; 0x4dc
 804e420:	f8a2 34e0 	strh.w	r3, [r2, #1248]	; 0x4e0
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   				  // Decimal String
 804e424:	220a      	movs	r2, #10
 804e426:	4631      	mov	r1, r6
 804e428:	4628      	mov	r0, r5
 804e42a:	f002 fc5b 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e42e:	4631      	mov	r1, r6
 804e430:	4620      	mov	r0, r4
 804e432:	f002 ff1d 	bl	8051270 <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e436:	4620      	mov	r0, r4
 804e438:	f7f1 feda 	bl	80401f0 <strlen>
 804e43c:	4b21      	ldr	r3, [pc, #132]	; (804e4c4 <updateModbusPayload+0x138>)
 804e43e:	881b      	ldrh	r3, [r3, #0]
 804e440:	5223      	strh	r3, [r4, r0]
 804e442:	e7d4      	b.n	804e3ee <updateModbusPayload+0x62>
					value += 256;
 804e444:	f505 7580 	add.w	r5, r5, #256	; 0x100
 804e448:	4b1b      	ldr	r3, [pc, #108]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e44a:	629d      	str	r5, [r3, #40]	; 0x28
 804e44c:	e7b7      	b.n	804e3be <updateModbusPayload+0x32>
				memset(buffer, 0x00, (6 * sizeof(char)));
 804e44e:	4a1a      	ldr	r2, [pc, #104]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e450:	f202 46dc 	addw	r6, r2, #1244	; 0x4dc
 804e454:	2300      	movs	r3, #0
 804e456:	f8c2 34dc 	str.w	r3, [r2, #1244]	; 0x4dc
 804e45a:	f8a2 34e0 	strh.w	r3, [r2, #1248]	; 0x4e0
				itoa(value,buffer,MB_PAYLOAD_RADIX);	   	   			// Decimal String
 804e45e:	220a      	movs	r2, #10
 804e460:	4631      	mov	r1, r6
 804e462:	4628      	mov	r0, r5
 804e464:	f002 fc3e 	bl	8050ce4 <itoa>
				strcat(gau8MBPayloadString,buffer);
 804e468:	4c15      	ldr	r4, [pc, #84]	; (804e4c0 <updateModbusPayload+0x134>)
 804e46a:	4631      	mov	r1, r6
 804e46c:	4620      	mov	r0, r4
 804e46e:	f002 feff 	bl	8051270 <strcat>
				strcat(gau8MBPayloadString,PAYLOAD_SEPARATOR);
 804e472:	4620      	mov	r0, r4
 804e474:	f7f1 febc 	bl	80401f0 <strlen>
 804e478:	4b12      	ldr	r3, [pc, #72]	; (804e4c4 <updateModbusPayload+0x138>)
 804e47a:	881b      	ldrh	r3, [r3, #0]
 804e47c:	5223      	strh	r3, [r4, r0]
 804e47e:	e7b6      	b.n	804e3ee <updateModbusPayload+0x62>
			memcpy(gau8TempMBPayloadString,gau8MBPayloadString,sizeof(gau8MBPayloadString));
 804e480:	4812      	ldr	r0, [pc, #72]	; (804e4cc <updateModbusPayload+0x140>)
 804e482:	f500 7462 	add.w	r4, r0, #904	; 0x388
 804e486:	f240 454c 	movw	r5, #1100	; 0x44c
 804e48a:	462a      	mov	r2, r5
 804e48c:	4621      	mov	r1, r4
 804e48e:	f200 70d4 	addw	r0, r0, #2004	; 0x7d4
 804e492:	f002 fe89 	bl	80511a8 <memcpy>
			memset(gau8MBPayloadString,0x00,1100 * sizeof(char));
 804e496:	462a      	mov	r2, r5
 804e498:	2100      	movs	r1, #0
 804e49a:	4620      	mov	r0, r4
 804e49c:	f002 fe92 	bl	80511c4 <memset>
			if(gu32MBProcessPayloadFlag)
 804e4a0:	4b05      	ldr	r3, [pc, #20]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e4a2:	f8d3 34e4 	ldr.w	r3, [r3, #1252]	; 0x4e4
 804e4a6:	b11b      	cbz	r3, 804e4b0 <updateModbusPayload+0x124>
				gu32MBProcessPayloadFlag = 0;
 804e4a8:	4b03      	ldr	r3, [pc, #12]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e4aa:	2200      	movs	r2, #0
 804e4ac:	f8c3 24e4 	str.w	r2, [r3, #1252]	; 0x4e4
			RegisterCounter = 0;
 804e4b0:	4b01      	ldr	r3, [pc, #4]	; (804e4b8 <updateModbusPayload+0x12c>)
 804e4b2:	2200      	movs	r2, #0
 804e4b4:	625a      	str	r2, [r3, #36]	; 0x24
}
 804e4b6:	e79e      	b.n	804e3f6 <updateModbusPayload+0x6a>
 804e4b8:	20004a78 	.word	0x20004a78
 804e4bc:	2000e750 	.word	0x2000e750
 804e4c0:	20001e78 	.word	0x20001e78
 804e4c4:	0805a058 	.word	0x0805a058
 804e4c8:	0805a174 	.word	0x0805a174
 804e4cc:	20001af0 	.word	0x20001af0

0804e4d0 <tcp_modbusclient_connect>:
	if(gu32MBOperateFlag)
 804e4d0:	4b22      	ldr	r3, [pc, #136]	; (804e55c <tcp_modbusclient_connect+0x8c>)
 804e4d2:	691b      	ldr	r3, [r3, #16]
 804e4d4:	b103      	cbz	r3, 804e4d8 <tcp_modbusclient_connect+0x8>
 804e4d6:	4770      	bx	lr
{
 804e4d8:	b510      	push	{r4, lr}
 804e4da:	b082      	sub	sp, #8
	  mbclient_pcb = tcp_new();
 804e4dc:	f7f8 fe7e 	bl	80471dc <tcp_new>
 804e4e0:	4b1e      	ldr	r3, [pc, #120]	; (804e55c <tcp_modbusclient_connect+0x8c>)
 804e4e2:	f8c3 04e8 	str.w	r0, [r3, #1256]	; 0x4e8
	if (mbclient_pcb != NULL)
 804e4e6:	2800      	cmp	r0, #0
 804e4e8:	d032      	beq.n	804e550 <tcp_modbusclient_connect+0x80>
	IP4_ADDR( &DestIPaddr, IP_ADDRESS_DESTI[0], IP_ADDRESS_DESTI[1], IP_ADDRESS_DESTI[2], IP_ADDRESS_DESTI[3]);
 804e4ea:	4a1d      	ldr	r2, [pc, #116]	; (804e560 <tcp_modbusclient_connect+0x90>)
 804e4ec:	7811      	ldrb	r1, [r2, #0]
 804e4ee:	7853      	ldrb	r3, [r2, #1]
 804e4f0:	041b      	lsls	r3, r3, #16
 804e4f2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 804e4f6:	7891      	ldrb	r1, [r2, #2]
 804e4f8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 804e4fc:	78d1      	ldrb	r1, [r2, #3]
 804e4fe:	430b      	orrs	r3, r1
 804e500:	021a      	lsls	r2, r3, #8
 804e502:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 804e506:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 804e50a:	0a19      	lsrs	r1, r3, #8
 804e50c:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 804e510:	430a      	orrs	r2, r1
 804e512:	ea42 6313 	orr.w	r3, r2, r3, lsr #24
 804e516:	9301      	str	r3, [sp, #4]
	  tcp_err(mbclient_pcb, tcp_modbusclient_error);
 804e518:	4912      	ldr	r1, [pc, #72]	; (804e564 <tcp_modbusclient_connect+0x94>)
 804e51a:	f7f8 f901 	bl	8046720 <tcp_err>
	  tcp_bind(mbclient_pcb, IP_ADDR_ANY,8009);
 804e51e:	4c0f      	ldr	r4, [pc, #60]	; (804e55c <tcp_modbusclient_connect+0x8c>)
 804e520:	f641 7249 	movw	r2, #8009	; 0x1f49
 804e524:	4910      	ldr	r1, [pc, #64]	; (804e568 <tcp_modbusclient_connect+0x98>)
 804e526:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e52a:	f7f7 ffcb 	bl	80464c4 <tcp_bind>
	  gu32MBClientConnectedFlag = 0;
 804e52e:	2300      	movs	r3, #0
 804e530:	60a3      	str	r3, [r4, #8]
	  err = tcp_connect(mbclient_pcb,&DestIPaddr,gu32ModbusTCPPort,tcp_modbusclient_connected); //502
 804e532:	4b0e      	ldr	r3, [pc, #56]	; (804e56c <tcp_modbusclient_connect+0x9c>)
 804e534:	4a0e      	ldr	r2, [pc, #56]	; (804e570 <tcp_modbusclient_connect+0xa0>)
 804e536:	8812      	ldrh	r2, [r2, #0]
 804e538:	a901      	add	r1, sp, #4
 804e53a:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e53e:	f7f8 fe6f 	bl	8047220 <tcp_connect>
 804e542:	f884 04ec 	strb.w	r0, [r4, #1260]	; 0x4ec
	  if(err != ERR_OK)
 804e546:	b928      	cbnz	r0, 804e554 <tcp_modbusclient_connect+0x84>
		gu32MBTCPTimer = THREE_SEC;
 804e548:	4b04      	ldr	r3, [pc, #16]	; (804e55c <tcp_modbusclient_connect+0x8c>)
 804e54a:	f640 32b8 	movw	r2, #3000	; 0xbb8
 804e54e:	61da      	str	r2, [r3, #28]
}
 804e550:	b002      	add	sp, #8
 804e552:	bd10      	pop	{r4, pc}
		Error_Handler();
 804e554:	f7ff fa54 	bl	804da00 <Error_Handler>
 804e558:	e7fa      	b.n	804e550 <tcp_modbusclient_connect+0x80>
 804e55a:	bf00      	nop
 804e55c:	20004a78 	.word	0x20004a78
 804e560:	2000385c 	.word	0x2000385c
 804e564:	0804e905 	.word	0x0804e905
 804e568:	080585d0 	.word	0x080585d0
 804e56c:	0804e285 	.word	0x0804e285
 804e570:	20003860 	.word	0x20003860

0804e574 <mbTCPPoll>:
	if( (gu32MBPOLLTimer != 0 ))//gu32EthLinkAlert == 1 gu32MBProcessPayloadFlag  ||
 804e574:	4bad      	ldr	r3, [pc, #692]	; (804e82c <mbTCPPoll+0x2b8>)
 804e576:	f8d3 34f0 	ldr.w	r3, [r3, #1264]	; 0x4f0
 804e57a:	2b00      	cmp	r3, #0
 804e57c:	f040 81b7 	bne.w	804e8ee <mbTCPPoll+0x37a>
{
 804e580:	b570      	push	{r4, r5, r6, lr}
	switch(enmMBCurrentState)
 804e582:	4aab      	ldr	r2, [pc, #684]	; (804e830 <mbTCPPoll+0x2bc>)
 804e584:	7812      	ldrb	r2, [r2, #0]
 804e586:	2a06      	cmp	r2, #6
 804e588:	f200 81ad 	bhi.w	804e8e6 <mbTCPPoll+0x372>
 804e58c:	e8df f012 	tbh	[pc, r2, lsl #1]
 804e590:	000b0007 	.word	0x000b0007
 804e594:	00380030 	.word	0x00380030
 804e598:	015a0040 	.word	0x015a0040
 804e59c:	019b      	.short	0x019b
			enmMBCurrentState = enmMB_CONNECTING;
 804e59e:	4ba4      	ldr	r3, [pc, #656]	; (804e830 <mbTCPPoll+0x2bc>)
 804e5a0:	2201      	movs	r2, #1
 804e5a2:	701a      	strb	r2, [r3, #0]
}
 804e5a4:	bd70      	pop	{r4, r5, r6, pc}
			if(gu32MBConnected == 0)
 804e5a6:	4ba1      	ldr	r3, [pc, #644]	; (804e82c <mbTCPPoll+0x2b8>)
 804e5a8:	68db      	ldr	r3, [r3, #12]
 804e5aa:	b92b      	cbnz	r3, 804e5b8 <mbTCPPoll+0x44>
				tcp_modbusclient_connect();
 804e5ac:	f7ff ff90 	bl	804e4d0 <tcp_modbusclient_connect>
			enmMBCurrentState = enmMB_CONNECTED;
 804e5b0:	4b9f      	ldr	r3, [pc, #636]	; (804e830 <mbTCPPoll+0x2bc>)
 804e5b2:	2202      	movs	r2, #2
 804e5b4:	701a      	strb	r2, [r3, #0]
		break;
 804e5b6:	e7f5      	b.n	804e5a4 <mbTCPPoll+0x30>
				updateModbusQueryFrame();
 804e5b8:	f7ff fe1e 	bl	804e1f8 <updateModbusQueryFrame>
				esTx->p_tx = pbuf_alloc(PBUF_TRANSPORT, 12 , PBUF_POOL);
 804e5bc:	4c9b      	ldr	r4, [pc, #620]	; (804e82c <mbTCPPoll+0x2b8>)
 804e5be:	6825      	ldr	r5, [r4, #0]
 804e5c0:	2203      	movs	r2, #3
 804e5c2:	210c      	movs	r1, #12
 804e5c4:	2000      	movs	r0, #0
 804e5c6:	f7f7 fbcb 	bl	8045d60 <pbuf_alloc>
 804e5ca:	60a8      	str	r0, [r5, #8]
				pbuf_take(esTx->p_tx, (char*)strMbClient.u32QueryFrame, 12);
 804e5cc:	6823      	ldr	r3, [r4, #0]
 804e5ce:	220c      	movs	r2, #12
 804e5d0:	4998      	ldr	r1, [pc, #608]	; (804e834 <mbTCPPoll+0x2c0>)
 804e5d2:	6898      	ldr	r0, [r3, #8]
 804e5d4:	f7f7 fe68 	bl	80462a8 <pbuf_take>
				tcp_modbusclient_send(pcbTx, esTx);
 804e5d8:	6821      	ldr	r1, [r4, #0]
 804e5da:	6860      	ldr	r0, [r4, #4]
 804e5dc:	f7ff fd50 	bl	804e080 <tcp_modbusclient_send>
				pbuf_free(esTx->p_tx);
 804e5e0:	6823      	ldr	r3, [r4, #0]
 804e5e2:	6898      	ldr	r0, [r3, #8]
 804e5e4:	f7f7 fb58 	bl	8045c98 <pbuf_free>
				gu32MBTCPTimer = THREE_SEC;
 804e5e8:	f640 33b8 	movw	r3, #3000	; 0xbb8
 804e5ec:	61e3      	str	r3, [r4, #28]
 804e5ee:	e7df      	b.n	804e5b0 <mbTCPPoll+0x3c>
			if(gu32MBTCPTimer == 0)
 804e5f0:	4b8e      	ldr	r3, [pc, #568]	; (804e82c <mbTCPPoll+0x2b8>)
 804e5f2:	69db      	ldr	r3, [r3, #28]
 804e5f4:	2b00      	cmp	r3, #0
 804e5f6:	d1d5      	bne.n	804e5a4 <mbTCPPoll+0x30>
				enmMBCurrentState = enmMB_RESPONSETIMEOUT;
 804e5f8:	4b8d      	ldr	r3, [pc, #564]	; (804e830 <mbTCPPoll+0x2bc>)
 804e5fa:	2205      	movs	r2, #5
 804e5fc:	701a      	strb	r2, [r3, #0]
 804e5fe:	e7d1      	b.n	804e5a4 <mbTCPPoll+0x30>
			 if(gu32MBTCPTimer == 0)
 804e600:	4b8a      	ldr	r3, [pc, #552]	; (804e82c <mbTCPPoll+0x2b8>)
 804e602:	69db      	ldr	r3, [r3, #28]
 804e604:	2b00      	cmp	r3, #0
 804e606:	d1cd      	bne.n	804e5a4 <mbTCPPoll+0x30>
				enmMBCurrentState = enmMB_RESPONSETIMEOUT;
 804e608:	4b89      	ldr	r3, [pc, #548]	; (804e830 <mbTCPPoll+0x2bc>)
 804e60a:	2205      	movs	r2, #5
 804e60c:	701a      	strb	r2, [r3, #0]
 804e60e:	e7c9      	b.n	804e5a4 <mbTCPPoll+0x30>
			if(gu32MBOperateFlag)
 804e610:	4a86      	ldr	r2, [pc, #536]	; (804e82c <mbTCPPoll+0x2b8>)
 804e612:	6912      	ldr	r2, [r2, #16]
 804e614:	2a00      	cmp	r2, #0
 804e616:	d0c5      	beq.n	804e5a4 <mbTCPPoll+0x30>
				if((((uint16_t)strMbClient.s8SlaveResponseArray[0] << 8) + strMbClient.s8SlaveResponseArray[1])
 804e618:	4887      	ldr	r0, [pc, #540]	; (804e838 <mbTCPPoll+0x2c4>)
 804e61a:	f990 20f4 	ldrsb.w	r2, [r0, #244]	; 0xf4
 804e61e:	b291      	uxth	r1, r2
 804e620:	f990 20f5 	ldrsb.w	r2, [r0, #245]	; 0xf5
 804e624:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 804e628:	2a03      	cmp	r2, #3
 804e62a:	d021      	beq.n	804e670 <mbTCPPoll+0xfc>
				gu32MBOperateFlag = 0;
 804e62c:	4b7f      	ldr	r3, [pc, #508]	; (804e82c <mbTCPPoll+0x2b8>)
 804e62e:	2200      	movs	r2, #0
 804e630:	611a      	str	r2, [r3, #16]
				enmMBCurrentState = enmMB_CONNECTING;
 804e632:	4a7f      	ldr	r2, [pc, #508]	; (804e830 <mbTCPPoll+0x2bc>)
 804e634:	2101      	movs	r1, #1
 804e636:	7011      	strb	r1, [r2, #0]
				message_count++;
 804e638:	695a      	ldr	r2, [r3, #20]
 804e63a:	440a      	add	r2, r1
 804e63c:	615a      	str	r2, [r3, #20]
				if(message_count >= strMbClient.u32NoofRegConfigured)
 804e63e:	4a7e      	ldr	r2, [pc, #504]	; (804e838 <mbTCPPoll+0x2c4>)
 804e640:	f8d2 2668 	ldr.w	r2, [r2, #1640]	; 0x668
 804e644:	695b      	ldr	r3, [r3, #20]
 804e646:	429a      	cmp	r2, r3
 804e648:	d806      	bhi.n	804e658 <mbTCPPoll+0xe4>
					message_count = 0;
 804e64a:	4b78      	ldr	r3, [pc, #480]	; (804e82c <mbTCPPoll+0x2b8>)
 804e64c:	2200      	movs	r2, #0
 804e64e:	615a      	str	r2, [r3, #20]
					gu32MBProcessPayloadFlag = 1;
 804e650:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
					gu32MBDataByteCounter = 0;
 804e654:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
				gu32MBPOLLTimer = gu32ModbusTCPPollingTime;
 804e658:	4b78      	ldr	r3, [pc, #480]	; (804e83c <mbTCPPoll+0x2c8>)
 804e65a:	681a      	ldr	r2, [r3, #0]
 804e65c:	4b73      	ldr	r3, [pc, #460]	; (804e82c <mbTCPPoll+0x2b8>)
 804e65e:	f8c3 24f0 	str.w	r2, [r3, #1264]	; 0x4f0
				memset(strMbClient.s8SlaveResponseArray,0x00,sizeof(strMbClient.s8SlaveResponseArray));
 804e662:	f44f 72af 	mov.w	r2, #350	; 0x15e
 804e666:	2100      	movs	r1, #0
 804e668:	4875      	ldr	r0, [pc, #468]	; (804e840 <mbTCPPoll+0x2cc>)
 804e66a:	f002 fdab 	bl	80511c4 <memset>
 804e66e:	e799      	b.n	804e5a4 <mbTCPPoll+0x30>
					if((((uint16_t)strMbClient.s8SlaveResponseArray[2] << 8) + strMbClient.s8SlaveResponseArray[3])
 804e670:	f990 20f6 	ldrsb.w	r2, [r0, #246]	; 0xf6
 804e674:	b291      	uxth	r1, r2
 804e676:	f990 20f7 	ldrsb.w	r2, [r0, #247]	; 0xf7
 804e67a:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 804e67e:	2a00      	cmp	r2, #0
 804e680:	d1d4      	bne.n	804e62c <mbTCPPoll+0xb8>
						gu32PayloadLength = ((uint32_t)strMbClient.s8SlaveResponseArray[4] << 8)
 804e682:	4602      	mov	r2, r0
 804e684:	f990 00f8 	ldrsb.w	r0, [r0, #248]	; 0xf8
								+ strMbClient.s8SlaveResponseArray[5];
 804e688:	f992 10f9 	ldrsb.w	r1, [r2, #249]	; 0xf9
 804e68c:	eb01 2100 	add.w	r1, r1, r0, lsl #8
						gu32PayloadLength = ((uint32_t)strMbClient.s8SlaveResponseArray[4] << 8)
 804e690:	4866      	ldr	r0, [pc, #408]	; (804e82c <mbTCPPoll+0x2b8>)
 804e692:	f8c0 14f4 	str.w	r1, [r0, #1268]	; 0x4f4
						if(strMbClient.s8SlaveResponseArray[6] == strMbClient.u32UnitId)
 804e696:	f992 10fa 	ldrsb.w	r1, [r2, #250]	; 0xfa
 804e69a:	68d2      	ldr	r2, [r2, #12]
 804e69c:	4291      	cmp	r1, r2
 804e69e:	d1c5      	bne.n	804e62c <mbTCPPoll+0xb8>
							if(strMbClient.s8SlaveResponseArray[7] == gu32MBTCPClientFuncCode[message_count])
 804e6a0:	4a65      	ldr	r2, [pc, #404]	; (804e838 <mbTCPPoll+0x2c4>)
 804e6a2:	f992 10fb 	ldrsb.w	r1, [r2, #251]	; 0xfb
 804e6a6:	6940      	ldr	r0, [r0, #20]
 804e6a8:	4a61      	ldr	r2, [pc, #388]	; (804e830 <mbTCPPoll+0x2bc>)
 804e6aa:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e6ae:	6852      	ldr	r2, [r2, #4]
 804e6b0:	4291      	cmp	r1, r2
 804e6b2:	d002      	beq.n	804e6ba <mbTCPPoll+0x146>
							else if((strMbClient.s8SlaveResponseArray[7] & 0x80 ) == 0x80)
 804e6b4:	2900      	cmp	r1, #0
 804e6b6:	dab9      	bge.n	804e62c <mbTCPPoll+0xb8>
 804e6b8:	e0ad      	b.n	804e816 <mbTCPPoll+0x2a2>
								gu32MBDataLengthBytes = ((uint8_t)strMbClient.s8SlaveResponseArray[8]);
 804e6ba:	4a5f      	ldr	r2, [pc, #380]	; (804e838 <mbTCPPoll+0x2c4>)
 804e6bc:	f892 50fc 	ldrb.w	r5, [r2, #252]	; 0xfc
 804e6c0:	4a5a      	ldr	r2, [pc, #360]	; (804e82c <mbTCPPoll+0x2b8>)
 804e6c2:	f8c2 54f8 	str.w	r5, [r2, #1272]	; 0x4f8
								if(strMbClient.s8SlaveResponseArray[7] == 1)
 804e6c6:	2901      	cmp	r1, #1
 804e6c8:	d02c      	beq.n	804e724 <mbTCPPoll+0x1b0>
									if(gu32MBDataLengthBytes == (2 * gu32MBTCPClientNoofPoints[message_count]))
 804e6ca:	4a58      	ldr	r2, [pc, #352]	; (804e82c <mbTCPPoll+0x2b8>)
 804e6cc:	6951      	ldr	r1, [r2, #20]
 804e6ce:	4a58      	ldr	r2, [pc, #352]	; (804e830 <mbTCPPoll+0x2bc>)
 804e6d0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e6d4:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e6d8:	ebb5 0f42 	cmp.w	r5, r2, lsl #1
 804e6dc:	d052      	beq.n	804e784 <mbTCPPoll+0x210>
										gu32MBDataByteCounter += gu32MBTCPClientNoofPoints[message_count];
 804e6de:	4b53      	ldr	r3, [pc, #332]	; (804e82c <mbTCPPoll+0x2b8>)
 804e6e0:	6959      	ldr	r1, [r3, #20]
 804e6e2:	4a53      	ldr	r2, [pc, #332]	; (804e830 <mbTCPPoll+0x2bc>)
 804e6e4:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e6e8:	f8d2 125c 	ldr.w	r1, [r2, #604]	; 0x25c
 804e6ec:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 804e6f0:	440a      	add	r2, r1
 804e6f2:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
 804e6f6:	e799      	b.n	804e62c <mbTCPPoll+0xb8>
										strMbClient.u32SlaveData[gu32MBDataByteCounter] = strMbClient.s8SlaveResponseArray[9 + LoopCounter];
 804e6f8:	f103 0409 	add.w	r4, r3, #9
 804e6fc:	4a4b      	ldr	r2, [pc, #300]	; (804e82c <mbTCPPoll+0x2b8>)
 804e6fe:	f8d2 04fc 	ldr.w	r0, [r2, #1276]	; 0x4fc
 804e702:	494d      	ldr	r1, [pc, #308]	; (804e838 <mbTCPPoll+0x2c4>)
 804e704:	440c      	add	r4, r1
 804e706:	f994 40f4 	ldrsb.w	r4, [r4, #244]	; 0xf4
 804e70a:	f100 0694 	add.w	r6, r0, #148	; 0x94
 804e70e:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 804e712:	604c      	str	r4, [r1, #4]
										gu32MBTCPDataStatus[gu32MBDataByteCounter++] = 2;
 804e714:	1c41      	adds	r1, r0, #1
 804e716:	f8c2 14fc 	str.w	r1, [r2, #1276]	; 0x4fc
 804e71a:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e71e:	2102      	movs	r1, #2
 804e720:	62d1      	str	r1, [r2, #44]	; 0x2c
									for(LoopCounter = 0; LoopCounter < gu32MBDataLengthBytes; LoopCounter++)
 804e722:	3301      	adds	r3, #1
 804e724:	429d      	cmp	r5, r3
 804e726:	d8e7      	bhi.n	804e6f8 <mbTCPPoll+0x184>
									if(gu32MBDataLengthBytes != gu32MBTCPClientNoofPoints[message_count])
 804e728:	4b40      	ldr	r3, [pc, #256]	; (804e82c <mbTCPPoll+0x2b8>)
 804e72a:	695a      	ldr	r2, [r3, #20]
 804e72c:	4b40      	ldr	r3, [pc, #256]	; (804e830 <mbTCPPoll+0x2bc>)
 804e72e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804e732:	f8d3 325c 	ldr.w	r3, [r3, #604]	; 0x25c
 804e736:	429d      	cmp	r5, r3
 804e738:	f43f af78 	beq.w	804e62c <mbTCPPoll+0xb8>
										gu32MBDataByteCounter += (gu32MBTCPClientNoofPoints[message_count] - gu32MBDataLengthBytes);
 804e73c:	4b3b      	ldr	r3, [pc, #236]	; (804e82c <mbTCPPoll+0x2b8>)
 804e73e:	6959      	ldr	r1, [r3, #20]
 804e740:	4a3b      	ldr	r2, [pc, #236]	; (804e830 <mbTCPPoll+0x2bc>)
 804e742:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e746:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e74a:	1b55      	subs	r5, r2, r5
 804e74c:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 804e750:	442a      	add	r2, r5
 804e752:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
 804e756:	e769      	b.n	804e62c <mbTCPPoll+0xb8>
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e758:	0058      	lsls	r0, r3, #1
 804e75a:	3009      	adds	r0, #9
 804e75c:	4936      	ldr	r1, [pc, #216]	; (804e838 <mbTCPPoll+0x2c4>)
 804e75e:	4408      	add	r0, r1
 804e760:	f990 00f4 	ldrsb.w	r0, [r0, #244]	; 0xf4
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] + 256 ;
 804e764:	440a      	add	r2, r1
 804e766:	f992 20f4 	ldrsb.w	r2, [r2, #244]	; 0xf4
 804e76a:	eb02 2200 	add.w	r2, r2, r0, lsl #8
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e76e:	482f      	ldr	r0, [pc, #188]	; (804e82c <mbTCPPoll+0x2b8>)
 804e770:	f8d0 04fc 	ldr.w	r0, [r0, #1276]	; 0x4fc
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] + 256 ;
 804e774:	f502 7280 	add.w	r2, r2, #256	; 0x100
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e778:	3094      	adds	r0, #148	; 0x94
 804e77a:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e77e:	604a      	str	r2, [r1, #4]
 804e780:	e025      	b.n	804e7ce <mbTCPPoll+0x25a>
										for(u32LoopCounter = 0; u32LoopCounter < gu32MBTCPClientNoofPoints[message_count];u32LoopCounter++)
 804e782:	3301      	adds	r3, #1
 804e784:	4a29      	ldr	r2, [pc, #164]	; (804e82c <mbTCPPoll+0x2b8>)
 804e786:	6951      	ldr	r1, [r2, #20]
 804e788:	4a29      	ldr	r2, [pc, #164]	; (804e830 <mbTCPPoll+0x2bc>)
 804e78a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e78e:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e792:	429a      	cmp	r2, r3
 804e794:	f67f af4a 	bls.w	804e62c <mbTCPPoll+0xb8>
											if((int32_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] < 0)
 804e798:	1d58      	adds	r0, r3, #5
 804e79a:	0042      	lsls	r2, r0, #1
 804e79c:	4926      	ldr	r1, [pc, #152]	; (804e838 <mbTCPPoll+0x2c4>)
 804e79e:	eb01 0140 	add.w	r1, r1, r0, lsl #1
 804e7a2:	f991 10f4 	ldrsb.w	r1, [r1, #244]	; 0xf4
 804e7a6:	2900      	cmp	r1, #0
 804e7a8:	dbd6      	blt.n	804e758 <mbTCPPoll+0x1e4>
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e7aa:	0058      	lsls	r0, r3, #1
 804e7ac:	3009      	adds	r0, #9
 804e7ae:	4922      	ldr	r1, [pc, #136]	; (804e838 <mbTCPPoll+0x2c4>)
 804e7b0:	4408      	add	r0, r1
 804e7b2:	f990 40f4 	ldrsb.w	r4, [r0, #244]	; 0xf4
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] ;
 804e7b6:	440a      	add	r2, r1
 804e7b8:	f992 20f4 	ldrsb.w	r2, [r2, #244]	; 0xf4
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e7bc:	481b      	ldr	r0, [pc, #108]	; (804e82c <mbTCPPoll+0x2b8>)
 804e7be:	f8d0 04fc 	ldr.w	r0, [r0, #1276]	; 0x4fc
																								 + (int16_t)strMbClient.s8SlaveResponseArray[9 + (2 * u32LoopCounter) + 1] ;
 804e7c2:	eb02 2204 	add.w	r2, r2, r4, lsl #8
												strMbClient.u32SlaveData[gu32MBDataByteCounter] = ((int16_t)strMbClient.s8SlaveResponseArray[9 + (2* u32LoopCounter)] << 8)
 804e7c6:	3094      	adds	r0, #148	; 0x94
 804e7c8:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e7cc:	604a      	str	r2, [r1, #4]
											gu32MBTCPDataStatus[gu32MBDataByteCounter] = 0;
 804e7ce:	4917      	ldr	r1, [pc, #92]	; (804e82c <mbTCPPoll+0x2b8>)
 804e7d0:	f8d1 24fc 	ldr.w	r2, [r1, #1276]	; 0x4fc
 804e7d4:	eb01 0082 	add.w	r0, r1, r2, lsl #2
 804e7d8:	2400      	movs	r4, #0
 804e7da:	62c4      	str	r4, [r0, #44]	; 0x2c
											gu32MBDataByteCounter++;
 804e7dc:	3201      	adds	r2, #1
 804e7de:	f8c1 24fc 	str.w	r2, [r1, #1276]	; 0x4fc
											if(gu32MBDataByteCounter >= gu32MBDataByteCounterLimit)
 804e7e2:	6a09      	ldr	r1, [r1, #32]
 804e7e4:	428a      	cmp	r2, r1
 804e7e6:	d3cc      	bcc.n	804e782 <mbTCPPoll+0x20e>
												gu32MBDataByteCounter = 0;
 804e7e8:	4a10      	ldr	r2, [pc, #64]	; (804e82c <mbTCPPoll+0x2b8>)
 804e7ea:	f8c2 44fc 	str.w	r4, [r2, #1276]	; 0x4fc
 804e7ee:	e7c8      	b.n	804e782 <mbTCPPoll+0x20e>
									strMbClient.u32SlaveData[gu32MBDataByteCounter] = strMbClient.s8SlaveResponseArray[8] ;
 804e7f0:	4a0e      	ldr	r2, [pc, #56]	; (804e82c <mbTCPPoll+0x2b8>)
 804e7f2:	f8d2 04fc 	ldr.w	r0, [r2, #1276]	; 0x4fc
 804e7f6:	4910      	ldr	r1, [pc, #64]	; (804e838 <mbTCPPoll+0x2c4>)
 804e7f8:	f991 40fc 	ldrsb.w	r4, [r1, #252]	; 0xfc
 804e7fc:	f100 0594 	add.w	r5, r0, #148	; 0x94
 804e800:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 804e804:	604c      	str	r4, [r1, #4]
									gu32MBTCPDataStatus[gu32MBDataByteCounter++] = 1;
 804e806:	1c41      	adds	r1, r0, #1
 804e808:	f8c2 14fc 	str.w	r1, [r2, #1276]	; 0x4fc
 804e80c:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 804e810:	2101      	movs	r1, #1
 804e812:	62d1      	str	r1, [r2, #44]	; 0x2c
								for(u32TempLoopCounter = 0; u32TempLoopCounter < gu32MBTCPClientNoofPoints[message_count];u32TempLoopCounter++)
 804e814:	440b      	add	r3, r1
 804e816:	4a05      	ldr	r2, [pc, #20]	; (804e82c <mbTCPPoll+0x2b8>)
 804e818:	6951      	ldr	r1, [r2, #20]
 804e81a:	4a05      	ldr	r2, [pc, #20]	; (804e830 <mbTCPPoll+0x2bc>)
 804e81c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e820:	f8d2 225c 	ldr.w	r2, [r2, #604]	; 0x25c
 804e824:	429a      	cmp	r2, r3
 804e826:	d8e3      	bhi.n	804e7f0 <mbTCPPoll+0x27c>
 804e828:	e700      	b.n	804e62c <mbTCPPoll+0xb8>
 804e82a:	bf00      	nop
 804e82c:	20004a78 	.word	0x20004a78
 804e830:	20001af0 	.word	0x20001af0
 804e834:	2000e770 	.word	0x2000e770
 804e838:	2000e750 	.word	0x2000e750
 804e83c:	20002c5c 	.word	0x20002c5c
 804e840:	2000e844 	.word	0x2000e844
			strMbClient.u32MBNoQueryAttempts++;
 804e844:	4a2a      	ldr	r2, [pc, #168]	; (804e8f0 <mbTCPPoll+0x37c>)
 804e846:	6893      	ldr	r3, [r2, #8]
 804e848:	3301      	adds	r3, #1
 804e84a:	6093      	str	r3, [r2, #8]
			if(strMbClient.u32MBNoQueryAttempts > 3)
 804e84c:	2b03      	cmp	r3, #3
 804e84e:	d930      	bls.n	804e8b2 <mbTCPPoll+0x33e>
				uint32_t temploopcounttcp = gu32MBDataByteCounter;
 804e850:	4a28      	ldr	r2, [pc, #160]	; (804e8f4 <mbTCPPoll+0x380>)
 804e852:	f8d2 34fc 	ldr.w	r3, [r2, #1276]	; 0x4fc
				gu32MBDataByteCounter += gu32MBTCPClientNoofPoints[message_count];
 804e856:	6950      	ldr	r0, [r2, #20]
 804e858:	4927      	ldr	r1, [pc, #156]	; (804e8f8 <mbTCPPoll+0x384>)
 804e85a:	eb01 0180 	add.w	r1, r1, r0, lsl #2
 804e85e:	f8d1 025c 	ldr.w	r0, [r1, #604]	; 0x25c
 804e862:	4418      	add	r0, r3
 804e864:	f8c2 04fc 	str.w	r0, [r2, #1276]	; 0x4fc
				for(iteratortcp = temploopcounttcp ; iteratortcp < gu32MBDataByteCounter ; iteratortcp++)
 804e868:	4298      	cmp	r0, r3
 804e86a:	d908      	bls.n	804e87e <mbTCPPoll+0x30a>
					strMbClient.u32SlaveData[iteratortcp] = 0;
 804e86c:	f103 0194 	add.w	r1, r3, #148	; 0x94
 804e870:	4a1f      	ldr	r2, [pc, #124]	; (804e8f0 <mbTCPPoll+0x37c>)
 804e872:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 804e876:	2100      	movs	r1, #0
 804e878:	6051      	str	r1, [r2, #4]
				for(iteratortcp = temploopcounttcp ; iteratortcp < gu32MBDataByteCounter ; iteratortcp++)
 804e87a:	3301      	adds	r3, #1
 804e87c:	e7f4      	b.n	804e868 <mbTCPPoll+0x2f4>
				strMbClient.u32MBNoQueryAttempts = 0;
 804e87e:	491c      	ldr	r1, [pc, #112]	; (804e8f0 <mbTCPPoll+0x37c>)
 804e880:	2300      	movs	r3, #0
 804e882:	608b      	str	r3, [r1, #8]
				message_count++;
 804e884:	4b1b      	ldr	r3, [pc, #108]	; (804e8f4 <mbTCPPoll+0x380>)
 804e886:	695a      	ldr	r2, [r3, #20]
 804e888:	3201      	adds	r2, #1
 804e88a:	615a      	str	r2, [r3, #20]
				if(message_count >= strMbClient.u32NoofRegConfigured)
 804e88c:	f8d1 2668 	ldr.w	r2, [r1, #1640]	; 0x668
 804e890:	695b      	ldr	r3, [r3, #20]
 804e892:	429a      	cmp	r2, r3
 804e894:	d80d      	bhi.n	804e8b2 <mbTCPPoll+0x33e>
					message_count = 0;
 804e896:	4b17      	ldr	r3, [pc, #92]	; (804e8f4 <mbTCPPoll+0x380>)
 804e898:	2200      	movs	r2, #0
 804e89a:	615a      	str	r2, [r3, #20]
					gu32MBProcessPayloadFlag = 1;
 804e89c:	2101      	movs	r1, #1
 804e89e:	f8c3 14e4 	str.w	r1, [r3, #1252]	; 0x4e4
					gu32MBNotResponding++;
 804e8a2:	f8d3 1500 	ldr.w	r1, [r3, #1280]	; 0x500
 804e8a6:	3101      	adds	r1, #1
 804e8a8:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
					gu32MBDataByteCounter = 0;
 804e8ac:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
					gu32MBClientConnectedFlag = 0;
 804e8b0:	609a      	str	r2, [r3, #8]
			enmMBCurrentState = enmMB_CLOSECLIENT;
 804e8b2:	4b11      	ldr	r3, [pc, #68]	; (804e8f8 <mbTCPPoll+0x384>)
 804e8b4:	2206      	movs	r2, #6
 804e8b6:	701a      	strb	r2, [r3, #0]
			memset(strMbClient.s8SlaveResponseArray,0x00,sizeof(strMbClient.s8SlaveResponseArray));
 804e8b8:	f44f 72af 	mov.w	r2, #350	; 0x15e
 804e8bc:	2100      	movs	r1, #0
 804e8be:	480f      	ldr	r0, [pc, #60]	; (804e8fc <mbTCPPoll+0x388>)
 804e8c0:	f002 fc80 	bl	80511c4 <memset>
			break;
 804e8c4:	e66e      	b.n	804e5a4 <mbTCPPoll+0x30>
			gu32MBConnected = 0;
 804e8c6:	4c0b      	ldr	r4, [pc, #44]	; (804e8f4 <mbTCPPoll+0x380>)
 804e8c8:	2500      	movs	r5, #0
 804e8ca:	60e5      	str	r5, [r4, #12]
			tcp_modbusclient_connection_close(pcbTx, esTx);
 804e8cc:	6821      	ldr	r1, [r4, #0]
 804e8ce:	6860      	ldr	r0, [r4, #4]
 804e8d0:	f7ff fc04 	bl	804e0dc <tcp_modbusclient_connection_close>
			enmMBCurrentState = enmMB_CONNECTING;
 804e8d4:	4b08      	ldr	r3, [pc, #32]	; (804e8f8 <mbTCPPoll+0x384>)
 804e8d6:	2201      	movs	r2, #1
 804e8d8:	701a      	strb	r2, [r3, #0]
			gu32MBOperateFlag = 0;
 804e8da:	6125      	str	r5, [r4, #16]
			gu32MBPOLLTimer = gu32ModbusTCPPollingTime;
 804e8dc:	4b08      	ldr	r3, [pc, #32]	; (804e900 <mbTCPPoll+0x38c>)
 804e8de:	681b      	ldr	r3, [r3, #0]
 804e8e0:	f8c4 34f0 	str.w	r3, [r4, #1264]	; 0x4f0
			break;
 804e8e4:	e65e      	b.n	804e5a4 <mbTCPPoll+0x30>
			enmMBCurrentState = enmMB_CONNECTING;
 804e8e6:	4b04      	ldr	r3, [pc, #16]	; (804e8f8 <mbTCPPoll+0x384>)
 804e8e8:	2201      	movs	r2, #1
 804e8ea:	701a      	strb	r2, [r3, #0]
		break;
 804e8ec:	e65a      	b.n	804e5a4 <mbTCPPoll+0x30>
 804e8ee:	4770      	bx	lr
 804e8f0:	2000e750 	.word	0x2000e750
 804e8f4:	20004a78 	.word	0x20004a78
 804e8f8:	20001af0 	.word	0x20001af0
 804e8fc:	2000e844 	.word	0x2000e844
 804e900:	20002c5c 	.word	0x20002c5c

0804e904 <tcp_modbusclient_error>:
{
 804e904:	b510      	push	{r4, lr}
	if(mbclient_pcb != NULL)
 804e906:	4b08      	ldr	r3, [pc, #32]	; (804e928 <tcp_modbusclient_error+0x24>)
 804e908:	f8d3 04e8 	ldr.w	r0, [r3, #1256]	; 0x4e8
 804e90c:	b108      	cbz	r0, 804e912 <tcp_modbusclient_error+0xe>
		mem_free(mbclient_pcb);
 804e90e:	f7f6 fe33 	bl	8045578 <mem_free>
	tcp_close(mbclient_pcb);
 804e912:	4c05      	ldr	r4, [pc, #20]	; (804e928 <tcp_modbusclient_error+0x24>)
 804e914:	f8d4 04e8 	ldr.w	r0, [r4, #1256]	; 0x4e8
 804e918:	f7f8 fa58 	bl	8046dcc <tcp_close>
	tcp_modbusclient_connect();
 804e91c:	f7ff fdd8 	bl	804e4d0 <tcp_modbusclient_connect>
	gu32MBClientConnectedFlag = 0;
 804e920:	2300      	movs	r3, #0
 804e922:	60a3      	str	r3, [r4, #8]
}
 804e924:	bd10      	pop	{r4, pc}
 804e926:	bf00      	nop
 804e928:	20004a78 	.word	0x20004a78

0804e92c <getSystemConfig>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
char * getSystemConfig(void)
{
 804e92c:	b5f0      	push	{r4, r5, r6, r7, lr}
 804e92e:	b08f      	sub	sp, #60	; 0x3c
	char * systemConfig = malloc(sizeof(char) * 2000);
 804e930:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804e934:	f002 f9d8 	bl	8050ce8 <malloc>
	if(systemConfig != NULL)
 804e938:	4604      	mov	r4, r0
 804e93a:	2800      	cmp	r0, #0
 804e93c:	f000 80f0 	beq.w	804eb20 <getSystemConfig+0x1f4>
	{
		memset(systemConfig,0x00,sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804e940:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804e944:	2100      	movs	r1, #0
 804e946:	f002 fc3d 	bl	80511c4 <memset>
		char temp_array[50];

		/* Start of Frame */
		strcpy((char *)systemConfig,(char * )START_OF_FRAME);
 804e94a:	4b77      	ldr	r3, [pc, #476]	; (804eb28 <getSystemConfig+0x1fc>)
 804e94c:	881b      	ldrh	r3, [r3, #0]
 804e94e:	8023      	strh	r3, [r4, #0]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e950:	4620      	mov	r0, r4
 804e952:	f7f1 fc4d 	bl	80401f0 <strlen>
 804e956:	4b75      	ldr	r3, [pc, #468]	; (804eb2c <getSystemConfig+0x200>)
 804e958:	881d      	ldrh	r5, [r3, #0]
 804e95a:	5225      	strh	r5, [r4, r0]

		/* Device UUID */
		strcat((char *)systemConfig,(char * )dinfo);
 804e95c:	4974      	ldr	r1, [pc, #464]	; (804eb30 <getSystemConfig+0x204>)
 804e95e:	4620      	mov	r0, r4
 804e960:	f002 fc86 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )"_Conf");
 804e964:	4620      	mov	r0, r4
 804e966:	f7f1 fc43 	bl	80401f0 <strlen>
 804e96a:	4603      	mov	r3, r0
 804e96c:	1821      	adds	r1, r4, r0
 804e96e:	4a71      	ldr	r2, [pc, #452]	; (804eb34 <getSystemConfig+0x208>)
 804e970:	6810      	ldr	r0, [r2, #0]
 804e972:	50e0      	str	r0, [r4, r3]
 804e974:	8893      	ldrh	r3, [r2, #4]
 804e976:	808b      	strh	r3, [r1, #4]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e978:	4620      	mov	r0, r4
 804e97a:	f7f1 fc39 	bl	80401f0 <strlen>
 804e97e:	5225      	strh	r5, [r4, r0]

		/* Model Number */
		strcat((char *)systemConfig,(char * )MODEL_NUMBER);
 804e980:	4620      	mov	r0, r4
 804e982:	f7f1 fc35 	bl	80401f0 <strlen>
 804e986:	4603      	mov	r3, r0
 804e988:	1826      	adds	r6, r4, r0
 804e98a:	4a6b      	ldr	r2, [pc, #428]	; (804eb38 <getSystemConfig+0x20c>)
 804e98c:	ca03      	ldmia	r2!, {r0, r1}
 804e98e:	50e0      	str	r0, [r4, r3]
 804e990:	6071      	str	r1, [r6, #4]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e992:	4620      	mov	r0, r4
 804e994:	f7f1 fc2c 	bl	80401f0 <strlen>
 804e998:	5225      	strh	r5, [r4, r0]

		/* Local Time Stamp */
		strcat((char *)systemConfig,(char * )gau8Date);
 804e99a:	4968      	ldr	r1, [pc, #416]	; (804eb3c <getSystemConfig+0x210>)
 804e99c:	4620      	mov	r0, r4
 804e99e:	f002 fc67 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )RTC_DATESEPARATOR);
 804e9a2:	4620      	mov	r0, r4
 804e9a4:	f7f1 fc24 	bl	80401f0 <strlen>
 804e9a8:	4b65      	ldr	r3, [pc, #404]	; (804eb40 <getSystemConfig+0x214>)
 804e9aa:	881e      	ldrh	r6, [r3, #0]
 804e9ac:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Month);
 804e9ae:	4965      	ldr	r1, [pc, #404]	; (804eb44 <getSystemConfig+0x218>)
 804e9b0:	4620      	mov	r0, r4
 804e9b2:	f002 fc5d 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )RTC_DATESEPARATOR);
 804e9b6:	4620      	mov	r0, r4
 804e9b8:	f7f1 fc1a 	bl	80401f0 <strlen>
 804e9bc:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Year);
 804e9be:	4962      	ldr	r1, [pc, #392]	; (804eb48 <getSystemConfig+0x21c>)
 804e9c0:	4620      	mov	r0, r4
 804e9c2:	f002 fc55 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )RTC_PARAM_SEPARATOR);
 804e9c6:	4620      	mov	r0, r4
 804e9c8:	f7f1 fc12 	bl	80401f0 <strlen>
 804e9cc:	4b5f      	ldr	r3, [pc, #380]	; (804eb4c <getSystemConfig+0x220>)
 804e9ce:	881b      	ldrh	r3, [r3, #0]
 804e9d0:	5223      	strh	r3, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Hour);
 804e9d2:	495f      	ldr	r1, [pc, #380]	; (804eb50 <getSystemConfig+0x224>)
 804e9d4:	4620      	mov	r0, r4
 804e9d6:	f002 fc4b 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )RTC_TIMESEPARATOR);
 804e9da:	4620      	mov	r0, r4
 804e9dc:	f7f1 fc08 	bl	80401f0 <strlen>
 804e9e0:	4b5c      	ldr	r3, [pc, #368]	; (804eb54 <getSystemConfig+0x228>)
 804e9e2:	881e      	ldrh	r6, [r3, #0]
 804e9e4:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Minutes);
 804e9e6:	495c      	ldr	r1, [pc, #368]	; (804eb58 <getSystemConfig+0x22c>)
 804e9e8:	4620      	mov	r0, r4
 804e9ea:	f002 fc41 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )RTC_TIMESEPARATOR);
 804e9ee:	4620      	mov	r0, r4
 804e9f0:	f7f1 fbfe 	bl	80401f0 <strlen>
 804e9f4:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8Seconds);
 804e9f6:	4959      	ldr	r1, [pc, #356]	; (804eb5c <getSystemConfig+0x230>)
 804e9f8:	4620      	mov	r0, r4
 804e9fa:	f002 fc39 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804e9fe:	4620      	mov	r0, r4
 804ea00:	f7f1 fbf6 	bl	80401f0 <strlen>
 804ea04:	5225      	strh	r5, [r4, r0]

		/* Firmware Version*/
		strcat((char *)systemConfig,(char * )FIRMWARE_VER);
 804ea06:	4620      	mov	r0, r4
 804ea08:	f7f1 fbf2 	bl	80401f0 <strlen>
 804ea0c:	4607      	mov	r7, r0
 804ea0e:	1826      	adds	r6, r4, r0
 804ea10:	4b53      	ldr	r3, [pc, #332]	; (804eb60 <getSystemConfig+0x234>)
 804ea12:	cb07      	ldmia	r3!, {r0, r1, r2}
 804ea14:	51e0      	str	r0, [r4, r7]
 804ea16:	6071      	str	r1, [r6, #4]
 804ea18:	60b2      	str	r2, [r6, #8]
 804ea1a:	881a      	ldrh	r2, [r3, #0]
 804ea1c:	789b      	ldrb	r3, [r3, #2]
 804ea1e:	81b2      	strh	r2, [r6, #12]
 804ea20:	73b3      	strb	r3, [r6, #14]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804ea22:	4620      	mov	r0, r4
 804ea24:	f7f1 fbe4 	bl	80401f0 <strlen>
 804ea28:	5225      	strh	r5, [r4, r0]

		strcat((char *)systemConfig,(char * )"SystemConfig :");
 804ea2a:	4620      	mov	r0, r4
 804ea2c:	f7f1 fbe0 	bl	80401f0 <strlen>
 804ea30:	4607      	mov	r7, r0
 804ea32:	1826      	adds	r6, r4, r0
 804ea34:	4b4b      	ldr	r3, [pc, #300]	; (804eb64 <getSystemConfig+0x238>)
 804ea36:	cb07      	ldmia	r3!, {r0, r1, r2}
 804ea38:	51e0      	str	r0, [r4, r7]
 804ea3a:	6071      	str	r1, [r6, #4]
 804ea3c:	60b2      	str	r2, [r6, #8]
 804ea3e:	881a      	ldrh	r2, [r3, #0]
 804ea40:	789b      	ldrb	r3, [r3, #2]
 804ea42:	81b2      	strh	r2, [r6, #12]
 804ea44:	73b3      	strb	r3, [r6, #14]
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804ea46:	4620      	mov	r0, r4
 804ea48:	f7f1 fbd2 	bl	80401f0 <strlen>
 804ea4c:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemConfig,(char * )gau8LastKnownConfiguration);
 804ea4e:	4946      	ldr	r1, [pc, #280]	; (804eb68 <getSystemConfig+0x23c>)
 804ea50:	4620      	mov	r0, r4
 804ea52:	f002 fc0d 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804ea56:	4620      	mov	r0, r4
 804ea58:	f7f1 fbca 	bl	80401f0 <strlen>
 804ea5c:	5225      	strh	r5, [r4, r0]

		/* Config Error */
		memset(temp_array, 0, sizeof(temp_array));
 804ea5e:	2732      	movs	r7, #50	; 0x32
 804ea60:	463a      	mov	r2, r7
 804ea62:	2100      	movs	r1, #0
 804ea64:	a801      	add	r0, sp, #4
 804ea66:	f002 fbad 	bl	80511c4 <memset>
		itoa(gu32ConfigNetworkErrorDatabase, temp_array, 10);
 804ea6a:	220a      	movs	r2, #10
 804ea6c:	a901      	add	r1, sp, #4
 804ea6e:	4b3f      	ldr	r3, [pc, #252]	; (804eb6c <getSystemConfig+0x240>)
 804ea70:	6818      	ldr	r0, [r3, #0]
 804ea72:	f002 f937 	bl	8050ce4 <itoa>
		strcat((char *)systemConfig,(char * )"NetworkErr ");
 804ea76:	4620      	mov	r0, r4
 804ea78:	f7f1 fbba 	bl	80401f0 <strlen>
 804ea7c:	4606      	mov	r6, r0
 804ea7e:	eb04 0c00 	add.w	ip, r4, r0
 804ea82:	4b3b      	ldr	r3, [pc, #236]	; (804eb70 <getSystemConfig+0x244>)
 804ea84:	cb07      	ldmia	r3!, {r0, r1, r2}
 804ea86:	51a0      	str	r0, [r4, r6]
 804ea88:	f8cc 1004 	str.w	r1, [ip, #4]
 804ea8c:	f8cc 2008 	str.w	r2, [ip, #8]
		strcat((char *)systemConfig,(char * )temp_array);
 804ea90:	a901      	add	r1, sp, #4
 804ea92:	4620      	mov	r0, r4
 804ea94:	f002 fbec 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804ea98:	4620      	mov	r0, r4
 804ea9a:	f7f1 fba9 	bl	80401f0 <strlen>
 804ea9e:	5225      	strh	r5, [r4, r0]

		memset(temp_array, 0, sizeof(temp_array));
 804eaa0:	463a      	mov	r2, r7
 804eaa2:	2100      	movs	r1, #0
 804eaa4:	a801      	add	r0, sp, #4
 804eaa6:	f002 fb8d 	bl	80511c4 <memset>
		itoa(gu32ConfigModbus485ErrorDatabase, temp_array, 10);
 804eaaa:	220a      	movs	r2, #10
 804eaac:	a901      	add	r1, sp, #4
 804eaae:	4b31      	ldr	r3, [pc, #196]	; (804eb74 <getSystemConfig+0x248>)
 804eab0:	6818      	ldr	r0, [r3, #0]
 804eab2:	f002 f917 	bl	8050ce4 <itoa>
		strcat((char *)systemConfig,(char * )"485Err ");
 804eab6:	4620      	mov	r0, r4
 804eab8:	f7f1 fb9a 	bl	80401f0 <strlen>
 804eabc:	4603      	mov	r3, r0
 804eabe:	1826      	adds	r6, r4, r0
 804eac0:	4a2d      	ldr	r2, [pc, #180]	; (804eb78 <getSystemConfig+0x24c>)
 804eac2:	ca03      	ldmia	r2!, {r0, r1}
 804eac4:	50e0      	str	r0, [r4, r3]
 804eac6:	6071      	str	r1, [r6, #4]
		strcat((char *)systemConfig,(char * )temp_array);
 804eac8:	a901      	add	r1, sp, #4
 804eaca:	4620      	mov	r0, r4
 804eacc:	f002 fbd0 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804ead0:	4620      	mov	r0, r4
 804ead2:	f7f1 fb8d 	bl	80401f0 <strlen>
 804ead6:	5225      	strh	r5, [r4, r0]

		memset(temp_array, 0, sizeof(temp_array));
 804ead8:	463a      	mov	r2, r7
 804eada:	2100      	movs	r1, #0
 804eadc:	a801      	add	r0, sp, #4
 804eade:	f002 fb71 	bl	80511c4 <memset>
		itoa(gu32ConfigModbusTCPErrorDatabase, temp_array, 10);
 804eae2:	220a      	movs	r2, #10
 804eae4:	a901      	add	r1, sp, #4
 804eae6:	4b25      	ldr	r3, [pc, #148]	; (804eb7c <getSystemConfig+0x250>)
 804eae8:	6818      	ldr	r0, [r3, #0]
 804eaea:	f002 f8fb 	bl	8050ce4 <itoa>
		strcat((char *)systemConfig,(char * )"MBTCPErr ");
 804eaee:	4620      	mov	r0, r4
 804eaf0:	f7f1 fb7e 	bl	80401f0 <strlen>
 804eaf4:	4602      	mov	r2, r0
 804eaf6:	1826      	adds	r6, r4, r0
 804eaf8:	4b21      	ldr	r3, [pc, #132]	; (804eb80 <getSystemConfig+0x254>)
 804eafa:	cb03      	ldmia	r3!, {r0, r1}
 804eafc:	50a0      	str	r0, [r4, r2]
 804eafe:	6071      	str	r1, [r6, #4]
 804eb00:	881b      	ldrh	r3, [r3, #0]
 804eb02:	8133      	strh	r3, [r6, #8]
		strcat((char *)systemConfig,(char * )temp_array);
 804eb04:	a901      	add	r1, sp, #4
 804eb06:	4620      	mov	r0, r4
 804eb08:	f002 fbb2 	bl	8051270 <strcat>
		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
 804eb0c:	4620      	mov	r0, r4
 804eb0e:	f7f1 fb6f 	bl	80401f0 <strlen>
 804eb12:	5225      	strh	r5, [r4, r0]

//		strcat((char *)systemConfig,(char * )"Diagnostic");
//		strcat((char *)systemConfig,(char * )PAYLOAD_SEPARATOR);
		strcat((char *)systemConfig,(char * )END_OF_FRAME);
 804eb14:	4620      	mov	r0, r4
 804eb16:	f7f1 fb6b 	bl	80401f0 <strlen>
 804eb1a:	4b1a      	ldr	r3, [pc, #104]	; (804eb84 <getSystemConfig+0x258>)
 804eb1c:	881b      	ldrh	r3, [r3, #0]
 804eb1e:	5223      	strh	r3, [r4, r0]

		return systemConfig;
	}
	else
		return NULL;
}
 804eb20:	4620      	mov	r0, r4
 804eb22:	b00f      	add	sp, #60	; 0x3c
 804eb24:	bdf0      	pop	{r4, r5, r6, r7, pc}
 804eb26:	bf00      	nop
 804eb28:	0805a198 	.word	0x0805a198
 804eb2c:	0805a058 	.word	0x0805a058
 804eb30:	20008a60 	.word	0x20008a60
 804eb34:	0805a19c 	.word	0x0805a19c
 804eb38:	08059fec 	.word	0x08059fec
 804eb3c:	20003898 	.word	0x20003898
 804eb40:	0805a1a4 	.word	0x0805a1a4
 804eb44:	20003890 	.word	0x20003890
 804eb48:	20003888 	.word	0x20003888
 804eb4c:	0805a038 	.word	0x0805a038
 804eb50:	200038a0 	.word	0x200038a0
 804eb54:	0805a0f8 	.word	0x0805a0f8
 804eb58:	200038a8 	.word	0x200038a8
 804eb5c:	200038b0 	.word	0x200038b0
 804eb60:	0805a1a8 	.word	0x0805a1a8
 804eb64:	0805a1b8 	.word	0x0805a1b8
 804eb68:	2000ede8 	.word	0x2000ede8
 804eb6c:	20004fac 	.word	0x20004fac
 804eb70:	0805a1c8 	.word	0x0805a1c8
 804eb74:	20005114 	.word	0x20005114
 804eb78:	0805a1d4 	.word	0x0805a1d4
 804eb7c:	20005140 	.word	0x20005140
 804eb80:	0805a1dc 	.word	0x0805a1dc
 804eb84:	0805a1e8 	.word	0x0805a1e8

0804eb88 <updateInputVoltage>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateInputVoltage(void)
{
 804eb88:	b510      	push	{r4, lr}
	sprintf(gcSystemSupplyVoltage,"%.2f",gfInputSupplyVoltage);
 804eb8a:	4b0b      	ldr	r3, [pc, #44]	; (804ebb8 <updateInputVoltage+0x30>)
 804eb8c:	6818      	ldr	r0, [r3, #0]
 804eb8e:	f7f1 fceb 	bl	8040568 <__aeabi_f2d>
 804eb92:	4602      	mov	r2, r0
 804eb94:	460b      	mov	r3, r1
 804eb96:	4c09      	ldr	r4, [pc, #36]	; (804ebbc <updateInputVoltage+0x34>)
 804eb98:	4621      	mov	r1, r4
 804eb9a:	4809      	ldr	r0, [pc, #36]	; (804ebc0 <updateInputVoltage+0x38>)
 804eb9c:	f002 fb48 	bl	8051230 <sprintf>
	sprintf(gcBatterySupplyVoltage,"%.2f",gfBatteryVoltage);
 804eba0:	4b08      	ldr	r3, [pc, #32]	; (804ebc4 <updateInputVoltage+0x3c>)
 804eba2:	6818      	ldr	r0, [r3, #0]
 804eba4:	f7f1 fce0 	bl	8040568 <__aeabi_f2d>
 804eba8:	4602      	mov	r2, r0
 804ebaa:	460b      	mov	r3, r1
 804ebac:	4621      	mov	r1, r4
 804ebae:	4806      	ldr	r0, [pc, #24]	; (804ebc8 <updateInputVoltage+0x40>)
 804ebb0:	f002 fb3e 	bl	8051230 <sprintf>
}
 804ebb4:	bd10      	pop	{r4, pc}
 804ebb6:	bf00      	nop
 804ebb8:	2000521c 	.word	0x2000521c
 804ebbc:	0805a1ec 	.word	0x0805a1ec
 804ebc0:	2000edd4 	.word	0x2000edd4
 804ebc4:	20005218 	.word	0x20005218
 804ebc8:	2000edc4 	.word	0x2000edc4

0804ebcc <formatGPSSring>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void formatGPSSring(void)
{
 804ebcc:	b570      	push	{r4, r5, r6, lr}
	/*Formulate Lat and Lon in standard format
		 * 1830.101 = 18 + (30.101094/60) = 18.5016849
		 * 7348.878 = 73 + (48.877697 /60) = 73.8146 */

	char *configptr = strtok(agpsLastLocationData, ",");
 804ebce:	4984      	ldr	r1, [pc, #528]	; (804ede0 <formatGPSSring+0x214>)
 804ebd0:	4884      	ldr	r0, [pc, #528]	; (804ede4 <formatGPSSring+0x218>)
 804ebd2:	f003 f9df 	bl	8051f94 <strtok>
 804ebd6:	4604      	mov	r4, r0
	gu32ExtractGPSParamCounter = 0;
 804ebd8:	4b83      	ldr	r3, [pc, #524]	; (804ede8 <formatGPSSring+0x21c>)
 804ebda:	2200      	movs	r2, #0
 804ebdc:	601a      	str	r2, [r3, #0]

	while(gu32ExtractGPSParamCounter != 9) //reference : while(configptr != NULL)
 804ebde:	e045      	b.n	804ec6c <formatGPSSring+0xa0>
	{
		switch(gu32ExtractGPSParamCounter)
		{
			case 0:
				/* Lat  */
				strcpy(gu32GPSLat,configptr);
 804ebe0:	4d80      	ldr	r5, [pc, #512]	; (804ede4 <formatGPSSring+0x218>)
 804ebe2:	4621      	mov	r1, r4
 804ebe4:	f105 0098 	add.w	r0, r5, #152	; 0x98
 804ebe8:	f002 fb5e 	bl	80512a8 <strcpy>
				templat = atof(&gu32GPSLat[2]);
 804ebec:	f105 009a 	add.w	r0, r5, #154	; 0x9a
 804ebf0:	f002 f835 	bl	8050c5e <atof>
 804ebf4:	ec51 0b10 	vmov	r0, r1, d0
 804ebf8:	f7f2 f806 	bl	8040c08 <__aeabi_d2f>
 804ebfc:	ee06 0a90 	vmov	s13, r0
				templat /= 60;
 804ec00:	eddf 7a7a 	vldr	s15, [pc, #488]	; 804edec <formatGPSSring+0x220>
 804ec04:	ee86 7aa7 	vdiv.f32	s14, s13, s15
				templat += (((gu32GPSLat[0]-'0') * 10) + (gu32GPSLat[1]-'0'));
 804ec08:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
 804ec0c:	3b30      	subs	r3, #48	; 0x30
 804ec0e:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 804ec12:	f895 3099 	ldrb.w	r3, [r5, #153]	; 0x99
 804ec16:	3b30      	subs	r3, #48	; 0x30
 804ec18:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 804ec1c:	ee07 3a90 	vmov	s15, r3
 804ec20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804ec24:	ee77 7a87 	vadd.f32	s15, s15, s14
 804ec28:	4b6f      	ldr	r3, [pc, #444]	; (804ede8 <formatGPSSring+0x21c>)
 804ec2a:	edc3 7a01 	vstr	s15, [r3, #4]
				sprintf(gu32GPSLatformatted,"%.7f",templat);
 804ec2e:	ee17 0a90 	vmov	r0, s15
 804ec32:	f7f1 fc99 	bl	8040568 <__aeabi_f2d>
 804ec36:	4602      	mov	r2, r0
 804ec38:	460b      	mov	r3, r1
 804ec3a:	f105 06a8 	add.w	r6, r5, #168	; 0xa8
 804ec3e:	496c      	ldr	r1, [pc, #432]	; (804edf0 <formatGPSSring+0x224>)
 804ec40:	4630      	mov	r0, r6
 804ec42:	f002 faf5 	bl	8051230 <sprintf>
				memset(agpsLastLocationDataFormatted,0x00,150);
 804ec46:	35b8      	adds	r5, #184	; 0xb8
 804ec48:	2296      	movs	r2, #150	; 0x96
 804ec4a:	2100      	movs	r1, #0
 804ec4c:	4628      	mov	r0, r5
 804ec4e:	f002 fab9 	bl	80511c4 <memset>
				strcpy(agpsLastLocationDataFormatted,gu32GPSLatformatted);
 804ec52:	4631      	mov	r1, r6
 804ec54:	4628      	mov	r0, r5
 804ec56:	f002 fb27 	bl	80512a8 <strcpy>

			default:

				break;
		}
		if(gu32ExtractGPSParamCounter != 9)
 804ec5a:	4b63      	ldr	r3, [pc, #396]	; (804ede8 <formatGPSSring+0x21c>)
 804ec5c:	681b      	ldr	r3, [r3, #0]
 804ec5e:	2b09      	cmp	r3, #9
 804ec60:	f040 80b7 	bne.w	804edd2 <formatGPSSring+0x206>
			configptr = strtok(NULL, ",");

		gu32ExtractGPSParamCounter++;
 804ec64:	4a60      	ldr	r2, [pc, #384]	; (804ede8 <formatGPSSring+0x21c>)
 804ec66:	6813      	ldr	r3, [r2, #0]
 804ec68:	3301      	adds	r3, #1
 804ec6a:	6013      	str	r3, [r2, #0]
	while(gu32ExtractGPSParamCounter != 9) //reference : while(configptr != NULL)
 804ec6c:	4b5e      	ldr	r3, [pc, #376]	; (804ede8 <formatGPSSring+0x21c>)
 804ec6e:	681b      	ldr	r3, [r3, #0]
 804ec70:	2b09      	cmp	r3, #9
 804ec72:	f000 80b4 	beq.w	804edde <formatGPSSring+0x212>
		switch(gu32ExtractGPSParamCounter)
 804ec76:	2b08      	cmp	r3, #8
 804ec78:	d8ef      	bhi.n	804ec5a <formatGPSSring+0x8e>
 804ec7a:	a201      	add	r2, pc, #4	; (adr r2, 804ec80 <formatGPSSring+0xb4>)
 804ec7c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 804ec80:	0804ebe1 	.word	0x0804ebe1
 804ec84:	0804eca5 	.word	0x0804eca5
 804ec88:	0804ecc5 	.word	0x0804ecc5
 804ec8c:	0804ed43 	.word	0x0804ed43
 804ec90:	0804ed5b 	.word	0x0804ed5b
 804ec94:	0804ed73 	.word	0x0804ed73
 804ec98:	0804ed8b 	.word	0x0804ed8b
 804ec9c:	0804eda3 	.word	0x0804eda3
 804eca0:	0804edbb 	.word	0x0804edbb
				strcat(agpsLastLocationDataFormatted,",");
 804eca4:	4d53      	ldr	r5, [pc, #332]	; (804edf4 <formatGPSSring+0x228>)
 804eca6:	4628      	mov	r0, r5
 804eca8:	f7f1 faa2 	bl	80401f0 <strlen>
 804ecac:	4b4c      	ldr	r3, [pc, #304]	; (804ede0 <formatGPSSring+0x214>)
 804ecae:	881e      	ldrh	r6, [r3, #0]
 804ecb0:	522e      	strh	r6, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ecb2:	4621      	mov	r1, r4
 804ecb4:	4628      	mov	r0, r5
 804ecb6:	f002 fadb 	bl	8051270 <strcat>
				strcat(agpsLastLocationDataFormatted,",");
 804ecba:	4628      	mov	r0, r5
 804ecbc:	f7f1 fa98 	bl	80401f0 <strlen>
 804ecc0:	522e      	strh	r6, [r5, r0]
				break;
 804ecc2:	e7ca      	b.n	804ec5a <formatGPSSring+0x8e>
				strcpy(gu32GPSLon,configptr);
 804ecc4:	4d47      	ldr	r5, [pc, #284]	; (804ede4 <formatGPSSring+0x218>)
 804ecc6:	4621      	mov	r1, r4
 804ecc8:	f505 70a8 	add.w	r0, r5, #336	; 0x150
 804eccc:	f002 faec 	bl	80512a8 <strcpy>
				templon = atof(&gu32GPSLon[3]);
 804ecd0:	f205 1053 	addw	r0, r5, #339	; 0x153
 804ecd4:	f001 ffc3 	bl	8050c5e <atof>
 804ecd8:	ec51 0b10 	vmov	r0, r1, d0
 804ecdc:	f7f1 ff94 	bl	8040c08 <__aeabi_d2f>
 804ece0:	ee06 0a90 	vmov	s13, r0
				templon /= 60;
 804ece4:	eddf 7a41 	vldr	s15, [pc, #260]	; 804edec <formatGPSSring+0x220>
 804ece8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
				templon += (((gu32GPSLon[0]- '0') * 100 )+ ((gu32GPSLon[1]-'0') * 10) +(gu32GPSLon[2]-'0'));
 804ecec:	f895 3150 	ldrb.w	r3, [r5, #336]	; 0x150
 804ecf0:	3b30      	subs	r3, #48	; 0x30
 804ecf2:	f895 2151 	ldrb.w	r2, [r5, #337]	; 0x151
 804ecf6:	3a30      	subs	r2, #48	; 0x30
 804ecf8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 804ecfc:	0052      	lsls	r2, r2, #1
 804ecfe:	2164      	movs	r1, #100	; 0x64
 804ed00:	fb01 2303 	mla	r3, r1, r3, r2
 804ed04:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
 804ed08:	3a30      	subs	r2, #48	; 0x30
 804ed0a:	4413      	add	r3, r2
 804ed0c:	ee07 3a90 	vmov	s15, r3
 804ed10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 804ed14:	ee77 7a87 	vadd.f32	s15, s15, s14
 804ed18:	4b33      	ldr	r3, [pc, #204]	; (804ede8 <formatGPSSring+0x21c>)
 804ed1a:	edc3 7a02 	vstr	s15, [r3, #8]
				sprintf(gu32GPSLonformatted,"%.7f",templon);
 804ed1e:	ee17 0a90 	vmov	r0, s15
 804ed22:	f7f1 fc21 	bl	8040568 <__aeabi_f2d>
 804ed26:	4602      	mov	r2, r0
 804ed28:	460b      	mov	r3, r1
 804ed2a:	f505 76b0 	add.w	r6, r5, #352	; 0x160
 804ed2e:	4930      	ldr	r1, [pc, #192]	; (804edf0 <formatGPSSring+0x224>)
 804ed30:	4630      	mov	r0, r6
 804ed32:	f002 fa7d 	bl	8051230 <sprintf>
				strcat(agpsLastLocationDataFormatted,gu32GPSLonformatted);
 804ed36:	4631      	mov	r1, r6
 804ed38:	f105 00b8 	add.w	r0, r5, #184	; 0xb8
 804ed3c:	f002 fa98 	bl	8051270 <strcat>
				break;
 804ed40:	e78b      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ed42:	4d2c      	ldr	r5, [pc, #176]	; (804edf4 <formatGPSSring+0x228>)
 804ed44:	4628      	mov	r0, r5
 804ed46:	f7f1 fa53 	bl	80401f0 <strlen>
 804ed4a:	4b25      	ldr	r3, [pc, #148]	; (804ede0 <formatGPSSring+0x214>)
 804ed4c:	881b      	ldrh	r3, [r3, #0]
 804ed4e:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ed50:	4621      	mov	r1, r4
 804ed52:	4628      	mov	r0, r5
 804ed54:	f002 fa8c 	bl	8051270 <strcat>
				break;
 804ed58:	e77f      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ed5a:	4d26      	ldr	r5, [pc, #152]	; (804edf4 <formatGPSSring+0x228>)
 804ed5c:	4628      	mov	r0, r5
 804ed5e:	f7f1 fa47 	bl	80401f0 <strlen>
 804ed62:	4b1f      	ldr	r3, [pc, #124]	; (804ede0 <formatGPSSring+0x214>)
 804ed64:	881b      	ldrh	r3, [r3, #0]
 804ed66:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ed68:	4621      	mov	r1, r4
 804ed6a:	4628      	mov	r0, r5
 804ed6c:	f002 fa80 	bl	8051270 <strcat>
				break;
 804ed70:	e773      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ed72:	4d20      	ldr	r5, [pc, #128]	; (804edf4 <formatGPSSring+0x228>)
 804ed74:	4628      	mov	r0, r5
 804ed76:	f7f1 fa3b 	bl	80401f0 <strlen>
 804ed7a:	4b19      	ldr	r3, [pc, #100]	; (804ede0 <formatGPSSring+0x214>)
 804ed7c:	881b      	ldrh	r3, [r3, #0]
 804ed7e:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ed80:	4621      	mov	r1, r4
 804ed82:	4628      	mov	r0, r5
 804ed84:	f002 fa74 	bl	8051270 <strcat>
				break;
 804ed88:	e767      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804ed8a:	4d1a      	ldr	r5, [pc, #104]	; (804edf4 <formatGPSSring+0x228>)
 804ed8c:	4628      	mov	r0, r5
 804ed8e:	f7f1 fa2f 	bl	80401f0 <strlen>
 804ed92:	4b13      	ldr	r3, [pc, #76]	; (804ede0 <formatGPSSring+0x214>)
 804ed94:	881b      	ldrh	r3, [r3, #0]
 804ed96:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804ed98:	4621      	mov	r1, r4
 804ed9a:	4628      	mov	r0, r5
 804ed9c:	f002 fa68 	bl	8051270 <strcat>
				break;
 804eda0:	e75b      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804eda2:	4d14      	ldr	r5, [pc, #80]	; (804edf4 <formatGPSSring+0x228>)
 804eda4:	4628      	mov	r0, r5
 804eda6:	f7f1 fa23 	bl	80401f0 <strlen>
 804edaa:	4b0d      	ldr	r3, [pc, #52]	; (804ede0 <formatGPSSring+0x214>)
 804edac:	881b      	ldrh	r3, [r3, #0]
 804edae:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804edb0:	4621      	mov	r1, r4
 804edb2:	4628      	mov	r0, r5
 804edb4:	f002 fa5c 	bl	8051270 <strcat>
				break;
 804edb8:	e74f      	b.n	804ec5a <formatGPSSring+0x8e>
				strcat(agpsLastLocationDataFormatted,",");
 804edba:	4d0e      	ldr	r5, [pc, #56]	; (804edf4 <formatGPSSring+0x228>)
 804edbc:	4628      	mov	r0, r5
 804edbe:	f7f1 fa17 	bl	80401f0 <strlen>
 804edc2:	4b07      	ldr	r3, [pc, #28]	; (804ede0 <formatGPSSring+0x214>)
 804edc4:	881b      	ldrh	r3, [r3, #0]
 804edc6:	522b      	strh	r3, [r5, r0]
				strcat(agpsLastLocationDataFormatted,configptr);
 804edc8:	4621      	mov	r1, r4
 804edca:	4628      	mov	r0, r5
 804edcc:	f002 fa50 	bl	8051270 <strcat>
				break;
 804edd0:	e743      	b.n	804ec5a <formatGPSSring+0x8e>
			configptr = strtok(NULL, ",");
 804edd2:	4903      	ldr	r1, [pc, #12]	; (804ede0 <formatGPSSring+0x214>)
 804edd4:	2000      	movs	r0, #0
 804edd6:	f003 f8dd 	bl	8051f94 <strtok>
 804edda:	4604      	mov	r4, r0
 804eddc:	e742      	b.n	804ec64 <formatGPSSring+0x98>

	}
}
 804edde:	bd70      	pop	{r4, r5, r6, pc}
 804ede0:	0805a058 	.word	0x0805a058
 804ede4:	20002710 	.word	0x20002710
 804ede8:	20004f8c 	.word	0x20004f8c
 804edec:	42700000 	.word	0x42700000
 804edf0:	0805a1f4 	.word	0x0805a1f4
 804edf4:	200027c8 	.word	0x200027c8

0804edf8 <getSystemDataString>:
{
 804edf8:	b5f0      	push	{r4, r5, r6, r7, lr}
 804edfa:	b08f      	sub	sp, #60	; 0x3c
	char * systemPayload = malloc(sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804edfc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804ee00:	f001 ff72 	bl	8050ce8 <malloc>
 804ee04:	4604      	mov	r4, r0
	getrtcStamp();
 804ee06:	f001 fddd 	bl	80509c4 <getrtcStamp>
	updateInputVoltage();
 804ee0a:	f7ff febd 	bl	804eb88 <updateInputVoltage>
	itoa(gu32EthLinkAlert,gacEthernetLinkStatus,10);
 804ee0e:	220a      	movs	r2, #10
 804ee10:	4991      	ldr	r1, [pc, #580]	; (804f058 <getSystemDataString+0x260>)
 804ee12:	4b92      	ldr	r3, [pc, #584]	; (804f05c <getSystemDataString+0x264>)
 804ee14:	6818      	ldr	r0, [r3, #0]
 804ee16:	f001 ff65 	bl	8050ce4 <itoa>
	itoa(gu32MBDataByteCounterLimit,gacMBDataPoints,10);
 804ee1a:	220a      	movs	r2, #10
 804ee1c:	4990      	ldr	r1, [pc, #576]	; (804f060 <getSystemDataString+0x268>)
 804ee1e:	4b91      	ldr	r3, [pc, #580]	; (804f064 <getSystemDataString+0x26c>)
 804ee20:	6818      	ldr	r0, [r3, #0]
 804ee22:	f001 ff5f 	bl	8050ce4 <itoa>
	itoa(gu32MBDataByteCounterLimitRTU,gacMBDataPointsRTU,10);
 804ee26:	220a      	movs	r2, #10
 804ee28:	498f      	ldr	r1, [pc, #572]	; (804f068 <getSystemDataString+0x270>)
 804ee2a:	4b90      	ldr	r3, [pc, #576]	; (804f06c <getSystemDataString+0x274>)
 804ee2c:	6818      	ldr	r0, [r3, #0]
 804ee2e:	f001 ff59 	bl	8050ce4 <itoa>
	itoa(gu32MBClientConnectedFlag,gacModbusStatus,10);
 804ee32:	4b8f      	ldr	r3, [pc, #572]	; (804f070 <getSystemDataString+0x278>)
 804ee34:	6818      	ldr	r0, [r3, #0]
 804ee36:	4d8f      	ldr	r5, [pc, #572]	; (804f074 <getSystemDataString+0x27c>)
 804ee38:	220a      	movs	r2, #10
 804ee3a:	f105 010c 	add.w	r1, r5, #12
 804ee3e:	f001 ff51 	bl	8050ce4 <itoa>
	itoa(gu32MBRTUClientConnectedFlag,gacModbusStatusRTU,10);
 804ee42:	4b8d      	ldr	r3, [pc, #564]	; (804f078 <getSystemDataString+0x280>)
 804ee44:	6818      	ldr	r0, [r3, #0]
 804ee46:	220a      	movs	r2, #10
 804ee48:	f105 0110 	add.w	r1, r5, #16
 804ee4c:	f001 ff4a 	bl	8050ce4 <itoa>
	if(strlen(gsmInstance.agpsLocationData) > 10)
 804ee50:	488a      	ldr	r0, [pc, #552]	; (804f07c <getSystemDataString+0x284>)
 804ee52:	f7f1 f9cd 	bl	80401f0 <strlen>
 804ee56:	280a      	cmp	r0, #10
 804ee58:	d812      	bhi.n	804ee80 <getSystemDataString+0x88>
	if(systemPayload != NULL)
 804ee5a:	b174      	cbz	r4, 804ee7a <getSystemDataString+0x82>
		memset(systemPayload,0x00,sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804ee5c:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804ee60:	2100      	movs	r1, #0
 804ee62:	4620      	mov	r0, r4
 804ee64:	f002 f9ae 	bl	80511c4 <memset>
		if(gu32OperateModbusTCP == 1)
 804ee68:	4b85      	ldr	r3, [pc, #532]	; (804f080 <getSystemDataString+0x288>)
 804ee6a:	681b      	ldr	r3, [r3, #0]
 804ee6c:	2b01      	cmp	r3, #1
 804ee6e:	d00f      	beq.n	804ee90 <getSystemDataString+0x98>
		if(gu32OperateModbus485 == 1)
 804ee70:	4b84      	ldr	r3, [pc, #528]	; (804f084 <getSystemDataString+0x28c>)
 804ee72:	681b      	ldr	r3, [r3, #0]
 804ee74:	2b01      	cmp	r3, #1
 804ee76:	f000 8133 	beq.w	804f0e0 <getSystemDataString+0x2e8>
}
 804ee7a:	4620      	mov	r0, r4
 804ee7c:	b00f      	add	sp, #60	; 0x3c
 804ee7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(agpsLastLocationData,gsmInstance.agpsLocationData,strlen(gsmInstance.agpsLocationData));
 804ee80:	4602      	mov	r2, r0
 804ee82:	497e      	ldr	r1, [pc, #504]	; (804f07c <getSystemDataString+0x284>)
 804ee84:	4880      	ldr	r0, [pc, #512]	; (804f088 <getSystemDataString+0x290>)
 804ee86:	f002 f98f 	bl	80511a8 <memcpy>
		formatGPSSring();
 804ee8a:	f7ff fe9f 	bl	804ebcc <formatGPSSring>
 804ee8e:	e7e4      	b.n	804ee5a <getSystemDataString+0x62>
			strcpy((char *)systemPayload,(char * )START_OF_FRAME);
 804ee90:	4b7e      	ldr	r3, [pc, #504]	; (804f08c <getSystemDataString+0x294>)
 804ee92:	881b      	ldrh	r3, [r3, #0]
 804ee94:	8023      	strh	r3, [r4, #0]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ee96:	4620      	mov	r0, r4
 804ee98:	f7f1 f9aa 	bl	80401f0 <strlen>
 804ee9c:	4b7c      	ldr	r3, [pc, #496]	; (804f090 <getSystemDataString+0x298>)
 804ee9e:	881d      	ldrh	r5, [r3, #0]
 804eea0:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )dinfo);
 804eea2:	497c      	ldr	r1, [pc, #496]	; (804f094 <getSystemDataString+0x29c>)
 804eea4:	4620      	mov	r0, r4
 804eea6:	f002 f9e3 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804eeaa:	4620      	mov	r0, r4
 804eeac:	f7f1 f9a0 	bl	80401f0 <strlen>
 804eeb0:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )MODEL_NUMBER);
 804eeb2:	4620      	mov	r0, r4
 804eeb4:	f7f1 f99c 	bl	80401f0 <strlen>
 804eeb8:	4603      	mov	r3, r0
 804eeba:	1826      	adds	r6, r4, r0
 804eebc:	4a76      	ldr	r2, [pc, #472]	; (804f098 <getSystemDataString+0x2a0>)
 804eebe:	ca03      	ldmia	r2!, {r0, r1}
 804eec0:	50e0      	str	r0, [r4, r3]
 804eec2:	6071      	str	r1, [r6, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804eec4:	4620      	mov	r0, r4
 804eec6:	f7f1 f993 	bl	80401f0 <strlen>
 804eeca:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )aShowDateStamp);
 804eecc:	4973      	ldr	r1, [pc, #460]	; (804f09c <getSystemDataString+0x2a4>)
 804eece:	4620      	mov	r0, r4
 804eed0:	f002 f9ce 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )" ");
 804eed4:	4620      	mov	r0, r4
 804eed6:	f7f1 f98b 	bl	80401f0 <strlen>
 804eeda:	4b71      	ldr	r3, [pc, #452]	; (804f0a0 <getSystemDataString+0x2a8>)
 804eedc:	881b      	ldrh	r3, [r3, #0]
 804eede:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )aShowTimeStamp);
 804eee0:	4970      	ldr	r1, [pc, #448]	; (804f0a4 <getSystemDataString+0x2ac>)
 804eee2:	4620      	mov	r0, r4
 804eee4:	f002 f9c4 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804eee8:	4620      	mov	r0, r4
 804eeea:	f7f1 f981 	bl	80401f0 <strlen>
 804eeee:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )FIRMWARE_VER);
 804eef0:	4620      	mov	r0, r4
 804eef2:	f7f1 f97d 	bl	80401f0 <strlen>
 804eef6:	4607      	mov	r7, r0
 804eef8:	1826      	adds	r6, r4, r0
 804eefa:	4b6b      	ldr	r3, [pc, #428]	; (804f0a8 <getSystemDataString+0x2b0>)
 804eefc:	cb07      	ldmia	r3!, {r0, r1, r2}
 804eefe:	51e0      	str	r0, [r4, r7]
 804ef00:	6071      	str	r1, [r6, #4]
 804ef02:	60b2      	str	r2, [r6, #8]
 804ef04:	881a      	ldrh	r2, [r3, #0]
 804ef06:	789b      	ldrb	r3, [r3, #2]
 804ef08:	81b2      	strh	r2, [r6, #12]
 804ef0a:	73b3      	strb	r3, [r6, #14]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef0c:	4620      	mov	r0, r4
 804ef0e:	f7f1 f96f 	bl	80401f0 <strlen>
 804ef12:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )BOOT_REGION);
 804ef14:	4620      	mov	r0, r4
 804ef16:	f7f1 f96b 	bl	80401f0 <strlen>
 804ef1a:	4b64      	ldr	r3, [pc, #400]	; (804f0ac <getSystemDataString+0x2b4>)
 804ef1c:	881b      	ldrh	r3, [r3, #0]
 804ef1e:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )",");
 804ef20:	4620      	mov	r0, r4
 804ef22:	f7f1 f965 	bl	80401f0 <strlen>
 804ef26:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacEthernetLinkStatus);
 804ef28:	494b      	ldr	r1, [pc, #300]	; (804f058 <getSystemDataString+0x260>)
 804ef2a:	4620      	mov	r0, r4
 804ef2c:	f002 f9a0 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef30:	4620      	mov	r0, r4
 804ef32:	f7f1 f95d 	bl	80401f0 <strlen>
 804ef36:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacMBDataPoints);
 804ef38:	4949      	ldr	r1, [pc, #292]	; (804f060 <getSystemDataString+0x268>)
 804ef3a:	4620      	mov	r0, r4
 804ef3c:	f002 f998 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef40:	4620      	mov	r0, r4
 804ef42:	f7f1 f955 	bl	80401f0 <strlen>
 804ef46:	5225      	strh	r5, [r4, r0]
			if((float)gfInputSupplyVoltage < 9.00f)
 804ef48:	4b59      	ldr	r3, [pc, #356]	; (804f0b0 <getSystemDataString+0x2b8>)
 804ef4a:	ed93 7a00 	vldr	s14, [r3]
 804ef4e:	eef2 7a02 	vmov.f32	s15, #34	; 0x41100000  9.0
 804ef52:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804ef56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804ef5a:	d56a      	bpl.n	804f032 <getSystemDataString+0x23a>
				strcat((char *)systemPayload,(char * )gcBatterySupplyVoltage);
 804ef5c:	4955      	ldr	r1, [pc, #340]	; (804f0b4 <getSystemDataString+0x2bc>)
 804ef5e:	4620      	mov	r0, r4
 804ef60:	f002 f986 	bl	8051270 <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef64:	4620      	mov	r0, r4
 804ef66:	f7f1 f943 	bl	80401f0 <strlen>
 804ef6a:	4b49      	ldr	r3, [pc, #292]	; (804f090 <getSystemDataString+0x298>)
 804ef6c:	881b      	ldrh	r3, [r3, #0]
 804ef6e:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gacModbusStatus);
 804ef70:	4951      	ldr	r1, [pc, #324]	; (804f0b8 <getSystemDataString+0x2c0>)
 804ef72:	4620      	mov	r0, r4
 804ef74:	f002 f97c 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef78:	4620      	mov	r0, r4
 804ef7a:	f7f1 f939 	bl	80401f0 <strlen>
 804ef7e:	4b44      	ldr	r3, [pc, #272]	; (804f090 <getSystemDataString+0x298>)
 804ef80:	881d      	ldrh	r5, [r3, #0]
 804ef82:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,"IP,");
 804ef84:	4620      	mov	r0, r4
 804ef86:	f7f1 f933 	bl	80401f0 <strlen>
 804ef8a:	4603      	mov	r3, r0
 804ef8c:	4a4b      	ldr	r2, [pc, #300]	; (804f0bc <getSystemDataString+0x2c4>)
 804ef8e:	6810      	ldr	r0, [r2, #0]
 804ef90:	50e0      	str	r0, [r4, r3]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804ef92:	4620      	mov	r0, r4
 804ef94:	f7f1 f92c 	bl	80401f0 <strlen>
 804ef98:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )agpsLastLocationDataFormatted);
 804ef9a:	4949      	ldr	r1, [pc, #292]	; (804f0c0 <getSystemDataString+0x2c8>)
 804ef9c:	4620      	mov	r0, r4
 804ef9e:	f002 f967 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804efa2:	4620      	mov	r0, r4
 804efa4:	f7f1 f924 	bl	80401f0 <strlen>
 804efa8:	5225      	strh	r5, [r4, r0]
			if(strlen(gsmInstance.agsmSignalStrength ) > 0)
 804efaa:	4b34      	ldr	r3, [pc, #208]	; (804f07c <getSystemDataString+0x284>)
 804efac:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 804efb0:	2b00      	cmp	r3, #0
 804efb2:	d049      	beq.n	804f048 <getSystemDataString+0x250>
				strcat((char *)systemPayload,(char * )gsmInstance.agsmSignalStrength);
 804efb4:	4943      	ldr	r1, [pc, #268]	; (804f0c4 <getSystemDataString+0x2cc>)
 804efb6:	4620      	mov	r0, r4
 804efb8:	f002 f95a 	bl	8051270 <strcat>
			u32TempVar = gu32GSMConfigCheckTimer / 1000;
 804efbc:	4b42      	ldr	r3, [pc, #264]	; (804f0c8 <getSystemDataString+0x2d0>)
 804efbe:	681d      	ldr	r5, [r3, #0]
 804efc0:	4b42      	ldr	r3, [pc, #264]	; (804f0cc <getSystemDataString+0x2d4>)
 804efc2:	fba3 3505 	umull	r3, r5, r3, r5
 804efc6:	09ad      	lsrs	r5, r5, #6
			memset(temp_array, 0, sizeof(temp_array));
 804efc8:	2232      	movs	r2, #50	; 0x32
 804efca:	2100      	movs	r1, #0
 804efcc:	a801      	add	r0, sp, #4
 804efce:	f002 f8f9 	bl	80511c4 <memset>
			itoa(u32TempVar, temp_array, 10);
 804efd2:	220a      	movs	r2, #10
 804efd4:	a901      	add	r1, sp, #4
 804efd6:	4628      	mov	r0, r5
 804efd8:	f001 fe84 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,(char * )",ConfigCheckTime:  ");
 804efdc:	4620      	mov	r0, r4
 804efde:	f7f1 f907 	bl	80401f0 <strlen>
 804efe2:	4607      	mov	r7, r0
 804efe4:	1826      	adds	r6, r4, r0
 804efe6:	4d3a      	ldr	r5, [pc, #232]	; (804f0d0 <getSystemDataString+0x2d8>)
 804efe8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804efea:	51e0      	str	r0, [r4, r7]
 804efec:	6071      	str	r1, [r6, #4]
 804efee:	60b2      	str	r2, [r6, #8]
 804eff0:	60f3      	str	r3, [r6, #12]
 804eff2:	6828      	ldr	r0, [r5, #0]
 804eff4:	6130      	str	r0, [r6, #16]
			strcat((char *)systemPayload,(char * )temp_array);
 804eff6:	a901      	add	r1, sp, #4
 804eff8:	4620      	mov	r0, r4
 804effa:	f002 f939 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804effe:	4620      	mov	r0, r4
 804f000:	f7f1 f8f6 	bl	80401f0 <strlen>
 804f004:	4b22      	ldr	r3, [pc, #136]	; (804f090 <getSystemDataString+0x298>)
 804f006:	881b      	ldrh	r3, [r3, #0]
 804f008:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,gau8TempMBPayloadString);
 804f00a:	4d32      	ldr	r5, [pc, #200]	; (804f0d4 <getSystemDataString+0x2dc>)
 804f00c:	4629      	mov	r1, r5
 804f00e:	4620      	mov	r0, r4
 804f010:	f002 f92e 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )END_OF_FRAME);
 804f014:	4620      	mov	r0, r4
 804f016:	f7f1 f8eb 	bl	80401f0 <strlen>
 804f01a:	4b2f      	ldr	r3, [pc, #188]	; (804f0d8 <getSystemDataString+0x2e0>)
 804f01c:	881b      	ldrh	r3, [r3, #0]
 804f01e:	5223      	strh	r3, [r4, r0]
			gu32TempLoopCounter = 0;
 804f020:	2100      	movs	r1, #0
 804f022:	4b14      	ldr	r3, [pc, #80]	; (804f074 <getSystemDataString+0x27c>)
 804f024:	6159      	str	r1, [r3, #20]
			memset(gau8TempMBPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimit);
 804f026:	4b0f      	ldr	r3, [pc, #60]	; (804f064 <getSystemDataString+0x26c>)
 804f028:	681a      	ldr	r2, [r3, #0]
 804f02a:	4628      	mov	r0, r5
 804f02c:	f002 f8ca 	bl	80511c4 <memset>
 804f030:	e71e      	b.n	804ee70 <getSystemDataString+0x78>
				strcat((char *)systemPayload,(char * )gcSystemSupplyVoltage);
 804f032:	492a      	ldr	r1, [pc, #168]	; (804f0dc <getSystemDataString+0x2e4>)
 804f034:	4620      	mov	r0, r4
 804f036:	f002 f91b 	bl	8051270 <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f03a:	4620      	mov	r0, r4
 804f03c:	f7f1 f8d8 	bl	80401f0 <strlen>
 804f040:	4b13      	ldr	r3, [pc, #76]	; (804f090 <getSystemDataString+0x298>)
 804f042:	881b      	ldrh	r3, [r3, #0]
 804f044:	5223      	strh	r3, [r4, r0]
 804f046:	e793      	b.n	804ef70 <getSystemDataString+0x178>
				strcat((char *)systemPayload,gpu8Norssi);
 804f048:	4b0f      	ldr	r3, [pc, #60]	; (804f088 <getSystemDataString+0x290>)
 804f04a:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
 804f04e:	4620      	mov	r0, r4
 804f050:	f002 f90e 	bl	8051270 <strcat>
 804f054:	e7b2      	b.n	804efbc <getSystemDataString+0x1c4>
 804f056:	bf00      	nop
 804f058:	2000ede4 	.word	0x2000ede4
 804f05c:	20003884 	.word	0x20003884
 804f060:	2000eddc 	.word	0x2000eddc
 804f064:	20004a98 	.word	0x20004a98
 804f068:	2000edcc 	.word	0x2000edcc
 804f06c:	20004a60 	.word	0x20004a60
 804f070:	20004a80 	.word	0x20004a80
 804f074:	20004f8c 	.word	0x20004f8c
 804f078:	200045ac 	.word	0x200045ac
 804f07c:	2000c61c 	.word	0x2000c61c
 804f080:	2000386c 	.word	0x2000386c
 804f084:	2000384c 	.word	0x2000384c
 804f088:	20002710 	.word	0x20002710
 804f08c:	0805a198 	.word	0x0805a198
 804f090:	0805a058 	.word	0x0805a058
 804f094:	20008a60 	.word	0x20008a60
 804f098:	08059fec 	.word	0x08059fec
 804f09c:	20005300 	.word	0x20005300
 804f0a0:	0805a038 	.word	0x0805a038
 804f0a4:	200052cc 	.word	0x200052cc
 804f0a8:	0805a1a8 	.word	0x0805a1a8
 804f0ac:	0805a1fc 	.word	0x0805a1fc
 804f0b0:	2000521c 	.word	0x2000521c
 804f0b4:	2000edc4 	.word	0x2000edc4
 804f0b8:	20004f98 	.word	0x20004f98
 804f0bc:	0805a200 	.word	0x0805a200
 804f0c0:	200027c8 	.word	0x200027c8
 804f0c4:	2000c6b2 	.word	0x2000c6b2
 804f0c8:	20005400 	.word	0x20005400
 804f0cc:	10624dd3 	.word	0x10624dd3
 804f0d0:	0805a204 	.word	0x0805a204
 804f0d4:	200022c4 	.word	0x200022c4
 804f0d8:	0805a1e8 	.word	0x0805a1e8
 804f0dc:	2000edd4 	.word	0x2000edd4
			strcat((char *)systemPayload,(char * )START_OF_FRAME);
 804f0e0:	4620      	mov	r0, r4
 804f0e2:	f7f1 f885 	bl	80401f0 <strlen>
 804f0e6:	4b88      	ldr	r3, [pc, #544]	; (804f308 <getSystemDataString+0x510>)
 804f0e8:	881b      	ldrh	r3, [r3, #0]
 804f0ea:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f0ec:	4620      	mov	r0, r4
 804f0ee:	f7f1 f87f 	bl	80401f0 <strlen>
 804f0f2:	4b86      	ldr	r3, [pc, #536]	; (804f30c <getSystemDataString+0x514>)
 804f0f4:	881d      	ldrh	r5, [r3, #0]
 804f0f6:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )dinfo);
 804f0f8:	4985      	ldr	r1, [pc, #532]	; (804f310 <getSystemDataString+0x518>)
 804f0fa:	4620      	mov	r0, r4
 804f0fc:	f002 f8b8 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )"_RTU");
 804f100:	4620      	mov	r0, r4
 804f102:	f7f1 f875 	bl	80401f0 <strlen>
 804f106:	4603      	mov	r3, r0
 804f108:	1821      	adds	r1, r4, r0
 804f10a:	4a82      	ldr	r2, [pc, #520]	; (804f314 <getSystemDataString+0x51c>)
 804f10c:	6810      	ldr	r0, [r2, #0]
 804f10e:	50e0      	str	r0, [r4, r3]
 804f110:	7913      	ldrb	r3, [r2, #4]
 804f112:	710b      	strb	r3, [r1, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f114:	4620      	mov	r0, r4
 804f116:	f7f1 f86b 	bl	80401f0 <strlen>
 804f11a:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )MODEL_NUMBER);
 804f11c:	4620      	mov	r0, r4
 804f11e:	f7f1 f867 	bl	80401f0 <strlen>
 804f122:	4603      	mov	r3, r0
 804f124:	1826      	adds	r6, r4, r0
 804f126:	4a7c      	ldr	r2, [pc, #496]	; (804f318 <getSystemDataString+0x520>)
 804f128:	ca03      	ldmia	r2!, {r0, r1}
 804f12a:	50e0      	str	r0, [r4, r3]
 804f12c:	6071      	str	r1, [r6, #4]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f12e:	4620      	mov	r0, r4
 804f130:	f7f1 f85e 	bl	80401f0 <strlen>
 804f134:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Date);
 804f136:	4979      	ldr	r1, [pc, #484]	; (804f31c <getSystemDataString+0x524>)
 804f138:	4620      	mov	r0, r4
 804f13a:	f002 f899 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804f13e:	4620      	mov	r0, r4
 804f140:	f7f1 f856 	bl	80401f0 <strlen>
 804f144:	4b76      	ldr	r3, [pc, #472]	; (804f320 <getSystemDataString+0x528>)
 804f146:	881e      	ldrh	r6, [r3, #0]
 804f148:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Month);
 804f14a:	4976      	ldr	r1, [pc, #472]	; (804f324 <getSystemDataString+0x52c>)
 804f14c:	4620      	mov	r0, r4
 804f14e:	f002 f88f 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804f152:	4620      	mov	r0, r4
 804f154:	f7f1 f84c 	bl	80401f0 <strlen>
 804f158:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Year);
 804f15a:	4973      	ldr	r1, [pc, #460]	; (804f328 <getSystemDataString+0x530>)
 804f15c:	4620      	mov	r0, r4
 804f15e:	f002 f887 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )RTC_PARAM_SEPARATOR);
 804f162:	4620      	mov	r0, r4
 804f164:	f7f1 f844 	bl	80401f0 <strlen>
 804f168:	4b70      	ldr	r3, [pc, #448]	; (804f32c <getSystemDataString+0x534>)
 804f16a:	881b      	ldrh	r3, [r3, #0]
 804f16c:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Hour);
 804f16e:	4970      	ldr	r1, [pc, #448]	; (804f330 <getSystemDataString+0x538>)
 804f170:	4620      	mov	r0, r4
 804f172:	f002 f87d 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804f176:	4620      	mov	r0, r4
 804f178:	f7f1 f83a 	bl	80401f0 <strlen>
 804f17c:	4b6d      	ldr	r3, [pc, #436]	; (804f334 <getSystemDataString+0x53c>)
 804f17e:	881e      	ldrh	r6, [r3, #0]
 804f180:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Minutes);
 804f182:	496d      	ldr	r1, [pc, #436]	; (804f338 <getSystemDataString+0x540>)
 804f184:	4620      	mov	r0, r4
 804f186:	f002 f873 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804f18a:	4620      	mov	r0, r4
 804f18c:	f7f1 f830 	bl	80401f0 <strlen>
 804f190:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gau8Seconds);
 804f192:	496a      	ldr	r1, [pc, #424]	; (804f33c <getSystemDataString+0x544>)
 804f194:	4620      	mov	r0, r4
 804f196:	f002 f86b 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f19a:	4620      	mov	r0, r4
 804f19c:	f7f1 f828 	bl	80401f0 <strlen>
 804f1a0:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )FIRMWARE_VER);
 804f1a2:	4620      	mov	r0, r4
 804f1a4:	f7f1 f824 	bl	80401f0 <strlen>
 804f1a8:	4607      	mov	r7, r0
 804f1aa:	1826      	adds	r6, r4, r0
 804f1ac:	4b64      	ldr	r3, [pc, #400]	; (804f340 <getSystemDataString+0x548>)
 804f1ae:	cb07      	ldmia	r3!, {r0, r1, r2}
 804f1b0:	51e0      	str	r0, [r4, r7]
 804f1b2:	6071      	str	r1, [r6, #4]
 804f1b4:	60b2      	str	r2, [r6, #8]
 804f1b6:	881a      	ldrh	r2, [r3, #0]
 804f1b8:	789b      	ldrb	r3, [r3, #2]
 804f1ba:	81b2      	strh	r2, [r6, #12]
 804f1bc:	73b3      	strb	r3, [r6, #14]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f1be:	4620      	mov	r0, r4
 804f1c0:	f7f1 f816 	bl	80401f0 <strlen>
 804f1c4:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )BOOT_REGION);
 804f1c6:	4620      	mov	r0, r4
 804f1c8:	f7f1 f812 	bl	80401f0 <strlen>
 804f1cc:	4b5d      	ldr	r3, [pc, #372]	; (804f344 <getSystemDataString+0x54c>)
 804f1ce:	881b      	ldrh	r3, [r3, #0]
 804f1d0:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )",");
 804f1d2:	4620      	mov	r0, r4
 804f1d4:	f7f1 f80c 	bl	80401f0 <strlen>
 804f1d8:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacEthernetLinkStatus);
 804f1da:	495b      	ldr	r1, [pc, #364]	; (804f348 <getSystemDataString+0x550>)
 804f1dc:	4620      	mov	r0, r4
 804f1de:	f002 f847 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f1e2:	4620      	mov	r0, r4
 804f1e4:	f7f1 f804 	bl	80401f0 <strlen>
 804f1e8:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )gacMBDataPointsRTU);
 804f1ea:	4958      	ldr	r1, [pc, #352]	; (804f34c <getSystemDataString+0x554>)
 804f1ec:	4620      	mov	r0, r4
 804f1ee:	f002 f83f 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f1f2:	4620      	mov	r0, r4
 804f1f4:	f7f0 fffc 	bl	80401f0 <strlen>
 804f1f8:	5225      	strh	r5, [r4, r0]
			if((float)gfInputSupplyVoltage < 9.00f)
 804f1fa:	4b55      	ldr	r3, [pc, #340]	; (804f350 <getSystemDataString+0x558>)
 804f1fc:	ed93 7a00 	vldr	s14, [r3]
 804f200:	eef2 7a02 	vmov.f32	s15, #34	; 0x41100000  9.0
 804f204:	eeb4 7ae7 	vcmpe.f32	s14, s15
 804f208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 804f20c:	d56a      	bpl.n	804f2e4 <getSystemDataString+0x4ec>
				strcat((char *)systemPayload,(char * )gcBatterySupplyVoltage);
 804f20e:	4951      	ldr	r1, [pc, #324]	; (804f354 <getSystemDataString+0x55c>)
 804f210:	4620      	mov	r0, r4
 804f212:	f002 f82d 	bl	8051270 <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f216:	4620      	mov	r0, r4
 804f218:	f7f0 ffea 	bl	80401f0 <strlen>
 804f21c:	4b3b      	ldr	r3, [pc, #236]	; (804f30c <getSystemDataString+0x514>)
 804f21e:	881b      	ldrh	r3, [r3, #0]
 804f220:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,(char * )gacModbusStatusRTU);
 804f222:	494d      	ldr	r1, [pc, #308]	; (804f358 <getSystemDataString+0x560>)
 804f224:	4620      	mov	r0, r4
 804f226:	f002 f823 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f22a:	4620      	mov	r0, r4
 804f22c:	f7f0 ffe0 	bl	80401f0 <strlen>
 804f230:	4b36      	ldr	r3, [pc, #216]	; (804f30c <getSystemDataString+0x514>)
 804f232:	881d      	ldrh	r5, [r3, #0]
 804f234:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,"RT,");
 804f236:	4620      	mov	r0, r4
 804f238:	f7f0 ffda 	bl	80401f0 <strlen>
 804f23c:	4603      	mov	r3, r0
 804f23e:	4a47      	ldr	r2, [pc, #284]	; (804f35c <getSystemDataString+0x564>)
 804f240:	6810      	ldr	r0, [r2, #0]
 804f242:	50e0      	str	r0, [r4, r3]
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f244:	4620      	mov	r0, r4
 804f246:	f7f0 ffd3 	bl	80401f0 <strlen>
 804f24a:	5225      	strh	r5, [r4, r0]
			strcat((char *)systemPayload,(char * )agpsLastLocationDataFormatted);
 804f24c:	4944      	ldr	r1, [pc, #272]	; (804f360 <getSystemDataString+0x568>)
 804f24e:	4620      	mov	r0, r4
 804f250:	f002 f80e 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f254:	4620      	mov	r0, r4
 804f256:	f7f0 ffcb 	bl	80401f0 <strlen>
 804f25a:	5225      	strh	r5, [r4, r0]
			if(strlen(gsmInstance.agsmSignalStrength ) > 0)
 804f25c:	4b41      	ldr	r3, [pc, #260]	; (804f364 <getSystemDataString+0x56c>)
 804f25e:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 804f262:	2b00      	cmp	r3, #0
 804f264:	d049      	beq.n	804f2fa <getSystemDataString+0x502>
				strcat((char *)systemPayload,(char * )gsmInstance.agsmSignalStrength);
 804f266:	4940      	ldr	r1, [pc, #256]	; (804f368 <getSystemDataString+0x570>)
 804f268:	4620      	mov	r0, r4
 804f26a:	f002 f801 	bl	8051270 <strcat>
			u32TempVar = gu32GSMConfigCheckTimer / 1000;
 804f26e:	4b3f      	ldr	r3, [pc, #252]	; (804f36c <getSystemDataString+0x574>)
 804f270:	681d      	ldr	r5, [r3, #0]
 804f272:	4b3f      	ldr	r3, [pc, #252]	; (804f370 <getSystemDataString+0x578>)
 804f274:	fba3 3505 	umull	r3, r5, r3, r5
 804f278:	09ad      	lsrs	r5, r5, #6
			memset(temp_array, 0, sizeof(temp_array));
 804f27a:	2232      	movs	r2, #50	; 0x32
 804f27c:	2100      	movs	r1, #0
 804f27e:	a801      	add	r0, sp, #4
 804f280:	f001 ffa0 	bl	80511c4 <memset>
			itoa(u32TempVar, temp_array, 10);
 804f284:	220a      	movs	r2, #10
 804f286:	a901      	add	r1, sp, #4
 804f288:	4628      	mov	r0, r5
 804f28a:	f001 fd2b 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,(char * )",ConfigCheckTime ");
 804f28e:	4620      	mov	r0, r4
 804f290:	f7f0 ffae 	bl	80401f0 <strlen>
 804f294:	4607      	mov	r7, r0
 804f296:	1826      	adds	r6, r4, r0
 804f298:	4d36      	ldr	r5, [pc, #216]	; (804f374 <getSystemDataString+0x57c>)
 804f29a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804f29c:	51e0      	str	r0, [r4, r7]
 804f29e:	6071      	str	r1, [r6, #4]
 804f2a0:	60b2      	str	r2, [r6, #8]
 804f2a2:	60f3      	str	r3, [r6, #12]
 804f2a4:	882b      	ldrh	r3, [r5, #0]
 804f2a6:	8233      	strh	r3, [r6, #16]
			strcat((char *)systemPayload,(char * )temp_array);
 804f2a8:	a901      	add	r1, sp, #4
 804f2aa:	4620      	mov	r0, r4
 804f2ac:	f001 ffe0 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f2b0:	4620      	mov	r0, r4
 804f2b2:	f7f0 ff9d 	bl	80401f0 <strlen>
 804f2b6:	4b15      	ldr	r3, [pc, #84]	; (804f30c <getSystemDataString+0x514>)
 804f2b8:	881b      	ldrh	r3, [r3, #0]
 804f2ba:	5223      	strh	r3, [r4, r0]
			strcat((char *)systemPayload,gau8TempMBRTUPayloadString);
 804f2bc:	4d2e      	ldr	r5, [pc, #184]	; (804f378 <getSystemDataString+0x580>)
 804f2be:	4629      	mov	r1, r5
 804f2c0:	4620      	mov	r0, r4
 804f2c2:	f001 ffd5 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )END_OF_FRAME);
 804f2c6:	4620      	mov	r0, r4
 804f2c8:	f7f0 ff92 	bl	80401f0 <strlen>
 804f2cc:	4b2b      	ldr	r3, [pc, #172]	; (804f37c <getSystemDataString+0x584>)
 804f2ce:	881b      	ldrh	r3, [r3, #0]
 804f2d0:	5223      	strh	r3, [r4, r0]
			gu32TempLoopCounter = 0;
 804f2d2:	2100      	movs	r1, #0
 804f2d4:	4b2a      	ldr	r3, [pc, #168]	; (804f380 <getSystemDataString+0x588>)
 804f2d6:	6159      	str	r1, [r3, #20]
			memset(gau8TempMBRTUPayloadString,0x00,sizeof(char) * gu32MBDataByteCounterLimitRTU);
 804f2d8:	4b2a      	ldr	r3, [pc, #168]	; (804f384 <getSystemDataString+0x58c>)
 804f2da:	681a      	ldr	r2, [r3, #0]
 804f2dc:	4628      	mov	r0, r5
 804f2de:	f001 ff71 	bl	80511c4 <memset>
		return systemPayload;
 804f2e2:	e5ca      	b.n	804ee7a <getSystemDataString+0x82>
				strcat((char *)systemPayload,(char * )gcSystemSupplyVoltage);
 804f2e4:	4928      	ldr	r1, [pc, #160]	; (804f388 <getSystemDataString+0x590>)
 804f2e6:	4620      	mov	r0, r4
 804f2e8:	f001 ffc2 	bl	8051270 <strcat>
				strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f2ec:	4620      	mov	r0, r4
 804f2ee:	f7f0 ff7f 	bl	80401f0 <strlen>
 804f2f2:	4b06      	ldr	r3, [pc, #24]	; (804f30c <getSystemDataString+0x514>)
 804f2f4:	881b      	ldrh	r3, [r3, #0]
 804f2f6:	5223      	strh	r3, [r4, r0]
 804f2f8:	e793      	b.n	804f222 <getSystemDataString+0x42a>
				strcat((char *)systemPayload,gpu8Norssi);
 804f2fa:	4b24      	ldr	r3, [pc, #144]	; (804f38c <getSystemDataString+0x594>)
 804f2fc:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
 804f300:	4620      	mov	r0, r4
 804f302:	f001 ffb5 	bl	8051270 <strcat>
 804f306:	e7b2      	b.n	804f26e <getSystemDataString+0x476>
 804f308:	0805a198 	.word	0x0805a198
 804f30c:	0805a058 	.word	0x0805a058
 804f310:	20008a60 	.word	0x20008a60
 804f314:	0805a218 	.word	0x0805a218
 804f318:	08059fec 	.word	0x08059fec
 804f31c:	20003898 	.word	0x20003898
 804f320:	0805a1a4 	.word	0x0805a1a4
 804f324:	20003890 	.word	0x20003890
 804f328:	20003888 	.word	0x20003888
 804f32c:	0805a038 	.word	0x0805a038
 804f330:	200038a0 	.word	0x200038a0
 804f334:	0805a0f8 	.word	0x0805a0f8
 804f338:	200038a8 	.word	0x200038a8
 804f33c:	200038b0 	.word	0x200038b0
 804f340:	0805a1a8 	.word	0x0805a1a8
 804f344:	0805a1fc 	.word	0x0805a1fc
 804f348:	2000ede4 	.word	0x2000ede4
 804f34c:	2000edcc 	.word	0x2000edcc
 804f350:	2000521c 	.word	0x2000521c
 804f354:	2000edc4 	.word	0x2000edc4
 804f358:	20004f9c 	.word	0x20004f9c
 804f35c:	0805a220 	.word	0x0805a220
 804f360:	200027c8 	.word	0x200027c8
 804f364:	2000c61c 	.word	0x2000c61c
 804f368:	2000c6b2 	.word	0x2000c6b2
 804f36c:	20005400 	.word	0x20005400
 804f370:	10624dd3 	.word	0x10624dd3
 804f374:	0805a224 	.word	0x0805a224
 804f378:	200016a4 	.word	0x200016a4
 804f37c:	0805a1e8 	.word	0x0805a1e8
 804f380:	20004f8c 	.word	0x20004f8c
 804f384:	20004a60 	.word	0x20004a60
 804f388:	2000edd4 	.word	0x2000edd4
 804f38c:	20002710 	.word	0x20002710

0804f390 <DiagnosticString>:
	else
		return NULL; // malloc Error . Memory Allocation Failure
}

void DiagnosticString(char * systemPayload, enmDiagnosticStatus DiagnosticStatus)
{
 804f390:	b5f0      	push	{r4, r5, r6, r7, lr}
 804f392:	b087      	sub	sp, #28
 804f394:	4604      	mov	r4, r0
 804f396:	460d      	mov	r5, r1
	char temp[20] = "";
 804f398:	2300      	movs	r3, #0
 804f39a:	9301      	str	r3, [sp, #4]
 804f39c:	9302      	str	r3, [sp, #8]
 804f39e:	9303      	str	r3, [sp, #12]
 804f3a0:	9304      	str	r3, [sp, #16]
 804f3a2:	9305      	str	r3, [sp, #20]
	switch(DiagnosticStatus)
 804f3a4:	290c      	cmp	r1, #12
 804f3a6:	d811      	bhi.n	804f3cc <DiagnosticString+0x3c>
 804f3a8:	290c      	cmp	r1, #12
 804f3aa:	f200 81cd 	bhi.w	804f748 <DiagnosticString+0x3b8>
 804f3ae:	e8df f011 	tbh	[pc, r1, lsl #1]
 804f3b2:	0020      	.short	0x0020
 804f3b4:	01cb01cb 	.word	0x01cb01cb
 804f3b8:	005c0040 	.word	0x005c0040
 804f3bc:	00c50073 	.word	0x00c50073
 804f3c0:	012300fd 	.word	0x012300fd
 804f3c4:	015b013f 	.word	0x015b013f
 804f3c8:	01930177 	.word	0x01930177
 804f3cc:	2963      	cmp	r1, #99	; 0x63
 804f3ce:	f040 81bb 	bne.w	804f748 <DiagnosticString+0x3b8>
			strcat((char *)systemPayload,temp);
			strcat((char *)systemPayload,(char * )",");
			break;

		case enmDiagnostic_IDLE:
			strcat((char *)systemPayload,"IDLE");
 804f3d2:	f7f0 ff0d 	bl	80401f0 <strlen>
 804f3d6:	4603      	mov	r3, r0
 804f3d8:	1821      	adds	r1, r4, r0
 804f3da:	4acd      	ldr	r2, [pc, #820]	; (804f710 <DiagnosticString+0x380>)
 804f3dc:	6810      	ldr	r0, [r2, #0]
 804f3de:	50e0      	str	r0, [r4, r3]
 804f3e0:	7913      	ldrb	r3, [r2, #4]
 804f3e2:	710b      	strb	r3, [r1, #4]
			strcat((char *)systemPayload,(char * )",");
 804f3e4:	4620      	mov	r0, r4
 804f3e6:	f7f0 ff03 	bl	80401f0 <strlen>
 804f3ea:	4bca      	ldr	r3, [pc, #808]	; (804f714 <DiagnosticString+0x384>)
 804f3ec:	881b      	ldrh	r3, [r3, #0]
 804f3ee:	5223      	strh	r3, [r4, r0]
			break;
 804f3f0:	e01d      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FS");
 804f3f2:	f7f0 fefd 	bl	80401f0 <strlen>
 804f3f6:	1822      	adds	r2, r4, r0
 804f3f8:	4bc7      	ldr	r3, [pc, #796]	; (804f718 <DiagnosticString+0x388>)
 804f3fa:	8819      	ldrh	r1, [r3, #0]
 804f3fc:	789b      	ldrb	r3, [r3, #2]
 804f3fe:	5221      	strh	r1, [r4, r0]
 804f400:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f402:	4620      	mov	r0, r4
 804f404:	f7f0 fef4 	bl	80401f0 <strlen>
 804f408:	4bc2      	ldr	r3, [pc, #776]	; (804f714 <DiagnosticString+0x384>)
 804f40a:	881e      	ldrh	r6, [r3, #0]
 804f40c:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f40e:	2210      	movs	r2, #16
 804f410:	a901      	add	r1, sp, #4
 804f412:	4628      	mov	r0, r5
 804f414:	f001 fc66 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f418:	a901      	add	r1, sp, #4
 804f41a:	4620      	mov	r0, r4
 804f41c:	f001 ff28 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f420:	4620      	mov	r0, r4
 804f422:	f7f0 fee5 	bl	80401f0 <strlen>
 804f426:	5226      	strh	r6, [r4, r0]
			FOTACompleteFlag = TRUE;
 804f428:	4bbc      	ldr	r3, [pc, #752]	; (804f71c <DiagnosticString+0x38c>)
 804f42a:	2201      	movs	r2, #1
 804f42c:	761a      	strb	r2, [r3, #24]
			strcat((char *)systemPayload,"IDLE");
			strcat((char *)systemPayload,(char * )",");
			break;
	}//end of switch(DiagnosticStatus)

}//end of void DiagnosticString(char * systemPayload,enmDiagnosticStatus DiagnosticStatus)
 804f42e:	b007      	add	sp, #28
 804f430:	bdf0      	pop	{r4, r5, r6, r7, pc}
			strcat((char *)systemPayload,"FF");
 804f432:	f7f0 fedd 	bl	80401f0 <strlen>
 804f436:	1822      	adds	r2, r4, r0
 804f438:	4bb9      	ldr	r3, [pc, #740]	; (804f720 <DiagnosticString+0x390>)
 804f43a:	8819      	ldrh	r1, [r3, #0]
 804f43c:	789b      	ldrb	r3, [r3, #2]
 804f43e:	5221      	strh	r1, [r4, r0]
 804f440:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f442:	4620      	mov	r0, r4
 804f444:	f7f0 fed4 	bl	80401f0 <strlen>
 804f448:	4bb2      	ldr	r3, [pc, #712]	; (804f714 <DiagnosticString+0x384>)
 804f44a:	881e      	ldrh	r6, [r3, #0]
 804f44c:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f44e:	2210      	movs	r2, #16
 804f450:	a901      	add	r1, sp, #4
 804f452:	4628      	mov	r0, r5
 804f454:	f001 fc46 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f458:	a901      	add	r1, sp, #4
 804f45a:	4620      	mov	r0, r4
 804f45c:	f001 ff08 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f460:	4620      	mov	r0, r4
 804f462:	f7f0 fec5 	bl	80401f0 <strlen>
 804f466:	5226      	strh	r6, [r4, r0]
			break;
 804f468:	e7e1      	b.n	804f42e <DiagnosticString+0x9e>
		strcat((char *)systemPayload,"FR");
 804f46a:	f7f0 fec1 	bl	80401f0 <strlen>
 804f46e:	1822      	adds	r2, r4, r0
 804f470:	4bac      	ldr	r3, [pc, #688]	; (804f724 <DiagnosticString+0x394>)
 804f472:	8819      	ldrh	r1, [r3, #0]
 804f474:	789b      	ldrb	r3, [r3, #2]
 804f476:	5221      	strh	r1, [r4, r0]
 804f478:	7093      	strb	r3, [r2, #2]
		strcat((char *)systemPayload,(char * )",");
 804f47a:	4620      	mov	r0, r4
 804f47c:	f7f0 feb8 	bl	80401f0 <strlen>
 804f480:	4ba4      	ldr	r3, [pc, #656]	; (804f714 <DiagnosticString+0x384>)
 804f482:	881d      	ldrh	r5, [r3, #0]
 804f484:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char *)gau8FotaURL);
 804f486:	49a8      	ldr	r1, [pc, #672]	; (804f728 <DiagnosticString+0x398>)
 804f488:	4620      	mov	r0, r4
 804f48a:	f001 fef1 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )",");
 804f48e:	4620      	mov	r0, r4
 804f490:	f7f0 feae 	bl	80401f0 <strlen>
 804f494:	5225      	strh	r5, [r4, r0]
			break;
 804f496:	e7ca      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f498:	f7f0 feaa 	bl	80401f0 <strlen>
 804f49c:	1822      	adds	r2, r4, r0
 804f49e:	4ba0      	ldr	r3, [pc, #640]	; (804f720 <DiagnosticString+0x390>)
 804f4a0:	8819      	ldrh	r1, [r3, #0]
 804f4a2:	789b      	ldrb	r3, [r3, #2]
 804f4a4:	5221      	strh	r1, [r4, r0]
 804f4a6:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f4a8:	4620      	mov	r0, r4
 804f4aa:	f7f0 fea1 	bl	80401f0 <strlen>
 804f4ae:	4b99      	ldr	r3, [pc, #612]	; (804f714 <DiagnosticString+0x384>)
 804f4b0:	881f      	ldrh	r7, [r3, #0]
 804f4b2:	5227      	strh	r7, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f4b4:	2210      	movs	r2, #16
 804f4b6:	a901      	add	r1, sp, #4
 804f4b8:	4628      	mov	r0, r5
 804f4ba:	f001 fc13 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f4be:	a901      	add	r1, sp, #4
 804f4c0:	4620      	mov	r0, r4
 804f4c2:	f001 fed5 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f4c6:	4620      	mov	r0, r4
 804f4c8:	f7f0 fe92 	bl	80401f0 <strlen>
 804f4cc:	5227      	strh	r7, [r4, r0]
			strcat((char *)systemPayload,"Input Supply : ");
 804f4ce:	4620      	mov	r0, r4
 804f4d0:	f7f0 fe8e 	bl	80401f0 <strlen>
 804f4d4:	4606      	mov	r6, r0
 804f4d6:	eb04 0c00 	add.w	ip, r4, r0
 804f4da:	4d94      	ldr	r5, [pc, #592]	; (804f72c <DiagnosticString+0x39c>)
 804f4dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804f4de:	51a0      	str	r0, [r4, r6]
 804f4e0:	f8cc 1004 	str.w	r1, [ip, #4]
 804f4e4:	f8cc 2008 	str.w	r2, [ip, #8]
 804f4e8:	f8cc 300c 	str.w	r3, [ip, #12]
			updateInputVoltage();
 804f4ec:	f7ff fb4c 	bl	804eb88 <updateInputVoltage>
			strcat((char *)systemPayload,(char * )gcSystemSupplyVoltage);
 804f4f0:	498f      	ldr	r1, [pc, #572]	; (804f730 <DiagnosticString+0x3a0>)
 804f4f2:	4620      	mov	r0, r4
 804f4f4:	f001 febc 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f4f8:	4620      	mov	r0, r4
 804f4fa:	f7f0 fe79 	bl	80401f0 <strlen>
 804f4fe:	5227      	strh	r7, [r4, r0]
			strcat((char *)systemPayload,"Internal Battery Supply : ");
 804f500:	4620      	mov	r0, r4
 804f502:	f7f0 fe75 	bl	80401f0 <strlen>
 804f506:	4684      	mov	ip, r0
 804f508:	1826      	adds	r6, r4, r0
 804f50a:	4d8a      	ldr	r5, [pc, #552]	; (804f734 <DiagnosticString+0x3a4>)
 804f50c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804f50e:	f844 000c 	str.w	r0, [r4, ip]
 804f512:	6071      	str	r1, [r6, #4]
 804f514:	60b2      	str	r2, [r6, #8]
 804f516:	60f3      	str	r3, [r6, #12]
 804f518:	cd03      	ldmia	r5!, {r0, r1}
 804f51a:	6130      	str	r0, [r6, #16]
 804f51c:	6171      	str	r1, [r6, #20]
 804f51e:	882a      	ldrh	r2, [r5, #0]
 804f520:	78ab      	ldrb	r3, [r5, #2]
 804f522:	8332      	strh	r2, [r6, #24]
 804f524:	76b3      	strb	r3, [r6, #26]
			updateInputVoltage();
 804f526:	f7ff fb2f 	bl	804eb88 <updateInputVoltage>
			strcat((char *)systemPayload,(char * )gcBatterySupplyVoltage);
 804f52a:	4983      	ldr	r1, [pc, #524]	; (804f738 <DiagnosticString+0x3a8>)
 804f52c:	4620      	mov	r0, r4
 804f52e:	f001 fe9f 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f532:	4620      	mov	r0, r4
 804f534:	f7f0 fe5c 	bl	80401f0 <strlen>
 804f538:	5227      	strh	r7, [r4, r0]
			break;
 804f53a:	e778      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f53c:	f7f0 fe58 	bl	80401f0 <strlen>
 804f540:	1822      	adds	r2, r4, r0
 804f542:	4b77      	ldr	r3, [pc, #476]	; (804f720 <DiagnosticString+0x390>)
 804f544:	8819      	ldrh	r1, [r3, #0]
 804f546:	789b      	ldrb	r3, [r3, #2]
 804f548:	5221      	strh	r1, [r4, r0]
 804f54a:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f54c:	4620      	mov	r0, r4
 804f54e:	f7f0 fe4f 	bl	80401f0 <strlen>
 804f552:	4b70      	ldr	r3, [pc, #448]	; (804f714 <DiagnosticString+0x384>)
 804f554:	881b      	ldrh	r3, [r3, #0]
 804f556:	5223      	strh	r3, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f558:	2210      	movs	r2, #16
 804f55a:	a901      	add	r1, sp, #4
 804f55c:	4628      	mov	r0, r5
 804f55e:	f001 fbc1 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f562:	a901      	add	r1, sp, #4
 804f564:	4620      	mov	r0, r4
 804f566:	f001 fe83 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",Received File Size : ");
 804f56a:	4620      	mov	r0, r4
 804f56c:	f7f0 fe40 	bl	80401f0 <strlen>
 804f570:	4607      	mov	r7, r0
 804f572:	1826      	adds	r6, r4, r0
 804f574:	4d71      	ldr	r5, [pc, #452]	; (804f73c <DiagnosticString+0x3ac>)
 804f576:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 804f578:	51e0      	str	r0, [r4, r7]
 804f57a:	6071      	str	r1, [r6, #4]
 804f57c:	60b2      	str	r2, [r6, #8]
 804f57e:	60f3      	str	r3, [r6, #12]
 804f580:	6828      	ldr	r0, [r5, #0]
 804f582:	6130      	str	r0, [r6, #16]
 804f584:	88aa      	ldrh	r2, [r5, #4]
 804f586:	79ab      	ldrb	r3, [r5, #6]
 804f588:	82b2      	strh	r2, [r6, #20]
 804f58a:	75b3      	strb	r3, [r6, #22]
			strcat((char *)systemPayload,(char *)gsmInstance.gu32RemoteConfigSizeinBytes);
 804f58c:	4b6c      	ldr	r3, [pc, #432]	; (804f740 <DiagnosticString+0x3b0>)
 804f58e:	f8d3 1e34 	ldr.w	r1, [r3, #3636]	; 0xe34
 804f592:	4620      	mov	r0, r4
 804f594:	f001 fe6c 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )" Bytes,");
 804f598:	4620      	mov	r0, r4
 804f59a:	f7f0 fe29 	bl	80401f0 <strlen>
 804f59e:	4603      	mov	r3, r0
 804f5a0:	1825      	adds	r5, r4, r0
 804f5a2:	4a68      	ldr	r2, [pc, #416]	; (804f744 <DiagnosticString+0x3b4>)
 804f5a4:	ca03      	ldmia	r2!, {r0, r1}
 804f5a6:	50e0      	str	r0, [r4, r3]
 804f5a8:	6069      	str	r1, [r5, #4]
			break;
 804f5aa:	e740      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f5ac:	f7f0 fe20 	bl	80401f0 <strlen>
 804f5b0:	1822      	adds	r2, r4, r0
 804f5b2:	4b5b      	ldr	r3, [pc, #364]	; (804f720 <DiagnosticString+0x390>)
 804f5b4:	8819      	ldrh	r1, [r3, #0]
 804f5b6:	789b      	ldrb	r3, [r3, #2]
 804f5b8:	5221      	strh	r1, [r4, r0]
 804f5ba:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f5bc:	4620      	mov	r0, r4
 804f5be:	f7f0 fe17 	bl	80401f0 <strlen>
 804f5c2:	4b54      	ldr	r3, [pc, #336]	; (804f714 <DiagnosticString+0x384>)
 804f5c4:	881e      	ldrh	r6, [r3, #0]
 804f5c6:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f5c8:	2210      	movs	r2, #16
 804f5ca:	a901      	add	r1, sp, #4
 804f5cc:	4628      	mov	r0, r5
 804f5ce:	f001 fb89 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f5d2:	a901      	add	r1, sp, #4
 804f5d4:	4620      	mov	r0, r4
 804f5d6:	f001 fe4b 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f5da:	4620      	mov	r0, r4
 804f5dc:	f7f0 fe08 	bl	80401f0 <strlen>
 804f5e0:	5226      	strh	r6, [r4, r0]
			strcat((char *)systemPayload,(char * )gsmInstance.u8LastMqttResponseCode);
 804f5e2:	4b57      	ldr	r3, [pc, #348]	; (804f740 <DiagnosticString+0x3b0>)
 804f5e4:	f8b3 1e22 	ldrh.w	r1, [r3, #3618]	; 0xe22
 804f5e8:	4620      	mov	r0, r4
 804f5ea:	f001 fe41 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f5ee:	4620      	mov	r0, r4
 804f5f0:	f7f0 fdfe 	bl	80401f0 <strlen>
 804f5f4:	5226      	strh	r6, [r4, r0]
			break;
 804f5f6:	e71a      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f5f8:	f7f0 fdfa 	bl	80401f0 <strlen>
 804f5fc:	1822      	adds	r2, r4, r0
 804f5fe:	4b48      	ldr	r3, [pc, #288]	; (804f720 <DiagnosticString+0x390>)
 804f600:	8819      	ldrh	r1, [r3, #0]
 804f602:	789b      	ldrb	r3, [r3, #2]
 804f604:	5221      	strh	r1, [r4, r0]
 804f606:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f608:	4620      	mov	r0, r4
 804f60a:	f7f0 fdf1 	bl	80401f0 <strlen>
 804f60e:	4b41      	ldr	r3, [pc, #260]	; (804f714 <DiagnosticString+0x384>)
 804f610:	881e      	ldrh	r6, [r3, #0]
 804f612:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f614:	2210      	movs	r2, #16
 804f616:	a901      	add	r1, sp, #4
 804f618:	4628      	mov	r0, r5
 804f61a:	f001 fb63 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f61e:	a901      	add	r1, sp, #4
 804f620:	4620      	mov	r0, r4
 804f622:	f001 fe25 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f626:	4620      	mov	r0, r4
 804f628:	f7f0 fde2 	bl	80401f0 <strlen>
 804f62c:	5226      	strh	r6, [r4, r0]
			break;
 804f62e:	e6fe      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f630:	f7f0 fdde 	bl	80401f0 <strlen>
 804f634:	1822      	adds	r2, r4, r0
 804f636:	4b3a      	ldr	r3, [pc, #232]	; (804f720 <DiagnosticString+0x390>)
 804f638:	8819      	ldrh	r1, [r3, #0]
 804f63a:	789b      	ldrb	r3, [r3, #2]
 804f63c:	5221      	strh	r1, [r4, r0]
 804f63e:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f640:	4620      	mov	r0, r4
 804f642:	f7f0 fdd5 	bl	80401f0 <strlen>
 804f646:	4b33      	ldr	r3, [pc, #204]	; (804f714 <DiagnosticString+0x384>)
 804f648:	881e      	ldrh	r6, [r3, #0]
 804f64a:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f64c:	2210      	movs	r2, #16
 804f64e:	a901      	add	r1, sp, #4
 804f650:	4628      	mov	r0, r5
 804f652:	f001 fb47 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f656:	a901      	add	r1, sp, #4
 804f658:	4620      	mov	r0, r4
 804f65a:	f001 fe09 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f65e:	4620      	mov	r0, r4
 804f660:	f7f0 fdc6 	bl	80401f0 <strlen>
 804f664:	5226      	strh	r6, [r4, r0]
			break;
 804f666:	e6e2      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f668:	f7f0 fdc2 	bl	80401f0 <strlen>
 804f66c:	1822      	adds	r2, r4, r0
 804f66e:	4b2c      	ldr	r3, [pc, #176]	; (804f720 <DiagnosticString+0x390>)
 804f670:	8819      	ldrh	r1, [r3, #0]
 804f672:	789b      	ldrb	r3, [r3, #2]
 804f674:	5221      	strh	r1, [r4, r0]
 804f676:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f678:	4620      	mov	r0, r4
 804f67a:	f7f0 fdb9 	bl	80401f0 <strlen>
 804f67e:	4b25      	ldr	r3, [pc, #148]	; (804f714 <DiagnosticString+0x384>)
 804f680:	881e      	ldrh	r6, [r3, #0]
 804f682:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f684:	2210      	movs	r2, #16
 804f686:	a901      	add	r1, sp, #4
 804f688:	4628      	mov	r0, r5
 804f68a:	f001 fb2b 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f68e:	a901      	add	r1, sp, #4
 804f690:	4620      	mov	r0, r4
 804f692:	f001 fded 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f696:	4620      	mov	r0, r4
 804f698:	f7f0 fdaa 	bl	80401f0 <strlen>
 804f69c:	5226      	strh	r6, [r4, r0]
		break;
 804f69e:	e6c6      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f6a0:	f7f0 fda6 	bl	80401f0 <strlen>
 804f6a4:	1822      	adds	r2, r4, r0
 804f6a6:	4b1e      	ldr	r3, [pc, #120]	; (804f720 <DiagnosticString+0x390>)
 804f6a8:	8819      	ldrh	r1, [r3, #0]
 804f6aa:	789b      	ldrb	r3, [r3, #2]
 804f6ac:	5221      	strh	r1, [r4, r0]
 804f6ae:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f6b0:	4620      	mov	r0, r4
 804f6b2:	f7f0 fd9d 	bl	80401f0 <strlen>
 804f6b6:	4b17      	ldr	r3, [pc, #92]	; (804f714 <DiagnosticString+0x384>)
 804f6b8:	881e      	ldrh	r6, [r3, #0]
 804f6ba:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f6bc:	2210      	movs	r2, #16
 804f6be:	a901      	add	r1, sp, #4
 804f6c0:	4628      	mov	r0, r5
 804f6c2:	f001 fb0f 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f6c6:	a901      	add	r1, sp, #4
 804f6c8:	4620      	mov	r0, r4
 804f6ca:	f001 fdd1 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f6ce:	4620      	mov	r0, r4
 804f6d0:	f7f0 fd8e 	bl	80401f0 <strlen>
 804f6d4:	5226      	strh	r6, [r4, r0]
			break;
 804f6d6:	e6aa      	b.n	804f42e <DiagnosticString+0x9e>
			strcat((char *)systemPayload,"FF");
 804f6d8:	f7f0 fd8a 	bl	80401f0 <strlen>
 804f6dc:	1822      	adds	r2, r4, r0
 804f6de:	4b10      	ldr	r3, [pc, #64]	; (804f720 <DiagnosticString+0x390>)
 804f6e0:	8819      	ldrh	r1, [r3, #0]
 804f6e2:	789b      	ldrb	r3, [r3, #2]
 804f6e4:	5221      	strh	r1, [r4, r0]
 804f6e6:	7093      	strb	r3, [r2, #2]
			strcat((char *)systemPayload,(char * )",");
 804f6e8:	4620      	mov	r0, r4
 804f6ea:	f7f0 fd81 	bl	80401f0 <strlen>
 804f6ee:	4b09      	ldr	r3, [pc, #36]	; (804f714 <DiagnosticString+0x384>)
 804f6f0:	881e      	ldrh	r6, [r3, #0]
 804f6f2:	5226      	strh	r6, [r4, r0]
			itoa(DiagnosticStatus,temp,CAN_PAYLOADSTRING_RADIX);
 804f6f4:	2210      	movs	r2, #16
 804f6f6:	a901      	add	r1, sp, #4
 804f6f8:	4628      	mov	r0, r5
 804f6fa:	f001 faf3 	bl	8050ce4 <itoa>
			strcat((char *)systemPayload,temp);
 804f6fe:	a901      	add	r1, sp, #4
 804f700:	4620      	mov	r0, r4
 804f702:	f001 fdb5 	bl	8051270 <strcat>
			strcat((char *)systemPayload,(char * )",");
 804f706:	4620      	mov	r0, r4
 804f708:	f7f0 fd72 	bl	80401f0 <strlen>
 804f70c:	5226      	strh	r6, [r4, r0]
			break;
 804f70e:	e68e      	b.n	804f42e <DiagnosticString+0x9e>
 804f710:	0805a290 	.word	0x0805a290
 804f714:	0805a058 	.word	0x0805a058
 804f718:	0805a238 	.word	0x0805a238
 804f71c:	20004f8c 	.word	0x20004f8c
 804f720:	0805a23c 	.word	0x0805a23c
 804f724:	0805a240 	.word	0x0805a240
 804f728:	2000056c 	.word	0x2000056c
 804f72c:	0805a244 	.word	0x0805a244
 804f730:	2000edd4 	.word	0x2000edd4
 804f734:	0805a254 	.word	0x0805a254
 804f738:	2000edc4 	.word	0x2000edc4
 804f73c:	0805a270 	.word	0x0805a270
 804f740:	2000c61c 	.word	0x2000c61c
 804f744:	0805a288 	.word	0x0805a288
			strcat((char *)systemPayload,"IDLE");
 804f748:	4620      	mov	r0, r4
 804f74a:	f7f0 fd51 	bl	80401f0 <strlen>
 804f74e:	4603      	mov	r3, r0
 804f750:	1821      	adds	r1, r4, r0
 804f752:	4a06      	ldr	r2, [pc, #24]	; (804f76c <DiagnosticString+0x3dc>)
 804f754:	6810      	ldr	r0, [r2, #0]
 804f756:	50e0      	str	r0, [r4, r3]
 804f758:	7913      	ldrb	r3, [r2, #4]
 804f75a:	710b      	strb	r3, [r1, #4]
			strcat((char *)systemPayload,(char * )",");
 804f75c:	4620      	mov	r0, r4
 804f75e:	f7f0 fd47 	bl	80401f0 <strlen>
 804f762:	4b03      	ldr	r3, [pc, #12]	; (804f770 <DiagnosticString+0x3e0>)
 804f764:	881b      	ldrh	r3, [r3, #0]
 804f766:	5223      	strh	r3, [r4, r0]
}//end of void DiagnosticString(char * systemPayload,enmDiagnosticStatus DiagnosticStatus)
 804f768:	e661      	b.n	804f42e <DiagnosticString+0x9e>
 804f76a:	bf00      	nop
 804f76c:	0805a290 	.word	0x0805a290
 804f770:	0805a058 	.word	0x0805a058

0804f774 <getDiagDataString>:
{
 804f774:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804f778:	4680      	mov	r8, r0
	char * systemPayload = malloc(sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804f77a:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 804f77e:	f001 fab3 	bl	8050ce8 <malloc>
	if(systemPayload != NULL)
 804f782:	4604      	mov	r4, r0
 804f784:	2800      	cmp	r0, #0
 804f786:	f000 8090 	beq.w	804f8aa <getDiagDataString+0x136>
		memset(systemPayload,0x00,sizeof(char) * GSM_PAYLOAD_MAX_SIZE);
 804f78a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 804f78e:	2100      	movs	r1, #0
 804f790:	f001 fd18 	bl	80511c4 <memset>
		strcpy((char *)systemPayload,(char * )START_OF_FRAME);
 804f794:	4b46      	ldr	r3, [pc, #280]	; (804f8b0 <getDiagDataString+0x13c>)
 804f796:	881b      	ldrh	r3, [r3, #0]
 804f798:	8023      	strh	r3, [r4, #0]
		strcat((char *)systemPayload,(char * )",");
 804f79a:	4620      	mov	r0, r4
 804f79c:	f7f0 fd28 	bl	80401f0 <strlen>
 804f7a0:	4b44      	ldr	r3, [pc, #272]	; (804f8b4 <getDiagDataString+0x140>)
 804f7a2:	881d      	ldrh	r5, [r3, #0]
 804f7a4:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char * )dinfo);
 804f7a6:	4944      	ldr	r1, [pc, #272]	; (804f8b8 <getDiagDataString+0x144>)
 804f7a8:	4620      	mov	r0, r4
 804f7aa:	f001 fd61 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )",");
 804f7ae:	4620      	mov	r0, r4
 804f7b0:	f7f0 fd1e 	bl	80401f0 <strlen>
 804f7b4:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,"Diagnostic");
 804f7b6:	4620      	mov	r0, r4
 804f7b8:	f7f0 fd1a 	bl	80401f0 <strlen>
 804f7bc:	4602      	mov	r2, r0
 804f7be:	1826      	adds	r6, r4, r0
 804f7c0:	4b3e      	ldr	r3, [pc, #248]	; (804f8bc <getDiagDataString+0x148>)
 804f7c2:	cb03      	ldmia	r3!, {r0, r1}
 804f7c4:	50a0      	str	r0, [r4, r2]
 804f7c6:	6071      	str	r1, [r6, #4]
 804f7c8:	881a      	ldrh	r2, [r3, #0]
 804f7ca:	789b      	ldrb	r3, [r3, #2]
 804f7cc:	8132      	strh	r2, [r6, #8]
 804f7ce:	72b3      	strb	r3, [r6, #10]
		strcat((char *)systemPayload,(char * )",");
 804f7d0:	4620      	mov	r0, r4
 804f7d2:	f7f0 fd0d 	bl	80401f0 <strlen>
 804f7d6:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char * )MODEL_NUMBER);
 804f7d8:	4620      	mov	r0, r4
 804f7da:	f7f0 fd09 	bl	80401f0 <strlen>
 804f7de:	4603      	mov	r3, r0
 804f7e0:	1826      	adds	r6, r4, r0
 804f7e2:	4a37      	ldr	r2, [pc, #220]	; (804f8c0 <getDiagDataString+0x14c>)
 804f7e4:	ca03      	ldmia	r2!, {r0, r1}
 804f7e6:	50e0      	str	r0, [r4, r3]
 804f7e8:	6071      	str	r1, [r6, #4]
		strcat((char *)systemPayload,(char * )",");
 804f7ea:	4620      	mov	r0, r4
 804f7ec:	f7f0 fd00 	bl	80401f0 <strlen>
 804f7f0:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Date);
 804f7f2:	4934      	ldr	r1, [pc, #208]	; (804f8c4 <getDiagDataString+0x150>)
 804f7f4:	4620      	mov	r0, r4
 804f7f6:	f001 fd3b 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804f7fa:	4620      	mov	r0, r4
 804f7fc:	f7f0 fcf8 	bl	80401f0 <strlen>
 804f800:	4b31      	ldr	r3, [pc, #196]	; (804f8c8 <getDiagDataString+0x154>)
 804f802:	881e      	ldrh	r6, [r3, #0]
 804f804:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Month);
 804f806:	4931      	ldr	r1, [pc, #196]	; (804f8cc <getDiagDataString+0x158>)
 804f808:	4620      	mov	r0, r4
 804f80a:	f001 fd31 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )RTC_DATESEPARATOR);
 804f80e:	4620      	mov	r0, r4
 804f810:	f7f0 fcee 	bl	80401f0 <strlen>
 804f814:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Year);
 804f816:	492e      	ldr	r1, [pc, #184]	; (804f8d0 <getDiagDataString+0x15c>)
 804f818:	4620      	mov	r0, r4
 804f81a:	f001 fd29 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )RTC_PARAM_SEPARATOR);
 804f81e:	4620      	mov	r0, r4
 804f820:	f7f0 fce6 	bl	80401f0 <strlen>
 804f824:	4b2b      	ldr	r3, [pc, #172]	; (804f8d4 <getDiagDataString+0x160>)
 804f826:	881b      	ldrh	r3, [r3, #0]
 804f828:	5223      	strh	r3, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Hour);
 804f82a:	492b      	ldr	r1, [pc, #172]	; (804f8d8 <getDiagDataString+0x164>)
 804f82c:	4620      	mov	r0, r4
 804f82e:	f001 fd1f 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804f832:	4620      	mov	r0, r4
 804f834:	f7f0 fcdc 	bl	80401f0 <strlen>
 804f838:	4b28      	ldr	r3, [pc, #160]	; (804f8dc <getDiagDataString+0x168>)
 804f83a:	881e      	ldrh	r6, [r3, #0]
 804f83c:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Minutes);
 804f83e:	4928      	ldr	r1, [pc, #160]	; (804f8e0 <getDiagDataString+0x16c>)
 804f840:	4620      	mov	r0, r4
 804f842:	f001 fd15 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )RTC_TIMESEPARATOR);
 804f846:	4620      	mov	r0, r4
 804f848:	f7f0 fcd2 	bl	80401f0 <strlen>
 804f84c:	5226      	strh	r6, [r4, r0]
		strcat((char *)systemPayload,(char * )gau8Seconds);
 804f84e:	4925      	ldr	r1, [pc, #148]	; (804f8e4 <getDiagDataString+0x170>)
 804f850:	4620      	mov	r0, r4
 804f852:	f001 fd0d 	bl	8051270 <strcat>
		strcat((char *)systemPayload,(char * )PAYLOAD_SEPARATOR);
 804f856:	4620      	mov	r0, r4
 804f858:	f7f0 fcca 	bl	80401f0 <strlen>
 804f85c:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char * )FIRMWARE_VER);
 804f85e:	4620      	mov	r0, r4
 804f860:	f7f0 fcc6 	bl	80401f0 <strlen>
 804f864:	4607      	mov	r7, r0
 804f866:	1826      	adds	r6, r4, r0
 804f868:	4b1f      	ldr	r3, [pc, #124]	; (804f8e8 <getDiagDataString+0x174>)
 804f86a:	cb07      	ldmia	r3!, {r0, r1, r2}
 804f86c:	51e0      	str	r0, [r4, r7]
 804f86e:	6071      	str	r1, [r6, #4]
 804f870:	60b2      	str	r2, [r6, #8]
 804f872:	881a      	ldrh	r2, [r3, #0]
 804f874:	789b      	ldrb	r3, [r3, #2]
 804f876:	81b2      	strh	r2, [r6, #12]
 804f878:	73b3      	strb	r3, [r6, #14]
		strcat((char *)systemPayload,(char * )",");
 804f87a:	4620      	mov	r0, r4
 804f87c:	f7f0 fcb8 	bl	80401f0 <strlen>
 804f880:	5225      	strh	r5, [r4, r0]
		strcat((char *)systemPayload,(char * )BOOT_REGION);
 804f882:	4620      	mov	r0, r4
 804f884:	f7f0 fcb4 	bl	80401f0 <strlen>
 804f888:	4b18      	ldr	r3, [pc, #96]	; (804f8ec <getDiagDataString+0x178>)
 804f88a:	881b      	ldrh	r3, [r3, #0]
 804f88c:	5223      	strh	r3, [r4, r0]
		strcat((char *)systemPayload,(char * )",");
 804f88e:	4620      	mov	r0, r4
 804f890:	f7f0 fcae 	bl	80401f0 <strlen>
 804f894:	5225      	strh	r5, [r4, r0]
		DiagnosticString(systemPayload,DiagnosticStatus);
 804f896:	4641      	mov	r1, r8
 804f898:	4620      	mov	r0, r4
 804f89a:	f7ff fd79 	bl	804f390 <DiagnosticString>
		strcat((char *)systemPayload,(char * )END_OF_FRAME);
 804f89e:	4620      	mov	r0, r4
 804f8a0:	f7f0 fca6 	bl	80401f0 <strlen>
 804f8a4:	4b12      	ldr	r3, [pc, #72]	; (804f8f0 <getDiagDataString+0x17c>)
 804f8a6:	881b      	ldrh	r3, [r3, #0]
 804f8a8:	5223      	strh	r3, [r4, r0]
}
 804f8aa:	4620      	mov	r0, r4
 804f8ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 804f8b0:	0805a198 	.word	0x0805a198
 804f8b4:	0805a058 	.word	0x0805a058
 804f8b8:	20008a60 	.word	0x20008a60
 804f8bc:	08059fb4 	.word	0x08059fb4
 804f8c0:	08059fec 	.word	0x08059fec
 804f8c4:	20003898 	.word	0x20003898
 804f8c8:	0805a1a4 	.word	0x0805a1a4
 804f8cc:	20003890 	.word	0x20003890
 804f8d0:	20003888 	.word	0x20003888
 804f8d4:	0805a038 	.word	0x0805a038
 804f8d8:	200038a0 	.word	0x200038a0
 804f8dc:	0805a0f8 	.word	0x0805a0f8
 804f8e0:	200038a8 	.word	0x200038a8
 804f8e4:	200038b0 	.word	0x200038b0
 804f8e8:	0805a1a8 	.word	0x0805a1a8
 804f8ec:	0805a1fc 	.word	0x0805a1fc
 804f8f0:	0805a1e8 	.word	0x0805a1e8

0804f8f4 <enqueue>:
* <hr>
*
*******************************************************************************/
void enqueue(strctQUEUE * queue,char * data)
{
	if(data != NULL)
 804f8f4:	b1d9      	cbz	r1, 804f92e <enqueue+0x3a>
{
 804f8f6:	b538      	push	{r3, r4, r5, lr}
 804f8f8:	4604      	mov	r4, r0
 804f8fa:	460d      	mov	r5, r1
	{
		if(queue->head == (MAX_QUEUE_SIZE))
 804f8fc:	6803      	ldr	r3, [r0, #0]
 804f8fe:	2b0a      	cmp	r3, #10
 804f900:	d012      	beq.n	804f928 <enqueue+0x34>
		{
			/*Queue Overflow */
			queue->head = 0;
		}
		/* If queue has data overwrite it */
		if(queue->data[queue->head] != NULL)
 804f902:	6823      	ldr	r3, [r4, #0]
 804f904:	3302      	adds	r3, #2
 804f906:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 804f90a:	b130      	cbz	r0, 804f91a <enqueue+0x26>
		{
			free(queue->data[queue->head]);
 804f90c:	f001 f9f4 	bl	8050cf8 <free>
			queue->data[queue->head] = NULL;
 804f910:	6823      	ldr	r3, [r4, #0]
 804f912:	3302      	adds	r3, #2
 804f914:	2200      	movs	r2, #0
 804f916:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
		}
		queue->data[queue->head]= data;
 804f91a:	6823      	ldr	r3, [r4, #0]
 804f91c:	1c9a      	adds	r2, r3, #2
 804f91e:	f844 5022 	str.w	r5, [r4, r2, lsl #2]
		queue->head++;
 804f922:	3301      	adds	r3, #1
 804f924:	6023      	str	r3, [r4, #0]
	else
	{
		/* Log Error */
		//Error_Callback(enmERROR_ENQUEUE);
	}
}
 804f926:	bd38      	pop	{r3, r4, r5, pc}
			queue->head = 0;
 804f928:	2300      	movs	r3, #0
 804f92a:	6003      	str	r3, [r0, #0]
 804f92c:	e7e9      	b.n	804f902 <enqueue+0xe>
 804f92e:	4770      	bx	lr

0804f930 <dequeue>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void dequeue(strctQUEUE * queue)
{
 804f930:	b510      	push	{r4, lr}
 804f932:	4604      	mov	r4, r0
	/* After data is uploaded free the pointer in queue->data */
    if(((queue->tail == 0) && (queue->head == 0)) || (queue->tail == queue->head))
 804f934:	6843      	ldr	r3, [r0, #4]
 804f936:	b90b      	cbnz	r3, 804f93c <dequeue+0xc>
 804f938:	6802      	ldr	r2, [r0, #0]
 804f93a:	b112      	cbz	r2, 804f942 <dequeue+0x12>
 804f93c:	6822      	ldr	r2, [r4, #0]
 804f93e:	4293      	cmp	r3, r2
 804f940:	d100      	bne.n	804f944 <dequeue+0x14>
        free(queue->data[queue->tail]);
        queue->data[queue->tail] = NULL;
        queue->tail++;
        if(queue->tail > (MAX_QUEUE_SIZE-1)) queue->tail=0;
    }
}
 804f942:	bd10      	pop	{r4, pc}
        free(queue->data[queue->tail]);
 804f944:	3302      	adds	r3, #2
 804f946:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 804f94a:	f001 f9d5 	bl	8050cf8 <free>
        queue->data[queue->tail] = NULL;
 804f94e:	6863      	ldr	r3, [r4, #4]
 804f950:	1c9a      	adds	r2, r3, #2
 804f952:	2100      	movs	r1, #0
 804f954:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
        queue->tail++;
 804f958:	3301      	adds	r3, #1
 804f95a:	6063      	str	r3, [r4, #4]
        if(queue->tail > (MAX_QUEUE_SIZE-1)) queue->tail=0;
 804f95c:	2b09      	cmp	r3, #9
 804f95e:	ddf0      	ble.n	804f942 <dequeue+0x12>
 804f960:	6061      	str	r1, [r4, #4]
}
 804f962:	e7ee      	b.n	804f942 <dequeue+0x12>

0804f964 <isQueueEmpty>:
* <hr>
*
*******************************************************************************/
uint32_t isQueueEmpty(strctQUEUE * queue)
{
	return((queue->head) == (queue->tail));
 804f964:	6802      	ldr	r2, [r0, #0]
 804f966:	6840      	ldr	r0, [r0, #4]
}
 804f968:	4282      	cmp	r2, r0
 804f96a:	bf14      	ite	ne
 804f96c:	2000      	movne	r0, #0
 804f96e:	2001      	moveq	r0, #1
 804f970:	4770      	bx	lr
	...

0804f974 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 804f974:	b500      	push	{lr}
 804f976:	b08b      	sub	sp, #44	; 0x2c

  /* USER CODE BEGIN RTC_Init 0 */
	readbackedupRTCCalender();
 804f978:	f000 ffe4 	bl	8050944 <readbackedupRTCCalender>
  /* USER CODE END RTC_Init 0 */

//  RTC_TimeTypeDef sTime = {0};
//  RTC_DateTypeDef sDate = {0};
  RTC_AlarmTypeDef sAlarm = {0};
 804f97c:	2228      	movs	r2, #40	; 0x28
 804f97e:	2100      	movs	r1, #0
 804f980:	4668      	mov	r0, sp
 804f982:	f001 fc1f 	bl	80511c4 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 804f986:	483b      	ldr	r0, [pc, #236]	; (804fa74 <MX_RTC_Init+0x100>)
 804f988:	4b3b      	ldr	r3, [pc, #236]	; (804fa78 <MX_RTC_Init+0x104>)
 804f98a:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 804f98c:	2300      	movs	r3, #0
 804f98e:	6043      	str	r3, [r0, #4]
  hrtc.Init.AsynchPrediv = 31;
 804f990:	221f      	movs	r2, #31
 804f992:	6082      	str	r2, [r0, #8]
  hrtc.Init.SynchPrediv = 1023;
 804f994:	f240 32ff 	movw	r2, #1023	; 0x3ff
 804f998:	60c2      	str	r2, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 804f99a:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 804f99c:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 804f99e:	6183      	str	r3, [r0, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 804f9a0:	f7f4 feed 	bl	804477e <HAL_RTC_Init>
 804f9a4:	2800      	cmp	r0, #0
 804f9a6:	d153      	bne.n	804fa50 <MX_RTC_Init+0xdc>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  STime1.Hours = sTimeStampget_backup.Hours;
 804f9a8:	4b34      	ldr	r3, [pc, #208]	; (804fa7c <MX_RTC_Init+0x108>)
 804f9aa:	781a      	ldrb	r2, [r3, #0]
 804f9ac:	4934      	ldr	r1, [pc, #208]	; (804fa80 <MX_RTC_Init+0x10c>)
 804f9ae:	700a      	strb	r2, [r1, #0]
  STime1.Minutes = sTimeStampget_backup.Minutes;
 804f9b0:	785a      	ldrb	r2, [r3, #1]
 804f9b2:	704a      	strb	r2, [r1, #1]
  STime1.Seconds = sTimeStampget_backup.Seconds;
 804f9b4:	789b      	ldrb	r3, [r3, #2]
 804f9b6:	708b      	strb	r3, [r1, #2]
  STime1.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 804f9b8:	2300      	movs	r3, #0
 804f9ba:	60cb      	str	r3, [r1, #12]
  STime1.StoreOperation = RTC_STOREOPERATION_RESET;
 804f9bc:	610b      	str	r3, [r1, #16]
  if (HAL_RTC_SetTime(&hrtc, &STime1, RTC_FORMAT_BCD) != HAL_OK)
 804f9be:	2201      	movs	r2, #1
 804f9c0:	482c      	ldr	r0, [pc, #176]	; (804fa74 <MX_RTC_Init+0x100>)
 804f9c2:	f7f4 ff49 	bl	8044858 <HAL_RTC_SetTime>
 804f9c6:	2800      	cmp	r0, #0
 804f9c8:	d145      	bne.n	804fa56 <MX_RTC_Init+0xe2>
  {
    Error_Handler();
  }
  SDate1.WeekDay = sTimeStampDateget_backup.WeekDay;
 804f9ca:	4b2e      	ldr	r3, [pc, #184]	; (804fa84 <MX_RTC_Init+0x110>)
 804f9cc:	781a      	ldrb	r2, [r3, #0]
 804f9ce:	492c      	ldr	r1, [pc, #176]	; (804fa80 <MX_RTC_Init+0x10c>)
 804f9d0:	750a      	strb	r2, [r1, #20]
  SDate1.Month = sTimeStampDateget_backup.Month;
 804f9d2:	785a      	ldrb	r2, [r3, #1]
 804f9d4:	754a      	strb	r2, [r1, #21]
  SDate1.Date = sTimeStampDateget_backup.Date;
 804f9d6:	789a      	ldrb	r2, [r3, #2]
 804f9d8:	758a      	strb	r2, [r1, #22]
  SDate1.Year = sTimeStampDateget_backup.Year;
 804f9da:	78db      	ldrb	r3, [r3, #3]
 804f9dc:	75cb      	strb	r3, [r1, #23]

  if (HAL_RTC_SetDate(&hrtc, &SDate1, RTC_FORMAT_BCD) != HAL_OK)
 804f9de:	2201      	movs	r2, #1
 804f9e0:	3114      	adds	r1, #20
 804f9e2:	4824      	ldr	r0, [pc, #144]	; (804fa74 <MX_RTC_Init+0x100>)
 804f9e4:	f7f4 ffb7 	bl	8044956 <HAL_RTC_SetDate>
 804f9e8:	2800      	cmp	r0, #0
 804f9ea:	d137      	bne.n	804fa5c <MX_RTC_Init+0xe8>
  {
    Error_Handler();
  }
  /** Enable the Alarm A
  */
  sAlarm.AlarmTime.Hours = 0x0;
 804f9ec:	2300      	movs	r3, #0
 804f9ee:	f88d 3000 	strb.w	r3, [sp]
  sAlarm.AlarmTime.Minutes = 0x0;
 804f9f2:	f88d 3001 	strb.w	r3, [sp, #1]
  sAlarm.AlarmTime.Seconds = 0x0;
 804f9f6:	f88d 3002 	strb.w	r3, [sp, #2]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 804f9fa:	9301      	str	r3, [sp, #4]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 804f9fc:	9303      	str	r3, [sp, #12]
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 804f9fe:	9304      	str	r3, [sp, #16]
  sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY|RTC_ALARMMASK_HOURS
 804fa00:	4a21      	ldr	r2, [pc, #132]	; (804fa88 <MX_RTC_Init+0x114>)
 804fa02:	9205      	str	r2, [sp, #20]
                              |RTC_ALARMMASK_SECONDS;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 804fa04:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 804fa06:	9307      	str	r3, [sp, #28]
  sAlarm.AlarmDateWeekDay = 0x1;
 804fa08:	2201      	movs	r2, #1
 804fa0a:	f88d 2020 	strb.w	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 804fa0e:	f44f 7380 	mov.w	r3, #256	; 0x100
 804fa12:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 804fa14:	4669      	mov	r1, sp
 804fa16:	4817      	ldr	r0, [pc, #92]	; (804fa74 <MX_RTC_Init+0x100>)
 804fa18:	f7f5 f80a 	bl	8044a30 <HAL_RTC_SetAlarm_IT>
 804fa1c:	bb08      	cbnz	r0, 804fa62 <MX_RTC_Init+0xee>
  {
    Error_Handler();
  }
  /** Enable the Alarm B
  */
  sAlarm.Alarm = RTC_ALARM_B;
 804fa1e:	f44f 7300 	mov.w	r3, #512	; 0x200
 804fa22:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 804fa24:	2201      	movs	r2, #1
 804fa26:	4669      	mov	r1, sp
 804fa28:	4812      	ldr	r0, [pc, #72]	; (804fa74 <MX_RTC_Init+0x100>)
 804fa2a:	f7f5 f801 	bl	8044a30 <HAL_RTC_SetAlarm_IT>
 804fa2e:	b9d8      	cbnz	r0, 804fa68 <MX_RTC_Init+0xf4>
  {
    Error_Handler();
  }
  /** Enable the WakeUp
  */
  __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);
 804fa30:	4810      	ldr	r0, [pc, #64]	; (804fa74 <MX_RTC_Init+0x100>)
 804fa32:	6802      	ldr	r2, [r0, #0]
 804fa34:	68d3      	ldr	r3, [r2, #12]
 804fa36:	b2db      	uxtb	r3, r3
 804fa38:	f463 6390 	orn	r3, r3, #1152	; 0x480
 804fa3c:	60d3      	str	r3, [r2, #12]
  if (HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 2074, RTC_WAKEUPCLOCK_RTCCLK_DIV16) != HAL_OK) // 2074 - 1 Sec
 804fa3e:	2200      	movs	r2, #0
 804fa40:	f640 011a 	movw	r1, #2074	; 0x81a
 804fa44:	f7f5 f914 	bl	8044c70 <HAL_RTCEx_SetWakeUpTimer_IT>
 804fa48:	b988      	cbnz	r0, 804fa6e <MX_RTC_Init+0xfa>
  /* USER CODE BEGIN RTC_Init 2 */
  // 32768 - 15 Sec interrupt at 180 Mhz
//  __HAL_RCC_RTC_ENABLE();
  /* USER CODE END RTC_Init 2 */

}
 804fa4a:	b00b      	add	sp, #44	; 0x2c
 804fa4c:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 804fa50:	f7fd ffd6 	bl	804da00 <Error_Handler>
 804fa54:	e7a8      	b.n	804f9a8 <MX_RTC_Init+0x34>
    Error_Handler();
 804fa56:	f7fd ffd3 	bl	804da00 <Error_Handler>
 804fa5a:	e7b6      	b.n	804f9ca <MX_RTC_Init+0x56>
    Error_Handler();
 804fa5c:	f7fd ffd0 	bl	804da00 <Error_Handler>
 804fa60:	e7c4      	b.n	804f9ec <MX_RTC_Init+0x78>
    Error_Handler();
 804fa62:	f7fd ffcd 	bl	804da00 <Error_Handler>
 804fa66:	e7da      	b.n	804fa1e <MX_RTC_Init+0xaa>
    Error_Handler();
 804fa68:	f7fd ffca 	bl	804da00 <Error_Handler>
 804fa6c:	e7e0      	b.n	804fa30 <MX_RTC_Init+0xbc>
    Error_Handler();
 804fa6e:	f7fd ffc7 	bl	804da00 <Error_Handler>
}
 804fa72:	e7ea      	b.n	804fa4a <MX_RTC_Init+0xd6>
 804fa74:	2000f5b8 	.word	0x2000f5b8
 804fa78:	40002800 	.word	0x40002800
 804fa7c:	20008b5c 	.word	0x20008b5c
 804fa80:	200051dc 	.word	0x200051dc
 804fa84:	20010318 	.word	0x20010318
 804fa88:	80800080 	.word	0x80800080

0804fa8c <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 804fa8c:	b510      	push	{r4, lr}
 804fa8e:	b08c      	sub	sp, #48	; 0x30
 804fa90:	4604      	mov	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 804fa92:	2230      	movs	r2, #48	; 0x30
 804fa94:	2100      	movs	r1, #0
 804fa96:	4668      	mov	r0, sp
 804fa98:	f001 fb94 	bl	80511c4 <memset>
  if(rtcHandle->Instance==RTC)
 804fa9c:	6822      	ldr	r2, [r4, #0]
 804fa9e:	4b12      	ldr	r3, [pc, #72]	; (804fae8 <HAL_RTC_MspInit+0x5c>)
 804faa0:	429a      	cmp	r2, r3
 804faa2:	d001      	beq.n	804faa8 <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 804faa4:	b00c      	add	sp, #48	; 0x30
 804faa6:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 804faa8:	2320      	movs	r3, #32
 804faaa:	9300      	str	r3, [sp, #0]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 804faac:	f44f 7300 	mov.w	r3, #512	; 0x200
 804fab0:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 804fab2:	4668      	mov	r0, sp
 804fab4:	f7f4 fcc8 	bl	8044448 <HAL_RCCEx_PeriphCLKConfig>
 804fab8:	b998      	cbnz	r0, 804fae2 <HAL_RTC_MspInit+0x56>
    __HAL_RCC_RTC_ENABLE();
 804faba:	4b0c      	ldr	r3, [pc, #48]	; (804faec <HAL_RTC_MspInit+0x60>)
 804fabc:	2201      	movs	r2, #1
 804fabe:	601a      	str	r2, [r3, #0]
    HAL_NVIC_SetPriority(RTC_WKUP_IRQn, 0, 0);
 804fac0:	2200      	movs	r2, #0
 804fac2:	4611      	mov	r1, r2
 804fac4:	2003      	movs	r0, #3
 804fac6:	f7f1 ff03 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_WKUP_IRQn);
 804faca:	2003      	movs	r0, #3
 804facc:	f7f1 ff34 	bl	8041938 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 804fad0:	2200      	movs	r2, #0
 804fad2:	4611      	mov	r1, r2
 804fad4:	2029      	movs	r0, #41	; 0x29
 804fad6:	f7f1 fefb 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 804fada:	2029      	movs	r0, #41	; 0x29
 804fadc:	f7f1 ff2c 	bl	8041938 <HAL_NVIC_EnableIRQ>
}
 804fae0:	e7e0      	b.n	804faa4 <HAL_RTC_MspInit+0x18>
      Error_Handler();
 804fae2:	f7fd ff8d 	bl	804da00 <Error_Handler>
 804fae6:	e7e8      	b.n	804faba <HAL_RTC_MspInit+0x2e>
 804fae8:	40002800 	.word	0x40002800
 804faec:	42470e3c 	.word	0x42470e3c

0804faf0 <GSM_CharReception_Callback>:
extern uint32_t gu32GSMCharacterTimeout;
volatile uint32_t u8GSMCharRcv = 0;
uint8_t u8gsmResponse = 0;
extern strctGSM gsmInstance;
void GSM_CharReception_Callback(void)
{
 804faf0:	b410      	push	{r4}
  return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 804faf2:	4b0c      	ldr	r3, [pc, #48]	; (804fb24 <GSM_CharReception_Callback+0x34>)
 804faf4:	685a      	ldr	r2, [r3, #4]
 804faf6:	b2d2      	uxtb	r2, r2
	u8gsmResponse = LL_USART_ReceiveData8(UART4);
 804faf8:	490b      	ldr	r1, [pc, #44]	; (804fb28 <GSM_CharReception_Callback+0x38>)
 804fafa:	700a      	strb	r2, [r1, #0]
	gsmInstance.as8GSM_Response_Buff[gsmInstance.u8GSM_Response_Character_Counter++] = u8gsmResponse;
 804fafc:	4b0b      	ldr	r3, [pc, #44]	; (804fb2c <GSM_CharReception_Callback+0x3c>)
 804fafe:	f8d3 0e3c 	ldr.w	r0, [r3, #3644]	; 0xe3c
 804fb02:	1c44      	adds	r4, r0, #1
 804fb04:	f8c3 4e3c 	str.w	r4, [r3, #3644]	; 0xe3c
 804fb08:	4403      	add	r3, r0
 804fb0a:	f883 2452 	strb.w	r2, [r3, #1106]	; 0x452
	gu32GSMCharacterTimeout = FIVEHUNDRED_MS;
 804fb0e:	4b08      	ldr	r3, [pc, #32]	; (804fb30 <GSM_CharReception_Callback+0x40>)
 804fb10:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 804fb14:	601a      	str	r2, [r3, #0]
	if(u8GSMCharRcv == 0)
 804fb16:	684b      	ldr	r3, [r1, #4]
 804fb18:	b90b      	cbnz	r3, 804fb1e <GSM_CharReception_Callback+0x2e>
		u8GSMCharRcv = 1;
 804fb1a:	2201      	movs	r2, #1
 804fb1c:	604a      	str	r2, [r1, #4]
}
 804fb1e:	f85d 4b04 	ldr.w	r4, [sp], #4
 804fb22:	4770      	bx	lr
 804fb24:	40004c00 	.word	0x40004c00
 804fb28:	200051f4 	.word	0x200051f4
 804fb2c:	2000c61c 	.word	0x2000c61c
 804fb30:	200053d4 	.word	0x200053d4

0804fb34 <MODBUS_CharReception_Callback>:
 804fb34:	4b14      	ldr	r3, [pc, #80]	; (804fb88 <MODBUS_CharReception_Callback+0x54>)
 804fb36:	685b      	ldr	r3, [r3, #4]
 804fb38:	b2db      	uxtb	r3, r3
uint8_t u8TestArrayCounter = 0;
volatile uint8_t gu8ModbusInterruptFlag = 0;
void MODBUS_CharReception_Callback(void)
{

	u8receivedChar =LL_USART_ReceiveData8(USART3);
 804fb3a:	4a14      	ldr	r2, [pc, #80]	; (804fb8c <MODBUS_CharReception_Callback+0x58>)
 804fb3c:	7013      	strb	r3, [r2, #0]
//
//	 if(u8TestArrayCounter == 25)
//	 {
//		 u8TestArrayCounter = 0;
//	 }
	if(gu8MBResponseFlag == 0)
 804fb3e:	4b14      	ldr	r3, [pc, #80]	; (804fb90 <MODBUS_CharReception_Callback+0x5c>)
 804fb40:	781b      	ldrb	r3, [r3, #0]
 804fb42:	b983      	cbnz	r3, 804fb66 <MODBUS_CharReception_Callback+0x32>
	{
		if(master.u8MBSlave_Address == u8receivedChar)
 804fb44:	4b13      	ldr	r3, [pc, #76]	; (804fb94 <MODBUS_CharReception_Callback+0x60>)
 804fb46:	781a      	ldrb	r2, [r3, #0]
 804fb48:	4b10      	ldr	r3, [pc, #64]	; (804fb8c <MODBUS_CharReception_Callback+0x58>)
 804fb4a:	781b      	ldrb	r3, [r3, #0]
 804fb4c:	b2db      	uxtb	r3, r3
 804fb4e:	429a      	cmp	r2, r3
 804fb50:	d119      	bne.n	804fb86 <MODBUS_CharReception_Callback+0x52>
		{
			/* Response from slave is received */
			gu8MBResponseFlag = 1;
 804fb52:	2301      	movs	r3, #1
 804fb54:	4a0e      	ldr	r2, [pc, #56]	; (804fb90 <MODBUS_CharReception_Callback+0x5c>)
 804fb56:	7013      	strb	r3, [r2, #0]
			gu32ModbusFrameEndTimer = gu32Modbus485ResponseTime;//ONE_SEC;//TWO_SEC;
 804fb58:	4a0f      	ldr	r2, [pc, #60]	; (804fb98 <MODBUS_CharReception_Callback+0x64>)
 804fb5a:	6811      	ldr	r1, [r2, #0]
 804fb5c:	4a0f      	ldr	r2, [pc, #60]	; (804fb9c <MODBUS_CharReception_Callback+0x68>)
 804fb5e:	6011      	str	r1, [r2, #0]
			gu32MBRTUClientConnectedFlag = 1;
 804fb60:	4a0f      	ldr	r2, [pc, #60]	; (804fba0 <MODBUS_CharReception_Callback+0x6c>)
 804fb62:	6013      	str	r3, [r2, #0]
 804fb64:	4770      	bx	lr
		}
	}
	else
	{
		master.u8SlaveResponseArray[master.u8MBResponseCharacterCounter++] = u8receivedChar;
 804fb66:	4b09      	ldr	r3, [pc, #36]	; (804fb8c <MODBUS_CharReception_Callback+0x58>)
 804fb68:	7819      	ldrb	r1, [r3, #0]
 804fb6a:	4b0a      	ldr	r3, [pc, #40]	; (804fb94 <MODBUS_CharReception_Callback+0x60>)
 804fb6c:	f893 2520 	ldrb.w	r2, [r3, #1312]	; 0x520
 804fb70:	1c50      	adds	r0, r2, #1
 804fb72:	f883 0520 	strb.w	r0, [r3, #1312]	; 0x520
 804fb76:	3202      	adds	r2, #2
 804fb78:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 804fb7c:	6059      	str	r1, [r3, #4]
		gu32ModbusFrameEndTimer = gu32Modbus485ResponseTime;//ONE_SEC;//TWO_SEC;
 804fb7e:	4b06      	ldr	r3, [pc, #24]	; (804fb98 <MODBUS_CharReception_Callback+0x64>)
 804fb80:	681a      	ldr	r2, [r3, #0]
 804fb82:	4b06      	ldr	r3, [pc, #24]	; (804fb9c <MODBUS_CharReception_Callback+0x68>)
 804fb84:	601a      	str	r2, [r3, #0]
	}
}
 804fb86:	4770      	bx	lr
 804fb88:	40004800 	.word	0x40004800
 804fb8c:	2000f5f6 	.word	0x2000f5f6
 804fb90:	2000459a 	.word	0x2000459a
 804fb94:	2000d868 	.word	0x2000d868
 804fb98:	20003858 	.word	0x20003858
 804fb9c:	200045a4 	.word	0x200045a4
 804fba0:	200045ac 	.word	0x200045ac

0804fba4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 804fba4:	b510      	push	{r4, lr}
 804fba6:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 804fba8:	2400      	movs	r4, #0
 804fbaa:	9400      	str	r4, [sp, #0]
 804fbac:	4b12      	ldr	r3, [pc, #72]	; (804fbf8 <HAL_MspInit+0x54>)
 804fbae:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804fbb0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 804fbb4:	645a      	str	r2, [r3, #68]	; 0x44
 804fbb6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 804fbb8:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 804fbbc:	9200      	str	r2, [sp, #0]
 804fbbe:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 804fbc0:	9401      	str	r4, [sp, #4]
 804fbc2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804fbc4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 804fbc8:	641a      	str	r2, [r3, #64]	; 0x40
 804fbca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804fbcc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 804fbd0:	9301      	str	r3, [sp, #4]
 804fbd2:	9b01      	ldr	r3, [sp, #4]

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* FLASH_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(FLASH_IRQn, 1, 0);
 804fbd4:	4622      	mov	r2, r4
 804fbd6:	2101      	movs	r1, #1
 804fbd8:	2004      	movs	r0, #4
 804fbda:	f7f1 fe79 	bl	80418d0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(FLASH_IRQn);
 804fbde:	2004      	movs	r0, #4
 804fbe0:	f7f1 feaa 	bl	8041938 <HAL_NVIC_EnableIRQ>
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 1, 0);
 804fbe4:	4622      	mov	r2, r4
 804fbe6:	2101      	movs	r1, #1
 804fbe8:	2005      	movs	r0, #5
 804fbea:	f7f1 fe71 	bl	80418d0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 804fbee:	2005      	movs	r0, #5
 804fbf0:	f7f1 fea2 	bl	8041938 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 804fbf4:	b002      	add	sp, #8
 804fbf6:	bd10      	pop	{r4, pc}
 804fbf8:	40023800 	.word	0x40023800

0804fbfc <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 804fbfc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  HAL_RCC_NMI_IRQHandler();
 804fbfe:	f7f4 fc11 	bl	8044424 <HAL_RCC_NMI_IRQHandler>
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 804fc02:	bd08      	pop	{r3, pc}

0804fc04 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 804fc04:	e7fe      	b.n	804fc04 <HardFault_Handler>

0804fc06 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 804fc06:	e7fe      	b.n	804fc06 <MemManage_Handler>

0804fc08 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 804fc08:	e7fe      	b.n	804fc08 <BusFault_Handler>

0804fc0a <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 804fc0a:	e7fe      	b.n	804fc0a <UsageFault_Handler>

0804fc0c <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 804fc0c:	4770      	bx	lr

0804fc0e <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 804fc0e:	4770      	bx	lr

0804fc10 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 804fc10:	4770      	bx	lr

0804fc12 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 804fc12:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 804fc14:	f7f1 fa38 	bl	8041088 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 804fc18:	bd08      	pop	{r3, pc}
	...

0804fc1c <RTC_WKUP_IRQHandler>:

/**
  * @brief This function handles RTC wake-up interrupt through EXTI line 22.
  */
void RTC_WKUP_IRQHandler(void)
{
 804fc1c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN RTC_WKUP_IRQn 0 */

  /* USER CODE END RTC_WKUP_IRQn 0 */
  HAL_RTCEx_WakeUpTimerIRQHandler(&hrtc);
 804fc1e:	4802      	ldr	r0, [pc, #8]	; (804fc28 <RTC_WKUP_IRQHandler+0xc>)
 804fc20:	f7f5 f8ae 	bl	8044d80 <HAL_RTCEx_WakeUpTimerIRQHandler>
  /* USER CODE BEGIN RTC_WKUP_IRQn 1 */

  /* USER CODE END RTC_WKUP_IRQn 1 */
}
 804fc24:	bd08      	pop	{r3, pc}
 804fc26:	bf00      	nop
 804fc28:	2000f5b8 	.word	0x2000f5b8

0804fc2c <FLASH_IRQHandler>:

/**
  * @brief This function handles Flash global interrupt.
  */
void FLASH_IRQHandler(void)
{
 804fc2c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN FLASH_IRQn 0 */

  /* USER CODE END FLASH_IRQn 0 */
  HAL_FLASH_IRQHandler();
 804fc2e:	f7f2 fd87 	bl	8042740 <HAL_FLASH_IRQHandler>
  /* USER CODE BEGIN FLASH_IRQn 1 */

  /* USER CODE END FLASH_IRQn 1 */
}
 804fc32:	bd08      	pop	{r3, pc}

0804fc34 <RCC_IRQHandler>:

  /* USER CODE END RCC_IRQn 0 */
  /* USER CODE BEGIN RCC_IRQn 1 */

  /* USER CODE END RCC_IRQn 1 */
}
 804fc34:	4770      	bx	lr
	...

0804fc38 <ADC_IRQHandler>:

/**
  * @brief This function handles ADC1, ADC2 and ADC3 global interrupts.
  */
void ADC_IRQHandler(void)
{
 804fc38:	b508      	push	{r3, lr}
  /* USER CODE BEGIN ADC_IRQn 0 */

  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 804fc3a:	4802      	ldr	r0, [pc, #8]	; (804fc44 <ADC_IRQHandler+0xc>)
 804fc3c:	f7f1 fc76 	bl	804152c <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC_IRQn 1 */

  /* USER CODE END ADC_IRQn 1 */
}
 804fc40:	bd08      	pop	{r3, pc}
 804fc42:	bf00      	nop
 804fc44:	200089b8 	.word	0x200089b8

0804fc48 <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
 804fc48:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
 804fc4a:	4802      	ldr	r0, [pc, #8]	; (804fc54 <I2C1_EV_IRQHandler+0xc>)
 804fc4c:	f7f3 ff2a 	bl	8043aa4 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
 804fc50:	bd08      	pop	{r3, pc}
 804fc52:	bf00      	nop
 804fc54:	2000d7c0 	.word	0x2000d7c0

0804fc58 <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
 804fc58:	b508      	push	{r3, lr}
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
 804fc5a:	4802      	ldr	r0, [pc, #8]	; (804fc64 <I2C1_ER_IRQHandler+0xc>)
 804fc5c:	f7f3 ffe8 	bl	8043c30 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
 804fc60:	bd08      	pop	{r3, pc}
 804fc62:	bf00      	nop
 804fc64:	2000d7c0 	.word	0x2000d7c0

0804fc68 <USART3_IRQHandler>:

/**
  * @brief This function handles USART3 global interrupt.
  */
void USART3_IRQHandler(void)
{
 804fc68:	b510      	push	{r4, lr}
  return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 804fc6a:	4b24      	ldr	r3, [pc, #144]	; (804fcfc <USART3_IRQHandler+0x94>)
 804fc6c:	681b      	ldr	r3, [r3, #0]
  /* USER CODE BEGIN USART3_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(USART3)!=RESET)
 804fc6e:	f013 0f20 	tst.w	r3, #32
 804fc72:	d114      	bne.n	804fc9e <USART3_IRQHandler+0x36>
  return (READ_BIT(USARTx->SR, USART_SR_TC) == (USART_SR_TC));
 804fc74:	4b21      	ldr	r3, [pc, #132]	; (804fcfc <USART3_IRQHandler+0x94>)
 804fc76:	681b      	ldr	r3, [r3, #0]
	{
	/* RXNE flag will be cleared by reading of RDR register (done in call) */
	/* Call function in charge of handling Character reception */
		MODBUS_CharReception_Callback();
	}
	else if(LL_USART_IsActiveFlag_TC(USART3)!=RESET)
 804fc78:	f013 0f40 	tst.w	r3, #64	; 0x40
 804fc7c:	d011      	beq.n	804fca2 <USART3_IRQHandler+0x3a>
	{
		if(u8MBQueryCharacterCounter <= 7)
 804fc7e:	4b20      	ldr	r3, [pc, #128]	; (804fd00 <USART3_IRQHandler+0x98>)
 804fc80:	781b      	ldrb	r3, [r3, #0]
 804fc82:	b2db      	uxtb	r3, r3
 804fc84:	2b07      	cmp	r3, #7
 804fc86:	d80d      	bhi.n	804fca4 <USART3_IRQHandler+0x3c>
		{
			LL_USART_TransmitData8(USART3,master.u8QueryFrame[u8MBQueryCharacterCounter++]);
 804fc88:	4b1d      	ldr	r3, [pc, #116]	; (804fd00 <USART3_IRQHandler+0x98>)
 804fc8a:	7819      	ldrb	r1, [r3, #0]
 804fc8c:	1c4a      	adds	r2, r1, #1
 804fc8e:	b2d2      	uxtb	r2, r2
 804fc90:	701a      	strb	r2, [r3, #0]
 804fc92:	4b1c      	ldr	r3, [pc, #112]	; (804fd04 <USART3_IRQHandler+0x9c>)
 804fc94:	440b      	add	r3, r1
 804fc96:	785a      	ldrb	r2, [r3, #1]
  USARTx->DR = Value;
 804fc98:	4b18      	ldr	r3, [pc, #96]	; (804fcfc <USART3_IRQHandler+0x94>)
 804fc9a:	605a      	str	r2, [r3, #4]
}
 804fc9c:	e001      	b.n	804fca2 <USART3_IRQHandler+0x3a>
		MODBUS_CharReception_Callback();
 804fc9e:	f7ff ff49 	bl	804fb34 <MODBUS_CharReception_Callback>
	}
  /* USER CODE END USART3_IRQn 0 */
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
 804fca2:	bd10      	pop	{r4, pc}
			HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_RE_Pin,GPIO_PIN_RESET);
 804fca4:	4c18      	ldr	r4, [pc, #96]	; (804fd08 <USART3_IRQHandler+0xa0>)
 804fca6:	2200      	movs	r2, #0
 804fca8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 804fcac:	4620      	mov	r0, r4
 804fcae:	f7f3 f815 	bl	8042cdc <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(MB_RE_GPIO_Port,MB_DE_Pin,GPIO_PIN_RESET);
 804fcb2:	2200      	movs	r2, #0
 804fcb4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 804fcb8:	4620      	mov	r0, r4
 804fcba:	f7f3 f80f 	bl	8042cdc <HAL_GPIO_WritePin>
			u8MBQueryCharacterCounter = 0;
 804fcbe:	2200      	movs	r2, #0
 804fcc0:	4b0f      	ldr	r3, [pc, #60]	; (804fd00 <USART3_IRQHandler+0x98>)
 804fcc2:	701a      	strb	r2, [r3, #0]
			master.u8MBResponseCharacterCounter = 0;
 804fcc4:	4b0f      	ldr	r3, [pc, #60]	; (804fd04 <USART3_IRQHandler+0x9c>)
 804fcc6:	f883 2520 	strb.w	r2, [r3, #1312]	; 0x520
			modbusState = enmMODBBUS_AWAIT_RESPONSE;
 804fcca:	4a10      	ldr	r2, [pc, #64]	; (804fd0c <USART3_IRQHandler+0xa4>)
 804fccc:	2102      	movs	r1, #2
 804fcce:	7011      	strb	r1, [r2, #0]
			gu32ModbusResponseTimeout = FOUR_SEC;
 804fcd0:	4a0f      	ldr	r2, [pc, #60]	; (804fd10 <USART3_IRQHandler+0xa8>)
 804fcd2:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 804fcd6:	6011      	str	r1, [r2, #0]
			gu8MBFrameTransmittedFlag = 1;
 804fcd8:	4a0e      	ldr	r2, [pc, #56]	; (804fd14 <USART3_IRQHandler+0xac>)
 804fcda:	2101      	movs	r1, #1
 804fcdc:	7011      	strb	r1, [r2, #0]
			master.u32PollDelay = ONE_SEC;
 804fcde:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 804fce2:	f8c3 2e4c 	str.w	r2, [r3, #3660]	; 0xe4c
  CLEAR_BIT(USARTx->CR1, USART_CR1_TCIE);
 804fce6:	4b05      	ldr	r3, [pc, #20]	; (804fcfc <USART3_IRQHandler+0x94>)
 804fce8:	68da      	ldr	r2, [r3, #12]
 804fcea:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 804fcee:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE);
 804fcf0:	68da      	ldr	r2, [r3, #12]
 804fcf2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 804fcf6:	60da      	str	r2, [r3, #12]
}
 804fcf8:	e7d3      	b.n	804fca2 <USART3_IRQHandler+0x3a>
 804fcfa:	bf00      	nop
 804fcfc:	40004800 	.word	0x40004800
 804fd00:	200045a0 	.word	0x200045a0
 804fd04:	2000d868 	.word	0x2000d868
 804fd08:	40021000 	.word	0x40021000
 804fd0c:	20004599 	.word	0x20004599
 804fd10:	200045a8 	.word	0x200045a8
 804fd14:	20004a6c 	.word	0x20004a6c

0804fd18 <RTC_Alarm_IRQHandler>:

/**
  * @brief This function handles RTC alarms A and B interrupt through EXTI line 17.
  */
void RTC_Alarm_IRQHandler(void)
{
 804fd18:	b508      	push	{r3, lr}
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 804fd1a:	4802      	ldr	r0, [pc, #8]	; (804fd24 <RTC_Alarm_IRQHandler+0xc>)
 804fd1c:	f7f4 fcc8 	bl	80446b0 <HAL_RTC_AlarmIRQHandler>
  /* USER CODE BEGIN RTC_Alarm_IRQn 1 */

  /* USER CODE END RTC_Alarm_IRQn 1 */
}
 804fd20:	bd08      	pop	{r3, pc}
 804fd22:	bf00      	nop
 804fd24:	2000f5b8 	.word	0x2000f5b8

0804fd28 <UART4_IRQHandler>:

/**
  * @brief This function handles UART4 global interrupt.
  */
void UART4_IRQHandler(void)
{
 804fd28:	b508      	push	{r3, lr}
  return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 804fd2a:	4b04      	ldr	r3, [pc, #16]	; (804fd3c <UART4_IRQHandler+0x14>)
 804fd2c:	681b      	ldr	r3, [r3, #0]
  /* USER CODE BEGIN UART4_IRQn 0 */
	if(LL_USART_IsActiveFlag_RXNE(UART4)!=RESET)
 804fd2e:	f013 0f20 	tst.w	r3, #32
 804fd32:	d100      	bne.n	804fd36 <UART4_IRQHandler+0xe>
	}
  /* USER CODE END UART4_IRQn 0 */
  /* USER CODE BEGIN UART4_IRQn 1 */

  /* USER CODE END UART4_IRQn 1 */
}
 804fd34:	bd08      	pop	{r3, pc}
		GSM_CharReception_Callback();
 804fd36:	f7ff fedb 	bl	804faf0 <GSM_CharReception_Callback>
}
 804fd3a:	e7fb      	b.n	804fd34 <UART4_IRQHandler+0xc>
 804fd3c:	40004c00 	.word	0x40004c00

0804fd40 <TIM7_IRQHandler>:

/**
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
 804fd40:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
 804fd42:	4802      	ldr	r0, [pc, #8]	; (804fd4c <TIM7_IRQHandler+0xc>)
 804fd44:	f7f5 f855 	bl	8044df2 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM7_IRQn 1 */

  /* USER CODE END TIM7_IRQn 1 */
}
 804fd48:	bd08      	pop	{r3, pc}
 804fd4a:	bf00      	nop
 804fd4c:	2000f5f8 	.word	0x2000f5f8

0804fd50 <DMA2_Stream4_IRQHandler>:

/**
  * @brief This function handles DMA2 stream4 global interrupt.
  */
void DMA2_Stream4_IRQHandler(void)
{
 804fd50:	b508      	push	{r3, lr}
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 804fd52:	4802      	ldr	r0, [pc, #8]	; (804fd5c <DMA2_Stream4_IRQHandler+0xc>)
 804fd54:	f7f1 ff48 	bl	8041be8 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream4_IRQn 1 */

  /* USER CODE END DMA2_Stream4_IRQn 1 */
}
 804fd58:	bd08      	pop	{r3, pc}
 804fd5a:	bf00      	nop
 804fd5c:	20008a00 	.word	0x20008a00

0804fd60 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 804fd60:	2001      	movs	r0, #1
 804fd62:	4770      	bx	lr

0804fd64 <_kill>:

int _kill(int pid, int sig)
{
	errno = EINVAL;
 804fd64:	4b02      	ldr	r3, [pc, #8]	; (804fd70 <_kill+0xc>)
 804fd66:	2216      	movs	r2, #22
 804fd68:	601a      	str	r2, [r3, #0]
	return -1;
}
 804fd6a:	f04f 30ff 	mov.w	r0, #4294967295
 804fd6e:	4770      	bx	lr
 804fd70:	20010330 	.word	0x20010330

0804fd74 <_exit>:

void _exit (int status)
{
 804fd74:	b508      	push	{r3, lr}
	_kill(status, -1);
 804fd76:	f04f 31ff 	mov.w	r1, #4294967295
 804fd7a:	f7ff fff3 	bl	804fd64 <_kill>
	while (1) {}		/* Make sure we hang here */
 804fd7e:	e7fe      	b.n	804fd7e <_exit+0xa>

0804fd80 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 804fd80:	b570      	push	{r4, r5, r6, lr}
 804fd82:	460c      	mov	r4, r1
 804fd84:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 804fd86:	2500      	movs	r5, #0
 804fd88:	42b5      	cmp	r5, r6
 804fd8a:	da07      	bge.n	804fd9c <_read+0x1c>
	{
		*ptr++ = __io_getchar();
 804fd8c:	f3af 8000 	nop.w
 804fd90:	4621      	mov	r1, r4
 804fd92:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 804fd96:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 804fd98:	460c      	mov	r4, r1
 804fd9a:	e7f5      	b.n	804fd88 <_read+0x8>
	}

return len;
}
 804fd9c:	4630      	mov	r0, r6
 804fd9e:	bd70      	pop	{r4, r5, r6, pc}

0804fda0 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 804fda0:	b570      	push	{r4, r5, r6, lr}
 804fda2:	460c      	mov	r4, r1
 804fda4:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 804fda6:	2500      	movs	r5, #0
 804fda8:	42b5      	cmp	r5, r6
 804fdaa:	da05      	bge.n	804fdb8 <_write+0x18>
	{
		__io_putchar(*ptr++);
 804fdac:	f814 0b01 	ldrb.w	r0, [r4], #1
 804fdb0:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 804fdb4:	3501      	adds	r5, #1
 804fdb6:	e7f7      	b.n	804fda8 <_write+0x8>
	}
	return len;
}
 804fdb8:	4630      	mov	r0, r6
 804fdba:	bd70      	pop	{r4, r5, r6, pc}

0804fdbc <_sbrk>:

caddr_t _sbrk(int incr)
{
 804fdbc:	4603      	mov	r3, r0
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 804fdbe:	4a0b      	ldr	r2, [pc, #44]	; (804fdec <_sbrk+0x30>)
 804fdc0:	6812      	ldr	r2, [r2, #0]
 804fdc2:	b142      	cbz	r2, 804fdd6 <_sbrk+0x1a>
		heap_end = &end;

	prev_heap_end = heap_end;
 804fdc4:	4a09      	ldr	r2, [pc, #36]	; (804fdec <_sbrk+0x30>)
 804fdc6:	6810      	ldr	r0, [r2, #0]
	if (heap_end + incr > stack_ptr)
 804fdc8:	4403      	add	r3, r0
 804fdca:	466a      	mov	r2, sp
 804fdcc:	4293      	cmp	r3, r2
 804fdce:	d806      	bhi.n	804fdde <_sbrk+0x22>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 804fdd0:	4a06      	ldr	r2, [pc, #24]	; (804fdec <_sbrk+0x30>)
 804fdd2:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 804fdd4:	4770      	bx	lr
		heap_end = &end;
 804fdd6:	4a05      	ldr	r2, [pc, #20]	; (804fdec <_sbrk+0x30>)
 804fdd8:	4905      	ldr	r1, [pc, #20]	; (804fdf0 <_sbrk+0x34>)
 804fdda:	6011      	str	r1, [r2, #0]
 804fddc:	e7f2      	b.n	804fdc4 <_sbrk+0x8>
		errno = ENOMEM;
 804fdde:	4b05      	ldr	r3, [pc, #20]	; (804fdf4 <_sbrk+0x38>)
 804fde0:	220c      	movs	r2, #12
 804fde2:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 804fde4:	f04f 30ff 	mov.w	r0, #4294967295
 804fde8:	4770      	bx	lr
 804fdea:	bf00      	nop
 804fdec:	20005208 	.word	0x20005208
 804fdf0:	20010340 	.word	0x20010340
 804fdf4:	20010330 	.word	0x20010330

0804fdf8 <_close>:

int _close(int file)
{
	return -1;
}
 804fdf8:	f04f 30ff 	mov.w	r0, #4294967295
 804fdfc:	4770      	bx	lr

0804fdfe <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 804fdfe:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 804fe02:	604b      	str	r3, [r1, #4]
	return 0;
}
 804fe04:	2000      	movs	r0, #0
 804fe06:	4770      	bx	lr

0804fe08 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 804fe08:	2001      	movs	r0, #1
 804fe0a:	4770      	bx	lr

0804fe0c <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 804fe0c:	2000      	movs	r0, #0
 804fe0e:	4770      	bx	lr

0804fe10 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 804fe10:	490e      	ldr	r1, [pc, #56]	; (804fe4c <SystemInit+0x3c>)
 804fe12:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 804fe16:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 804fe1a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 804fe1e:	4b0c      	ldr	r3, [pc, #48]	; (804fe50 <SystemInit+0x40>)
 804fe20:	681a      	ldr	r2, [r3, #0]
 804fe22:	f042 0201 	orr.w	r2, r2, #1
 804fe26:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 804fe28:	2000      	movs	r0, #0
 804fe2a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 804fe2c:	681a      	ldr	r2, [r3, #0]
 804fe2e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 804fe32:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 804fe36:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 804fe38:	4a06      	ldr	r2, [pc, #24]	; (804fe54 <SystemInit+0x44>)
 804fe3a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 804fe3c:	681a      	ldr	r2, [r3, #0]
 804fe3e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 804fe42:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 804fe44:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 804fe46:	4b04      	ldr	r3, [pc, #16]	; (804fe58 <SystemInit+0x48>)
 804fe48:	608b      	str	r3, [r1, #8]
#endif
}
 804fe4a:	4770      	bx	lr
 804fe4c:	e000ed00 	.word	0xe000ed00
 804fe50:	40023800 	.word	0x40023800
 804fe54:	24003010 	.word	0x24003010
 804fe58:	08040000 	.word	0x08040000

0804fe5c <MX_TIM7_Init>:

TIM_HandleTypeDef htim7;

/* TIM7 init function */
void MX_TIM7_Init(void)
{
 804fe5c:	b500      	push	{lr}
 804fe5e:	b083      	sub	sp, #12
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 804fe60:	2300      	movs	r3, #0
 804fe62:	9300      	str	r3, [sp, #0]
 804fe64:	9301      	str	r3, [sp, #4]

  htim7.Instance = TIM7;
 804fe66:	480f      	ldr	r0, [pc, #60]	; (804fea4 <MX_TIM7_Init+0x48>)
 804fe68:	4a0f      	ldr	r2, [pc, #60]	; (804fea8 <MX_TIM7_Init+0x4c>)
 804fe6a:	6002      	str	r2, [r0, #0]
  htim7.Init.Prescaler = 1;
 804fe6c:	2201      	movs	r2, #1
 804fe6e:	6042      	str	r2, [r0, #4]
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 804fe70:	6083      	str	r3, [r0, #8]
  htim7.Init.Period = 41999;
 804fe72:	f24a 420f 	movw	r2, #41999	; 0xa40f
 804fe76:	60c2      	str	r2, [r0, #12]
  htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 804fe78:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
 804fe7a:	f7f5 f8db 	bl	8045034 <HAL_TIM_Base_Init>
 804fe7e:	b950      	cbnz	r0, 804fe96 <MX_TIM7_Init+0x3a>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 804fe80:	2300      	movs	r3, #0
 804fe82:	9300      	str	r3, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 804fe84:	9301      	str	r3, [sp, #4]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
 804fe86:	4669      	mov	r1, sp
 804fe88:	4806      	ldr	r0, [pc, #24]	; (804fea4 <MX_TIM7_Init+0x48>)
 804fe8a:	f7f5 f8ed 	bl	8045068 <HAL_TIMEx_MasterConfigSynchronization>
 804fe8e:	b928      	cbnz	r0, 804fe9c <MX_TIM7_Init+0x40>
  {
    Error_Handler();
  }

}
 804fe90:	b003      	add	sp, #12
 804fe92:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 804fe96:	f7fd fdb3 	bl	804da00 <Error_Handler>
 804fe9a:	e7f1      	b.n	804fe80 <MX_TIM7_Init+0x24>
    Error_Handler();
 804fe9c:	f7fd fdb0 	bl	804da00 <Error_Handler>
}
 804fea0:	e7f6      	b.n	804fe90 <MX_TIM7_Init+0x34>
 804fea2:	bf00      	nop
 804fea4:	2000f5f8 	.word	0x2000f5f8
 804fea8:	40001400 	.word	0x40001400

0804feac <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM7)
 804feac:	6802      	ldr	r2, [r0, #0]
 804feae:	4b0e      	ldr	r3, [pc, #56]	; (804fee8 <HAL_TIM_Base_MspInit+0x3c>)
 804feb0:	429a      	cmp	r2, r3
 804feb2:	d000      	beq.n	804feb6 <HAL_TIM_Base_MspInit+0xa>
 804feb4:	4770      	bx	lr
{
 804feb6:	b500      	push	{lr}
 804feb8:	b083      	sub	sp, #12
  {
  /* USER CODE BEGIN TIM7_MspInit 0 */

  /* USER CODE END TIM7_MspInit 0 */
    /* TIM7 clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
 804feba:	2200      	movs	r2, #0
 804febc:	9201      	str	r2, [sp, #4]
 804febe:	f503 3309 	add.w	r3, r3, #140288	; 0x22400
 804fec2:	6c19      	ldr	r1, [r3, #64]	; 0x40
 804fec4:	f041 0120 	orr.w	r1, r1, #32
 804fec8:	6419      	str	r1, [r3, #64]	; 0x40
 804feca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 804fecc:	f003 0320 	and.w	r3, r3, #32
 804fed0:	9301      	str	r3, [sp, #4]
 804fed2:	9b01      	ldr	r3, [sp, #4]

    /* TIM7 interrupt Init */
    HAL_NVIC_SetPriority(TIM7_IRQn, 1, 0);
 804fed4:	2101      	movs	r1, #1
 804fed6:	2037      	movs	r0, #55	; 0x37
 804fed8:	f7f1 fcfa 	bl	80418d0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
 804fedc:	2037      	movs	r0, #55	; 0x37
 804fede:	f7f1 fd2b 	bl	8041938 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }
}
 804fee2:	b003      	add	sp, #12
 804fee4:	f85d fb04 	ldr.w	pc, [sp], #4
 804fee8:	40001400 	.word	0x40001400

0804feec <MX_UART4_Init>:
#include "externs.h"
/* USER CODE END 0 */

/* UART4 init function */
void MX_UART4_Init(void)
{
 804feec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 804fef0:	b090      	sub	sp, #64	; 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 804fef2:	2400      	movs	r4, #0
 804fef4:	9409      	str	r4, [sp, #36]	; 0x24
 804fef6:	940a      	str	r4, [sp, #40]	; 0x28
 804fef8:	940b      	str	r4, [sp, #44]	; 0x2c
 804fefa:	940c      	str	r4, [sp, #48]	; 0x30
 804fefc:	940d      	str	r4, [sp, #52]	; 0x34
 804fefe:	940e      	str	r4, [sp, #56]	; 0x38
 804ff00:	940f      	str	r4, [sp, #60]	; 0x3c
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
 804ff02:	4b3b      	ldr	r3, [pc, #236]	; (804fff0 <MX_UART4_Init+0x104>)
 804ff04:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804ff06:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 804ff0a:	641a      	str	r2, [r3, #64]	; 0x40
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 804ff0c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 804ff0e:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 804ff12:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 804ff14:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB1ENR, Periphs);
 804ff16:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ff18:	f042 0201 	orr.w	r2, r2, #1
 804ff1c:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 804ff1e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ff20:	f002 0201 	and.w	r2, r2, #1
 804ff24:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 804ff26:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 804ff28:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 804ff2a:	f042 0204 	orr.w	r2, r2, #4
 804ff2e:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 804ff30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 804ff32:	f003 0304 	and.w	r3, r3, #4
 804ff36:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 804ff38:	9b00      	ldr	r3, [sp, #0]
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOC);
  /**UART4 GPIO Configuration
  PA0/WKUP   ------> UART4_TX
  PC11   ------> UART4_RX
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_0;
 804ff3a:	2501      	movs	r5, #1
 804ff3c:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 804ff3e:	f04f 0802 	mov.w	r8, #2
 804ff42:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 804ff46:	2703      	movs	r7, #3
 804ff48:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 804ff4a:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 804ff4c:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
 804ff4e:	2608      	movs	r6, #8
 804ff50:	9608      	str	r6, [sp, #32]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 804ff52:	a903      	add	r1, sp, #12
 804ff54:	4827      	ldr	r0, [pc, #156]	; (804fff4 <MX_UART4_Init+0x108>)
 804ff56:	f7f5 f8ac 	bl	80450b2 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_11;
 804ff5a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 804ff5e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 804ff60:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 804ff64:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 804ff66:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 804ff68:	9507      	str	r5, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_8;
 804ff6a:	9608      	str	r6, [sp, #32]
  LL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 804ff6c:	a903      	add	r1, sp, #12
 804ff6e:	4822      	ldr	r0, [pc, #136]	; (804fff8 <MX_UART4_Init+0x10c>)
 804ff70:	f7f5 f89f 	bl	80450b2 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 804ff74:	4b21      	ldr	r3, [pc, #132]	; (804fffc <MX_UART4_Init+0x110>)
 804ff76:	68da      	ldr	r2, [r3, #12]
 804ff78:	f3c2 2202 	ubfx	r2, r2, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 804ff7c:	f1c2 0307 	rsb	r3, r2, #7
 804ff80:	2b04      	cmp	r3, #4
 804ff82:	bf28      	it	cs
 804ff84:	2304      	movcs	r3, #4
 804ff86:	4619      	mov	r1, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804ff88:	1d13      	adds	r3, r2, #4
 804ff8a:	2b06      	cmp	r3, #6
 804ff8c:	d92e      	bls.n	804ffec <MX_UART4_Init+0x100>
 804ff8e:	3a03      	subs	r2, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 804ff90:	f04f 33ff 	mov.w	r3, #4294967295
 804ff94:	408b      	lsls	r3, r1
 804ff96:	43db      	mvns	r3, r3
 804ff98:	f003 0303 	and.w	r3, r3, #3
 804ff9c:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 804ff9e:	011b      	lsls	r3, r3, #4
 804ffa0:	b2db      	uxtb	r3, r3
 804ffa2:	4a17      	ldr	r2, [pc, #92]	; (8050000 <MX_UART4_Init+0x114>)
 804ffa4:	f882 3334 	strb.w	r3, [r2, #820]	; 0x334
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 804ffa8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 804ffac:	6053      	str	r3, [r2, #4]

  /* UART4 interrupt Init */
  NVIC_SetPriority(UART4_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),3, 0));
  NVIC_EnableIRQ(UART4_IRQn);

  USART_InitStruct.BaudRate = 115200;
 804ffae:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 804ffb2:	9309      	str	r3, [sp, #36]	; 0x24
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 804ffb4:	2300      	movs	r3, #0
 804ffb6:	930a      	str	r3, [sp, #40]	; 0x28
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 804ffb8:	930b      	str	r3, [sp, #44]	; 0x2c
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 804ffba:	930c      	str	r3, [sp, #48]	; 0x30
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 804ffbc:	220c      	movs	r2, #12
 804ffbe:	920d      	str	r2, [sp, #52]	; 0x34
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 804ffc0:	930e      	str	r3, [sp, #56]	; 0x38
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 804ffc2:	930f      	str	r3, [sp, #60]	; 0x3c
  LL_USART_Init(UART4, &USART_InitStruct);
 804ffc4:	4c0f      	ldr	r4, [pc, #60]	; (8050004 <MX_UART4_Init+0x118>)
 804ffc6:	a909      	add	r1, sp, #36	; 0x24
 804ffc8:	4620      	mov	r0, r4
 804ffca:	f7f5 f97d 	bl	80452c8 <LL_USART_Init>
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 804ffce:	6923      	ldr	r3, [r4, #16]
 804ffd0:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 804ffd4:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 804ffd6:	6963      	ldr	r3, [r4, #20]
 804ffd8:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 804ffdc:	6163      	str	r3, [r4, #20]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 804ffde:	68e3      	ldr	r3, [r4, #12]
 804ffe0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 804ffe4:	60e3      	str	r3, [r4, #12]
  LL_USART_ConfigAsyncMode(UART4);
  LL_USART_Enable(UART4);

}
 804ffe6:	b010      	add	sp, #64	; 0x40
 804ffe8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 804ffec:	2200      	movs	r2, #0
 804ffee:	e7cf      	b.n	804ff90 <MX_UART4_Init+0xa4>
 804fff0:	40023800 	.word	0x40023800
 804fff4:	40020000 	.word	0x40020000
 804fff8:	40020800 	.word	0x40020800
 804fffc:	e000ed00 	.word	0xe000ed00
 8050000:	e000e100 	.word	0xe000e100
 8050004:	40004c00 	.word	0x40004c00

08050008 <MX_USART3_UART_Init>:
/* USART3 init function */

void MX_USART3_UART_Init(void)
{
 8050008:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 805000c:	b090      	sub	sp, #64	; 0x40
  LL_USART_InitTypeDef USART_InitStruct = {0};
 805000e:	2400      	movs	r4, #0
 8050010:	9409      	str	r4, [sp, #36]	; 0x24
 8050012:	940a      	str	r4, [sp, #40]	; 0x28
 8050014:	940b      	str	r4, [sp, #44]	; 0x2c
 8050016:	940c      	str	r4, [sp, #48]	; 0x30
 8050018:	940d      	str	r4, [sp, #52]	; 0x34
 805001a:	940e      	str	r4, [sp, #56]	; 0x38
 805001c:	940f      	str	r4, [sp, #60]	; 0x3c
  SET_BIT(RCC->APB1ENR, Periphs);
 805001e:	4b3b      	ldr	r3, [pc, #236]	; (805010c <MX_USART3_UART_Init+0x104>)
 8050020:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8050022:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8050026:	641a      	str	r2, [r3, #64]	; 0x40
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8050028:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 805002a:	f402 2280 	and.w	r2, r2, #262144	; 0x40000
 805002e:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 8050030:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB1ENR, Periphs);
 8050032:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8050034:	f042 0202 	orr.w	r2, r2, #2
 8050038:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 805003a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 805003c:	f002 0202 	and.w	r2, r2, #2
 8050040:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8050042:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 8050044:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8050046:	f042 0208 	orr.w	r2, r2, #8
 805004a:	631a      	str	r2, [r3, #48]	; 0x30
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 805004c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 805004e:	f003 0308 	and.w	r3, r3, #8
 8050052:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8050054:	9b00      	ldr	r3, [sp, #0]
  LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOD);
  /**USART3 GPIO Configuration
  PB10   ------> USART3_TX
  PD9   ------> USART3_RX
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_10;
 8050056:	f44f 6380 	mov.w	r3, #1024	; 0x400
 805005a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 805005c:	f04f 0802 	mov.w	r8, #2
 8050060:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8050064:	2703      	movs	r7, #3
 8050066:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8050068:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 805006a:	2601      	movs	r6, #1
 805006c:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 805006e:	2507      	movs	r5, #7
 8050070:	9508      	str	r5, [sp, #32]
  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8050072:	a903      	add	r1, sp, #12
 8050074:	4826      	ldr	r0, [pc, #152]	; (8050110 <MX_USART3_UART_Init+0x108>)
 8050076:	f7f5 f81c 	bl	80450b2 <LL_GPIO_Init>

  GPIO_InitStruct.Pin = LL_GPIO_PIN_9;
 805007a:	f44f 7300 	mov.w	r3, #512	; 0x200
 805007e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 8050080:	f8cd 8010 	str.w	r8, [sp, #16]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 8050084:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 8050086:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;
 8050088:	9607      	str	r6, [sp, #28]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 805008a:	9508      	str	r5, [sp, #32]
  LL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 805008c:	a903      	add	r1, sp, #12
 805008e:	4821      	ldr	r0, [pc, #132]	; (8050114 <MX_USART3_UART_Init+0x10c>)
 8050090:	f7f5 f80f 	bl	80450b2 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8050094:	4b20      	ldr	r3, [pc, #128]	; (8050118 <MX_USART3_UART_Init+0x110>)
 8050096:	68da      	ldr	r2, [r3, #12]
 8050098:	f3c2 2202 	ubfx	r2, r2, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 805009c:	1aab      	subs	r3, r5, r2
 805009e:	2b04      	cmp	r3, #4
 80500a0:	bf28      	it	cs
 80500a2:	2304      	movcs	r3, #4
 80500a4:	4619      	mov	r1, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80500a6:	1d13      	adds	r3, r2, #4
 80500a8:	2b06      	cmp	r3, #6
 80500aa:	d92d      	bls.n	8050108 <MX_USART3_UART_Init+0x100>
 80500ac:	3a03      	subs	r2, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80500ae:	f04f 33ff 	mov.w	r3, #4294967295
 80500b2:	408b      	lsls	r3, r1
 80500b4:	43db      	mvns	r3, r3
 80500b6:	f003 0304 	and.w	r3, r3, #4
 80500ba:	4093      	lsls	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80500bc:	011b      	lsls	r3, r3, #4
 80500be:	b2db      	uxtb	r3, r3
 80500c0:	4a16      	ldr	r2, [pc, #88]	; (805011c <MX_USART3_UART_Init+0x114>)
 80500c2:	f882 3327 	strb.w	r3, [r2, #807]	; 0x327
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80500c6:	2380      	movs	r3, #128	; 0x80
 80500c8:	6053      	str	r3, [r2, #4]

  /* USART3 interrupt Init */
  NVIC_SetPriority(USART3_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),4, 0));
  NVIC_EnableIRQ(USART3_IRQn);

  USART_InitStruct.BaudRate = 9600;
 80500ca:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80500ce:	9309      	str	r3, [sp, #36]	; 0x24
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 80500d0:	2300      	movs	r3, #0
 80500d2:	930a      	str	r3, [sp, #40]	; 0x28
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 80500d4:	930b      	str	r3, [sp, #44]	; 0x2c
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 80500d6:	930c      	str	r3, [sp, #48]	; 0x30
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 80500d8:	220c      	movs	r2, #12
 80500da:	920d      	str	r2, [sp, #52]	; 0x34
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 80500dc:	930e      	str	r3, [sp, #56]	; 0x38
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 80500de:	930f      	str	r3, [sp, #60]	; 0x3c
  LL_USART_Init(USART3, &USART_InitStruct);
 80500e0:	4c0f      	ldr	r4, [pc, #60]	; (8050120 <MX_USART3_UART_Init+0x118>)
 80500e2:	a909      	add	r1, sp, #36	; 0x24
 80500e4:	4620      	mov	r0, r4
 80500e6:	f7f5 f8ef 	bl	80452c8 <LL_USART_Init>
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80500ea:	6923      	ldr	r3, [r4, #16]
 80500ec:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80500f0:	6123      	str	r3, [r4, #16]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 80500f2:	6963      	ldr	r3, [r4, #20]
 80500f4:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 80500f8:	6163      	str	r3, [r4, #20]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 80500fa:	68e3      	ldr	r3, [r4, #12]
 80500fc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8050100:	60e3      	str	r3, [r4, #12]
  LL_USART_ConfigAsyncMode(USART3);
  LL_USART_Enable(USART3);

}
 8050102:	b010      	add	sp, #64	; 0x40
 8050104:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8050108:	2200      	movs	r2, #0
 805010a:	e7d0      	b.n	80500ae <MX_USART3_UART_Init+0xa6>
 805010c:	40023800 	.word	0x40023800
 8050110:	40020400 	.word	0x40020400
 8050114:	40020c00 	.word	0x40020c00
 8050118:	e000ed00 	.word	0xe000ed00
 805011c:	e000e100 	.word	0xe000e100
 8050120:	40004800 	.word	0x40004800
 8050124:	00000000 	.word	0x00000000

08050128 <calculateInputVoltage>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void calculateInputVoltage(void)
{
 8050128:	b510      	push	{r4, lr}
 805012a:	ed2d 8b02 	vpush	{d8}
	/* Calculate Input Votage from adc data */
	gfInputSupplyVoltage = (float) ((MAX_INPUT_VTG * gau32BatteryProcessedData[ADC_VIN + 1])/ADC_RESOLUTION);
 805012e:	4c2a      	ldr	r4, [pc, #168]	; (80501d8 <calculateInputVoltage+0xb0>)
 8050130:	6863      	ldr	r3, [r4, #4]
 8050132:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8050136:	00db      	lsls	r3, r3, #3
 8050138:	4a28      	ldr	r2, [pc, #160]	; (80501dc <calculateInputVoltage+0xb4>)
 805013a:	fba2 2303 	umull	r2, r3, r2, r3
 805013e:	0adb      	lsrs	r3, r3, #11
 8050140:	ee07 3a90 	vmov	s15, r3
 8050144:	eeb8 8a67 	vcvt.f32.u32	s16, s15
	gfBatteryVoltage = ((((3.3 * ( 2 * gau32BatteryProcessedData[ADC_VIN])) / 4095) * 2 ) / 0.6 ) - 0.2;
 8050148:	6820      	ldr	r0, [r4, #0]
 805014a:	0040      	lsls	r0, r0, #1
 805014c:	f7f0 f9ea 	bl	8040524 <__aeabi_ui2d>
 8050150:	a319      	add	r3, pc, #100	; (adr r3, 80501b8 <calculateInputVoltage+0x90>)
 8050152:	e9d3 2300 	ldrd	r2, r3, [r3]
 8050156:	f7f0 fa5f 	bl	8040618 <__aeabi_dmul>
 805015a:	a319      	add	r3, pc, #100	; (adr r3, 80501c0 <calculateInputVoltage+0x98>)
 805015c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8050160:	f7f0 fb84 	bl	804086c <__aeabi_ddiv>
 8050164:	4602      	mov	r2, r0
 8050166:	460b      	mov	r3, r1
 8050168:	f7f0 f8a0 	bl	80402ac <__adddf3>
 805016c:	a316      	add	r3, pc, #88	; (adr r3, 80501c8 <calculateInputVoltage+0xa0>)
 805016e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8050172:	f7f0 fb7b 	bl	804086c <__aeabi_ddiv>
 8050176:	a316      	add	r3, pc, #88	; (adr r3, 80501d0 <calculateInputVoltage+0xa8>)
 8050178:	e9d3 2300 	ldrd	r2, r3, [r3]
 805017c:	f7f0 f894 	bl	80402a8 <__aeabi_dsub>
 8050180:	f7f0 fd42 	bl	8040c08 <__aeabi_d2f>
 8050184:	60a0      	str	r0, [r4, #8]
	/* Add diode drop for actual voltage */
	gfInputSupplyVoltage += INPUT_DIODE_DROP;
 8050186:	eddf 7a16 	vldr	s15, [pc, #88]	; 80501e0 <calculateInputVoltage+0xb8>
 805018a:	ee78 7a27 	vadd.f32	s15, s16, s15
 805018e:	edc4 7a03 	vstr	s15, [r4, #12]
	/* Check if system is powered from 8.4 V dc battery pack */
	if(gfInputSupplyVoltage <= VIN_BATTERY_VTG)
 8050192:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
 8050196:	eef4 7ac7 	vcmpe.f32	s15, s14
 805019a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 805019e:	d804      	bhi.n	80501aa <calculateInputVoltage+0x82>
	{
		gu32InputSupplySwitchedAlert = TRUE;
 80501a0:	2201      	movs	r2, #1
 80501a2:	6122      	str	r2, [r4, #16]
	}
	else
	{
		gu32InputSupplySwitchedAlert = FALSE;
	}
}
 80501a4:	ecbd 8b02 	vpop	{d8}
 80501a8:	bd10      	pop	{r4, pc}
		gu32InputSupplySwitchedAlert = FALSE;
 80501aa:	4b0b      	ldr	r3, [pc, #44]	; (80501d8 <calculateInputVoltage+0xb0>)
 80501ac:	2200      	movs	r2, #0
 80501ae:	611a      	str	r2, [r3, #16]
}
 80501b0:	e7f8      	b.n	80501a4 <calculateInputVoltage+0x7c>
 80501b2:	bf00      	nop
 80501b4:	f3af 8000 	nop.w
 80501b8:	66666666 	.word	0x66666666
 80501bc:	400a6666 	.word	0x400a6666
 80501c0:	00000000 	.word	0x00000000
 80501c4:	40affe00 	.word	0x40affe00
 80501c8:	33333333 	.word	0x33333333
 80501cc:	3fe33333 	.word	0x3fe33333
 80501d0:	9999999a 	.word	0x9999999a
 80501d4:	3fc99999 	.word	0x3fc99999
 80501d8:	20005210 	.word	0x20005210
 80501dc:	affea003 	.word	0xaffea003
 80501e0:	3fb33333 	.word	0x3fb33333

080501e4 <operateadc>:
{
 80501e4:	b508      	push	{r3, lr}
	if(gu32ADCPollTimer)
 80501e6:	4b32      	ldr	r3, [pc, #200]	; (80502b0 <operateadc+0xcc>)
 80501e8:	681b      	ldr	r3, [r3, #0]
 80501ea:	2b00      	cmp	r3, #0
 80501ec:	d14c      	bne.n	8050288 <operateadc+0xa4>
	switch(enmAdcSMCurrentState)
 80501ee:	4b31      	ldr	r3, [pc, #196]	; (80502b4 <operateadc+0xd0>)
 80501f0:	7d1b      	ldrb	r3, [r3, #20]
 80501f2:	2b03      	cmp	r3, #3
 80501f4:	d853      	bhi.n	805029e <operateadc+0xba>
 80501f6:	e8df f003 	tbb	[pc, r3]
 80501fa:	1702      	.short	0x1702
 80501fc:	4048      	.short	0x4048
			if((HAL_ADC_Start_DMA(&hadc1, (uint32_t*)gau32BatteryPeripheralData, 2) != HAL_OK))
 80501fe:	2202      	movs	r2, #2
 8050200:	492d      	ldr	r1, [pc, #180]	; (80502b8 <operateadc+0xd4>)
 8050202:	482e      	ldr	r0, [pc, #184]	; (80502bc <operateadc+0xd8>)
 8050204:	f7f1 f8cc 	bl	80413a0 <HAL_ADC_Start_DMA>
 8050208:	b118      	cbz	r0, 8050212 <operateadc+0x2e>
				enmAdcSMCurrentState = enmADC_ERROR;
 805020a:	4b2a      	ldr	r3, [pc, #168]	; (80502b4 <operateadc+0xd0>)
 805020c:	2203      	movs	r2, #3
 805020e:	751a      	strb	r2, [r3, #20]
 8050210:	e03a      	b.n	8050288 <operateadc+0xa4>
				HAL_ADC_Start_IT(&hadc1);
 8050212:	482a      	ldr	r0, [pc, #168]	; (80502bc <operateadc+0xd8>)
 8050214:	f7f1 f824 	bl	8041260 <HAL_ADC_Start_IT>
				enmAdcSMCurrentState = enmADC_GETDATA;
 8050218:	4b26      	ldr	r3, [pc, #152]	; (80502b4 <operateadc+0xd0>)
 805021a:	2201      	movs	r2, #1
 805021c:	751a      	strb	r2, [r3, #20]
				gu32ADCOperationTimer = ONE_MIN;
 805021e:	4b28      	ldr	r3, [pc, #160]	; (80502c0 <operateadc+0xdc>)
 8050220:	f64e 2260 	movw	r2, #60000	; 0xea60
 8050224:	601a      	str	r2, [r3, #0]
 8050226:	e02f      	b.n	8050288 <operateadc+0xa4>
			if((g32AdcConversionStatusBatt == TRUE) && (gu32ADCOperationTimer != 0))
 8050228:	4b22      	ldr	r3, [pc, #136]	; (80502b4 <operateadc+0xd0>)
 805022a:	6a1b      	ldr	r3, [r3, #32]
 805022c:	2b01      	cmp	r3, #1
 805022e:	d013      	beq.n	8050258 <operateadc+0x74>
			else if((!g32AdcConversionStatus) | (!g32AdcConversionStatusBatt) | (gu32ADCOperationTimer == 0))
 8050230:	4a20      	ldr	r2, [pc, #128]	; (80502b4 <operateadc+0xd0>)
 8050232:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8050234:	6a13      	ldr	r3, [r2, #32]
 8050236:	fab3 f383 	clz	r3, r3
 805023a:	095b      	lsrs	r3, r3, #5
 805023c:	2900      	cmp	r1, #0
 805023e:	bf08      	it	eq
 8050240:	2301      	moveq	r3, #1
 8050242:	4a1f      	ldr	r2, [pc, #124]	; (80502c0 <operateadc+0xdc>)
 8050244:	6812      	ldr	r2, [r2, #0]
 8050246:	fab2 f282 	clz	r2, r2
 805024a:	0952      	lsrs	r2, r2, #5
 805024c:	b903      	cbnz	r3, 8050250 <operateadc+0x6c>
 805024e:	b1da      	cbz	r2, 8050288 <operateadc+0xa4>
				enmAdcSMCurrentState = enmADC_IDLE;
 8050250:	4b18      	ldr	r3, [pc, #96]	; (80502b4 <operateadc+0xd0>)
 8050252:	2200      	movs	r2, #0
 8050254:	751a      	strb	r2, [r3, #20]
 8050256:	e017      	b.n	8050288 <operateadc+0xa4>
			if((g32AdcConversionStatusBatt == TRUE) && (gu32ADCOperationTimer != 0))
 8050258:	4b19      	ldr	r3, [pc, #100]	; (80502c0 <operateadc+0xdc>)
 805025a:	681b      	ldr	r3, [r3, #0]
 805025c:	2b00      	cmp	r3, #0
 805025e:	d0e7      	beq.n	8050230 <operateadc+0x4c>
				gu32ADCOperationTimer = 0;
 8050260:	2200      	movs	r2, #0
 8050262:	4b17      	ldr	r3, [pc, #92]	; (80502c0 <operateadc+0xdc>)
 8050264:	601a      	str	r2, [r3, #0]
				gau32BatteryProcessedData[ADC_VIN + 1] = gau32BatteryPeripheralData[ADC_VIN +1];
 8050266:	4b13      	ldr	r3, [pc, #76]	; (80502b4 <operateadc+0xd0>)
 8050268:	69d9      	ldr	r1, [r3, #28]
 805026a:	6059      	str	r1, [r3, #4]
				gau32BatteryProcessedData[ADC_VIN] = gau32BatteryPeripheralData[ADC_VIN];
 805026c:	6999      	ldr	r1, [r3, #24]
 805026e:	6019      	str	r1, [r3, #0]
				enmAdcSMCurrentState = enmADC_PROCESSDATA;
 8050270:	2102      	movs	r1, #2
 8050272:	7519      	strb	r1, [r3, #20]
				g32AdcConversionStatusBatt = FALSE;
 8050274:	621a      	str	r2, [r3, #32]
				g32AdcConversionStatus = FALSE;
 8050276:	625a      	str	r2, [r3, #36]	; 0x24
 8050278:	e006      	b.n	8050288 <operateadc+0xa4>
			gu32ADCPollTimer = TEN_SEC;
 805027a:	4b0d      	ldr	r3, [pc, #52]	; (80502b0 <operateadc+0xcc>)
 805027c:	f242 7210 	movw	r2, #10000	; 0x2710
 8050280:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 8050282:	4b0c      	ldr	r3, [pc, #48]	; (80502b4 <operateadc+0xd0>)
 8050284:	2200      	movs	r2, #0
 8050286:	751a      	strb	r2, [r3, #20]
}
 8050288:	bd08      	pop	{r3, pc}
			calculateInputVoltage();
 805028a:	f7ff ff4d 	bl	8050128 <calculateInputVoltage>
			gu32ADCPollTimer = TEN_SEC;
 805028e:	4b08      	ldr	r3, [pc, #32]	; (80502b0 <operateadc+0xcc>)
 8050290:	f242 7210 	movw	r2, #10000	; 0x2710
 8050294:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 8050296:	4b07      	ldr	r3, [pc, #28]	; (80502b4 <operateadc+0xd0>)
 8050298:	2200      	movs	r2, #0
 805029a:	751a      	strb	r2, [r3, #20]
			break;
 805029c:	e7f4      	b.n	8050288 <operateadc+0xa4>
			gu32ADCPollTimer = TEN_SEC;
 805029e:	4b04      	ldr	r3, [pc, #16]	; (80502b0 <operateadc+0xcc>)
 80502a0:	f242 7210 	movw	r2, #10000	; 0x2710
 80502a4:	601a      	str	r2, [r3, #0]
			enmAdcSMCurrentState = enmADC_IDLE;
 80502a6:	4b03      	ldr	r3, [pc, #12]	; (80502b4 <operateadc+0xd0>)
 80502a8:	2200      	movs	r2, #0
 80502aa:	751a      	strb	r2, [r3, #20]
			break;
 80502ac:	e7ec      	b.n	8050288 <operateadc+0xa4>
 80502ae:	bf00      	nop
 80502b0:	200053f8 	.word	0x200053f8
 80502b4:	20005210 	.word	0x20005210
 80502b8:	20005228 	.word	0x20005228
 80502bc:	200089b8 	.word	0x200089b8
 80502c0:	200053f4 	.word	0x200053f4

080502c4 <HAL_ADC_ConvCpltCallback>:
 *
 * */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
	/*Sequence conversion complete . Read Processed Value */
	if(hadc->Instance == ADC1)
 80502c4:	6803      	ldr	r3, [r0, #0]
 80502c6:	4a0b      	ldr	r2, [pc, #44]	; (80502f4 <HAL_ADC_ConvCpltCallback+0x30>)
 80502c8:	4293      	cmp	r3, r2
 80502ca:	d003      	beq.n	80502d4 <HAL_ADC_ConvCpltCallback+0x10>
	{
		if(g32AdcConversionStatusBatt == FALSE)
			g32AdcConversionStatusBatt = TRUE;

	}
	else if(hadc->Instance == ADC3)
 80502cc:	4a0a      	ldr	r2, [pc, #40]	; (80502f8 <HAL_ADC_ConvCpltCallback+0x34>)
 80502ce:	4293      	cmp	r3, r2
 80502d0:	d008      	beq.n	80502e4 <HAL_ADC_ConvCpltCallback+0x20>
	}
	else
	{
		/* Unknown Interrupt */
	}
}
 80502d2:	4770      	bx	lr
		if(g32AdcConversionStatusBatt == FALSE)
 80502d4:	4b09      	ldr	r3, [pc, #36]	; (80502fc <HAL_ADC_ConvCpltCallback+0x38>)
 80502d6:	6a1b      	ldr	r3, [r3, #32]
 80502d8:	2b00      	cmp	r3, #0
 80502da:	d1fa      	bne.n	80502d2 <HAL_ADC_ConvCpltCallback+0xe>
			g32AdcConversionStatusBatt = TRUE;
 80502dc:	4b07      	ldr	r3, [pc, #28]	; (80502fc <HAL_ADC_ConvCpltCallback+0x38>)
 80502de:	2201      	movs	r2, #1
 80502e0:	621a      	str	r2, [r3, #32]
 80502e2:	4770      	bx	lr
		if(g32AdcConversionStatus == FALSE)
 80502e4:	4b05      	ldr	r3, [pc, #20]	; (80502fc <HAL_ADC_ConvCpltCallback+0x38>)
 80502e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80502e8:	2b00      	cmp	r3, #0
 80502ea:	d1f2      	bne.n	80502d2 <HAL_ADC_ConvCpltCallback+0xe>
			g32AdcConversionStatus = TRUE;
 80502ec:	4b03      	ldr	r3, [pc, #12]	; (80502fc <HAL_ADC_ConvCpltCallback+0x38>)
 80502ee:	2201      	movs	r2, #1
 80502f0:	625a      	str	r2, [r3, #36]	; 0x24
}
 80502f2:	e7ee      	b.n	80502d2 <HAL_ADC_ConvCpltCallback+0xe>
 80502f4:	40012000 	.word	0x40012000
 80502f8:	40012200 	.word	0x40012200
 80502fc:	20005210 	.word	0x20005210

08050300 <HAL_I2C_ErrorCallback>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 8050300:	b508      	push	{r3, lr}
	assertError(enmTORERRORS_MEM_I2C,enmERRORSTATE_ACTIVE);
 8050302:	2101      	movs	r1, #1
 8050304:	200e      	movs	r0, #14
 8050306:	f7fb fa17 	bl	804b738 <assertError>
}
 805030a:	bd08      	pop	{r3, pc}

0805030c <initMemoryRead>:
* <hr>
*
*******************************************************************************/
void initMemoryRead(void)
{
	gau8MemoryOperationRead[0] = FALSE;
 805030c:	4b0b      	ldr	r3, [pc, #44]	; (805033c <initMemoryRead+0x30>)
 805030e:	2100      	movs	r1, #0
 8050310:	7119      	strb	r1, [r3, #4]
	gau8MemoryOperationRead[1] = TRUE;
 8050312:	2201      	movs	r2, #1
 8050314:	715a      	strb	r2, [r3, #5]
	gau8MemoryOperationRead[2] = TRUE;
 8050316:	719a      	strb	r2, [r3, #6]
	gau8MemoryOperationRead[3] = TRUE;
 8050318:	71da      	strb	r2, [r3, #7]
	gau8MemoryOperationRead[4] = TRUE;
 805031a:	721a      	strb	r2, [r3, #8]
	gau8MemoryOperationRead[5] = TRUE;
 805031c:	725a      	strb	r2, [r3, #9]
	gau8MemoryOperationRead[6] = TRUE;
 805031e:	729a      	strb	r2, [r3, #10]
	gau8MemoryOperationRead[7] = TRUE;
 8050320:	72da      	strb	r2, [r3, #11]
	gau8MemoryOperationRead[8] = TRUE;
 8050322:	731a      	strb	r2, [r3, #12]
	gau8MemoryOperationRead[9] = TRUE;
 8050324:	735a      	strb	r2, [r3, #13]
	gau8MemoryOperationRead[10] = TRUE;
 8050326:	739a      	strb	r2, [r3, #14]
	gau8MemoryOperationRead[11] = TRUE;
 8050328:	73da      	strb	r2, [r3, #15]
	gau8MemoryOperationRead[12] = TRUE;
 805032a:	741a      	strb	r2, [r3, #16]
	gau8MemoryOperationRead[13] = TRUE;
 805032c:	745a      	strb	r2, [r3, #17]
	gau8MemoryOperationRead[14] = TRUE;
 805032e:	749a      	strb	r2, [r3, #18]
	gau8MemoryOperationRead[15] = TRUE;
 8050330:	74da      	strb	r2, [r3, #19]
	gau8MemoryOperationRead[16] = TRUE;
 8050332:	751a      	strb	r2, [r3, #20]
	gau8MemoryOperationRead[17] = TRUE;
 8050334:	755a      	strb	r2, [r3, #21]
	gu32MemoryOperation = EEPROM_OPR_READ;
 8050336:	4b02      	ldr	r3, [pc, #8]	; (8050340 <initMemoryRead+0x34>)
 8050338:	7019      	strb	r1, [r3, #0]
}
 805033a:	4770      	bx	lr
 805033c:	20005250 	.word	0x20005250
 8050340:	20003878 	.word	0x20003878

08050344 <initSystemDefaultsfromMemory>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void initSystemDefaultsfromMemory(void)
{
 8050344:	b538      	push	{r3, r4, r5, lr}
	/* */
	if(strlen(strI2cEeprom.pu8NetworkAPN) != 0)
 8050346:	4b26      	ldr	r3, [pc, #152]	; (80503e0 <initSystemDefaultsfromMemory+0x9c>)
 8050348:	f893 3c16 	ldrb.w	r3, [r3, #3094]	; 0xc16
 805034c:	b9b3      	cbnz	r3, 805037c <initSystemDefaultsfromMemory+0x38>
	{
		memset(gau8GSM4G_apn,0x00,sizeof(char) * 100);
		memcpy(gau8GSM4G_apn,strI2cEeprom.pu8NetworkAPN, strlen(strI2cEeprom.pu8NetworkAPN));
	}
	if(strlen(strI2cEeprom.pu8RdServerURL) != 0)
 805034e:	4b24      	ldr	r3, [pc, #144]	; (80503e0 <initSystemDefaultsfromMemory+0x9c>)
 8050350:	f893 3c2a 	ldrb.w	r3, [r3, #3114]	; 0xc2a
 8050354:	bb13      	cbnz	r3, 805039c <initSystemDefaultsfromMemory+0x58>
	{
		memset(gau8GSM_url,0x00,sizeof(char) * 100);
		memcpy( gau8GSM_url, strI2cEeprom.pu8RdServerURL, strlen(strI2cEeprom.pu8RdServerURL));
	}
	if(strlen(strI2cEeprom.pu8MobileNumber) != 0)
 8050356:	4b22      	ldr	r3, [pc, #136]	; (80503e0 <initSystemDefaultsfromMemory+0x9c>)
 8050358:	f893 3c07 	ldrb.w	r3, [r3, #3079]	; 0xc07
 805035c:	bb73      	cbnz	r3, 80503bc <initSystemDefaultsfromMemory+0x78>
	{
		memset(gau8GSM_smsto,0x00,sizeof(char) * 15);
		memcpy(gau8GSM_smsto, strI2cEeprom.pu8MobileNumber,strlen(strI2cEeprom.pu8MobileNumber));
	}
	gsmInstance.u32OFFPayloadUploadFreq = atoi(strI2cEeprom.pu8RdUploadOffFreq);
 805035e:	4d21      	ldr	r5, [pc, #132]	; (80503e4 <initSystemDefaultsfromMemory+0xa0>)
 8050360:	4628      	mov	r0, r5
 8050362:	f000 fc7f 	bl	8050c64 <atoi>
 8050366:	4c20      	ldr	r4, [pc, #128]	; (80503e8 <initSystemDefaultsfromMemory+0xa4>)
 8050368:	f8c4 0e2c 	str.w	r0, [r4, #3628]	; 0xe2c
	gsmInstance.u32ONPayloadUploadFreq = atoi(strI2cEeprom.pu8RdUploadOnFreq);
 805036c:	1f68      	subs	r0, r5, #5
 805036e:	f000 fc79 	bl	8050c64 <atoi>
 8050372:	f8c4 0e28 	str.w	r0, [r4, #3624]	; 0xe28
	initGSMSIM868();
 8050376:	f7fb fc43 	bl	804bc00 <initGSMSIM868>
}
 805037a:	bd38      	pop	{r3, r4, r5, pc}
		memset(gau8GSM4G_apn,0x00,sizeof(char) * 100);
 805037c:	4c1b      	ldr	r4, [pc, #108]	; (80503ec <initSystemDefaultsfromMemory+0xa8>)
 805037e:	2264      	movs	r2, #100	; 0x64
 8050380:	2100      	movs	r1, #0
 8050382:	4620      	mov	r0, r4
 8050384:	f000 ff1e 	bl	80511c4 <memset>
		memcpy(gau8GSM4G_apn,strI2cEeprom.pu8NetworkAPN, strlen(strI2cEeprom.pu8NetworkAPN));
 8050388:	4d19      	ldr	r5, [pc, #100]	; (80503f0 <initSystemDefaultsfromMemory+0xac>)
 805038a:	4628      	mov	r0, r5
 805038c:	f7ef ff30 	bl	80401f0 <strlen>
 8050390:	4602      	mov	r2, r0
 8050392:	4629      	mov	r1, r5
 8050394:	4620      	mov	r0, r4
 8050396:	f000 ff07 	bl	80511a8 <memcpy>
 805039a:	e7d8      	b.n	805034e <initSystemDefaultsfromMemory+0xa>
		memset(gau8GSM_url,0x00,sizeof(char) * 100);
 805039c:	4c15      	ldr	r4, [pc, #84]	; (80503f4 <initSystemDefaultsfromMemory+0xb0>)
 805039e:	2264      	movs	r2, #100	; 0x64
 80503a0:	2100      	movs	r1, #0
 80503a2:	4620      	mov	r0, r4
 80503a4:	f000 ff0e 	bl	80511c4 <memset>
		memcpy( gau8GSM_url, strI2cEeprom.pu8RdServerURL, strlen(strI2cEeprom.pu8RdServerURL));
 80503a8:	4d13      	ldr	r5, [pc, #76]	; (80503f8 <initSystemDefaultsfromMemory+0xb4>)
 80503aa:	4628      	mov	r0, r5
 80503ac:	f7ef ff20 	bl	80401f0 <strlen>
 80503b0:	4602      	mov	r2, r0
 80503b2:	4629      	mov	r1, r5
 80503b4:	4620      	mov	r0, r4
 80503b6:	f000 fef7 	bl	80511a8 <memcpy>
 80503ba:	e7cc      	b.n	8050356 <initSystemDefaultsfromMemory+0x12>
		memset(gau8GSM_smsto,0x00,sizeof(char) * 15);
 80503bc:	4c0f      	ldr	r4, [pc, #60]	; (80503fc <initSystemDefaultsfromMemory+0xb8>)
 80503be:	2300      	movs	r3, #0
 80503c0:	6023      	str	r3, [r4, #0]
 80503c2:	6063      	str	r3, [r4, #4]
 80503c4:	60a3      	str	r3, [r4, #8]
 80503c6:	f8c4 300b 	str.w	r3, [r4, #11]
		memcpy(gau8GSM_smsto, strI2cEeprom.pu8MobileNumber,strlen(strI2cEeprom.pu8MobileNumber));
 80503ca:	4d0d      	ldr	r5, [pc, #52]	; (8050400 <initSystemDefaultsfromMemory+0xbc>)
 80503cc:	4628      	mov	r0, r5
 80503ce:	f7ef ff0f 	bl	80401f0 <strlen>
 80503d2:	4602      	mov	r2, r0
 80503d4:	4629      	mov	r1, r5
 80503d6:	4620      	mov	r0, r4
 80503d8:	f000 fee6 	bl	80511a8 <memcpy>
 80503dc:	e7bf      	b.n	805035e <initSystemDefaultsfromMemory+0x1a>
 80503de:	bf00      	nop
 80503e0:	2000f63c 	.word	0x2000f63c
 80503e4:	20010301 	.word	0x20010301
 80503e8:	2000c61c 	.word	0x2000c61c
 80503ec:	20000618 	.word	0x20000618
 80503f0:	20010252 	.word	0x20010252
 80503f4:	200002fc 	.word	0x200002fc
 80503f8:	20010266 	.word	0x20010266
 80503fc:	20000248 	.word	0x20000248
 8050400:	20010243 	.word	0x20010243

08050404 <HAL_I2C_MemRxCpltCallback>:
{
 8050404:	b508      	push	{r3, lr}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0)
 8050406:	4b20      	ldr	r3, [pc, #128]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050408:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 805040c:	2b01      	cmp	r3, #1
 805040e:	d006      	beq.n	805041e <HAL_I2C_MemRxCpltCallback+0x1a>
		if(gu32EEPROMInitforSerialFlash == 0)
 8050410:	4b1d      	ldr	r3, [pc, #116]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050412:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8050414:	b913      	cbnz	r3, 805041c <HAL_I2C_MemRxCpltCallback+0x18>
			gu8SignatureReadFlag = TRUE;
 8050416:	4b1c      	ldr	r3, [pc, #112]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050418:	2201      	movs	r2, #1
 805041a:	701a      	strb	r2, [r3, #0]
}
 805041c:	bd08      	pop	{r3, pc}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0)
 805041e:	4b1b      	ldr	r3, [pc, #108]	; (805048c <HAL_I2C_MemRxCpltCallback+0x88>)
 8050420:	681b      	ldr	r3, [r3, #0]
 8050422:	2b00      	cmp	r3, #0
 8050424:	d0f4      	beq.n	8050410 <HAL_I2C_MemRxCpltCallback+0xc>
			&& (gu8OperateSystemStatus != FALSE))
 8050426:	4b1a      	ldr	r3, [pc, #104]	; (8050490 <HAL_I2C_MemRxCpltCallback+0x8c>)
 8050428:	789b      	ldrb	r3, [r3, #2]
 805042a:	2b00      	cmp	r3, #0
 805042c:	d0f0      	beq.n	8050410 <HAL_I2C_MemRxCpltCallback+0xc>
		if(gau8MemoryOperationRead[u8RdMemLoopCounter] == TRUE)
 805042e:	4b16      	ldr	r3, [pc, #88]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050430:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 8050434:	4413      	add	r3, r2
 8050436:	791b      	ldrb	r3, [r3, #4]
 8050438:	2b01      	cmp	r3, #1
 805043a:	d006      	beq.n	805044a <HAL_I2C_MemRxCpltCallback+0x46>
		gu8MemoryOperationStatus = 0;
 805043c:	2300      	movs	r3, #0
 805043e:	4a12      	ldr	r2, [pc, #72]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050440:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
		gu32I2CMemoryOperationTimeout = 0;
 8050444:	4a11      	ldr	r2, [pc, #68]	; (805048c <HAL_I2C_MemRxCpltCallback+0x88>)
 8050446:	6013      	str	r3, [r2, #0]
 8050448:	e7e8      	b.n	805041c <HAL_I2C_MemRxCpltCallback+0x18>
			gau8MemoryOperationRead[u8RdMemLoopCounter] = FALSE;
 805044a:	4b0f      	ldr	r3, [pc, #60]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 805044c:	1899      	adds	r1, r3, r2
 805044e:	2000      	movs	r0, #0
 8050450:	7108      	strb	r0, [r1, #4]
			u8RdMemLoopCounter ++;
 8050452:	3201      	adds	r2, #1
 8050454:	b2d2      	uxtb	r2, r2
 8050456:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
			if(u8RdMemLoopCounter >= I2CMEM_MAX_OPRATIONS)
 805045a:	2a0e      	cmp	r2, #14
 805045c:	d9ee      	bls.n	805043c <HAL_I2C_MemRxCpltCallback+0x38>
				gu32MemoryOperation = EEPROM_OPR_IDLE;
 805045e:	4a0c      	ldr	r2, [pc, #48]	; (8050490 <HAL_I2C_MemRxCpltCallback+0x8c>)
 8050460:	2302      	movs	r3, #2
 8050462:	7013      	strb	r3, [r2, #0]
				u8RdMemLoopCounter = 0;
 8050464:	4b08      	ldr	r3, [pc, #32]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050466:	f883 0024 	strb.w	r0, [r3, #36]	; 0x24
				gu8MemoryRdOperationFlag = TRUE;
 805046a:	2101      	movs	r1, #1
 805046c:	f883 1026 	strb.w	r1, [r3, #38]	; 0x26
				gu8MemoryCycleComplete = TRUE;
 8050470:	7051      	strb	r1, [r2, #1]
				if(gu8RestoreSystemSettings == TRUE)
 8050472:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8050476:	428b      	cmp	r3, r1
 8050478:	d1e0      	bne.n	805043c <HAL_I2C_MemRxCpltCallback+0x38>
					initSystemDefaultsfromMemory();
 805047a:	f7ff ff63 	bl	8050344 <initSystemDefaultsfromMemory>
					gu8RestoreSystemSettings = FALSE;
 805047e:	4b02      	ldr	r3, [pc, #8]	; (8050488 <HAL_I2C_MemRxCpltCallback+0x84>)
 8050480:	2200      	movs	r2, #0
 8050482:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
 8050486:	e7d9      	b.n	805043c <HAL_I2C_MemRxCpltCallback+0x38>
 8050488:	20005250 	.word	0x20005250
 805048c:	200053f0 	.word	0x200053f0
 8050490:	20003878 	.word	0x20003878

08050494 <systemReset>:
}


void systemReset(void)
{
	while(1);
 8050494:	e7fe      	b.n	8050494 <systemReset>
	...

08050498 <HAL_I2C_MemTxCpltCallback>:
{
 8050498:	b508      	push	{r3, lr}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0))
 805049a:	4b25      	ldr	r3, [pc, #148]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 805049c:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 80504a0:	2b01      	cmp	r3, #1
 80504a2:	d000      	beq.n	80504a6 <HAL_I2C_MemTxCpltCallback+0xe>
}
 80504a4:	bd08      	pop	{r3, pc}
	if((gu8MemoryOperationStatus == 1) && (gu32I2CMemoryOperationTimeout !=0))
 80504a6:	4b23      	ldr	r3, [pc, #140]	; (8050534 <HAL_I2C_MemTxCpltCallback+0x9c>)
 80504a8:	681b      	ldr	r3, [r3, #0]
 80504aa:	2b00      	cmp	r3, #0
 80504ac:	d0fa      	beq.n	80504a4 <HAL_I2C_MemTxCpltCallback+0xc>
		if(gau8MemoryOperationWrite[u8WrMemLoopCounter] == TRUE)
 80504ae:	4b20      	ldr	r3, [pc, #128]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504b0:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 80504b4:	4413      	add	r3, r2
 80504b6:	7d1b      	ldrb	r3, [r3, #20]
 80504b8:	2b01      	cmp	r3, #1
 80504ba:	d006      	beq.n	80504ca <HAL_I2C_MemTxCpltCallback+0x32>
		gu8MemoryOperationStatus = 0;
 80504bc:	2300      	movs	r3, #0
 80504be:	4a1c      	ldr	r2, [pc, #112]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504c0:	f882 3023 	strb.w	r3, [r2, #35]	; 0x23
		gu32I2CMemoryOperationTimeout = 0;
 80504c4:	4a1b      	ldr	r2, [pc, #108]	; (8050534 <HAL_I2C_MemTxCpltCallback+0x9c>)
 80504c6:	6013      	str	r3, [r2, #0]
}
 80504c8:	e7ec      	b.n	80504a4 <HAL_I2C_MemTxCpltCallback+0xc>
			if(gu8PageWriteCycle == TRUE)
 80504ca:	4b19      	ldr	r3, [pc, #100]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504cc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80504d0:	2b01      	cmp	r3, #1
 80504d2:	d019      	beq.n	8050508 <HAL_I2C_MemTxCpltCallback+0x70>
				gau8MemoryOperationWrite[u8WrMemLoopCounter] = FALSE;
 80504d4:	4b16      	ldr	r3, [pc, #88]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504d6:	1899      	adds	r1, r3, r2
 80504d8:	2000      	movs	r0, #0
 80504da:	7508      	strb	r0, [r1, #20]
				u8WrMemLoopCounter ++;
 80504dc:	3201      	adds	r2, #1
 80504de:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
			if(u8WrMemLoopCounter >= I2CMEM_MAX_OPRATIONS)
 80504e2:	4b13      	ldr	r3, [pc, #76]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504e4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80504e8:	2b0e      	cmp	r3, #14
 80504ea:	d9e7      	bls.n	80504bc <HAL_I2C_MemTxCpltCallback+0x24>
				gu32MemoryOperation = EEPROM_OPR_READ;
 80504ec:	4b12      	ldr	r3, [pc, #72]	; (8050538 <HAL_I2C_MemTxCpltCallback+0xa0>)
 80504ee:	2200      	movs	r2, #0
 80504f0:	701a      	strb	r2, [r3, #0]
				if(u32DefautParamWriteStatus == TRUE)
 80504f2:	4b0f      	ldr	r3, [pc, #60]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 80504f4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80504f6:	2b01      	cmp	r3, #1
 80504f8:	d018      	beq.n	805052c <HAL_I2C_MemTxCpltCallback+0x94>
					initMemoryRead();
 80504fa:	f7ff ff07 	bl	805030c <initMemoryRead>
				u8WrMemLoopCounter = 0;
 80504fe:	4b0c      	ldr	r3, [pc, #48]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050500:	2200      	movs	r2, #0
 8050502:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8050506:	e7d9      	b.n	80504bc <HAL_I2C_MemTxCpltCallback+0x24>
				if(gu8PageWriteCounter > cycleRequired)
 8050508:	4909      	ldr	r1, [pc, #36]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 805050a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 805050c:	6c89      	ldr	r1, [r1, #72]	; 0x48
 805050e:	428b      	cmp	r3, r1
 8050510:	d908      	bls.n	8050524 <HAL_I2C_MemTxCpltCallback+0x8c>
					gau8MemoryOperationWrite[u8WrMemLoopCounter] = FALSE;
 8050512:	4b07      	ldr	r3, [pc, #28]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050514:	1898      	adds	r0, r3, r2
 8050516:	2100      	movs	r1, #0
 8050518:	7501      	strb	r1, [r0, #20]
					u8WrMemLoopCounter ++;
 805051a:	3201      	adds	r2, #1
 805051c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
					gu8PageWriteCounter  = 0;
 8050520:	6319      	str	r1, [r3, #48]	; 0x30
 8050522:	e7de      	b.n	80504e2 <HAL_I2C_MemTxCpltCallback+0x4a>
					gu8PageWriteCounter ++;
 8050524:	3301      	adds	r3, #1
 8050526:	4a02      	ldr	r2, [pc, #8]	; (8050530 <HAL_I2C_MemTxCpltCallback+0x98>)
 8050528:	6313      	str	r3, [r2, #48]	; 0x30
 805052a:	e7da      	b.n	80504e2 <HAL_I2C_MemTxCpltCallback+0x4a>
					systemReset();						/* IDWT will reset the system */
 805052c:	f7ff ffb2 	bl	8050494 <systemReset>
 8050530:	20005250 	.word	0x20005250
 8050534:	200053f0 	.word	0x200053f0
 8050538:	20003878 	.word	0x20003878

0805053c <updateEthLinkStatus>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void updateEthLinkStatus(void)
{
 805053c:	b510      	push	{r4, lr}
	HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &gu32EthLinkStatus);
 805053e:	4c09      	ldr	r4, [pc, #36]	; (8050564 <updateEthLinkStatus+0x28>)
 8050540:	4622      	mov	r2, r4
 8050542:	2101      	movs	r1, #1
 8050544:	4808      	ldr	r0, [pc, #32]	; (8050568 <updateEthLinkStatus+0x2c>)
 8050546:	f7f1 fe96 	bl	8042276 <HAL_ETH_ReadPHYRegister>
	if((gu32EthLinkStatus & PHY_LINKED_STATUS) != PHY_LINKED_STATUS)
 805054a:	6823      	ldr	r3, [r4, #0]
 805054c:	f013 0f04 	tst.w	r3, #4
 8050550:	d103      	bne.n	805055a <updateEthLinkStatus+0x1e>
		gu32EthLinkAlert = 1;
 8050552:	4b06      	ldr	r3, [pc, #24]	; (805056c <updateEthLinkStatus+0x30>)
 8050554:	2201      	movs	r2, #1
 8050556:	601a      	str	r2, [r3, #0]
	else
		gu32EthLinkAlert = 0;
}
 8050558:	bd10      	pop	{r4, pc}
		gu32EthLinkAlert = 0;
 805055a:	4b04      	ldr	r3, [pc, #16]	; (805056c <updateEthLinkStatus+0x30>)
 805055c:	2200      	movs	r2, #0
 805055e:	601a      	str	r2, [r3, #0]
}
 8050560:	e7fa      	b.n	8050558 <updateEthLinkStatus+0x1c>
 8050562:	bf00      	nop
 8050564:	200052b0 	.word	0x200052b0
 8050568:	2000a440 	.word	0x2000a440
 805056c:	20003884 	.word	0x20003884

08050570 <GetSector>:
  */
static uint32_t GetSector(uint32_t Address)
{
  uint32_t sector = 0;

  if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
 8050570:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 8050574:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050578:	f0c0 809a 	bcc.w	80506b0 <GetSector+0x140>
  {
    sector = FLASH_SECTOR_0;
  }
  else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
 805057c:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8050580:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050584:	f0c0 8096 	bcc.w	80506b4 <GetSector+0x144>
  {
    sector = FLASH_SECTOR_1;
  }
  else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
 8050588:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 805058c:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 8050590:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050594:	f0c0 8090 	bcc.w	80506b8 <GetSector+0x148>
  {
    sector = FLASH_SECTOR_2;
  }
  else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
 8050598:	f100 4378 	add.w	r3, r0, #4160749568	; 0xf8000000
 805059c:	f5a3 4340 	sub.w	r3, r3, #49152	; 0xc000
 80505a0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80505a4:	f0c0 808a 	bcc.w	80506bc <GetSector+0x14c>
  {
    sector = FLASH_SECTOR_3;
  }
  else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
 80505a8:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505ac:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
 80505b0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80505b4:	f0c0 8084 	bcc.w	80506c0 <GetSector+0x150>
  {
    sector = FLASH_SECTOR_4;
  }
  else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
 80505b8:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505bc:	f503 037e 	add.w	r3, r3, #16646144	; 0xfe0000
 80505c0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80505c4:	d37e      	bcc.n	80506c4 <GetSector+0x154>
  {
    sector = FLASH_SECTOR_5;
  }
  else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
 80505c6:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505ca:	f503 037c 	add.w	r3, r3, #16515072	; 0xfc0000
 80505ce:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80505d2:	d379      	bcc.n	80506c8 <GetSector+0x158>
  {
    sector = FLASH_SECTOR_6;
  }
  else if((Address < ADDR_FLASH_SECTOR_8) && (Address >= ADDR_FLASH_SECTOR_7))
 80505d4:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505d8:	f503 037a 	add.w	r3, r3, #16384000	; 0xfa0000
 80505dc:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80505e0:	d374      	bcc.n	80506cc <GetSector+0x15c>
  {
    sector = FLASH_SECTOR_7;
  }
  else if((Address < ADDR_FLASH_SECTOR_9) && (Address >= ADDR_FLASH_SECTOR_8))
 80505e2:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505e6:	f503 0378 	add.w	r3, r3, #16252928	; 0xf80000
 80505ea:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80505ee:	d36f      	bcc.n	80506d0 <GetSector+0x160>
  {
    sector = FLASH_SECTOR_8;
  }
  else if((Address < ADDR_FLASH_SECTOR_10) && (Address >= ADDR_FLASH_SECTOR_9))
 80505f0:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 80505f4:	f503 0376 	add.w	r3, r3, #16121856	; 0xf60000
 80505f8:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 80505fc:	d36a      	bcc.n	80506d4 <GetSector+0x164>
  {
    sector = FLASH_SECTOR_9;
  }
  else if((Address < ADDR_FLASH_SECTOR_11) && (Address >= ADDR_FLASH_SECTOR_10))
 80505fe:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050602:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 8050606:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 805060a:	d365      	bcc.n	80506d8 <GetSector+0x168>
  {
    sector = FLASH_SECTOR_10;
  }
  else if((Address < ADDR_FLASH_SECTOR_12) && (Address >= ADDR_FLASH_SECTOR_11))
 805060c:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050610:	f503 0372 	add.w	r3, r3, #15859712	; 0xf20000
 8050614:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050618:	d360      	bcc.n	80506dc <GetSector+0x16c>
  {
    sector = FLASH_SECTOR_11;
  }
  else if((Address < ADDR_FLASH_SECTOR_13) && (Address >= ADDR_FLASH_SECTOR_12))
 805061a:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 805061e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050622:	d35d      	bcc.n	80506e0 <GetSector+0x170>
  {
    sector = FLASH_SECTOR_12;
  }
  else if((Address < ADDR_FLASH_SECTOR_14) && (Address >= ADDR_FLASH_SECTOR_13))
 8050624:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 8050628:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 805062c:	d35a      	bcc.n	80506e4 <GetSector+0x174>
  {
    sector = FLASH_SECTOR_13;
  }
  else if((Address < ADDR_FLASH_SECTOR_15) && (Address >= ADDR_FLASH_SECTOR_14))
 805062e:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 8050632:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 8050636:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 805063a:	d355      	bcc.n	80506e8 <GetSector+0x178>
  {
    sector = FLASH_SECTOR_14;
  }
  else if((Address < ADDR_FLASH_SECTOR_16) && (Address >= ADDR_FLASH_SECTOR_15))
 805063c:	f1a0 6301 	sub.w	r3, r0, #135266304	; 0x8100000
 8050640:	f5a3 4340 	sub.w	r3, r3, #49152	; 0xc000
 8050644:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8050648:	d350      	bcc.n	80506ec <GetSector+0x17c>
  {
    sector = FLASH_SECTOR_15;
  }
  else if((Address < ADDR_FLASH_SECTOR_17) && (Address >= ADDR_FLASH_SECTOR_16))
 805064a:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 805064e:	f503 036f 	add.w	r3, r3, #15663104	; 0xef0000
 8050652:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8050656:	d34b      	bcc.n	80506f0 <GetSector+0x180>
  {
    sector = FLASH_SECTOR_16;
  }
  else if((Address < ADDR_FLASH_SECTOR_18) && (Address >= ADDR_FLASH_SECTOR_17))
 8050658:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 805065c:	f503 036e 	add.w	r3, r3, #15597568	; 0xee0000
 8050660:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050664:	d346      	bcc.n	80506f4 <GetSector+0x184>
  {
    sector = FLASH_SECTOR_17;
  }
  else if((Address < ADDR_FLASH_SECTOR_19) && (Address >= ADDR_FLASH_SECTOR_18))
 8050666:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 805066a:	f503 036c 	add.w	r3, r3, #15466496	; 0xec0000
 805066e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050672:	d341      	bcc.n	80506f8 <GetSector+0x188>
  {
    sector = FLASH_SECTOR_18;
  }
  else if((Address < ADDR_FLASH_SECTOR_20) && (Address >= ADDR_FLASH_SECTOR_19))
 8050674:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050678:	f503 036a 	add.w	r3, r3, #15335424	; 0xea0000
 805067c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8050680:	d33c      	bcc.n	80506fc <GetSector+0x18c>
  {
    sector = FLASH_SECTOR_19;
  }
  else if((Address < ADDR_FLASH_SECTOR_21) && (Address >= ADDR_FLASH_SECTOR_20))
 8050682:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050686:	f503 0368 	add.w	r3, r3, #15204352	; 0xe80000
 805068a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 805068e:	d337      	bcc.n	8050700 <GetSector+0x190>
  {
    sector = FLASH_SECTOR_20;
  }
  else if((Address < ADDR_FLASH_SECTOR_22) && (Address >= ADDR_FLASH_SECTOR_21))
 8050690:	f100 4377 	add.w	r3, r0, #4143972352	; 0xf7000000
 8050694:	f503 0366 	add.w	r3, r3, #15073280	; 0xe60000
 8050698:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 805069c:	d332      	bcc.n	8050704 <GetSector+0x194>
  {
    sector = FLASH_SECTOR_21;
  }
  else if((Address < ADDR_FLASH_SECTOR_23) && (Address >= ADDR_FLASH_SECTOR_22))
 805069e:	f100 4077 	add.w	r0, r0, #4143972352	; 0xf7000000
 80506a2:	f500 0064 	add.w	r0, r0, #14942208	; 0xe40000
 80506a6:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 80506aa:	d22d      	bcs.n	8050708 <GetSector+0x198>
  {
    sector = FLASH_SECTOR_22;
 80506ac:	2016      	movs	r0, #22
 80506ae:	4770      	bx	lr
    sector = FLASH_SECTOR_0;
 80506b0:	2000      	movs	r0, #0
 80506b2:	4770      	bx	lr
    sector = FLASH_SECTOR_1;
 80506b4:	2001      	movs	r0, #1
 80506b6:	4770      	bx	lr
    sector = FLASH_SECTOR_2;
 80506b8:	2002      	movs	r0, #2
 80506ba:	4770      	bx	lr
    sector = FLASH_SECTOR_3;
 80506bc:	2003      	movs	r0, #3
 80506be:	4770      	bx	lr
    sector = FLASH_SECTOR_4;
 80506c0:	2004      	movs	r0, #4
 80506c2:	4770      	bx	lr
    sector = FLASH_SECTOR_5;
 80506c4:	2005      	movs	r0, #5
 80506c6:	4770      	bx	lr
    sector = FLASH_SECTOR_6;
 80506c8:	2006      	movs	r0, #6
 80506ca:	4770      	bx	lr
    sector = FLASH_SECTOR_7;
 80506cc:	2007      	movs	r0, #7
 80506ce:	4770      	bx	lr
    sector = FLASH_SECTOR_8;
 80506d0:	2008      	movs	r0, #8
 80506d2:	4770      	bx	lr
    sector = FLASH_SECTOR_9;
 80506d4:	2009      	movs	r0, #9
 80506d6:	4770      	bx	lr
    sector = FLASH_SECTOR_10;
 80506d8:	200a      	movs	r0, #10
 80506da:	4770      	bx	lr
    sector = FLASH_SECTOR_11;
 80506dc:	200b      	movs	r0, #11
 80506de:	4770      	bx	lr
    sector = FLASH_SECTOR_12;
 80506e0:	200c      	movs	r0, #12
 80506e2:	4770      	bx	lr
    sector = FLASH_SECTOR_13;
 80506e4:	200d      	movs	r0, #13
 80506e6:	4770      	bx	lr
    sector = FLASH_SECTOR_14;
 80506e8:	200e      	movs	r0, #14
 80506ea:	4770      	bx	lr
    sector = FLASH_SECTOR_15;
 80506ec:	200f      	movs	r0, #15
 80506ee:	4770      	bx	lr
    sector = FLASH_SECTOR_16;
 80506f0:	2010      	movs	r0, #16
 80506f2:	4770      	bx	lr
    sector = FLASH_SECTOR_17;
 80506f4:	2011      	movs	r0, #17
 80506f6:	4770      	bx	lr
    sector = FLASH_SECTOR_18;
 80506f8:	2012      	movs	r0, #18
 80506fa:	4770      	bx	lr
    sector = FLASH_SECTOR_19;
 80506fc:	2013      	movs	r0, #19
 80506fe:	4770      	bx	lr
    sector = FLASH_SECTOR_20;
 8050700:	2014      	movs	r0, #20
 8050702:	4770      	bx	lr
    sector = FLASH_SECTOR_21;
 8050704:	2015      	movs	r0, #21
 8050706:	4770      	bx	lr
  }
  else/*(Address < FLASH_END_ADDR) && (Address >= ADDR_FLASH_SECTOR_23))*/
  {
    sector = FLASH_SECTOR_23;
 8050708:	2017      	movs	r0, #23
  }
  return sector;
}
 805070a:	4770      	bx	lr

0805070c <FLASH_If_Init>:
{
 805070c:	b508      	push	{r3, lr}
  HAL_FLASH_Unlock();
 805070e:	f7f2 f893 	bl	8042838 <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8050712:	4b02      	ldr	r3, [pc, #8]	; (805071c <FLASH_If_Init+0x10>)
 8050714:	22f3      	movs	r2, #243	; 0xf3
 8050716:	60da      	str	r2, [r3, #12]
}
 8050718:	bd08      	pop	{r3, pc}
 805071a:	bf00      	nop
 805071c:	40023c00 	.word	0x40023c00

08050720 <FLASH_If_Erase>:
{
 8050720:	b510      	push	{r4, lr}
 8050722:	b086      	sub	sp, #24
 8050724:	4604      	mov	r4, r0
  FLASH_If_Init();
 8050726:	f7ff fff1 	bl	805070c <FLASH_If_Init>
  UserStartSector = GetSector(StartSector);
 805072a:	4620      	mov	r0, r4
 805072c:	f7ff ff20 	bl	8050570 <GetSector>
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8050730:	2300      	movs	r3, #0
 8050732:	9300      	str	r3, [sp, #0]
  pEraseInit.Sector = UserStartSector;
 8050734:	9002      	str	r0, [sp, #8]
  pEraseInit.NbSectors = 1;
 8050736:	2301      	movs	r3, #1
 8050738:	9303      	str	r3, [sp, #12]
  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 805073a:	2302      	movs	r3, #2
 805073c:	9304      	str	r3, [sp, #16]
  if (HAL_FLASHEx_Erase(&pEraseInit, &SectorError) != HAL_OK)
 805073e:	a905      	add	r1, sp, #20
 8050740:	4668      	mov	r0, sp
 8050742:	f7f2 f98d 	bl	8042a60 <HAL_FLASHEx_Erase>
 8050746:	b908      	cbnz	r0, 805074c <FLASH_If_Erase+0x2c>
}
 8050748:	b006      	add	sp, #24
 805074a:	bd10      	pop	{r4, pc}
     return (1);
 805074c:	2001      	movs	r0, #1
 805074e:	e7fb      	b.n	8050748 <FLASH_If_Erase+0x28>

08050750 <FLASH_If_Write>:
{
 8050750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8050752:	4604      	mov	r4, r0
 8050754:	460e      	mov	r6, r1
 8050756:	4617      	mov	r7, r2
  FLASH_If_Init();
 8050758:	f7ff ffd8 	bl	805070c <FLASH_If_Init>
  for (i = 0; (i < (DataLength / 4)) && (FlashAddress <= (USER_FLASH_END_ADDRESS - 4)); i++)//USER_FLASH_END_ADDRESS
 805075c:	2500      	movs	r5, #0
 805075e:	e003      	b.n	8050768 <FLASH_If_Write+0x18>
      FlashAddress += 4;
 8050760:	3404      	adds	r4, #4
      u32LastMemoryWriteLocation = FlashAddress;
 8050762:	4b13      	ldr	r3, [pc, #76]	; (80507b0 <FLASH_If_Write+0x60>)
 8050764:	601c      	str	r4, [r3, #0]
  for (i = 0; (i < (DataLength / 4)) && (FlashAddress <= (USER_FLASH_END_ADDRESS - 4)); i++)//USER_FLASH_END_ADDRESS
 8050766:	3501      	adds	r5, #1
 8050768:	ebb5 0f97 	cmp.w	r5, r7, lsr #2
 805076c:	d219      	bcs.n	80507a2 <FLASH_If_Write+0x52>
 805076e:	4b11      	ldr	r3, [pc, #68]	; (80507b4 <FLASH_If_Write+0x64>)
 8050770:	429c      	cmp	r4, r3
 8050772:	d816      	bhi.n	80507a2 <FLASH_If_Write+0x52>
    if (HAL_FLASH_Program(TYPEPROGRAM_WORD, FlashAddress, *(uint32_t*)(Data+i)) == HAL_OK)
 8050774:	f856 2025 	ldr.w	r2, [r6, r5, lsl #2]
 8050778:	2300      	movs	r3, #0
 805077a:	4621      	mov	r1, r4
 805077c:	2002      	movs	r0, #2
 805077e:	f7f2 f8ad 	bl	80428dc <HAL_FLASH_Program>
 8050782:	b948      	cbnz	r0, 8050798 <FLASH_If_Write+0x48>
      if (*(uint32_t*)FlashAddress != *(uint32_t*)(Data+i))
 8050784:	6821      	ldr	r1, [r4, #0]
 8050786:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 805078a:	4299      	cmp	r1, r3
 805078c:	d0e8      	beq.n	8050760 <FLASH_If_Write+0x10>
    	Diagnostic(enmDiagnostic_MEM_WR_CHK_SUM_ERROR);
 805078e:	200b      	movs	r0, #11
 8050790:	f7fb ff42 	bl	804c618 <Diagnostic>
        return(FLASHIF_WRITINGCTRL_ERROR);
 8050794:	2002      	movs	r0, #2
 8050796:	e009      	b.n	80507ac <FLASH_If_Write+0x5c>
    	Diagnostic(enmDiagnostic_MEM_WR_ERROR);
 8050798:	200a      	movs	r0, #10
 805079a:	f7fb ff3d 	bl	804c618 <Diagnostic>
    	return (FLASHIF_WRITING_ERROR);
 805079e:	2003      	movs	r0, #3
 80507a0:	e004      	b.n	80507ac <FLASH_If_Write+0x5c>
  u32LastMemoryWriteLocation = FlashAddress;
 80507a2:	4b03      	ldr	r3, [pc, #12]	; (80507b0 <FLASH_If_Write+0x60>)
 80507a4:	601c      	str	r4, [r3, #0]
  HAL_FLASH_Lock();
 80507a6:	f7f2 f85f 	bl	8042868 <HAL_FLASH_Lock>
  return (FLASHIF_OK);
 80507aa:	2000      	movs	r0, #0
}
 80507ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80507ae:	bf00      	nop
 80507b0:	200052b4 	.word	0x200052b4
 80507b4:	081dfffc 	.word	0x081dfffc

080507b8 <WriteDatatoFlash>:
 Change History:
 Author           	Date                Remarks
 KloudQ Team      26-07-2021			Initial Definition
******************************************************************************/
uint32_t WriteDatatoFlash(uint32_t Sector,uint8_t *data,uint32_t configLen,uint32_t writeCycle)
{
 80507b8:	b508      	push	{r3, lr}
	if(FLASH_If_Write(Sector,(uint32_t*)data,configLen) == FLASHIF_OK)
 80507ba:	f7ff ffc9 	bl	8050750 <FLASH_If_Write>
 80507be:	b100      	cbz	r0, 80507c2 <WriteDatatoFlash+0xa>
		return SUCCESS;
	else
		return ERROR;
 80507c0:	2001      	movs	r0, #1
}
 80507c2:	bd08      	pop	{r3, pc}

080507c4 <FLASH_If_Erase_User>:
 Author            	Date                Remarks
 KloudQ Team        26/03/2020			initial Definitions
 Kloudq Team		28/04/2020			Memory Segment Logic Added
******************************************************************************/
uint32_t FLASH_If_Erase_User(uint32_t start,enmBootMemorySegment memorySegment)
{
 80507c4:	b510      	push	{r4, lr}
 80507c6:	b086      	sub	sp, #24
 80507c8:	460c      	mov	r4, r1
	uint32_t UserStartSector;
	uint32_t SectorError;
	FLASH_EraseInitTypeDef pEraseInit;

	/* Unlock the Flash to enable the flash control register access *************/
	FLASH_If_Init();
 80507ca:	f7ff ff9f 	bl	805070c <FLASH_If_Init>

  /* Get the sector where start the user flash area */
  if(memorySegment == enmBOOTSEGMENT_X_JUMP)
 80507ce:	2c58      	cmp	r4, #88	; 0x58
 80507d0:	d009      	beq.n	80507e6 <FLASH_If_Erase_User+0x22>
	  else
		  pEraseInit.NbSectors = 1;
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;

  }
  else if(memorySegment == enmBOOTSEGMENT_Y_JUMP)
 80507d2:	2c59      	cmp	r4, #89	; 0x59
 80507d4:	d018      	beq.n	8050808 <FLASH_If_Erase_User+0x44>
		  pEraseInit.NbSectors = 1;
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
  }
  /* Lock the Flash to disable the flash control register access (recommended
     to protect the FLASH memory against possible unwanted operation) *********/
	if (HAL_FLASHEx_Erase(&pEraseInit, &SectorError) != HAL_OK)
 80507d6:	a905      	add	r1, sp, #20
 80507d8:	4668      	mov	r0, sp
 80507da:	f7f2 f941 	bl	8042a60 <HAL_FLASHEx_Erase>
 80507de:	bb20      	cbnz	r0, 805082a <FLASH_If_Erase_User+0x66>
	{
		/* Error occurred while page erase */
		return (FLASHIF_WRITING_ERROR);
	}
	else
		return (FLASHIF_OK);
 80507e0:	2000      	movs	r0, #0
}
 80507e2:	b006      	add	sp, #24
 80507e4:	bd10      	pop	{r4, pc}
	  UserStartSector = GetSector(APPLICATION_ADD_X);
 80507e6:	4812      	ldr	r0, [pc, #72]	; (8050830 <FLASH_If_Erase_User+0x6c>)
 80507e8:	f7ff fec2 	bl	8050570 <GetSector>
	  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 80507ec:	2300      	movs	r3, #0
 80507ee:	9300      	str	r3, [sp, #0]
	  pEraseInit.Sector = UserStartSector;
 80507f0:	9002      	str	r0, [sp, #8]
	  if(u32ConfigFileReadComplete == 0)
 80507f2:	4b10      	ldr	r3, [pc, #64]	; (8050834 <FLASH_If_Erase_User+0x70>)
 80507f4:	681b      	ldr	r3, [r3, #0]
 80507f6:	b923      	cbnz	r3, 8050802 <FLASH_If_Erase_User+0x3e>
		  pEraseInit.NbSectors = 10;
 80507f8:	230a      	movs	r3, #10
 80507fa:	9303      	str	r3, [sp, #12]
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 80507fc:	2302      	movs	r3, #2
 80507fe:	9304      	str	r3, [sp, #16]
 8050800:	e7e9      	b.n	80507d6 <FLASH_If_Erase_User+0x12>
		  pEraseInit.NbSectors = 1;
 8050802:	2301      	movs	r3, #1
 8050804:	9303      	str	r3, [sp, #12]
 8050806:	e7f9      	b.n	80507fc <FLASH_If_Erase_User+0x38>
	  UserStartSector = GetSector(APPLICATION_ADD_Y);
 8050808:	480b      	ldr	r0, [pc, #44]	; (8050838 <FLASH_If_Erase_User+0x74>)
 805080a:	f7ff feb1 	bl	8050570 <GetSector>
	  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 805080e:	2300      	movs	r3, #0
 8050810:	9300      	str	r3, [sp, #0]
	  pEraseInit.Sector = UserStartSector;
 8050812:	9002      	str	r0, [sp, #8]
	  if(u32ConfigFileReadComplete == 0)
 8050814:	4b07      	ldr	r3, [pc, #28]	; (8050834 <FLASH_If_Erase_User+0x70>)
 8050816:	681b      	ldr	r3, [r3, #0]
 8050818:	b923      	cbnz	r3, 8050824 <FLASH_If_Erase_User+0x60>
		  pEraseInit.NbSectors = 10;
 805081a:	230a      	movs	r3, #10
 805081c:	9303      	str	r3, [sp, #12]
	  pEraseInit.VoltageRange = VOLTAGE_RANGE_3;
 805081e:	2302      	movs	r3, #2
 8050820:	9304      	str	r3, [sp, #16]
 8050822:	e7d8      	b.n	80507d6 <FLASH_If_Erase_User+0x12>
		  pEraseInit.NbSectors = 1;
 8050824:	2301      	movs	r3, #1
 8050826:	9303      	str	r3, [sp, #12]
 8050828:	e7f9      	b.n	805081e <FLASH_If_Erase_User+0x5a>
		return (FLASHIF_WRITING_ERROR);
 805082a:	2003      	movs	r0, #3
 805082c:	e7d9      	b.n	80507e2 <FLASH_If_Erase_User+0x1e>
 805082e:	bf00      	nop
 8050830:	08004000 	.word	0x08004000
 8050834:	20004504 	.word	0x20004504
 8050838:	08104000 	.word	0x08104000

0805083c <getNewFirmwareStorageLocation>:
 KloudQ Team        30/03/2020			initial Definitions
******************************************************************************/
/* TODO:  Need to take care for empty memory  */
enmBootMemorySegment getNewFirmwareStorageLocation(void)
{
	if(BOOTMEMORYINFO == enmBOOTSEGMENT_X_JUMP)
 805083c:	f04f 6301 	mov.w	r3, #135266304	; 0x8100000
 8050840:	681b      	ldr	r3, [r3, #0]
 8050842:	2b58      	cmp	r3, #88	; 0x58
 8050844:	d009      	beq.n	805085a <getNewFirmwareStorageLocation+0x1e>
			u32LastMemoryWriteLocation = APPLICATION_ADD_X;

		return enmBOOTSEGMENT_X_JUMP;

	}
	else if(BOOTMEMORYINFO == enmBOOTSEGMENT_Y_JUMP)
 8050846:	2b59      	cmp	r3, #89	; 0x59
 8050848:	d00f      	beq.n	805086a <getNewFirmwareStorageLocation+0x2e>
		return enmBOOTSEGMENT_Y_JUMP;
	}
	else
	{
		/* Illegal Firmware Information . Abort FOTA Jumping */
		if(u32ConfigFileReadComplete == 0)
 805084a:	4b0c      	ldr	r3, [pc, #48]	; (805087c <getNewFirmwareStorageLocation+0x40>)
 805084c:	681b      	ldr	r3, [r3, #0]
 805084e:	b913      	cbnz	r3, 8050856 <getNewFirmwareStorageLocation+0x1a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_Y;
 8050850:	4b0b      	ldr	r3, [pc, #44]	; (8050880 <getNewFirmwareStorageLocation+0x44>)
 8050852:	4a0c      	ldr	r2, [pc, #48]	; (8050884 <getNewFirmwareStorageLocation+0x48>)
 8050854:	601a      	str	r2, [r3, #0]

		return enmBOOTSEGMENT_Y_JUMP;//enmBOOTSEGMENT_UNKNOWN;
 8050856:	2059      	movs	r0, #89	; 0x59
	}
}
 8050858:	4770      	bx	lr
		if(u32ConfigFileReadComplete == 0)
 805085a:	4b08      	ldr	r3, [pc, #32]	; (805087c <getNewFirmwareStorageLocation+0x40>)
 805085c:	681b      	ldr	r3, [r3, #0]
 805085e:	b913      	cbnz	r3, 8050866 <getNewFirmwareStorageLocation+0x2a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_X;
 8050860:	4b07      	ldr	r3, [pc, #28]	; (8050880 <getNewFirmwareStorageLocation+0x44>)
 8050862:	4a09      	ldr	r2, [pc, #36]	; (8050888 <getNewFirmwareStorageLocation+0x4c>)
 8050864:	601a      	str	r2, [r3, #0]
		return enmBOOTSEGMENT_X_JUMP;
 8050866:	2058      	movs	r0, #88	; 0x58
 8050868:	4770      	bx	lr
		if(u32ConfigFileReadComplete == 0)
 805086a:	4b04      	ldr	r3, [pc, #16]	; (805087c <getNewFirmwareStorageLocation+0x40>)
 805086c:	681b      	ldr	r3, [r3, #0]
 805086e:	b913      	cbnz	r3, 8050876 <getNewFirmwareStorageLocation+0x3a>
			u32LastMemoryWriteLocation = APPLICATION_ADD_Y;
 8050870:	4b03      	ldr	r3, [pc, #12]	; (8050880 <getNewFirmwareStorageLocation+0x44>)
 8050872:	4a04      	ldr	r2, [pc, #16]	; (8050884 <getNewFirmwareStorageLocation+0x48>)
 8050874:	601a      	str	r2, [r3, #0]
		return enmBOOTSEGMENT_Y_JUMP;
 8050876:	2059      	movs	r0, #89	; 0x59
 8050878:	4770      	bx	lr
 805087a:	bf00      	nop
 805087c:	20004504 	.word	0x20004504
 8050880:	200052b4 	.word	0x200052b4
 8050884:	08104000 	.word	0x08104000
 8050888:	08004000 	.word	0x08004000

0805088c <flashWriteBootSection>:
 KloudQ Team        26/03/2020			initial Definitions
 Kloudq Team		27/03/2020			Wr/Rd Tested , Timeout added
******************************************************************************/
uint32_t gu32DataFromMemory = 0;
uint32_t flashWriteBootSection(enmBootMemorySegment memorySegment)
{
 805088c:	b538      	push	{r3, r4, r5, lr}
 805088e:	4604      	mov	r4, r0
	uint32_t status = 0;
	if(FLASH_If_Erase(ADDR_FLASH_SECTOR_12) != FLASHIF_OK)
 8050890:	f04f 6001 	mov.w	r0, #135266304	; 0x8100000
 8050894:	f7ff ff44 	bl	8050720 <FLASH_If_Erase>
 8050898:	b9d0      	cbnz	r0, 80508d0 <flashWriteBootSection+0x44>
 805089a:	4605      	mov	r5, r0
		status = 1;
	}
	else
	{
		/* FOTA Storage location update  */
		switch(memorySegment)
 805089c:	2c58      	cmp	r4, #88	; 0x58
 805089e:	d003      	beq.n	80508a8 <flashWriteBootSection+0x1c>
 80508a0:	2c59      	cmp	r4, #89	; 0x59
 80508a2:	d00b      	beq.n	80508bc <flashWriteBootSection+0x30>
 80508a4:	2501      	movs	r5, #1
 80508a6:	e014      	b.n	80508d2 <flashWriteBootSection+0x46>
		{

			case enmBOOTSEGMENT_X_JUMP:
				u32LastMemoryWriteLocation = ADDR_FLASH_SECTOR_12;
 80508a8:	f04f 6101 	mov.w	r1, #135266304	; 0x8100000
 80508ac:	4b0a      	ldr	r3, [pc, #40]	; (80508d8 <flashWriteBootSection+0x4c>)
 80508ae:	6019      	str	r1, [r3, #0]
				if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, u32LastMemoryWriteLocation,(uint32_t)0x58) == HAL_OK)
 80508b0:	2258      	movs	r2, #88	; 0x58
 80508b2:	2300      	movs	r3, #0
 80508b4:	2002      	movs	r0, #2
 80508b6:	f7f2 f811 	bl	80428dc <HAL_FLASH_Program>
 80508ba:	e00a      	b.n	80508d2 <flashWriteBootSection+0x46>
					status = 0;
				}
				break;

			case enmBOOTSEGMENT_Y_JUMP:
				u32LastMemoryWriteLocation = ADDR_FLASH_SECTOR_12;
 80508bc:	f04f 6101 	mov.w	r1, #135266304	; 0x8100000
 80508c0:	4b05      	ldr	r3, [pc, #20]	; (80508d8 <flashWriteBootSection+0x4c>)
 80508c2:	6019      	str	r1, [r3, #0]
				if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, u32LastMemoryWriteLocation,(uint32_t)0x59) == HAL_OK)
 80508c4:	2259      	movs	r2, #89	; 0x59
 80508c6:	2300      	movs	r3, #0
 80508c8:	2002      	movs	r0, #2
 80508ca:	f7f2 f807 	bl	80428dc <HAL_FLASH_Program>
 80508ce:	e000      	b.n	80508d2 <flashWriteBootSection+0x46>
		status = 1;
 80508d0:	2501      	movs	r5, #1
				status = 1;
				break;
		}
	}
	return status;
}
 80508d2:	4628      	mov	r0, r5
 80508d4:	bd38      	pop	{r3, r4, r5, pc}
 80508d6:	bf00      	nop
 80508d8:	200052b4 	.word	0x200052b4

080508dc <HAL_RTCEx_WakeUpTimerEventCallback>:
*******************************************************************************/

void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
{
	//HAL_GPIO_TogglePin(LED_1_GPIO_Port,LED_1_Pin);
}
 80508dc:	4770      	bx	lr

080508de <HAL_RTC_AlarmAEventCallback>:
*
*******************************************************************************/
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{

}
 80508de:	4770      	bx	lr

080508e0 <getRTCCalender>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void getRTCCalender(void)
{
 80508e0:	b570      	push	{r4, r5, r6, lr}
 80508e2:	b082      	sub	sp, #8

  /* Get the RTC current Time */
  HAL_RTC_GetTime(&hrtc, &stimestructureget, RTC_FORMAT_BIN);
 80508e4:	4d11      	ldr	r5, [pc, #68]	; (805092c <getRTCCalender+0x4c>)
 80508e6:	4e12      	ldr	r6, [pc, #72]	; (8050930 <getRTCCalender+0x50>)
 80508e8:	2200      	movs	r2, #0
 80508ea:	4629      	mov	r1, r5
 80508ec:	4630      	mov	r0, r6
 80508ee:	f7f4 f978 	bl	8044be2 <HAL_RTC_GetTime>
  /* Get the RTC current Date */
  HAL_RTC_GetDate(&hrtc, &sdatestructureget, RTC_FORMAT_BIN);
 80508f2:	4c10      	ldr	r4, [pc, #64]	; (8050934 <getRTCCalender+0x54>)
 80508f4:	2200      	movs	r2, #0
 80508f6:	4621      	mov	r1, r4
 80508f8:	4630      	mov	r0, r6
 80508fa:	f7f4 f99a 	bl	8044c32 <HAL_RTC_GetDate>

  /* Display time Format : hh:mm:ss */
  sprintf((char*)aShowTimeStamp,"%.2d:%.2d:%.2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
 80508fe:	78ab      	ldrb	r3, [r5, #2]
 8050900:	4e0d      	ldr	r6, [pc, #52]	; (8050938 <getRTCCalender+0x58>)
 8050902:	9300      	str	r3, [sp, #0]
 8050904:	786b      	ldrb	r3, [r5, #1]
 8050906:	782a      	ldrb	r2, [r5, #0]
 8050908:	490c      	ldr	r1, [pc, #48]	; (805093c <getRTCCalender+0x5c>)
 805090a:	4630      	mov	r0, r6
 805090c:	f000 fc90 	bl	8051230 <sprintf>
  /* Display date Format : mm-dd-yy */
  sprintf((char*)aShowDateStamp,"%.2d/%.2d/%.2d",sdatestructureget.Date, sdatestructureget.Month, 2000 + sdatestructureget.Year);
 8050910:	78e3      	ldrb	r3, [r4, #3]
 8050912:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 8050916:	9300      	str	r3, [sp, #0]
 8050918:	7863      	ldrb	r3, [r4, #1]
 805091a:	78a2      	ldrb	r2, [r4, #2]
 805091c:	4908      	ldr	r1, [pc, #32]	; (8050940 <getRTCCalender+0x60>)
 805091e:	f106 0034 	add.w	r0, r6, #52	; 0x34
 8050922:	f000 fc85 	bl	8051230 <sprintf>
}
 8050926:	b002      	add	sp, #8
 8050928:	bd70      	pop	{r4, r5, r6, pc}
 805092a:	bf00      	nop
 805092c:	2001031c 	.word	0x2001031c
 8050930:	2000f5b8 	.word	0x2000f5b8
 8050934:	20010314 	.word	0x20010314
 8050938:	200052cc 	.word	0x200052cc
 805093c:	0805a2dc 	.word	0x0805a2dc
 8050940:	0805a2ec 	.word	0x0805a2ec

08050944 <readbackedupRTCCalender>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void readbackedupRTCCalender(void)
{
 8050944:	b538      	push	{r3, r4, r5, lr}
   /* Read Data */
   sTimeStampget_backup.Hours = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1);
 8050946:	4c11      	ldr	r4, [pc, #68]	; (805098c <readbackedupRTCCalender+0x48>)
 8050948:	2101      	movs	r1, #1
 805094a:	4620      	mov	r0, r4
 805094c:	f7f4 fa36 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 8050950:	4d0f      	ldr	r5, [pc, #60]	; (8050990 <readbackedupRTCCalender+0x4c>)
 8050952:	7028      	strb	r0, [r5, #0]
   sTimeStampget_backup.Minutes = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR2);
 8050954:	2102      	movs	r1, #2
 8050956:	4620      	mov	r0, r4
 8050958:	f7f4 fa30 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 805095c:	7068      	strb	r0, [r5, #1]
   sTimeStampget_backup.Seconds = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR3);
 805095e:	2103      	movs	r1, #3
 8050960:	4620      	mov	r0, r4
 8050962:	f7f4 fa2b 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 8050966:	70a8      	strb	r0, [r5, #2]
   sTimeStampDateget_backup.Date =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR4);
 8050968:	2104      	movs	r1, #4
 805096a:	4620      	mov	r0, r4
 805096c:	f7f4 fa26 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 8050970:	4d08      	ldr	r5, [pc, #32]	; (8050994 <readbackedupRTCCalender+0x50>)
 8050972:	70a8      	strb	r0, [r5, #2]
   sTimeStampDateget_backup.Month =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR5);
 8050974:	2105      	movs	r1, #5
 8050976:	4620      	mov	r0, r4
 8050978:	f7f4 fa20 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 805097c:	7068      	strb	r0, [r5, #1]
   sTimeStampDateget_backup.Year =  HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR6);
 805097e:	2106      	movs	r1, #6
 8050980:	4620      	mov	r0, r4
 8050982:	f7f4 fa1b 	bl	8044dbc <HAL_RTCEx_BKUPRead>
 8050986:	70e8      	strb	r0, [r5, #3]
}
 8050988:	bd38      	pop	{r3, r4, r5, pc}
 805098a:	bf00      	nop
 805098c:	2000f5b8 	.word	0x2000f5b8
 8050990:	20008b5c 	.word	0x20008b5c
 8050994:	20010318 	.word	0x20010318

08050998 <DecimalToBCD>:
* <hr>
*
*******************************************************************************/
uint32_t DecimalToBCD (uint32_t Decimal)
{
   return (((Decimal/10) << 4) | (Decimal % 10));
 8050998:	4b05      	ldr	r3, [pc, #20]	; (80509b0 <DecimalToBCD+0x18>)
 805099a:	fba3 2300 	umull	r2, r3, r3, r0
 805099e:	08db      	lsrs	r3, r3, #3
 80509a0:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80509a4:	eba0 0042 	sub.w	r0, r0, r2, lsl #1
}
 80509a8:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
 80509ac:	4770      	bx	lr
 80509ae:	bf00      	nop
 80509b0:	cccccccd 	.word	0xcccccccd

080509b4 <BCDToDecimal>:
* <hr>
*
*******************************************************************************/
uint32_t BCDToDecimal(uint32_t BCD)
{
   return (((BCD >> 4) * 10) + (BCD & 0xF));
 80509b4:	0903      	lsrs	r3, r0, #4
 80509b6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80509ba:	f000 000f 	and.w	r0, r0, #15
}
 80509be:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 80509c2:	4770      	bx	lr

080509c4 <getrtcStamp>:
* </table><br><br>
* <hr>
*
*******************************************************************************/
void getrtcStamp(void)
{
 80509c4:	b570      	push	{r4, r5, r6, lr}
	HAL_RTC_GetTime(&hrtc,&STime1,RTC_FORMAT_BCD);
 80509c6:	4d1f      	ldr	r5, [pc, #124]	; (8050a44 <getrtcStamp+0x80>)
 80509c8:	4c1f      	ldr	r4, [pc, #124]	; (8050a48 <getrtcStamp+0x84>)
 80509ca:	2201      	movs	r2, #1
 80509cc:	4629      	mov	r1, r5
 80509ce:	4620      	mov	r0, r4
 80509d0:	f7f4 f907 	bl	8044be2 <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc,&SDate1,RTC_FORMAT_BCD);
 80509d4:	4e1d      	ldr	r6, [pc, #116]	; (8050a4c <getrtcStamp+0x88>)
 80509d6:	2201      	movs	r2, #1
 80509d8:	4631      	mov	r1, r6
 80509da:	4620      	mov	r0, r4
 80509dc:	f7f4 f929 	bl	8044c32 <HAL_RTC_GetDate>

	itoa(BCDToDecimal(SDate1.Year),gau8Year,PAYLOAD_DATA_STRING_RADIX);
 80509e0:	78f0      	ldrb	r0, [r6, #3]
 80509e2:	f7ff ffe7 	bl	80509b4 <BCDToDecimal>
 80509e6:	4c1a      	ldr	r4, [pc, #104]	; (8050a50 <getrtcStamp+0x8c>)
 80509e8:	220a      	movs	r2, #10
 80509ea:	4621      	mov	r1, r4
 80509ec:	f000 f97a 	bl	8050ce4 <itoa>
	itoa(BCDToDecimal(SDate1.Month),gau8Month,PAYLOAD_DATA_STRING_RADIX);
 80509f0:	7870      	ldrb	r0, [r6, #1]
 80509f2:	f7ff ffdf 	bl	80509b4 <BCDToDecimal>
 80509f6:	220a      	movs	r2, #10
 80509f8:	f104 0108 	add.w	r1, r4, #8
 80509fc:	f000 f972 	bl	8050ce4 <itoa>
	itoa(BCDToDecimal(SDate1.Date),gau8Date,PAYLOAD_DATA_STRING_RADIX);
 8050a00:	78b0      	ldrb	r0, [r6, #2]
 8050a02:	f7ff ffd7 	bl	80509b4 <BCDToDecimal>
 8050a06:	220a      	movs	r2, #10
 8050a08:	f104 0110 	add.w	r1, r4, #16
 8050a0c:	f000 f96a 	bl	8050ce4 <itoa>

	itoa(BCDToDecimal(STime1.Hours),gau8Hour,PAYLOAD_DATA_STRING_RADIX);
 8050a10:	7828      	ldrb	r0, [r5, #0]
 8050a12:	f7ff ffcf 	bl	80509b4 <BCDToDecimal>
 8050a16:	220a      	movs	r2, #10
 8050a18:	f104 0118 	add.w	r1, r4, #24
 8050a1c:	f000 f962 	bl	8050ce4 <itoa>
	itoa(BCDToDecimal(STime1.Minutes),gau8Minutes,PAYLOAD_DATA_STRING_RADIX);
 8050a20:	7868      	ldrb	r0, [r5, #1]
 8050a22:	f7ff ffc7 	bl	80509b4 <BCDToDecimal>
 8050a26:	220a      	movs	r2, #10
 8050a28:	f104 0120 	add.w	r1, r4, #32
 8050a2c:	f000 f95a 	bl	8050ce4 <itoa>
	itoa(BCDToDecimal(STime1.Seconds),gau8Seconds,PAYLOAD_DATA_STRING_RADIX);
 8050a30:	78a8      	ldrb	r0, [r5, #2]
 8050a32:	f7ff ffbf 	bl	80509b4 <BCDToDecimal>
 8050a36:	220a      	movs	r2, #10
 8050a38:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8050a3c:	f000 f952 	bl	8050ce4 <itoa>
}
 8050a40:	bd70      	pop	{r4, r5, r6, pc}
 8050a42:	bf00      	nop
 8050a44:	200051dc 	.word	0x200051dc
 8050a48:	2000f5b8 	.word	0x2000f5b8
 8050a4c:	200051f0 	.word	0x200051f0
 8050a50:	20003888 	.word	0x20003888

08050a54 <HAL_TIM_PeriodElapsedCallback>:
volatile uint32_t gu32UploadFailTimer = TEN_MIN;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* Timer 7 . 1 ms Interrupt */
	if(htim->Instance == TIM7)
 8050a54:	6802      	ldr	r2, [r0, #0]
 8050a56:	4b62      	ldr	r3, [pc, #392]	; (8050be0 <HAL_TIM_PeriodElapsedCallback+0x18c>)
 8050a58:	429a      	cmp	r2, r3
 8050a5a:	d000      	beq.n	8050a5e <HAL_TIM_PeriodElapsedCallback+0xa>
		if(gu32FotaRquestFlag == FALSE)
		{
			if(gu32SystemResetTimer)gu32SystemResetTimer--;
		}
	}
	}
 8050a5c:	4770      	bx	lr
		if(gu32MBTCPTimer)gu32MBTCPTimer--;
 8050a5e:	4b61      	ldr	r3, [pc, #388]	; (8050be4 <HAL_TIM_PeriodElapsedCallback+0x190>)
 8050a60:	681b      	ldr	r3, [r3, #0]
 8050a62:	b113      	cbz	r3, 8050a6a <HAL_TIM_PeriodElapsedCallback+0x16>
 8050a64:	3b01      	subs	r3, #1
 8050a66:	4a5f      	ldr	r2, [pc, #380]	; (8050be4 <HAL_TIM_PeriodElapsedCallback+0x190>)
 8050a68:	6013      	str	r3, [r2, #0]
		if(gu32MBPOLLTimer)gu32MBPOLLTimer--;
 8050a6a:	4b5f      	ldr	r3, [pc, #380]	; (8050be8 <HAL_TIM_PeriodElapsedCallback+0x194>)
 8050a6c:	681b      	ldr	r3, [r3, #0]
 8050a6e:	b113      	cbz	r3, 8050a76 <HAL_TIM_PeriodElapsedCallback+0x22>
 8050a70:	3b01      	subs	r3, #1
 8050a72:	4a5d      	ldr	r2, [pc, #372]	; (8050be8 <HAL_TIM_PeriodElapsedCallback+0x194>)
 8050a74:	6013      	str	r3, [r2, #0]
		if(master.u32PollDelay)master.u32PollDelay--;
 8050a76:	4b5d      	ldr	r3, [pc, #372]	; (8050bec <HAL_TIM_PeriodElapsedCallback+0x198>)
 8050a78:	f8d3 3e4c 	ldr.w	r3, [r3, #3660]	; 0xe4c
 8050a7c:	b11b      	cbz	r3, 8050a86 <HAL_TIM_PeriodElapsedCallback+0x32>
 8050a7e:	3b01      	subs	r3, #1
 8050a80:	4a5a      	ldr	r2, [pc, #360]	; (8050bec <HAL_TIM_PeriodElapsedCallback+0x198>)
 8050a82:	f8c2 3e4c 	str.w	r3, [r2, #3660]	; 0xe4c
		if(gu32MBCharacterDelay)gu32MBCharacterDelay--;
 8050a86:	4b5a      	ldr	r3, [pc, #360]	; (8050bf0 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 8050a88:	681b      	ldr	r3, [r3, #0]
 8050a8a:	b113      	cbz	r3, 8050a92 <HAL_TIM_PeriodElapsedCallback+0x3e>
 8050a8c:	3b01      	subs	r3, #1
 8050a8e:	4a58      	ldr	r2, [pc, #352]	; (8050bf0 <HAL_TIM_PeriodElapsedCallback+0x19c>)
 8050a90:	6013      	str	r3, [r2, #0]
		if(gu32ModbusFrameEndTimer)gu32ModbusFrameEndTimer--;
 8050a92:	4b58      	ldr	r3, [pc, #352]	; (8050bf4 <HAL_TIM_PeriodElapsedCallback+0x1a0>)
 8050a94:	681b      	ldr	r3, [r3, #0]
 8050a96:	b113      	cbz	r3, 8050a9e <HAL_TIM_PeriodElapsedCallback+0x4a>
 8050a98:	3b01      	subs	r3, #1
 8050a9a:	4a56      	ldr	r2, [pc, #344]	; (8050bf4 <HAL_TIM_PeriodElapsedCallback+0x1a0>)
 8050a9c:	6013      	str	r3, [r2, #0]
		if(gu32ModbusResponseTimeout)gu32ModbusResponseTimeout--;
 8050a9e:	4b56      	ldr	r3, [pc, #344]	; (8050bf8 <HAL_TIM_PeriodElapsedCallback+0x1a4>)
 8050aa0:	681b      	ldr	r3, [r3, #0]
 8050aa2:	b113      	cbz	r3, 8050aaa <HAL_TIM_PeriodElapsedCallback+0x56>
 8050aa4:	3b01      	subs	r3, #1
 8050aa6:	4a54      	ldr	r2, [pc, #336]	; (8050bf8 <HAL_TIM_PeriodElapsedCallback+0x1a4>)
 8050aa8:	6013      	str	r3, [r2, #0]
		if(gu32LinkDisconnectTimer)gu32LinkDisconnectTimer--;
 8050aaa:	4b54      	ldr	r3, [pc, #336]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050aac:	681b      	ldr	r3, [r3, #0]
 8050aae:	b11b      	cbz	r3, 8050ab8 <HAL_TIM_PeriodElapsedCallback+0x64>
 8050ab0:	4a52      	ldr	r2, [pc, #328]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050ab2:	6813      	ldr	r3, [r2, #0]
 8050ab4:	3b01      	subs	r3, #1
 8050ab6:	6013      	str	r3, [r2, #0]
		if(gu32GSMCharacterTimeout)gu32GSMCharacterTimeout--;
 8050ab8:	4b51      	ldr	r3, [pc, #324]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050aba:	681b      	ldr	r3, [r3, #0]
 8050abc:	b113      	cbz	r3, 8050ac4 <HAL_TIM_PeriodElapsedCallback+0x70>
 8050abe:	3b01      	subs	r3, #1
 8050ac0:	4a4f      	ldr	r2, [pc, #316]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050ac2:	6013      	str	r3, [r2, #0]
		if(gsmInstance.u32GSMTimer)gsmInstance.u32GSMTimer--;
 8050ac4:	4b4f      	ldr	r3, [pc, #316]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050ac6:	f8d3 3e24 	ldr.w	r3, [r3, #3620]	; 0xe24
 8050aca:	b12b      	cbz	r3, 8050ad8 <HAL_TIM_PeriodElapsedCallback+0x84>
 8050acc:	4a4d      	ldr	r2, [pc, #308]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050ace:	f8d2 3e24 	ldr.w	r3, [r2, #3620]	; 0xe24
 8050ad2:	3b01      	subs	r3, #1
 8050ad4:	f8c2 3e24 	str.w	r3, [r2, #3620]	; 0xe24
		if(gsmInstance.u32GSMResponseTimer)gsmInstance.u32GSMResponseTimer--;
 8050ad8:	4b4a      	ldr	r3, [pc, #296]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050ada:	f8d3 3e38 	ldr.w	r3, [r3, #3640]	; 0xe38
 8050ade:	b12b      	cbz	r3, 8050aec <HAL_TIM_PeriodElapsedCallback+0x98>
 8050ae0:	4a48      	ldr	r2, [pc, #288]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050ae2:	f8d2 3e38 	ldr.w	r3, [r2, #3640]	; 0xe38
 8050ae6:	3b01      	subs	r3, #1
 8050ae8:	f8c2 3e38 	str.w	r3, [r2, #3640]	; 0xe38
		if(gsmInstance.u32GSMHeartbeatTimer)gsmInstance.u32GSMHeartbeatTimer--;
 8050aec:	4b45      	ldr	r3, [pc, #276]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050aee:	f8d3 3e30 	ldr.w	r3, [r3, #3632]	; 0xe30
 8050af2:	b11b      	cbz	r3, 8050afc <HAL_TIM_PeriodElapsedCallback+0xa8>
 8050af4:	3b01      	subs	r3, #1
 8050af6:	4a43      	ldr	r2, [pc, #268]	; (8050c04 <HAL_TIM_PeriodElapsedCallback+0x1b0>)
 8050af8:	f8c2 3e30 	str.w	r3, [r2, #3632]	; 0xe30
		if(gu32GSMHangTimer)gu32GSMHangTimer--;
 8050afc:	4b40      	ldr	r3, [pc, #256]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050afe:	685b      	ldr	r3, [r3, #4]
 8050b00:	b11b      	cbz	r3, 8050b0a <HAL_TIM_PeriodElapsedCallback+0xb6>
 8050b02:	4a3f      	ldr	r2, [pc, #252]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b04:	6853      	ldr	r3, [r2, #4]
 8050b06:	3b01      	subs	r3, #1
 8050b08:	6053      	str	r3, [r2, #4]
		if(gu32GPSCharacterTimeout)gu32GPSCharacterTimeout--;
 8050b0a:	4b3d      	ldr	r3, [pc, #244]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b0c:	689b      	ldr	r3, [r3, #8]
 8050b0e:	b113      	cbz	r3, 8050b16 <HAL_TIM_PeriodElapsedCallback+0xc2>
 8050b10:	3b01      	subs	r3, #1
 8050b12:	4a3b      	ldr	r2, [pc, #236]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b14:	6093      	str	r3, [r2, #8]
		if(gu32PayloadQueueEnqueue)gu32PayloadQueueEnqueue--;
 8050b16:	4b3a      	ldr	r3, [pc, #232]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b18:	68db      	ldr	r3, [r3, #12]
 8050b1a:	b11b      	cbz	r3, 8050b24 <HAL_TIM_PeriodElapsedCallback+0xd0>
 8050b1c:	4a38      	ldr	r2, [pc, #224]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b1e:	68d3      	ldr	r3, [r2, #12]
 8050b20:	3b01      	subs	r3, #1
 8050b22:	60d3      	str	r3, [r2, #12]
		if(gu32TempPayloadQueueEnqueue)gu32TempPayloadQueueEnqueue--;
 8050b24:	4b36      	ldr	r3, [pc, #216]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b26:	691b      	ldr	r3, [r3, #16]
 8050b28:	b11b      	cbz	r3, 8050b32 <HAL_TIM_PeriodElapsedCallback+0xde>
 8050b2a:	4a35      	ldr	r2, [pc, #212]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b2c:	6913      	ldr	r3, [r2, #16]
 8050b2e:	3b01      	subs	r3, #1
 8050b30:	6113      	str	r3, [r2, #16]
		if(gu32FotaFileReadTimer)gu32FotaFileReadTimer--;
 8050b32:	4b33      	ldr	r3, [pc, #204]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b34:	695b      	ldr	r3, [r3, #20]
 8050b36:	b11b      	cbz	r3, 8050b40 <HAL_TIM_PeriodElapsedCallback+0xec>
 8050b38:	4a31      	ldr	r2, [pc, #196]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b3a:	6953      	ldr	r3, [r2, #20]
 8050b3c:	3b01      	subs	r3, #1
 8050b3e:	6153      	str	r3, [r2, #20]
		if(gu32GSMRestartTimer)gu32GSMRestartTimer--; /* Added on 6/2/22 . Was Missing :P */
 8050b40:	4b2e      	ldr	r3, [pc, #184]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050b42:	685b      	ldr	r3, [r3, #4]
 8050b44:	b11b      	cbz	r3, 8050b4e <HAL_TIM_PeriodElapsedCallback+0xfa>
 8050b46:	4a2d      	ldr	r2, [pc, #180]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050b48:	6853      	ldr	r3, [r2, #4]
 8050b4a:	3b01      	subs	r3, #1
 8050b4c:	6053      	str	r3, [r2, #4]
		if(gu32RTCUpdateTimer)gu32RTCUpdateTimer--;
 8050b4e:	4b2c      	ldr	r3, [pc, #176]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b50:	699b      	ldr	r3, [r3, #24]
 8050b52:	b113      	cbz	r3, 8050b5a <HAL_TIM_PeriodElapsedCallback+0x106>
 8050b54:	3b01      	subs	r3, #1
 8050b56:	4a2a      	ldr	r2, [pc, #168]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b58:	6193      	str	r3, [r2, #24]
		if(gu32I2CMemoryOperationTimeout)gu32I2CMemoryOperationTimeout--;
 8050b5a:	4b29      	ldr	r3, [pc, #164]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b5c:	69db      	ldr	r3, [r3, #28]
 8050b5e:	b113      	cbz	r3, 8050b66 <HAL_TIM_PeriodElapsedCallback+0x112>
 8050b60:	3b01      	subs	r3, #1
 8050b62:	4a27      	ldr	r2, [pc, #156]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b64:	61d3      	str	r3, [r2, #28]
		if(gu32ADCOperationTimer)gu32ADCOperationTimer--;
 8050b66:	4b26      	ldr	r3, [pc, #152]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b68:	6a1b      	ldr	r3, [r3, #32]
 8050b6a:	b113      	cbz	r3, 8050b72 <HAL_TIM_PeriodElapsedCallback+0x11e>
 8050b6c:	3b01      	subs	r3, #1
 8050b6e:	4a24      	ldr	r2, [pc, #144]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b70:	6213      	str	r3, [r2, #32]
		if(gu32ADCPollTimer)gu32ADCPollTimer--;
 8050b72:	4b23      	ldr	r3, [pc, #140]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8050b76:	b113      	cbz	r3, 8050b7e <HAL_TIM_PeriodElapsedCallback+0x12a>
 8050b78:	3b01      	subs	r3, #1
 8050b7a:	4a21      	ldr	r2, [pc, #132]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b7c:	6253      	str	r3, [r2, #36]	; 0x24
		if(gu32LedTimer)gu32LedTimer--;
 8050b7e:	4b20      	ldr	r3, [pc, #128]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8050b82:	b11b      	cbz	r3, 8050b8c <HAL_TIM_PeriodElapsedCallback+0x138>
 8050b84:	4a1e      	ldr	r2, [pc, #120]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b86:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8050b88:	3b01      	subs	r3, #1
 8050b8a:	6293      	str	r3, [r2, #40]	; 0x28
		if(gu32GSMConfigCheckTimer)gu32GSMConfigCheckTimer--;
 8050b8c:	4b1c      	ldr	r3, [pc, #112]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8050b90:	b11b      	cbz	r3, 8050b9a <HAL_TIM_PeriodElapsedCallback+0x146>
 8050b92:	4a1b      	ldr	r2, [pc, #108]	; (8050c00 <HAL_TIM_PeriodElapsedCallback+0x1ac>)
 8050b94:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8050b96:	3b01      	subs	r3, #1
 8050b98:	62d3      	str	r3, [r2, #44]	; 0x2c
		if(gu32LinkDownTimer)gu32LinkDownTimer--;
 8050b9a:	4b18      	ldr	r3, [pc, #96]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050b9c:	689b      	ldr	r3, [r3, #8]
 8050b9e:	b11b      	cbz	r3, 8050ba8 <HAL_TIM_PeriodElapsedCallback+0x154>
 8050ba0:	4a16      	ldr	r2, [pc, #88]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050ba2:	6893      	ldr	r3, [r2, #8]
 8050ba4:	3b01      	subs	r3, #1
 8050ba6:	6093      	str	r3, [r2, #8]
		if(gu32SystemResetTimer)gu32SystemResetTimer--;
 8050ba8:	4b14      	ldr	r3, [pc, #80]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050baa:	68db      	ldr	r3, [r3, #12]
 8050bac:	b113      	cbz	r3, 8050bb4 <HAL_TIM_PeriodElapsedCallback+0x160>
 8050bae:	3b01      	subs	r3, #1
 8050bb0:	4a12      	ldr	r2, [pc, #72]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050bb2:	60d3      	str	r3, [r2, #12]
		if(gu32UploadFailTimer)gu32UploadFailTimer--;
 8050bb4:	4b11      	ldr	r3, [pc, #68]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050bb6:	691b      	ldr	r3, [r3, #16]
 8050bb8:	b11b      	cbz	r3, 8050bc2 <HAL_TIM_PeriodElapsedCallback+0x16e>
 8050bba:	4a10      	ldr	r2, [pc, #64]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050bbc:	6913      	ldr	r3, [r2, #16]
 8050bbe:	3b01      	subs	r3, #1
 8050bc0:	6113      	str	r3, [r2, #16]
		if(gu32FotaRquestFlag == FALSE)
 8050bc2:	4b11      	ldr	r3, [pc, #68]	; (8050c08 <HAL_TIM_PeriodElapsedCallback+0x1b4>)
 8050bc4:	681b      	ldr	r3, [r3, #0]
 8050bc6:	2b00      	cmp	r3, #0
 8050bc8:	f47f af48 	bne.w	8050a5c <HAL_TIM_PeriodElapsedCallback+0x8>
			if(gu32SystemResetTimer)gu32SystemResetTimer--;
 8050bcc:	4b0b      	ldr	r3, [pc, #44]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050bce:	68db      	ldr	r3, [r3, #12]
 8050bd0:	2b00      	cmp	r3, #0
 8050bd2:	f43f af43 	beq.w	8050a5c <HAL_TIM_PeriodElapsedCallback+0x8>
 8050bd6:	3b01      	subs	r3, #1
 8050bd8:	4a08      	ldr	r2, [pc, #32]	; (8050bfc <HAL_TIM_PeriodElapsedCallback+0x1a8>)
 8050bda:	60d3      	str	r3, [r2, #12]
	}
 8050bdc:	e73e      	b.n	8050a5c <HAL_TIM_PeriodElapsedCallback+0x8>
 8050bde:	bf00      	nop
 8050be0:	40001400 	.word	0x40001400
 8050be4:	20004a94 	.word	0x20004a94
 8050be8:	20004f68 	.word	0x20004f68
 8050bec:	2000d868 	.word	0x2000d868
 8050bf0:	20004a70 	.word	0x20004a70
 8050bf4:	200045a4 	.word	0x200045a4
 8050bf8:	200045a8 	.word	0x200045a8
 8050bfc:	200038b8 	.word	0x200038b8
 8050c00:	200053d4 	.word	0x200053d4
 8050c04:	2000c61c 	.word	0x2000c61c
 8050c08:	20004410 	.word	0x20004410

08050c0c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8050c0c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8050c44 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8050c10:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8050c12:	e003      	b.n	8050c1c <LoopCopyDataInit>

08050c14 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8050c14:	4b0c      	ldr	r3, [pc, #48]	; (8050c48 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8050c16:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8050c18:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8050c1a:	3104      	adds	r1, #4

08050c1c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8050c1c:	480b      	ldr	r0, [pc, #44]	; (8050c4c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8050c1e:	4b0c      	ldr	r3, [pc, #48]	; (8050c50 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8050c20:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8050c22:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8050c24:	d3f6      	bcc.n	8050c14 <CopyDataInit>
  ldr  r2, =_sbss
 8050c26:	4a0b      	ldr	r2, [pc, #44]	; (8050c54 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8050c28:	e002      	b.n	8050c30 <LoopFillZerobss>

08050c2a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8050c2a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8050c2c:	f842 3b04 	str.w	r3, [r2], #4

08050c30 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8050c30:	4b09      	ldr	r3, [pc, #36]	; (8050c58 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8050c32:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8050c34:	d3f9      	bcc.n	8050c2a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8050c36:	f7ff f8eb 	bl	804fe10 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8050c3a:	f000 f817 	bl	8050c6c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8050c3e:	f7fc fd53 	bl	804d6e8 <main>
  bx  lr    
 8050c42:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8050c44:	20030000 	.word	0x20030000
  ldr  r3, =_sidata
 8050c48:	0805a7b4 	.word	0x0805a7b4
  ldr  r0, =_sdata
 8050c4c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8050c50:	2000427c 	.word	0x2000427c
  ldr  r2, =_sbss
 8050c54:	2000427c 	.word	0x2000427c
  ldr  r3, = _ebss
 8050c58:	20010340 	.word	0x20010340

08050c5c <CAN1_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8050c5c:	e7fe      	b.n	8050c5c <CAN1_RX0_IRQHandler>

08050c5e <atof>:
 8050c5e:	2100      	movs	r1, #0
 8050c60:	f001 b98c 	b.w	8051f7c <strtod>

08050c64 <atoi>:
 8050c64:	220a      	movs	r2, #10
 8050c66:	2100      	movs	r1, #0
 8050c68:	f001 ba48 	b.w	80520fc <strtol>

08050c6c <__libc_init_array>:
 8050c6c:	b570      	push	{r4, r5, r6, lr}
 8050c6e:	4d0d      	ldr	r5, [pc, #52]	; (8050ca4 <__libc_init_array+0x38>)
 8050c70:	4c0d      	ldr	r4, [pc, #52]	; (8050ca8 <__libc_init_array+0x3c>)
 8050c72:	1b64      	subs	r4, r4, r5
 8050c74:	10a4      	asrs	r4, r4, #2
 8050c76:	2600      	movs	r6, #0
 8050c78:	42a6      	cmp	r6, r4
 8050c7a:	d109      	bne.n	8050c90 <__libc_init_array+0x24>
 8050c7c:	4d0b      	ldr	r5, [pc, #44]	; (8050cac <__libc_init_array+0x40>)
 8050c7e:	4c0c      	ldr	r4, [pc, #48]	; (8050cb0 <__libc_init_array+0x44>)
 8050c80:	f007 fc14 	bl	80584ac <_init>
 8050c84:	1b64      	subs	r4, r4, r5
 8050c86:	10a4      	asrs	r4, r4, #2
 8050c88:	2600      	movs	r6, #0
 8050c8a:	42a6      	cmp	r6, r4
 8050c8c:	d105      	bne.n	8050c9a <__libc_init_array+0x2e>
 8050c8e:	bd70      	pop	{r4, r5, r6, pc}
 8050c90:	f855 3b04 	ldr.w	r3, [r5], #4
 8050c94:	4798      	blx	r3
 8050c96:	3601      	adds	r6, #1
 8050c98:	e7ee      	b.n	8050c78 <__libc_init_array+0xc>
 8050c9a:	f855 3b04 	ldr.w	r3, [r5], #4
 8050c9e:	4798      	blx	r3
 8050ca0:	3601      	adds	r6, #1
 8050ca2:	e7f2      	b.n	8050c8a <__libc_init_array+0x1e>
 8050ca4:	0805a7a8 	.word	0x0805a7a8
 8050ca8:	0805a7a8 	.word	0x0805a7a8
 8050cac:	0805a7a8 	.word	0x0805a7a8
 8050cb0:	0805a7b0 	.word	0x0805a7b0

08050cb4 <__itoa>:
 8050cb4:	1e93      	subs	r3, r2, #2
 8050cb6:	2b22      	cmp	r3, #34	; 0x22
 8050cb8:	b510      	push	{r4, lr}
 8050cba:	460c      	mov	r4, r1
 8050cbc:	d904      	bls.n	8050cc8 <__itoa+0x14>
 8050cbe:	2300      	movs	r3, #0
 8050cc0:	700b      	strb	r3, [r1, #0]
 8050cc2:	461c      	mov	r4, r3
 8050cc4:	4620      	mov	r0, r4
 8050cc6:	bd10      	pop	{r4, pc}
 8050cc8:	2a0a      	cmp	r2, #10
 8050cca:	d109      	bne.n	8050ce0 <__itoa+0x2c>
 8050ccc:	2800      	cmp	r0, #0
 8050cce:	da07      	bge.n	8050ce0 <__itoa+0x2c>
 8050cd0:	232d      	movs	r3, #45	; 0x2d
 8050cd2:	700b      	strb	r3, [r1, #0]
 8050cd4:	4240      	negs	r0, r0
 8050cd6:	2101      	movs	r1, #1
 8050cd8:	4421      	add	r1, r4
 8050cda:	f002 fc07 	bl	80534ec <__utoa>
 8050cde:	e7f1      	b.n	8050cc4 <__itoa+0x10>
 8050ce0:	2100      	movs	r1, #0
 8050ce2:	e7f9      	b.n	8050cd8 <__itoa+0x24>

08050ce4 <itoa>:
 8050ce4:	f7ff bfe6 	b.w	8050cb4 <__itoa>

08050ce8 <malloc>:
 8050ce8:	4b02      	ldr	r3, [pc, #8]	; (8050cf4 <malloc+0xc>)
 8050cea:	4601      	mov	r1, r0
 8050cec:	6818      	ldr	r0, [r3, #0]
 8050cee:	f000 b80b 	b.w	8050d08 <_malloc_r>
 8050cf2:	bf00      	nop
 8050cf4:	200038cc 	.word	0x200038cc

08050cf8 <free>:
 8050cf8:	4b02      	ldr	r3, [pc, #8]	; (8050d04 <free+0xc>)
 8050cfa:	4601      	mov	r1, r0
 8050cfc:	6818      	ldr	r0, [r3, #0]
 8050cfe:	f004 bf07 	b.w	8055b10 <_free_r>
 8050d02:	bf00      	nop
 8050d04:	200038cc 	.word	0x200038cc

08050d08 <_malloc_r>:
 8050d08:	f101 030b 	add.w	r3, r1, #11
 8050d0c:	2b16      	cmp	r3, #22
 8050d0e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8050d12:	4605      	mov	r5, r0
 8050d14:	d906      	bls.n	8050d24 <_malloc_r+0x1c>
 8050d16:	f033 0707 	bics.w	r7, r3, #7
 8050d1a:	d504      	bpl.n	8050d26 <_malloc_r+0x1e>
 8050d1c:	230c      	movs	r3, #12
 8050d1e:	602b      	str	r3, [r5, #0]
 8050d20:	2400      	movs	r4, #0
 8050d22:	e1ae      	b.n	8051082 <_malloc_r+0x37a>
 8050d24:	2710      	movs	r7, #16
 8050d26:	42b9      	cmp	r1, r7
 8050d28:	d8f8      	bhi.n	8050d1c <_malloc_r+0x14>
 8050d2a:	4628      	mov	r0, r5
 8050d2c:	f000 fa52 	bl	80511d4 <__malloc_lock>
 8050d30:	f5b7 7ffc 	cmp.w	r7, #504	; 0x1f8
 8050d34:	4ec3      	ldr	r6, [pc, #780]	; (8051044 <_malloc_r+0x33c>)
 8050d36:	d238      	bcs.n	8050daa <_malloc_r+0xa2>
 8050d38:	f107 0208 	add.w	r2, r7, #8
 8050d3c:	4432      	add	r2, r6
 8050d3e:	f1a2 0108 	sub.w	r1, r2, #8
 8050d42:	6854      	ldr	r4, [r2, #4]
 8050d44:	428c      	cmp	r4, r1
 8050d46:	ea4f 03d7 	mov.w	r3, r7, lsr #3
 8050d4a:	d102      	bne.n	8050d52 <_malloc_r+0x4a>
 8050d4c:	68d4      	ldr	r4, [r2, #12]
 8050d4e:	42a2      	cmp	r2, r4
 8050d50:	d010      	beq.n	8050d74 <_malloc_r+0x6c>
 8050d52:	6863      	ldr	r3, [r4, #4]
 8050d54:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8050d58:	f023 0303 	bic.w	r3, r3, #3
 8050d5c:	60ca      	str	r2, [r1, #12]
 8050d5e:	4423      	add	r3, r4
 8050d60:	6091      	str	r1, [r2, #8]
 8050d62:	685a      	ldr	r2, [r3, #4]
 8050d64:	f042 0201 	orr.w	r2, r2, #1
 8050d68:	605a      	str	r2, [r3, #4]
 8050d6a:	4628      	mov	r0, r5
 8050d6c:	f000 fa38 	bl	80511e0 <__malloc_unlock>
 8050d70:	3408      	adds	r4, #8
 8050d72:	e186      	b.n	8051082 <_malloc_r+0x37a>
 8050d74:	3302      	adds	r3, #2
 8050d76:	4ab4      	ldr	r2, [pc, #720]	; (8051048 <_malloc_r+0x340>)
 8050d78:	6934      	ldr	r4, [r6, #16]
 8050d7a:	4294      	cmp	r4, r2
 8050d7c:	4611      	mov	r1, r2
 8050d7e:	d077      	beq.n	8050e70 <_malloc_r+0x168>
 8050d80:	6860      	ldr	r0, [r4, #4]
 8050d82:	f020 0c03 	bic.w	ip, r0, #3
 8050d86:	ebac 0007 	sub.w	r0, ip, r7
 8050d8a:	280f      	cmp	r0, #15
 8050d8c:	dd48      	ble.n	8050e20 <_malloc_r+0x118>
 8050d8e:	19e1      	adds	r1, r4, r7
 8050d90:	f040 0301 	orr.w	r3, r0, #1
 8050d94:	f047 0701 	orr.w	r7, r7, #1
 8050d98:	6067      	str	r7, [r4, #4]
 8050d9a:	e9c6 1104 	strd	r1, r1, [r6, #16]
 8050d9e:	e9c1 2202 	strd	r2, r2, [r1, #8]
 8050da2:	604b      	str	r3, [r1, #4]
 8050da4:	f844 000c 	str.w	r0, [r4, ip]
 8050da8:	e7df      	b.n	8050d6a <_malloc_r+0x62>
 8050daa:	0a7b      	lsrs	r3, r7, #9
 8050dac:	d02a      	beq.n	8050e04 <_malloc_r+0xfc>
 8050dae:	2b04      	cmp	r3, #4
 8050db0:	d812      	bhi.n	8050dd8 <_malloc_r+0xd0>
 8050db2:	09bb      	lsrs	r3, r7, #6
 8050db4:	3338      	adds	r3, #56	; 0x38
 8050db6:	1c5a      	adds	r2, r3, #1
 8050db8:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8050dbc:	f1a2 0c08 	sub.w	ip, r2, #8
 8050dc0:	6854      	ldr	r4, [r2, #4]
 8050dc2:	4564      	cmp	r4, ip
 8050dc4:	d006      	beq.n	8050dd4 <_malloc_r+0xcc>
 8050dc6:	6862      	ldr	r2, [r4, #4]
 8050dc8:	f022 0203 	bic.w	r2, r2, #3
 8050dcc:	1bd0      	subs	r0, r2, r7
 8050dce:	280f      	cmp	r0, #15
 8050dd0:	dd1c      	ble.n	8050e0c <_malloc_r+0x104>
 8050dd2:	3b01      	subs	r3, #1
 8050dd4:	3301      	adds	r3, #1
 8050dd6:	e7ce      	b.n	8050d76 <_malloc_r+0x6e>
 8050dd8:	2b14      	cmp	r3, #20
 8050dda:	d801      	bhi.n	8050de0 <_malloc_r+0xd8>
 8050ddc:	335b      	adds	r3, #91	; 0x5b
 8050dde:	e7ea      	b.n	8050db6 <_malloc_r+0xae>
 8050de0:	2b54      	cmp	r3, #84	; 0x54
 8050de2:	d802      	bhi.n	8050dea <_malloc_r+0xe2>
 8050de4:	0b3b      	lsrs	r3, r7, #12
 8050de6:	336e      	adds	r3, #110	; 0x6e
 8050de8:	e7e5      	b.n	8050db6 <_malloc_r+0xae>
 8050dea:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8050dee:	d802      	bhi.n	8050df6 <_malloc_r+0xee>
 8050df0:	0bfb      	lsrs	r3, r7, #15
 8050df2:	3377      	adds	r3, #119	; 0x77
 8050df4:	e7df      	b.n	8050db6 <_malloc_r+0xae>
 8050df6:	f240 5254 	movw	r2, #1364	; 0x554
 8050dfa:	4293      	cmp	r3, r2
 8050dfc:	d804      	bhi.n	8050e08 <_malloc_r+0x100>
 8050dfe:	0cbb      	lsrs	r3, r7, #18
 8050e00:	337c      	adds	r3, #124	; 0x7c
 8050e02:	e7d8      	b.n	8050db6 <_malloc_r+0xae>
 8050e04:	233f      	movs	r3, #63	; 0x3f
 8050e06:	e7d6      	b.n	8050db6 <_malloc_r+0xae>
 8050e08:	237e      	movs	r3, #126	; 0x7e
 8050e0a:	e7d4      	b.n	8050db6 <_malloc_r+0xae>
 8050e0c:	2800      	cmp	r0, #0
 8050e0e:	68e1      	ldr	r1, [r4, #12]
 8050e10:	db04      	blt.n	8050e1c <_malloc_r+0x114>
 8050e12:	68a3      	ldr	r3, [r4, #8]
 8050e14:	60d9      	str	r1, [r3, #12]
 8050e16:	608b      	str	r3, [r1, #8]
 8050e18:	18a3      	adds	r3, r4, r2
 8050e1a:	e7a2      	b.n	8050d62 <_malloc_r+0x5a>
 8050e1c:	460c      	mov	r4, r1
 8050e1e:	e7d0      	b.n	8050dc2 <_malloc_r+0xba>
 8050e20:	2800      	cmp	r0, #0
 8050e22:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8050e26:	db07      	blt.n	8050e38 <_malloc_r+0x130>
 8050e28:	44a4      	add	ip, r4
 8050e2a:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8050e2e:	f043 0301 	orr.w	r3, r3, #1
 8050e32:	f8cc 3004 	str.w	r3, [ip, #4]
 8050e36:	e798      	b.n	8050d6a <_malloc_r+0x62>
 8050e38:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
 8050e3c:	6870      	ldr	r0, [r6, #4]
 8050e3e:	f080 809e 	bcs.w	8050f7e <_malloc_r+0x276>
 8050e42:	ea4f 02dc 	mov.w	r2, ip, lsr #3
 8050e46:	ea4f 1e5c 	mov.w	lr, ip, lsr #5
 8050e4a:	f04f 0c01 	mov.w	ip, #1
 8050e4e:	3201      	adds	r2, #1
 8050e50:	fa0c fc0e 	lsl.w	ip, ip, lr
 8050e54:	ea4c 0000 	orr.w	r0, ip, r0
 8050e58:	6070      	str	r0, [r6, #4]
 8050e5a:	f856 c032 	ldr.w	ip, [r6, r2, lsl #3]
 8050e5e:	eb06 00c2 	add.w	r0, r6, r2, lsl #3
 8050e62:	3808      	subs	r0, #8
 8050e64:	e9c4 c002 	strd	ip, r0, [r4, #8]
 8050e68:	f846 4032 	str.w	r4, [r6, r2, lsl #3]
 8050e6c:	f8cc 400c 	str.w	r4, [ip, #12]
 8050e70:	2001      	movs	r0, #1
 8050e72:	109a      	asrs	r2, r3, #2
 8050e74:	fa00 f202 	lsl.w	r2, r0, r2
 8050e78:	6870      	ldr	r0, [r6, #4]
 8050e7a:	4290      	cmp	r0, r2
 8050e7c:	d326      	bcc.n	8050ecc <_malloc_r+0x1c4>
 8050e7e:	4210      	tst	r0, r2
 8050e80:	d106      	bne.n	8050e90 <_malloc_r+0x188>
 8050e82:	f023 0303 	bic.w	r3, r3, #3
 8050e86:	0052      	lsls	r2, r2, #1
 8050e88:	4210      	tst	r0, r2
 8050e8a:	f103 0304 	add.w	r3, r3, #4
 8050e8e:	d0fa      	beq.n	8050e86 <_malloc_r+0x17e>
 8050e90:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
 8050e94:	46c1      	mov	r9, r8
 8050e96:	469e      	mov	lr, r3
 8050e98:	f8d9 400c 	ldr.w	r4, [r9, #12]
 8050e9c:	454c      	cmp	r4, r9
 8050e9e:	f040 80b3 	bne.w	8051008 <_malloc_r+0x300>
 8050ea2:	f10e 0e01 	add.w	lr, lr, #1
 8050ea6:	f01e 0f03 	tst.w	lr, #3
 8050eaa:	f109 0908 	add.w	r9, r9, #8
 8050eae:	d1f3      	bne.n	8050e98 <_malloc_r+0x190>
 8050eb0:	0798      	lsls	r0, r3, #30
 8050eb2:	f040 80ec 	bne.w	805108e <_malloc_r+0x386>
 8050eb6:	6873      	ldr	r3, [r6, #4]
 8050eb8:	ea23 0302 	bic.w	r3, r3, r2
 8050ebc:	6073      	str	r3, [r6, #4]
 8050ebe:	6870      	ldr	r0, [r6, #4]
 8050ec0:	0052      	lsls	r2, r2, #1
 8050ec2:	4290      	cmp	r0, r2
 8050ec4:	d302      	bcc.n	8050ecc <_malloc_r+0x1c4>
 8050ec6:	2a00      	cmp	r2, #0
 8050ec8:	f040 80ee 	bne.w	80510a8 <_malloc_r+0x3a0>
 8050ecc:	f8d6 b008 	ldr.w	fp, [r6, #8]
 8050ed0:	f8db 1004 	ldr.w	r1, [fp, #4]
 8050ed4:	f021 0903 	bic.w	r9, r1, #3
 8050ed8:	45b9      	cmp	r9, r7
 8050eda:	d304      	bcc.n	8050ee6 <_malloc_r+0x1de>
 8050edc:	eba9 0207 	sub.w	r2, r9, r7
 8050ee0:	2a0f      	cmp	r2, #15
 8050ee2:	f300 8149 	bgt.w	8051178 <_malloc_r+0x470>
 8050ee6:	4a59      	ldr	r2, [pc, #356]	; (805104c <_malloc_r+0x344>)
 8050ee8:	6811      	ldr	r1, [r2, #0]
 8050eea:	3110      	adds	r1, #16
 8050eec:	eb0b 0309 	add.w	r3, fp, r9
 8050ef0:	4439      	add	r1, r7
 8050ef2:	2008      	movs	r0, #8
 8050ef4:	9301      	str	r3, [sp, #4]
 8050ef6:	9100      	str	r1, [sp, #0]
 8050ef8:	f002 faea 	bl	80534d0 <sysconf>
 8050efc:	4a54      	ldr	r2, [pc, #336]	; (8051050 <_malloc_r+0x348>)
 8050efe:	e9dd 1300 	ldrd	r1, r3, [sp]
 8050f02:	4680      	mov	r8, r0
 8050f04:	6810      	ldr	r0, [r2, #0]
 8050f06:	3001      	adds	r0, #1
 8050f08:	bf1f      	itttt	ne
 8050f0a:	f101 31ff 	addne.w	r1, r1, #4294967295
 8050f0e:	4441      	addne	r1, r8
 8050f10:	f1c8 0000 	rsbne	r0, r8, #0
 8050f14:	4001      	andne	r1, r0
 8050f16:	4628      	mov	r0, r5
 8050f18:	e9cd 1300 	strd	r1, r3, [sp]
 8050f1c:	f000 f978 	bl	8051210 <_sbrk_r>
 8050f20:	1c42      	adds	r2, r0, #1
 8050f22:	4604      	mov	r4, r0
 8050f24:	f000 80fc 	beq.w	8051120 <_malloc_r+0x418>
 8050f28:	9b01      	ldr	r3, [sp, #4]
 8050f2a:	9900      	ldr	r1, [sp, #0]
 8050f2c:	4a48      	ldr	r2, [pc, #288]	; (8051050 <_malloc_r+0x348>)
 8050f2e:	4283      	cmp	r3, r0
 8050f30:	d902      	bls.n	8050f38 <_malloc_r+0x230>
 8050f32:	45b3      	cmp	fp, r6
 8050f34:	f040 80f4 	bne.w	8051120 <_malloc_r+0x418>
 8050f38:	f8df a120 	ldr.w	sl, [pc, #288]	; 805105c <_malloc_r+0x354>
 8050f3c:	f8da 0000 	ldr.w	r0, [sl]
 8050f40:	42a3      	cmp	r3, r4
 8050f42:	eb00 0e01 	add.w	lr, r0, r1
 8050f46:	f8ca e000 	str.w	lr, [sl]
 8050f4a:	f108 3cff 	add.w	ip, r8, #4294967295
 8050f4e:	f040 80ad 	bne.w	80510ac <_malloc_r+0x3a4>
 8050f52:	ea13 0f0c 	tst.w	r3, ip
 8050f56:	f040 80a9 	bne.w	80510ac <_malloc_r+0x3a4>
 8050f5a:	68b3      	ldr	r3, [r6, #8]
 8050f5c:	4449      	add	r1, r9
 8050f5e:	f041 0101 	orr.w	r1, r1, #1
 8050f62:	6059      	str	r1, [r3, #4]
 8050f64:	4a3b      	ldr	r2, [pc, #236]	; (8051054 <_malloc_r+0x34c>)
 8050f66:	f8da 3000 	ldr.w	r3, [sl]
 8050f6a:	6811      	ldr	r1, [r2, #0]
 8050f6c:	428b      	cmp	r3, r1
 8050f6e:	bf88      	it	hi
 8050f70:	6013      	strhi	r3, [r2, #0]
 8050f72:	4a39      	ldr	r2, [pc, #228]	; (8051058 <_malloc_r+0x350>)
 8050f74:	6811      	ldr	r1, [r2, #0]
 8050f76:	428b      	cmp	r3, r1
 8050f78:	bf88      	it	hi
 8050f7a:	6013      	strhi	r3, [r2, #0]
 8050f7c:	e0d0      	b.n	8051120 <_malloc_r+0x418>
 8050f7e:	f5bc 6f20 	cmp.w	ip, #2560	; 0xa00
 8050f82:	ea4f 225c 	mov.w	r2, ip, lsr #9
 8050f86:	d218      	bcs.n	8050fba <_malloc_r+0x2b2>
 8050f88:	ea4f 129c 	mov.w	r2, ip, lsr #6
 8050f8c:	3238      	adds	r2, #56	; 0x38
 8050f8e:	f102 0e01 	add.w	lr, r2, #1
 8050f92:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
 8050f96:	f856 e03e 	ldr.w	lr, [r6, lr, lsl #3]
 8050f9a:	45f0      	cmp	r8, lr
 8050f9c:	d12b      	bne.n	8050ff6 <_malloc_r+0x2ee>
 8050f9e:	1092      	asrs	r2, r2, #2
 8050fa0:	f04f 0c01 	mov.w	ip, #1
 8050fa4:	fa0c f202 	lsl.w	r2, ip, r2
 8050fa8:	4310      	orrs	r0, r2
 8050faa:	6070      	str	r0, [r6, #4]
 8050fac:	e9c4 e802 	strd	lr, r8, [r4, #8]
 8050fb0:	f8c8 4008 	str.w	r4, [r8, #8]
 8050fb4:	f8ce 400c 	str.w	r4, [lr, #12]
 8050fb8:	e75a      	b.n	8050e70 <_malloc_r+0x168>
 8050fba:	2a14      	cmp	r2, #20
 8050fbc:	d801      	bhi.n	8050fc2 <_malloc_r+0x2ba>
 8050fbe:	325b      	adds	r2, #91	; 0x5b
 8050fc0:	e7e5      	b.n	8050f8e <_malloc_r+0x286>
 8050fc2:	2a54      	cmp	r2, #84	; 0x54
 8050fc4:	d803      	bhi.n	8050fce <_malloc_r+0x2c6>
 8050fc6:	ea4f 321c 	mov.w	r2, ip, lsr #12
 8050fca:	326e      	adds	r2, #110	; 0x6e
 8050fcc:	e7df      	b.n	8050f8e <_malloc_r+0x286>
 8050fce:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8050fd2:	d803      	bhi.n	8050fdc <_malloc_r+0x2d4>
 8050fd4:	ea4f 32dc 	mov.w	r2, ip, lsr #15
 8050fd8:	3277      	adds	r2, #119	; 0x77
 8050fda:	e7d8      	b.n	8050f8e <_malloc_r+0x286>
 8050fdc:	f240 5e54 	movw	lr, #1364	; 0x554
 8050fe0:	4572      	cmp	r2, lr
 8050fe2:	bf9a      	itte	ls
 8050fe4:	ea4f 429c 	movls.w	r2, ip, lsr #18
 8050fe8:	327c      	addls	r2, #124	; 0x7c
 8050fea:	227e      	movhi	r2, #126	; 0x7e
 8050fec:	e7cf      	b.n	8050f8e <_malloc_r+0x286>
 8050fee:	f8de e008 	ldr.w	lr, [lr, #8]
 8050ff2:	45f0      	cmp	r8, lr
 8050ff4:	d005      	beq.n	8051002 <_malloc_r+0x2fa>
 8050ff6:	f8de 2004 	ldr.w	r2, [lr, #4]
 8050ffa:	f022 0203 	bic.w	r2, r2, #3
 8050ffe:	4562      	cmp	r2, ip
 8051000:	d8f5      	bhi.n	8050fee <_malloc_r+0x2e6>
 8051002:	f8de 800c 	ldr.w	r8, [lr, #12]
 8051006:	e7d1      	b.n	8050fac <_malloc_r+0x2a4>
 8051008:	6860      	ldr	r0, [r4, #4]
 805100a:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 805100e:	f020 0003 	bic.w	r0, r0, #3
 8051012:	eba0 0a07 	sub.w	sl, r0, r7
 8051016:	f1ba 0f0f 	cmp.w	sl, #15
 805101a:	dd21      	ble.n	8051060 <_malloc_r+0x358>
 805101c:	68a3      	ldr	r3, [r4, #8]
 805101e:	19e2      	adds	r2, r4, r7
 8051020:	f047 0701 	orr.w	r7, r7, #1
 8051024:	6067      	str	r7, [r4, #4]
 8051026:	f8c3 c00c 	str.w	ip, [r3, #12]
 805102a:	f8cc 3008 	str.w	r3, [ip, #8]
 805102e:	f04a 0301 	orr.w	r3, sl, #1
 8051032:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8051036:	e9c2 1102 	strd	r1, r1, [r2, #8]
 805103a:	6053      	str	r3, [r2, #4]
 805103c:	f844 a000 	str.w	sl, [r4, r0]
 8051040:	e693      	b.n	8050d6a <_malloc_r+0x62>
 8051042:	bf00      	nop
 8051044:	20003cf8 	.word	0x20003cf8
 8051048:	20003d00 	.word	0x20003d00
 805104c:	20005444 	.word	0x20005444
 8051050:	20004100 	.word	0x20004100
 8051054:	2000543c 	.word	0x2000543c
 8051058:	20005440 	.word	0x20005440
 805105c:	20005414 	.word	0x20005414
 8051060:	f1ba 0f00 	cmp.w	sl, #0
 8051064:	db11      	blt.n	805108a <_malloc_r+0x382>
 8051066:	4420      	add	r0, r4
 8051068:	6843      	ldr	r3, [r0, #4]
 805106a:	f043 0301 	orr.w	r3, r3, #1
 805106e:	6043      	str	r3, [r0, #4]
 8051070:	f854 3f08 	ldr.w	r3, [r4, #8]!
 8051074:	4628      	mov	r0, r5
 8051076:	f8c3 c00c 	str.w	ip, [r3, #12]
 805107a:	f8cc 3008 	str.w	r3, [ip, #8]
 805107e:	f000 f8af 	bl	80511e0 <__malloc_unlock>
 8051082:	4620      	mov	r0, r4
 8051084:	b003      	add	sp, #12
 8051086:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 805108a:	4664      	mov	r4, ip
 805108c:	e706      	b.n	8050e9c <_malloc_r+0x194>
 805108e:	f858 0908 	ldr.w	r0, [r8], #-8
 8051092:	4540      	cmp	r0, r8
 8051094:	f103 33ff 	add.w	r3, r3, #4294967295
 8051098:	f43f af0a 	beq.w	8050eb0 <_malloc_r+0x1a8>
 805109c:	e70f      	b.n	8050ebe <_malloc_r+0x1b6>
 805109e:	3304      	adds	r3, #4
 80510a0:	0052      	lsls	r2, r2, #1
 80510a2:	4210      	tst	r0, r2
 80510a4:	d0fb      	beq.n	805109e <_malloc_r+0x396>
 80510a6:	e6f3      	b.n	8050e90 <_malloc_r+0x188>
 80510a8:	4673      	mov	r3, lr
 80510aa:	e7fa      	b.n	80510a2 <_malloc_r+0x39a>
 80510ac:	6810      	ldr	r0, [r2, #0]
 80510ae:	3001      	adds	r0, #1
 80510b0:	bf1b      	ittet	ne
 80510b2:	1ae3      	subne	r3, r4, r3
 80510b4:	4473      	addne	r3, lr
 80510b6:	6014      	streq	r4, [r2, #0]
 80510b8:	f8ca 3000 	strne.w	r3, [sl]
 80510bc:	f014 0307 	ands.w	r3, r4, #7
 80510c0:	bf1a      	itte	ne
 80510c2:	f1c3 0008 	rsbne	r0, r3, #8
 80510c6:	1824      	addne	r4, r4, r0
 80510c8:	4618      	moveq	r0, r3
 80510ca:	1862      	adds	r2, r4, r1
 80510cc:	ea02 010c 	and.w	r1, r2, ip
 80510d0:	4480      	add	r8, r0
 80510d2:	eba8 0801 	sub.w	r8, r8, r1
 80510d6:	ea08 080c 	and.w	r8, r8, ip
 80510da:	4641      	mov	r1, r8
 80510dc:	4628      	mov	r0, r5
 80510de:	9301      	str	r3, [sp, #4]
 80510e0:	9200      	str	r2, [sp, #0]
 80510e2:	f000 f895 	bl	8051210 <_sbrk_r>
 80510e6:	1c43      	adds	r3, r0, #1
 80510e8:	e9dd 2300 	ldrd	r2, r3, [sp]
 80510ec:	d105      	bne.n	80510fa <_malloc_r+0x3f2>
 80510ee:	b32b      	cbz	r3, 805113c <_malloc_r+0x434>
 80510f0:	f1a3 0008 	sub.w	r0, r3, #8
 80510f4:	4410      	add	r0, r2
 80510f6:	f04f 0800 	mov.w	r8, #0
 80510fa:	f8da 2000 	ldr.w	r2, [sl]
 80510fe:	60b4      	str	r4, [r6, #8]
 8051100:	1b00      	subs	r0, r0, r4
 8051102:	4440      	add	r0, r8
 8051104:	4442      	add	r2, r8
 8051106:	f040 0001 	orr.w	r0, r0, #1
 805110a:	45b3      	cmp	fp, r6
 805110c:	f8ca 2000 	str.w	r2, [sl]
 8051110:	6060      	str	r0, [r4, #4]
 8051112:	f43f af27 	beq.w	8050f64 <_malloc_r+0x25c>
 8051116:	f1b9 0f0f 	cmp.w	r9, #15
 805111a:	d812      	bhi.n	8051142 <_malloc_r+0x43a>
 805111c:	2301      	movs	r3, #1
 805111e:	6063      	str	r3, [r4, #4]
 8051120:	68b3      	ldr	r3, [r6, #8]
 8051122:	685b      	ldr	r3, [r3, #4]
 8051124:	f023 0303 	bic.w	r3, r3, #3
 8051128:	42bb      	cmp	r3, r7
 805112a:	eba3 0207 	sub.w	r2, r3, r7
 805112e:	d301      	bcc.n	8051134 <_malloc_r+0x42c>
 8051130:	2a0f      	cmp	r2, #15
 8051132:	dc21      	bgt.n	8051178 <_malloc_r+0x470>
 8051134:	4628      	mov	r0, r5
 8051136:	f000 f853 	bl	80511e0 <__malloc_unlock>
 805113a:	e5f1      	b.n	8050d20 <_malloc_r+0x18>
 805113c:	4610      	mov	r0, r2
 805113e:	4698      	mov	r8, r3
 8051140:	e7db      	b.n	80510fa <_malloc_r+0x3f2>
 8051142:	f8db 3004 	ldr.w	r3, [fp, #4]
 8051146:	f1a9 090c 	sub.w	r9, r9, #12
 805114a:	f029 0907 	bic.w	r9, r9, #7
 805114e:	f003 0301 	and.w	r3, r3, #1
 8051152:	ea43 0309 	orr.w	r3, r3, r9
 8051156:	f8cb 3004 	str.w	r3, [fp, #4]
 805115a:	2205      	movs	r2, #5
 805115c:	eb0b 0309 	add.w	r3, fp, r9
 8051160:	f1b9 0f0f 	cmp.w	r9, #15
 8051164:	e9c3 2201 	strd	r2, r2, [r3, #4]
 8051168:	f67f aefc 	bls.w	8050f64 <_malloc_r+0x25c>
 805116c:	f10b 0108 	add.w	r1, fp, #8
 8051170:	4628      	mov	r0, r5
 8051172:	f004 fccd 	bl	8055b10 <_free_r>
 8051176:	e6f5      	b.n	8050f64 <_malloc_r+0x25c>
 8051178:	68b4      	ldr	r4, [r6, #8]
 805117a:	f047 0301 	orr.w	r3, r7, #1
 805117e:	4427      	add	r7, r4
 8051180:	f042 0201 	orr.w	r2, r2, #1
 8051184:	6063      	str	r3, [r4, #4]
 8051186:	60b7      	str	r7, [r6, #8]
 8051188:	607a      	str	r2, [r7, #4]
 805118a:	e5ee      	b.n	8050d6a <_malloc_r+0x62>

0805118c <memcmp>:
 805118c:	b530      	push	{r4, r5, lr}
 805118e:	3901      	subs	r1, #1
 8051190:	2400      	movs	r4, #0
 8051192:	42a2      	cmp	r2, r4
 8051194:	d101      	bne.n	805119a <memcmp+0xe>
 8051196:	2000      	movs	r0, #0
 8051198:	e005      	b.n	80511a6 <memcmp+0x1a>
 805119a:	5d03      	ldrb	r3, [r0, r4]
 805119c:	3401      	adds	r4, #1
 805119e:	5d0d      	ldrb	r5, [r1, r4]
 80511a0:	42ab      	cmp	r3, r5
 80511a2:	d0f6      	beq.n	8051192 <memcmp+0x6>
 80511a4:	1b58      	subs	r0, r3, r5
 80511a6:	bd30      	pop	{r4, r5, pc}

080511a8 <memcpy>:
 80511a8:	440a      	add	r2, r1
 80511aa:	4291      	cmp	r1, r2
 80511ac:	f100 33ff 	add.w	r3, r0, #4294967295
 80511b0:	d100      	bne.n	80511b4 <memcpy+0xc>
 80511b2:	4770      	bx	lr
 80511b4:	b510      	push	{r4, lr}
 80511b6:	f811 4b01 	ldrb.w	r4, [r1], #1
 80511ba:	f803 4f01 	strb.w	r4, [r3, #1]!
 80511be:	4291      	cmp	r1, r2
 80511c0:	d1f9      	bne.n	80511b6 <memcpy+0xe>
 80511c2:	bd10      	pop	{r4, pc}

080511c4 <memset>:
 80511c4:	4402      	add	r2, r0
 80511c6:	4603      	mov	r3, r0
 80511c8:	4293      	cmp	r3, r2
 80511ca:	d100      	bne.n	80511ce <memset+0xa>
 80511cc:	4770      	bx	lr
 80511ce:	f803 1b01 	strb.w	r1, [r3], #1
 80511d2:	e7f9      	b.n	80511c8 <memset+0x4>

080511d4 <__malloc_lock>:
 80511d4:	4801      	ldr	r0, [pc, #4]	; (80511dc <__malloc_lock+0x8>)
 80511d6:	f005 b8f5 	b.w	80563c4 <__retarget_lock_acquire_recursive>
 80511da:	bf00      	nop
 80511dc:	20010338 	.word	0x20010338

080511e0 <__malloc_unlock>:
 80511e0:	4801      	ldr	r0, [pc, #4]	; (80511e8 <__malloc_unlock+0x8>)
 80511e2:	f005 b8f0 	b.w	80563c6 <__retarget_lock_release_recursive>
 80511e6:	bf00      	nop
 80511e8:	20010338 	.word	0x20010338

080511ec <printf>:
 80511ec:	b40f      	push	{r0, r1, r2, r3}
 80511ee:	b507      	push	{r0, r1, r2, lr}
 80511f0:	4906      	ldr	r1, [pc, #24]	; (805120c <printf+0x20>)
 80511f2:	ab04      	add	r3, sp, #16
 80511f4:	6808      	ldr	r0, [r1, #0]
 80511f6:	f853 2b04 	ldr.w	r2, [r3], #4
 80511fa:	6881      	ldr	r1, [r0, #8]
 80511fc:	9301      	str	r3, [sp, #4]
 80511fe:	f002 f9b7 	bl	8053570 <_vfprintf_r>
 8051202:	b003      	add	sp, #12
 8051204:	f85d eb04 	ldr.w	lr, [sp], #4
 8051208:	b004      	add	sp, #16
 805120a:	4770      	bx	lr
 805120c:	200038cc 	.word	0x200038cc

08051210 <_sbrk_r>:
 8051210:	b538      	push	{r3, r4, r5, lr}
 8051212:	4d06      	ldr	r5, [pc, #24]	; (805122c <_sbrk_r+0x1c>)
 8051214:	2300      	movs	r3, #0
 8051216:	4604      	mov	r4, r0
 8051218:	4608      	mov	r0, r1
 805121a:	602b      	str	r3, [r5, #0]
 805121c:	f7fe fdce 	bl	804fdbc <_sbrk>
 8051220:	1c43      	adds	r3, r0, #1
 8051222:	d102      	bne.n	805122a <_sbrk_r+0x1a>
 8051224:	682b      	ldr	r3, [r5, #0]
 8051226:	b103      	cbz	r3, 805122a <_sbrk_r+0x1a>
 8051228:	6023      	str	r3, [r4, #0]
 805122a:	bd38      	pop	{r3, r4, r5, pc}
 805122c:	20010330 	.word	0x20010330

08051230 <sprintf>:
 8051230:	b40e      	push	{r1, r2, r3}
 8051232:	b500      	push	{lr}
 8051234:	b09c      	sub	sp, #112	; 0x70
 8051236:	ab1d      	add	r3, sp, #116	; 0x74
 8051238:	9002      	str	r0, [sp, #8]
 805123a:	9006      	str	r0, [sp, #24]
 805123c:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8051240:	4809      	ldr	r0, [pc, #36]	; (8051268 <sprintf+0x38>)
 8051242:	9107      	str	r1, [sp, #28]
 8051244:	9104      	str	r1, [sp, #16]
 8051246:	4909      	ldr	r1, [pc, #36]	; (805126c <sprintf+0x3c>)
 8051248:	f853 2b04 	ldr.w	r2, [r3], #4
 805124c:	9105      	str	r1, [sp, #20]
 805124e:	6800      	ldr	r0, [r0, #0]
 8051250:	9301      	str	r3, [sp, #4]
 8051252:	a902      	add	r1, sp, #8
 8051254:	f000 ff5c 	bl	8052110 <_svfprintf_r>
 8051258:	9b02      	ldr	r3, [sp, #8]
 805125a:	2200      	movs	r2, #0
 805125c:	701a      	strb	r2, [r3, #0]
 805125e:	b01c      	add	sp, #112	; 0x70
 8051260:	f85d eb04 	ldr.w	lr, [sp], #4
 8051264:	b003      	add	sp, #12
 8051266:	4770      	bx	lr
 8051268:	200038cc 	.word	0x200038cc
 805126c:	ffff0208 	.word	0xffff0208

08051270 <strcat>:
 8051270:	b510      	push	{r4, lr}
 8051272:	4602      	mov	r2, r0
 8051274:	7814      	ldrb	r4, [r2, #0]
 8051276:	4613      	mov	r3, r2
 8051278:	3201      	adds	r2, #1
 805127a:	2c00      	cmp	r4, #0
 805127c:	d1fa      	bne.n	8051274 <strcat+0x4>
 805127e:	3b01      	subs	r3, #1
 8051280:	f811 2b01 	ldrb.w	r2, [r1], #1
 8051284:	f803 2f01 	strb.w	r2, [r3, #1]!
 8051288:	2a00      	cmp	r2, #0
 805128a:	d1f9      	bne.n	8051280 <strcat+0x10>
 805128c:	bd10      	pop	{r4, pc}

0805128e <strchr>:
 805128e:	b2c9      	uxtb	r1, r1
 8051290:	4603      	mov	r3, r0
 8051292:	f810 2b01 	ldrb.w	r2, [r0], #1
 8051296:	b11a      	cbz	r2, 80512a0 <strchr+0x12>
 8051298:	428a      	cmp	r2, r1
 805129a:	d1f9      	bne.n	8051290 <strchr+0x2>
 805129c:	4618      	mov	r0, r3
 805129e:	4770      	bx	lr
 80512a0:	2900      	cmp	r1, #0
 80512a2:	bf18      	it	ne
 80512a4:	2300      	movne	r3, #0
 80512a6:	e7f9      	b.n	805129c <strchr+0xe>

080512a8 <strcpy>:
 80512a8:	4603      	mov	r3, r0
 80512aa:	f811 2b01 	ldrb.w	r2, [r1], #1
 80512ae:	f803 2b01 	strb.w	r2, [r3], #1
 80512b2:	2a00      	cmp	r2, #0
 80512b4:	d1f9      	bne.n	80512aa <strcpy+0x2>
 80512b6:	4770      	bx	lr

080512b8 <strncmp>:
 80512b8:	b510      	push	{r4, lr}
 80512ba:	b16a      	cbz	r2, 80512d8 <strncmp+0x20>
 80512bc:	3901      	subs	r1, #1
 80512be:	1884      	adds	r4, r0, r2
 80512c0:	f810 3b01 	ldrb.w	r3, [r0], #1
 80512c4:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80512c8:	4293      	cmp	r3, r2
 80512ca:	d103      	bne.n	80512d4 <strncmp+0x1c>
 80512cc:	42a0      	cmp	r0, r4
 80512ce:	d001      	beq.n	80512d4 <strncmp+0x1c>
 80512d0:	2b00      	cmp	r3, #0
 80512d2:	d1f5      	bne.n	80512c0 <strncmp+0x8>
 80512d4:	1a98      	subs	r0, r3, r2
 80512d6:	bd10      	pop	{r4, pc}
 80512d8:	4610      	mov	r0, r2
 80512da:	e7fc      	b.n	80512d6 <strncmp+0x1e>

080512dc <strncpy>:
 80512dc:	b510      	push	{r4, lr}
 80512de:	3901      	subs	r1, #1
 80512e0:	4603      	mov	r3, r0
 80512e2:	b132      	cbz	r2, 80512f2 <strncpy+0x16>
 80512e4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80512e8:	f803 4b01 	strb.w	r4, [r3], #1
 80512ec:	3a01      	subs	r2, #1
 80512ee:	2c00      	cmp	r4, #0
 80512f0:	d1f7      	bne.n	80512e2 <strncpy+0x6>
 80512f2:	441a      	add	r2, r3
 80512f4:	2100      	movs	r1, #0
 80512f6:	4293      	cmp	r3, r2
 80512f8:	d100      	bne.n	80512fc <strncpy+0x20>
 80512fa:	bd10      	pop	{r4, pc}
 80512fc:	f803 1b01 	strb.w	r1, [r3], #1
 8051300:	e7f9      	b.n	80512f6 <strncpy+0x1a>

08051302 <strstr>:
 8051302:	b5f0      	push	{r4, r5, r6, r7, lr}
 8051304:	780c      	ldrb	r4, [r1, #0]
 8051306:	b164      	cbz	r4, 8051322 <strstr+0x20>
 8051308:	4603      	mov	r3, r0
 805130a:	781a      	ldrb	r2, [r3, #0]
 805130c:	4618      	mov	r0, r3
 805130e:	1c5e      	adds	r6, r3, #1
 8051310:	b90a      	cbnz	r2, 8051316 <strstr+0x14>
 8051312:	4610      	mov	r0, r2
 8051314:	e005      	b.n	8051322 <strstr+0x20>
 8051316:	4294      	cmp	r4, r2
 8051318:	d108      	bne.n	805132c <strstr+0x2a>
 805131a:	460d      	mov	r5, r1
 805131c:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 8051320:	b902      	cbnz	r2, 8051324 <strstr+0x22>
 8051322:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8051324:	f813 7f01 	ldrb.w	r7, [r3, #1]!
 8051328:	4297      	cmp	r7, r2
 805132a:	d0f7      	beq.n	805131c <strstr+0x1a>
 805132c:	4633      	mov	r3, r6
 805132e:	e7ec      	b.n	805130a <strstr+0x8>

08051330 <sulp>:
 8051330:	b570      	push	{r4, r5, r6, lr}
 8051332:	4604      	mov	r4, r0
 8051334:	460d      	mov	r5, r1
 8051336:	ec45 4b10 	vmov	d0, r4, r5
 805133a:	4616      	mov	r6, r2
 805133c:	f005 fbe0 	bl	8056b00 <__ulp>
 8051340:	ec51 0b10 	vmov	r0, r1, d0
 8051344:	b17e      	cbz	r6, 8051366 <sulp+0x36>
 8051346:	f3c5 530a 	ubfx	r3, r5, #20, #11
 805134a:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 805134e:	2b00      	cmp	r3, #0
 8051350:	dd09      	ble.n	8051366 <sulp+0x36>
 8051352:	051b      	lsls	r3, r3, #20
 8051354:	f103 557f 	add.w	r5, r3, #1069547520	; 0x3fc00000
 8051358:	2400      	movs	r4, #0
 805135a:	f505 1540 	add.w	r5, r5, #3145728	; 0x300000
 805135e:	4622      	mov	r2, r4
 8051360:	462b      	mov	r3, r5
 8051362:	f7ef f959 	bl	8040618 <__aeabi_dmul>
 8051366:	bd70      	pop	{r4, r5, r6, pc}

08051368 <_strtod_l>:
 8051368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 805136c:	b0a3      	sub	sp, #140	; 0x8c
 805136e:	461f      	mov	r7, r3
 8051370:	2300      	movs	r3, #0
 8051372:	931e      	str	r3, [sp, #120]	; 0x78
 8051374:	4ba4      	ldr	r3, [pc, #656]	; (8051608 <_strtod_l+0x2a0>)
 8051376:	9219      	str	r2, [sp, #100]	; 0x64
 8051378:	681b      	ldr	r3, [r3, #0]
 805137a:	9307      	str	r3, [sp, #28]
 805137c:	4604      	mov	r4, r0
 805137e:	4618      	mov	r0, r3
 8051380:	4688      	mov	r8, r1
 8051382:	f7ee ff35 	bl	80401f0 <strlen>
 8051386:	f04f 0a00 	mov.w	sl, #0
 805138a:	4605      	mov	r5, r0
 805138c:	f04f 0b00 	mov.w	fp, #0
 8051390:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 8051394:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051396:	781a      	ldrb	r2, [r3, #0]
 8051398:	2a2b      	cmp	r2, #43	; 0x2b
 805139a:	d04c      	beq.n	8051436 <_strtod_l+0xce>
 805139c:	d839      	bhi.n	8051412 <_strtod_l+0xaa>
 805139e:	2a0d      	cmp	r2, #13
 80513a0:	d832      	bhi.n	8051408 <_strtod_l+0xa0>
 80513a2:	2a08      	cmp	r2, #8
 80513a4:	d832      	bhi.n	805140c <_strtod_l+0xa4>
 80513a6:	2a00      	cmp	r2, #0
 80513a8:	d03c      	beq.n	8051424 <_strtod_l+0xbc>
 80513aa:	2300      	movs	r3, #0
 80513ac:	930e      	str	r3, [sp, #56]	; 0x38
 80513ae:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 80513b0:	7833      	ldrb	r3, [r6, #0]
 80513b2:	2b30      	cmp	r3, #48	; 0x30
 80513b4:	f040 80b4 	bne.w	8051520 <_strtod_l+0x1b8>
 80513b8:	7873      	ldrb	r3, [r6, #1]
 80513ba:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80513be:	2b58      	cmp	r3, #88	; 0x58
 80513c0:	d16c      	bne.n	805149c <_strtod_l+0x134>
 80513c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80513c4:	9301      	str	r3, [sp, #4]
 80513c6:	ab1e      	add	r3, sp, #120	; 0x78
 80513c8:	9702      	str	r7, [sp, #8]
 80513ca:	9300      	str	r3, [sp, #0]
 80513cc:	4a8f      	ldr	r2, [pc, #572]	; (805160c <_strtod_l+0x2a4>)
 80513ce:	ab1f      	add	r3, sp, #124	; 0x7c
 80513d0:	a91d      	add	r1, sp, #116	; 0x74
 80513d2:	4620      	mov	r0, r4
 80513d4:	f004 fce2 	bl	8055d9c <__gethex>
 80513d8:	f010 0707 	ands.w	r7, r0, #7
 80513dc:	4605      	mov	r5, r0
 80513de:	d005      	beq.n	80513ec <_strtod_l+0x84>
 80513e0:	2f06      	cmp	r7, #6
 80513e2:	d12a      	bne.n	805143a <_strtod_l+0xd2>
 80513e4:	3601      	adds	r6, #1
 80513e6:	2300      	movs	r3, #0
 80513e8:	961d      	str	r6, [sp, #116]	; 0x74
 80513ea:	930e      	str	r3, [sp, #56]	; 0x38
 80513ec:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80513ee:	2b00      	cmp	r3, #0
 80513f0:	f040 8596 	bne.w	8051f20 <_strtod_l+0xbb8>
 80513f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80513f6:	b1db      	cbz	r3, 8051430 <_strtod_l+0xc8>
 80513f8:	4652      	mov	r2, sl
 80513fa:	f10b 4300 	add.w	r3, fp, #2147483648	; 0x80000000
 80513fe:	ec43 2b10 	vmov	d0, r2, r3
 8051402:	b023      	add	sp, #140	; 0x8c
 8051404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8051408:	2a20      	cmp	r2, #32
 805140a:	d1ce      	bne.n	80513aa <_strtod_l+0x42>
 805140c:	3301      	adds	r3, #1
 805140e:	931d      	str	r3, [sp, #116]	; 0x74
 8051410:	e7c0      	b.n	8051394 <_strtod_l+0x2c>
 8051412:	2a2d      	cmp	r2, #45	; 0x2d
 8051414:	d1c9      	bne.n	80513aa <_strtod_l+0x42>
 8051416:	2201      	movs	r2, #1
 8051418:	920e      	str	r2, [sp, #56]	; 0x38
 805141a:	1c5a      	adds	r2, r3, #1
 805141c:	921d      	str	r2, [sp, #116]	; 0x74
 805141e:	785b      	ldrb	r3, [r3, #1]
 8051420:	2b00      	cmp	r3, #0
 8051422:	d1c4      	bne.n	80513ae <_strtod_l+0x46>
 8051424:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8051426:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 805142a:	2b00      	cmp	r3, #0
 805142c:	f040 8576 	bne.w	8051f1c <_strtod_l+0xbb4>
 8051430:	4652      	mov	r2, sl
 8051432:	465b      	mov	r3, fp
 8051434:	e7e3      	b.n	80513fe <_strtod_l+0x96>
 8051436:	2200      	movs	r2, #0
 8051438:	e7ee      	b.n	8051418 <_strtod_l+0xb0>
 805143a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 805143c:	b13a      	cbz	r2, 805144e <_strtod_l+0xe6>
 805143e:	2135      	movs	r1, #53	; 0x35
 8051440:	a820      	add	r0, sp, #128	; 0x80
 8051442:	f005 fc68 	bl	8056d16 <__copybits>
 8051446:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051448:	4620      	mov	r0, r4
 805144a:	f005 f860 	bl	805650e <_Bfree>
 805144e:	3f01      	subs	r7, #1
 8051450:	2f05      	cmp	r7, #5
 8051452:	d807      	bhi.n	8051464 <_strtod_l+0xfc>
 8051454:	e8df f007 	tbb	[pc, r7]
 8051458:	1d180b0e 	.word	0x1d180b0e
 805145c:	030e      	.short	0x030e
 805145e:	f04f 0b00 	mov.w	fp, #0
 8051462:	46da      	mov	sl, fp
 8051464:	0728      	lsls	r0, r5, #28
 8051466:	d5c1      	bpl.n	80513ec <_strtod_l+0x84>
 8051468:	f04b 4b00 	orr.w	fp, fp, #2147483648	; 0x80000000
 805146c:	e7be      	b.n	80513ec <_strtod_l+0x84>
 805146e:	e9dd ab20 	ldrd	sl, fp, [sp, #128]	; 0x80
 8051472:	e7f7      	b.n	8051464 <_strtod_l+0xfc>
 8051474:	e9dd a320 	ldrd	sl, r3, [sp, #128]	; 0x80
 8051478:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 805147a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 805147e:	f202 4233 	addw	r2, r2, #1075	; 0x433
 8051482:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
 8051486:	e7ed      	b.n	8051464 <_strtod_l+0xfc>
 8051488:	f8df b184 	ldr.w	fp, [pc, #388]	; 8051610 <_strtod_l+0x2a8>
 805148c:	f04f 0a00 	mov.w	sl, #0
 8051490:	e7e8      	b.n	8051464 <_strtod_l+0xfc>
 8051492:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
 8051496:	f04f 3aff 	mov.w	sl, #4294967295
 805149a:	e7e3      	b.n	8051464 <_strtod_l+0xfc>
 805149c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 805149e:	1c5a      	adds	r2, r3, #1
 80514a0:	921d      	str	r2, [sp, #116]	; 0x74
 80514a2:	785b      	ldrb	r3, [r3, #1]
 80514a4:	2b30      	cmp	r3, #48	; 0x30
 80514a6:	d0f9      	beq.n	805149c <_strtod_l+0x134>
 80514a8:	2b00      	cmp	r3, #0
 80514aa:	d09f      	beq.n	80513ec <_strtod_l+0x84>
 80514ac:	2301      	movs	r3, #1
 80514ae:	f04f 0900 	mov.w	r9, #0
 80514b2:	9304      	str	r3, [sp, #16]
 80514b4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80514b6:	930a      	str	r3, [sp, #40]	; 0x28
 80514b8:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 80514bc:	464f      	mov	r7, r9
 80514be:	220a      	movs	r2, #10
 80514c0:	981d      	ldr	r0, [sp, #116]	; 0x74
 80514c2:	7806      	ldrb	r6, [r0, #0]
 80514c4:	f1a6 0330 	sub.w	r3, r6, #48	; 0x30
 80514c8:	b2d9      	uxtb	r1, r3
 80514ca:	2909      	cmp	r1, #9
 80514cc:	d92a      	bls.n	8051524 <_strtod_l+0x1bc>
 80514ce:	9907      	ldr	r1, [sp, #28]
 80514d0:	462a      	mov	r2, r5
 80514d2:	f7ff fef1 	bl	80512b8 <strncmp>
 80514d6:	b398      	cbz	r0, 8051540 <_strtod_l+0x1d8>
 80514d8:	2000      	movs	r0, #0
 80514da:	4633      	mov	r3, r6
 80514dc:	463d      	mov	r5, r7
 80514de:	9007      	str	r0, [sp, #28]
 80514e0:	4602      	mov	r2, r0
 80514e2:	2b65      	cmp	r3, #101	; 0x65
 80514e4:	d001      	beq.n	80514ea <_strtod_l+0x182>
 80514e6:	2b45      	cmp	r3, #69	; 0x45
 80514e8:	d118      	bne.n	805151c <_strtod_l+0x1b4>
 80514ea:	b91d      	cbnz	r5, 80514f4 <_strtod_l+0x18c>
 80514ec:	9b04      	ldr	r3, [sp, #16]
 80514ee:	4303      	orrs	r3, r0
 80514f0:	d098      	beq.n	8051424 <_strtod_l+0xbc>
 80514f2:	2500      	movs	r5, #0
 80514f4:	f8dd 8074 	ldr.w	r8, [sp, #116]	; 0x74
 80514f8:	f108 0301 	add.w	r3, r8, #1
 80514fc:	931d      	str	r3, [sp, #116]	; 0x74
 80514fe:	f898 3001 	ldrb.w	r3, [r8, #1]
 8051502:	2b2b      	cmp	r3, #43	; 0x2b
 8051504:	d075      	beq.n	80515f2 <_strtod_l+0x28a>
 8051506:	2b2d      	cmp	r3, #45	; 0x2d
 8051508:	d07b      	beq.n	8051602 <_strtod_l+0x29a>
 805150a:	f04f 0c00 	mov.w	ip, #0
 805150e:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8051512:	2909      	cmp	r1, #9
 8051514:	f240 8082 	bls.w	805161c <_strtod_l+0x2b4>
 8051518:	f8cd 8074 	str.w	r8, [sp, #116]	; 0x74
 805151c:	2600      	movs	r6, #0
 805151e:	e09d      	b.n	805165c <_strtod_l+0x2f4>
 8051520:	2300      	movs	r3, #0
 8051522:	e7c4      	b.n	80514ae <_strtod_l+0x146>
 8051524:	2f08      	cmp	r7, #8
 8051526:	bfd8      	it	le
 8051528:	9909      	ldrle	r1, [sp, #36]	; 0x24
 805152a:	f100 0001 	add.w	r0, r0, #1
 805152e:	bfda      	itte	le
 8051530:	fb02 3301 	mlale	r3, r2, r1, r3
 8051534:	9309      	strle	r3, [sp, #36]	; 0x24
 8051536:	fb02 3909 	mlagt	r9, r2, r9, r3
 805153a:	3701      	adds	r7, #1
 805153c:	901d      	str	r0, [sp, #116]	; 0x74
 805153e:	e7bf      	b.n	80514c0 <_strtod_l+0x158>
 8051540:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051542:	195a      	adds	r2, r3, r5
 8051544:	921d      	str	r2, [sp, #116]	; 0x74
 8051546:	5d5b      	ldrb	r3, [r3, r5]
 8051548:	2f00      	cmp	r7, #0
 805154a:	d037      	beq.n	80515bc <_strtod_l+0x254>
 805154c:	9007      	str	r0, [sp, #28]
 805154e:	463d      	mov	r5, r7
 8051550:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8051554:	2a09      	cmp	r2, #9
 8051556:	d912      	bls.n	805157e <_strtod_l+0x216>
 8051558:	2201      	movs	r2, #1
 805155a:	e7c2      	b.n	80514e2 <_strtod_l+0x17a>
 805155c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 805155e:	1c5a      	adds	r2, r3, #1
 8051560:	921d      	str	r2, [sp, #116]	; 0x74
 8051562:	785b      	ldrb	r3, [r3, #1]
 8051564:	3001      	adds	r0, #1
 8051566:	2b30      	cmp	r3, #48	; 0x30
 8051568:	d0f8      	beq.n	805155c <_strtod_l+0x1f4>
 805156a:	f1a3 0231 	sub.w	r2, r3, #49	; 0x31
 805156e:	2a08      	cmp	r2, #8
 8051570:	f200 84db 	bhi.w	8051f2a <_strtod_l+0xbc2>
 8051574:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 8051576:	9007      	str	r0, [sp, #28]
 8051578:	2000      	movs	r0, #0
 805157a:	920a      	str	r2, [sp, #40]	; 0x28
 805157c:	4605      	mov	r5, r0
 805157e:	3b30      	subs	r3, #48	; 0x30
 8051580:	f100 0201 	add.w	r2, r0, #1
 8051584:	d014      	beq.n	80515b0 <_strtod_l+0x248>
 8051586:	9907      	ldr	r1, [sp, #28]
 8051588:	4411      	add	r1, r2
 805158a:	9107      	str	r1, [sp, #28]
 805158c:	462a      	mov	r2, r5
 805158e:	eb00 0e05 	add.w	lr, r0, r5
 8051592:	210a      	movs	r1, #10
 8051594:	4572      	cmp	r2, lr
 8051596:	d113      	bne.n	80515c0 <_strtod_l+0x258>
 8051598:	182a      	adds	r2, r5, r0
 805159a:	2a08      	cmp	r2, #8
 805159c:	f105 0501 	add.w	r5, r5, #1
 80515a0:	4405      	add	r5, r0
 80515a2:	dc1c      	bgt.n	80515de <_strtod_l+0x276>
 80515a4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80515a6:	220a      	movs	r2, #10
 80515a8:	fb02 3301 	mla	r3, r2, r1, r3
 80515ac:	9309      	str	r3, [sp, #36]	; 0x24
 80515ae:	2200      	movs	r2, #0
 80515b0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80515b2:	1c59      	adds	r1, r3, #1
 80515b4:	911d      	str	r1, [sp, #116]	; 0x74
 80515b6:	785b      	ldrb	r3, [r3, #1]
 80515b8:	4610      	mov	r0, r2
 80515ba:	e7c9      	b.n	8051550 <_strtod_l+0x1e8>
 80515bc:	4638      	mov	r0, r7
 80515be:	e7d2      	b.n	8051566 <_strtod_l+0x1fe>
 80515c0:	2a08      	cmp	r2, #8
 80515c2:	dc04      	bgt.n	80515ce <_strtod_l+0x266>
 80515c4:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80515c6:	434e      	muls	r6, r1
 80515c8:	9609      	str	r6, [sp, #36]	; 0x24
 80515ca:	3201      	adds	r2, #1
 80515cc:	e7e2      	b.n	8051594 <_strtod_l+0x22c>
 80515ce:	f102 0c01 	add.w	ip, r2, #1
 80515d2:	f1bc 0f10 	cmp.w	ip, #16
 80515d6:	bfd8      	it	le
 80515d8:	fb01 f909 	mulle.w	r9, r1, r9
 80515dc:	e7f5      	b.n	80515ca <_strtod_l+0x262>
 80515de:	2d10      	cmp	r5, #16
 80515e0:	bfdc      	itt	le
 80515e2:	220a      	movle	r2, #10
 80515e4:	fb02 3909 	mlale	r9, r2, r9, r3
 80515e8:	e7e1      	b.n	80515ae <_strtod_l+0x246>
 80515ea:	2300      	movs	r3, #0
 80515ec:	9307      	str	r3, [sp, #28]
 80515ee:	2201      	movs	r2, #1
 80515f0:	e77c      	b.n	80514ec <_strtod_l+0x184>
 80515f2:	f04f 0c00 	mov.w	ip, #0
 80515f6:	f108 0302 	add.w	r3, r8, #2
 80515fa:	931d      	str	r3, [sp, #116]	; 0x74
 80515fc:	f898 3002 	ldrb.w	r3, [r8, #2]
 8051600:	e785      	b.n	805150e <_strtod_l+0x1a6>
 8051602:	f04f 0c01 	mov.w	ip, #1
 8051606:	e7f6      	b.n	80515f6 <_strtod_l+0x28e>
 8051608:	0805a5d0 	.word	0x0805a5d0
 805160c:	0805a300 	.word	0x0805a300
 8051610:	7ff00000 	.word	0x7ff00000
 8051614:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051616:	1c59      	adds	r1, r3, #1
 8051618:	911d      	str	r1, [sp, #116]	; 0x74
 805161a:	785b      	ldrb	r3, [r3, #1]
 805161c:	2b30      	cmp	r3, #48	; 0x30
 805161e:	d0f9      	beq.n	8051614 <_strtod_l+0x2ac>
 8051620:	f1a3 0131 	sub.w	r1, r3, #49	; 0x31
 8051624:	2908      	cmp	r1, #8
 8051626:	f63f af79 	bhi.w	805151c <_strtod_l+0x1b4>
 805162a:	f1a3 0e30 	sub.w	lr, r3, #48	; 0x30
 805162e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051630:	9308      	str	r3, [sp, #32]
 8051632:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051634:	1c59      	adds	r1, r3, #1
 8051636:	911d      	str	r1, [sp, #116]	; 0x74
 8051638:	785b      	ldrb	r3, [r3, #1]
 805163a:	f1a3 0630 	sub.w	r6, r3, #48	; 0x30
 805163e:	2e09      	cmp	r6, #9
 8051640:	d937      	bls.n	80516b2 <_strtod_l+0x34a>
 8051642:	9e08      	ldr	r6, [sp, #32]
 8051644:	1b89      	subs	r1, r1, r6
 8051646:	2908      	cmp	r1, #8
 8051648:	f644 661f 	movw	r6, #19999	; 0x4e1f
 805164c:	dc02      	bgt.n	8051654 <_strtod_l+0x2ec>
 805164e:	4576      	cmp	r6, lr
 8051650:	bfa8      	it	ge
 8051652:	4676      	movge	r6, lr
 8051654:	f1bc 0f00 	cmp.w	ip, #0
 8051658:	d000      	beq.n	805165c <_strtod_l+0x2f4>
 805165a:	4276      	negs	r6, r6
 805165c:	2d00      	cmp	r5, #0
 805165e:	d14f      	bne.n	8051700 <_strtod_l+0x398>
 8051660:	9904      	ldr	r1, [sp, #16]
 8051662:	4301      	orrs	r1, r0
 8051664:	f47f aec2 	bne.w	80513ec <_strtod_l+0x84>
 8051668:	2a00      	cmp	r2, #0
 805166a:	f47f aedb 	bne.w	8051424 <_strtod_l+0xbc>
 805166e:	2b69      	cmp	r3, #105	; 0x69
 8051670:	d027      	beq.n	80516c2 <_strtod_l+0x35a>
 8051672:	dc24      	bgt.n	80516be <_strtod_l+0x356>
 8051674:	2b49      	cmp	r3, #73	; 0x49
 8051676:	d024      	beq.n	80516c2 <_strtod_l+0x35a>
 8051678:	2b4e      	cmp	r3, #78	; 0x4e
 805167a:	f47f aed3 	bne.w	8051424 <_strtod_l+0xbc>
 805167e:	499e      	ldr	r1, [pc, #632]	; (80518f8 <_strtod_l+0x590>)
 8051680:	a81d      	add	r0, sp, #116	; 0x74
 8051682:	f004 fde3 	bl	805624c <__match>
 8051686:	2800      	cmp	r0, #0
 8051688:	f43f aecc 	beq.w	8051424 <_strtod_l+0xbc>
 805168c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 805168e:	781b      	ldrb	r3, [r3, #0]
 8051690:	2b28      	cmp	r3, #40	; 0x28
 8051692:	d12d      	bne.n	80516f0 <_strtod_l+0x388>
 8051694:	4999      	ldr	r1, [pc, #612]	; (80518fc <_strtod_l+0x594>)
 8051696:	aa20      	add	r2, sp, #128	; 0x80
 8051698:	a81d      	add	r0, sp, #116	; 0x74
 805169a:	f004 fdeb 	bl	8056274 <__hexnan>
 805169e:	2805      	cmp	r0, #5
 80516a0:	d126      	bne.n	80516f0 <_strtod_l+0x388>
 80516a2:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80516a4:	f8dd a080 	ldr.w	sl, [sp, #128]	; 0x80
 80516a8:	f043 4bff 	orr.w	fp, r3, #2139095040	; 0x7f800000
 80516ac:	f44b 0be0 	orr.w	fp, fp, #7340032	; 0x700000
 80516b0:	e69c      	b.n	80513ec <_strtod_l+0x84>
 80516b2:	210a      	movs	r1, #10
 80516b4:	fb01 3e0e 	mla	lr, r1, lr, r3
 80516b8:	f1ae 0e30 	sub.w	lr, lr, #48	; 0x30
 80516bc:	e7b9      	b.n	8051632 <_strtod_l+0x2ca>
 80516be:	2b6e      	cmp	r3, #110	; 0x6e
 80516c0:	e7db      	b.n	805167a <_strtod_l+0x312>
 80516c2:	498f      	ldr	r1, [pc, #572]	; (8051900 <_strtod_l+0x598>)
 80516c4:	a81d      	add	r0, sp, #116	; 0x74
 80516c6:	f004 fdc1 	bl	805624c <__match>
 80516ca:	2800      	cmp	r0, #0
 80516cc:	f43f aeaa 	beq.w	8051424 <_strtod_l+0xbc>
 80516d0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80516d2:	498c      	ldr	r1, [pc, #560]	; (8051904 <_strtod_l+0x59c>)
 80516d4:	3b01      	subs	r3, #1
 80516d6:	a81d      	add	r0, sp, #116	; 0x74
 80516d8:	931d      	str	r3, [sp, #116]	; 0x74
 80516da:	f004 fdb7 	bl	805624c <__match>
 80516de:	b910      	cbnz	r0, 80516e6 <_strtod_l+0x37e>
 80516e0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80516e2:	3301      	adds	r3, #1
 80516e4:	931d      	str	r3, [sp, #116]	; 0x74
 80516e6:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8051914 <_strtod_l+0x5ac>
 80516ea:	f04f 0a00 	mov.w	sl, #0
 80516ee:	e67d      	b.n	80513ec <_strtod_l+0x84>
 80516f0:	4885      	ldr	r0, [pc, #532]	; (8051908 <_strtod_l+0x5a0>)
 80516f2:	f005 fb8d 	bl	8056e10 <nan>
 80516f6:	ed8d 0b04 	vstr	d0, [sp, #16]
 80516fa:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80516fe:	e675      	b.n	80513ec <_strtod_l+0x84>
 8051700:	9b07      	ldr	r3, [sp, #28]
 8051702:	9809      	ldr	r0, [sp, #36]	; 0x24
 8051704:	1af3      	subs	r3, r6, r3
 8051706:	2f00      	cmp	r7, #0
 8051708:	bf08      	it	eq
 805170a:	462f      	moveq	r7, r5
 805170c:	2d10      	cmp	r5, #16
 805170e:	9308      	str	r3, [sp, #32]
 8051710:	46a8      	mov	r8, r5
 8051712:	bfa8      	it	ge
 8051714:	f04f 0810 	movge.w	r8, #16
 8051718:	f7ee ff04 	bl	8040524 <__aeabi_ui2d>
 805171c:	2d09      	cmp	r5, #9
 805171e:	4682      	mov	sl, r0
 8051720:	468b      	mov	fp, r1
 8051722:	dd13      	ble.n	805174c <_strtod_l+0x3e4>
 8051724:	4b79      	ldr	r3, [pc, #484]	; (805190c <_strtod_l+0x5a4>)
 8051726:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 805172a:	e953 2312 	ldrd	r2, r3, [r3, #-72]	; 0x48
 805172e:	f7ee ff73 	bl	8040618 <__aeabi_dmul>
 8051732:	4682      	mov	sl, r0
 8051734:	4648      	mov	r0, r9
 8051736:	468b      	mov	fp, r1
 8051738:	f7ee fef4 	bl	8040524 <__aeabi_ui2d>
 805173c:	4602      	mov	r2, r0
 805173e:	460b      	mov	r3, r1
 8051740:	4650      	mov	r0, sl
 8051742:	4659      	mov	r1, fp
 8051744:	f7ee fdb2 	bl	80402ac <__adddf3>
 8051748:	4682      	mov	sl, r0
 805174a:	468b      	mov	fp, r1
 805174c:	2d0f      	cmp	r5, #15
 805174e:	dc38      	bgt.n	80517c2 <_strtod_l+0x45a>
 8051750:	9b08      	ldr	r3, [sp, #32]
 8051752:	2b00      	cmp	r3, #0
 8051754:	f43f ae4a 	beq.w	80513ec <_strtod_l+0x84>
 8051758:	dd24      	ble.n	80517a4 <_strtod_l+0x43c>
 805175a:	2b16      	cmp	r3, #22
 805175c:	dc0b      	bgt.n	8051776 <_strtod_l+0x40e>
 805175e:	4d6b      	ldr	r5, [pc, #428]	; (805190c <_strtod_l+0x5a4>)
 8051760:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8051764:	e9d5 0100 	ldrd	r0, r1, [r5]
 8051768:	4652      	mov	r2, sl
 805176a:	465b      	mov	r3, fp
 805176c:	f7ee ff54 	bl	8040618 <__aeabi_dmul>
 8051770:	4682      	mov	sl, r0
 8051772:	468b      	mov	fp, r1
 8051774:	e63a      	b.n	80513ec <_strtod_l+0x84>
 8051776:	9a08      	ldr	r2, [sp, #32]
 8051778:	f1c5 0325 	rsb	r3, r5, #37	; 0x25
 805177c:	4293      	cmp	r3, r2
 805177e:	db20      	blt.n	80517c2 <_strtod_l+0x45a>
 8051780:	4c62      	ldr	r4, [pc, #392]	; (805190c <_strtod_l+0x5a4>)
 8051782:	f1c5 050f 	rsb	r5, r5, #15
 8051786:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 805178a:	4652      	mov	r2, sl
 805178c:	465b      	mov	r3, fp
 805178e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8051792:	f7ee ff41 	bl	8040618 <__aeabi_dmul>
 8051796:	9b08      	ldr	r3, [sp, #32]
 8051798:	1b5d      	subs	r5, r3, r5
 805179a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 805179e:	e9d4 2300 	ldrd	r2, r3, [r4]
 80517a2:	e7e3      	b.n	805176c <_strtod_l+0x404>
 80517a4:	9b08      	ldr	r3, [sp, #32]
 80517a6:	3316      	adds	r3, #22
 80517a8:	db0b      	blt.n	80517c2 <_strtod_l+0x45a>
 80517aa:	9b07      	ldr	r3, [sp, #28]
 80517ac:	4a57      	ldr	r2, [pc, #348]	; (805190c <_strtod_l+0x5a4>)
 80517ae:	1b9e      	subs	r6, r3, r6
 80517b0:	eb02 06c6 	add.w	r6, r2, r6, lsl #3
 80517b4:	e9d6 2300 	ldrd	r2, r3, [r6]
 80517b8:	4650      	mov	r0, sl
 80517ba:	4659      	mov	r1, fp
 80517bc:	f7ef f856 	bl	804086c <__aeabi_ddiv>
 80517c0:	e7d6      	b.n	8051770 <_strtod_l+0x408>
 80517c2:	9b08      	ldr	r3, [sp, #32]
 80517c4:	eba5 0808 	sub.w	r8, r5, r8
 80517c8:	4498      	add	r8, r3
 80517ca:	f1b8 0f00 	cmp.w	r8, #0
 80517ce:	dd71      	ble.n	80518b4 <_strtod_l+0x54c>
 80517d0:	f018 030f 	ands.w	r3, r8, #15
 80517d4:	d00a      	beq.n	80517ec <_strtod_l+0x484>
 80517d6:	494d      	ldr	r1, [pc, #308]	; (805190c <_strtod_l+0x5a4>)
 80517d8:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 80517dc:	4652      	mov	r2, sl
 80517de:	465b      	mov	r3, fp
 80517e0:	e9d1 0100 	ldrd	r0, r1, [r1]
 80517e4:	f7ee ff18 	bl	8040618 <__aeabi_dmul>
 80517e8:	4682      	mov	sl, r0
 80517ea:	468b      	mov	fp, r1
 80517ec:	f038 080f 	bics.w	r8, r8, #15
 80517f0:	d04d      	beq.n	805188e <_strtod_l+0x526>
 80517f2:	f5b8 7f9a 	cmp.w	r8, #308	; 0x134
 80517f6:	dd22      	ble.n	805183e <_strtod_l+0x4d6>
 80517f8:	2500      	movs	r5, #0
 80517fa:	462e      	mov	r6, r5
 80517fc:	9509      	str	r5, [sp, #36]	; 0x24
 80517fe:	9507      	str	r5, [sp, #28]
 8051800:	2322      	movs	r3, #34	; 0x22
 8051802:	f8df b110 	ldr.w	fp, [pc, #272]	; 8051914 <_strtod_l+0x5ac>
 8051806:	6023      	str	r3, [r4, #0]
 8051808:	f04f 0a00 	mov.w	sl, #0
 805180c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805180e:	2b00      	cmp	r3, #0
 8051810:	f43f adec 	beq.w	80513ec <_strtod_l+0x84>
 8051814:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051816:	4620      	mov	r0, r4
 8051818:	f004 fe79 	bl	805650e <_Bfree>
 805181c:	9907      	ldr	r1, [sp, #28]
 805181e:	4620      	mov	r0, r4
 8051820:	f004 fe75 	bl	805650e <_Bfree>
 8051824:	4631      	mov	r1, r6
 8051826:	4620      	mov	r0, r4
 8051828:	f004 fe71 	bl	805650e <_Bfree>
 805182c:	9909      	ldr	r1, [sp, #36]	; 0x24
 805182e:	4620      	mov	r0, r4
 8051830:	f004 fe6d 	bl	805650e <_Bfree>
 8051834:	4629      	mov	r1, r5
 8051836:	4620      	mov	r0, r4
 8051838:	f004 fe69 	bl	805650e <_Bfree>
 805183c:	e5d6      	b.n	80513ec <_strtod_l+0x84>
 805183e:	2300      	movs	r3, #0
 8051840:	ea4f 1828 	mov.w	r8, r8, asr #4
 8051844:	4650      	mov	r0, sl
 8051846:	4659      	mov	r1, fp
 8051848:	4699      	mov	r9, r3
 805184a:	f1b8 0f01 	cmp.w	r8, #1
 805184e:	dc21      	bgt.n	8051894 <_strtod_l+0x52c>
 8051850:	b10b      	cbz	r3, 8051856 <_strtod_l+0x4ee>
 8051852:	4682      	mov	sl, r0
 8051854:	468b      	mov	fp, r1
 8051856:	4b2e      	ldr	r3, [pc, #184]	; (8051910 <_strtod_l+0x5a8>)
 8051858:	f1ab 7b54 	sub.w	fp, fp, #55574528	; 0x3500000
 805185c:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
 8051860:	4652      	mov	r2, sl
 8051862:	465b      	mov	r3, fp
 8051864:	e9d9 0100 	ldrd	r0, r1, [r9]
 8051868:	f7ee fed6 	bl	8040618 <__aeabi_dmul>
 805186c:	4b29      	ldr	r3, [pc, #164]	; (8051914 <_strtod_l+0x5ac>)
 805186e:	460a      	mov	r2, r1
 8051870:	400b      	ands	r3, r1
 8051872:	4929      	ldr	r1, [pc, #164]	; (8051918 <_strtod_l+0x5b0>)
 8051874:	428b      	cmp	r3, r1
 8051876:	4682      	mov	sl, r0
 8051878:	d8be      	bhi.n	80517f8 <_strtod_l+0x490>
 805187a:	f5a1 1180 	sub.w	r1, r1, #1048576	; 0x100000
 805187e:	428b      	cmp	r3, r1
 8051880:	bf86      	itte	hi
 8051882:	f8df b098 	ldrhi.w	fp, [pc, #152]	; 805191c <_strtod_l+0x5b4>
 8051886:	f04f 3aff 	movhi.w	sl, #4294967295
 805188a:	f102 7b54 	addls.w	fp, r2, #55574528	; 0x3500000
 805188e:	2300      	movs	r3, #0
 8051890:	9304      	str	r3, [sp, #16]
 8051892:	e081      	b.n	8051998 <_strtod_l+0x630>
 8051894:	f018 0f01 	tst.w	r8, #1
 8051898:	d007      	beq.n	80518aa <_strtod_l+0x542>
 805189a:	4b1d      	ldr	r3, [pc, #116]	; (8051910 <_strtod_l+0x5a8>)
 805189c:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
 80518a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80518a4:	f7ee feb8 	bl	8040618 <__aeabi_dmul>
 80518a8:	2301      	movs	r3, #1
 80518aa:	f109 0901 	add.w	r9, r9, #1
 80518ae:	ea4f 0868 	mov.w	r8, r8, asr #1
 80518b2:	e7ca      	b.n	805184a <_strtod_l+0x4e2>
 80518b4:	d0eb      	beq.n	805188e <_strtod_l+0x526>
 80518b6:	f1c8 0800 	rsb	r8, r8, #0
 80518ba:	f018 020f 	ands.w	r2, r8, #15
 80518be:	d00a      	beq.n	80518d6 <_strtod_l+0x56e>
 80518c0:	4b12      	ldr	r3, [pc, #72]	; (805190c <_strtod_l+0x5a4>)
 80518c2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80518c6:	4650      	mov	r0, sl
 80518c8:	4659      	mov	r1, fp
 80518ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 80518ce:	f7ee ffcd 	bl	804086c <__aeabi_ddiv>
 80518d2:	4682      	mov	sl, r0
 80518d4:	468b      	mov	fp, r1
 80518d6:	ea5f 1828 	movs.w	r8, r8, asr #4
 80518da:	d0d8      	beq.n	805188e <_strtod_l+0x526>
 80518dc:	f1b8 0f1f 	cmp.w	r8, #31
 80518e0:	dd1e      	ble.n	8051920 <_strtod_l+0x5b8>
 80518e2:	2500      	movs	r5, #0
 80518e4:	462e      	mov	r6, r5
 80518e6:	9509      	str	r5, [sp, #36]	; 0x24
 80518e8:	9507      	str	r5, [sp, #28]
 80518ea:	2322      	movs	r3, #34	; 0x22
 80518ec:	f04f 0a00 	mov.w	sl, #0
 80518f0:	f04f 0b00 	mov.w	fp, #0
 80518f4:	6023      	str	r3, [r4, #0]
 80518f6:	e789      	b.n	805180c <_strtod_l+0x4a4>
 80518f8:	0805a35d 	.word	0x0805a35d
 80518fc:	0805a314 	.word	0x0805a314
 8051900:	0805a355 	.word	0x0805a355
 8051904:	0805a4f1 	.word	0x0805a4f1
 8051908:	0805a79f 	.word	0x0805a79f
 805190c:	0805a670 	.word	0x0805a670
 8051910:	0805a648 	.word	0x0805a648
 8051914:	7ff00000 	.word	0x7ff00000
 8051918:	7ca00000 	.word	0x7ca00000
 805191c:	7fefffff 	.word	0x7fefffff
 8051920:	f018 0310 	ands.w	r3, r8, #16
 8051924:	bf18      	it	ne
 8051926:	236a      	movne	r3, #106	; 0x6a
 8051928:	f8df 93b4 	ldr.w	r9, [pc, #948]	; 8051ce0 <_strtod_l+0x978>
 805192c:	9304      	str	r3, [sp, #16]
 805192e:	4650      	mov	r0, sl
 8051930:	4659      	mov	r1, fp
 8051932:	2300      	movs	r3, #0
 8051934:	f018 0f01 	tst.w	r8, #1
 8051938:	d004      	beq.n	8051944 <_strtod_l+0x5dc>
 805193a:	e9d9 2300 	ldrd	r2, r3, [r9]
 805193e:	f7ee fe6b 	bl	8040618 <__aeabi_dmul>
 8051942:	2301      	movs	r3, #1
 8051944:	ea5f 0868 	movs.w	r8, r8, asr #1
 8051948:	f109 0908 	add.w	r9, r9, #8
 805194c:	d1f2      	bne.n	8051934 <_strtod_l+0x5cc>
 805194e:	b10b      	cbz	r3, 8051954 <_strtod_l+0x5ec>
 8051950:	4682      	mov	sl, r0
 8051952:	468b      	mov	fp, r1
 8051954:	9b04      	ldr	r3, [sp, #16]
 8051956:	b1bb      	cbz	r3, 8051988 <_strtod_l+0x620>
 8051958:	f3cb 530a 	ubfx	r3, fp, #20, #11
 805195c:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
 8051960:	2b00      	cmp	r3, #0
 8051962:	4659      	mov	r1, fp
 8051964:	dd10      	ble.n	8051988 <_strtod_l+0x620>
 8051966:	2b1f      	cmp	r3, #31
 8051968:	f340 8128 	ble.w	8051bbc <_strtod_l+0x854>
 805196c:	2b34      	cmp	r3, #52	; 0x34
 805196e:	bfde      	ittt	le
 8051970:	3b20      	suble	r3, #32
 8051972:	f04f 32ff 	movle.w	r2, #4294967295
 8051976:	fa02 f303 	lslle.w	r3, r2, r3
 805197a:	f04f 0a00 	mov.w	sl, #0
 805197e:	bfcc      	ite	gt
 8051980:	f04f 7b5c 	movgt.w	fp, #57671680	; 0x3700000
 8051984:	ea03 0b01 	andle.w	fp, r3, r1
 8051988:	2200      	movs	r2, #0
 805198a:	2300      	movs	r3, #0
 805198c:	4650      	mov	r0, sl
 805198e:	4659      	mov	r1, fp
 8051990:	f7ef f8aa 	bl	8040ae8 <__aeabi_dcmpeq>
 8051994:	2800      	cmp	r0, #0
 8051996:	d1a4      	bne.n	80518e2 <_strtod_l+0x57a>
 8051998:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805199a:	9300      	str	r3, [sp, #0]
 805199c:	990a      	ldr	r1, [sp, #40]	; 0x28
 805199e:	462b      	mov	r3, r5
 80519a0:	463a      	mov	r2, r7
 80519a2:	4620      	mov	r0, r4
 80519a4:	f004 fe06 	bl	80565b4 <__s2b>
 80519a8:	9009      	str	r0, [sp, #36]	; 0x24
 80519aa:	2800      	cmp	r0, #0
 80519ac:	f43f af24 	beq.w	80517f8 <_strtod_l+0x490>
 80519b0:	9b07      	ldr	r3, [sp, #28]
 80519b2:	1b9e      	subs	r6, r3, r6
 80519b4:	9b08      	ldr	r3, [sp, #32]
 80519b6:	2b00      	cmp	r3, #0
 80519b8:	bfb4      	ite	lt
 80519ba:	4633      	movlt	r3, r6
 80519bc:	2300      	movge	r3, #0
 80519be:	9310      	str	r3, [sp, #64]	; 0x40
 80519c0:	9b08      	ldr	r3, [sp, #32]
 80519c2:	2500      	movs	r5, #0
 80519c4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80519c8:	9318      	str	r3, [sp, #96]	; 0x60
 80519ca:	462e      	mov	r6, r5
 80519cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80519ce:	4620      	mov	r0, r4
 80519d0:	6859      	ldr	r1, [r3, #4]
 80519d2:	f004 fd77 	bl	80564c4 <_Balloc>
 80519d6:	9007      	str	r0, [sp, #28]
 80519d8:	2800      	cmp	r0, #0
 80519da:	f43f af11 	beq.w	8051800 <_strtod_l+0x498>
 80519de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80519e0:	691a      	ldr	r2, [r3, #16]
 80519e2:	3202      	adds	r2, #2
 80519e4:	f103 010c 	add.w	r1, r3, #12
 80519e8:	0092      	lsls	r2, r2, #2
 80519ea:	300c      	adds	r0, #12
 80519ec:	f7ff fbdc 	bl	80511a8 <memcpy>
 80519f0:	ec4b ab10 	vmov	d0, sl, fp
 80519f4:	aa20      	add	r2, sp, #128	; 0x80
 80519f6:	a91f      	add	r1, sp, #124	; 0x7c
 80519f8:	4620      	mov	r0, r4
 80519fa:	e9cd ab0a 	strd	sl, fp, [sp, #40]	; 0x28
 80519fe:	f005 f8fb 	bl	8056bf8 <__d2b>
 8051a02:	901e      	str	r0, [sp, #120]	; 0x78
 8051a04:	2800      	cmp	r0, #0
 8051a06:	f43f aefb 	beq.w	8051800 <_strtod_l+0x498>
 8051a0a:	2101      	movs	r1, #1
 8051a0c:	4620      	mov	r0, r4
 8051a0e:	f004 fe6b 	bl	80566e8 <__i2b>
 8051a12:	4606      	mov	r6, r0
 8051a14:	2800      	cmp	r0, #0
 8051a16:	f43f aef3 	beq.w	8051800 <_strtod_l+0x498>
 8051a1a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8051a1c:	9904      	ldr	r1, [sp, #16]
 8051a1e:	2b00      	cmp	r3, #0
 8051a20:	bfab      	itete	ge
 8051a22:	9a10      	ldrge	r2, [sp, #64]	; 0x40
 8051a24:	9a18      	ldrlt	r2, [sp, #96]	; 0x60
 8051a26:	9f18      	ldrge	r7, [sp, #96]	; 0x60
 8051a28:	f8dd 9040 	ldrlt.w	r9, [sp, #64]	; 0x40
 8051a2c:	bfac      	ite	ge
 8051a2e:	eb03 0902 	addge.w	r9, r3, r2
 8051a32:	1ad7      	sublt	r7, r2, r3
 8051a34:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8051a36:	eba3 0801 	sub.w	r8, r3, r1
 8051a3a:	4490      	add	r8, r2
 8051a3c:	4ba3      	ldr	r3, [pc, #652]	; (8051ccc <_strtod_l+0x964>)
 8051a3e:	f108 38ff 	add.w	r8, r8, #4294967295
 8051a42:	4598      	cmp	r8, r3
 8051a44:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
 8051a48:	f280 80cc 	bge.w	8051be4 <_strtod_l+0x87c>
 8051a4c:	eba3 0308 	sub.w	r3, r3, r8
 8051a50:	2b1f      	cmp	r3, #31
 8051a52:	eba2 0203 	sub.w	r2, r2, r3
 8051a56:	f04f 0101 	mov.w	r1, #1
 8051a5a:	f300 80b6 	bgt.w	8051bca <_strtod_l+0x862>
 8051a5e:	fa01 f303 	lsl.w	r3, r1, r3
 8051a62:	9311      	str	r3, [sp, #68]	; 0x44
 8051a64:	2300      	movs	r3, #0
 8051a66:	930c      	str	r3, [sp, #48]	; 0x30
 8051a68:	eb09 0802 	add.w	r8, r9, r2
 8051a6c:	9b04      	ldr	r3, [sp, #16]
 8051a6e:	45c1      	cmp	r9, r8
 8051a70:	4417      	add	r7, r2
 8051a72:	441f      	add	r7, r3
 8051a74:	464b      	mov	r3, r9
 8051a76:	bfa8      	it	ge
 8051a78:	4643      	movge	r3, r8
 8051a7a:	42bb      	cmp	r3, r7
 8051a7c:	bfa8      	it	ge
 8051a7e:	463b      	movge	r3, r7
 8051a80:	2b00      	cmp	r3, #0
 8051a82:	bfc2      	ittt	gt
 8051a84:	eba8 0803 	subgt.w	r8, r8, r3
 8051a88:	1aff      	subgt	r7, r7, r3
 8051a8a:	eba9 0903 	subgt.w	r9, r9, r3
 8051a8e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8051a90:	2b00      	cmp	r3, #0
 8051a92:	dd17      	ble.n	8051ac4 <_strtod_l+0x75c>
 8051a94:	4631      	mov	r1, r6
 8051a96:	461a      	mov	r2, r3
 8051a98:	4620      	mov	r0, r4
 8051a9a:	f004 fee1 	bl	8056860 <__pow5mult>
 8051a9e:	4606      	mov	r6, r0
 8051aa0:	2800      	cmp	r0, #0
 8051aa2:	f43f aead 	beq.w	8051800 <_strtod_l+0x498>
 8051aa6:	4601      	mov	r1, r0
 8051aa8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8051aaa:	4620      	mov	r0, r4
 8051aac:	f004 fe32 	bl	8056714 <__multiply>
 8051ab0:	900f      	str	r0, [sp, #60]	; 0x3c
 8051ab2:	2800      	cmp	r0, #0
 8051ab4:	f43f aea4 	beq.w	8051800 <_strtod_l+0x498>
 8051ab8:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051aba:	4620      	mov	r0, r4
 8051abc:	f004 fd27 	bl	805650e <_Bfree>
 8051ac0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051ac2:	931e      	str	r3, [sp, #120]	; 0x78
 8051ac4:	f1b8 0f00 	cmp.w	r8, #0
 8051ac8:	f300 8091 	bgt.w	8051bee <_strtod_l+0x886>
 8051acc:	9b08      	ldr	r3, [sp, #32]
 8051ace:	2b00      	cmp	r3, #0
 8051ad0:	dd08      	ble.n	8051ae4 <_strtod_l+0x77c>
 8051ad2:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8051ad4:	9907      	ldr	r1, [sp, #28]
 8051ad6:	4620      	mov	r0, r4
 8051ad8:	f004 fec2 	bl	8056860 <__pow5mult>
 8051adc:	9007      	str	r0, [sp, #28]
 8051ade:	2800      	cmp	r0, #0
 8051ae0:	f43f ae8e 	beq.w	8051800 <_strtod_l+0x498>
 8051ae4:	2f00      	cmp	r7, #0
 8051ae6:	dd08      	ble.n	8051afa <_strtod_l+0x792>
 8051ae8:	9907      	ldr	r1, [sp, #28]
 8051aea:	463a      	mov	r2, r7
 8051aec:	4620      	mov	r0, r4
 8051aee:	f004 fef7 	bl	80568e0 <__lshift>
 8051af2:	9007      	str	r0, [sp, #28]
 8051af4:	2800      	cmp	r0, #0
 8051af6:	f43f ae83 	beq.w	8051800 <_strtod_l+0x498>
 8051afa:	f1b9 0f00 	cmp.w	r9, #0
 8051afe:	dd08      	ble.n	8051b12 <_strtod_l+0x7aa>
 8051b00:	4631      	mov	r1, r6
 8051b02:	464a      	mov	r2, r9
 8051b04:	4620      	mov	r0, r4
 8051b06:	f004 feeb 	bl	80568e0 <__lshift>
 8051b0a:	4606      	mov	r6, r0
 8051b0c:	2800      	cmp	r0, #0
 8051b0e:	f43f ae77 	beq.w	8051800 <_strtod_l+0x498>
 8051b12:	9a07      	ldr	r2, [sp, #28]
 8051b14:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051b16:	4620      	mov	r0, r4
 8051b18:	f004 ff6a 	bl	80569f0 <__mdiff>
 8051b1c:	4605      	mov	r5, r0
 8051b1e:	2800      	cmp	r0, #0
 8051b20:	f43f ae6e 	beq.w	8051800 <_strtod_l+0x498>
 8051b24:	68c3      	ldr	r3, [r0, #12]
 8051b26:	930f      	str	r3, [sp, #60]	; 0x3c
 8051b28:	2300      	movs	r3, #0
 8051b2a:	60c3      	str	r3, [r0, #12]
 8051b2c:	4631      	mov	r1, r6
 8051b2e:	f004 ff43 	bl	80569b8 <__mcmp>
 8051b32:	2800      	cmp	r0, #0
 8051b34:	da65      	bge.n	8051c02 <_strtod_l+0x89a>
 8051b36:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051b38:	ea53 030a 	orrs.w	r3, r3, sl
 8051b3c:	f040 8087 	bne.w	8051c4e <_strtod_l+0x8e6>
 8051b40:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8051b44:	2b00      	cmp	r3, #0
 8051b46:	f040 8082 	bne.w	8051c4e <_strtod_l+0x8e6>
 8051b4a:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8051b4e:	0d1b      	lsrs	r3, r3, #20
 8051b50:	051b      	lsls	r3, r3, #20
 8051b52:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
 8051b56:	d97a      	bls.n	8051c4e <_strtod_l+0x8e6>
 8051b58:	696b      	ldr	r3, [r5, #20]
 8051b5a:	b913      	cbnz	r3, 8051b62 <_strtod_l+0x7fa>
 8051b5c:	692b      	ldr	r3, [r5, #16]
 8051b5e:	2b01      	cmp	r3, #1
 8051b60:	dd75      	ble.n	8051c4e <_strtod_l+0x8e6>
 8051b62:	4629      	mov	r1, r5
 8051b64:	2201      	movs	r2, #1
 8051b66:	4620      	mov	r0, r4
 8051b68:	f004 feba 	bl	80568e0 <__lshift>
 8051b6c:	4631      	mov	r1, r6
 8051b6e:	4605      	mov	r5, r0
 8051b70:	f004 ff22 	bl	80569b8 <__mcmp>
 8051b74:	2800      	cmp	r0, #0
 8051b76:	dd6a      	ble.n	8051c4e <_strtod_l+0x8e6>
 8051b78:	9904      	ldr	r1, [sp, #16]
 8051b7a:	4a55      	ldr	r2, [pc, #340]	; (8051cd0 <_strtod_l+0x968>)
 8051b7c:	465b      	mov	r3, fp
 8051b7e:	2900      	cmp	r1, #0
 8051b80:	f000 8085 	beq.w	8051c8e <_strtod_l+0x926>
 8051b84:	ea02 010b 	and.w	r1, r2, fp
 8051b88:	f1b1 6fd6 	cmp.w	r1, #112197632	; 0x6b00000
 8051b8c:	dc7f      	bgt.n	8051c8e <_strtod_l+0x926>
 8051b8e:	f1b1 7f5c 	cmp.w	r1, #57671680	; 0x3700000
 8051b92:	f77f aeaa 	ble.w	80518ea <_strtod_l+0x582>
 8051b96:	4a4f      	ldr	r2, [pc, #316]	; (8051cd4 <_strtod_l+0x96c>)
 8051b98:	2300      	movs	r3, #0
 8051b9a:	e9cd 3216 	strd	r3, r2, [sp, #88]	; 0x58
 8051b9e:	4650      	mov	r0, sl
 8051ba0:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 8051ba4:	4659      	mov	r1, fp
 8051ba6:	f7ee fd37 	bl	8040618 <__aeabi_dmul>
 8051baa:	460b      	mov	r3, r1
 8051bac:	4303      	orrs	r3, r0
 8051bae:	bf08      	it	eq
 8051bb0:	2322      	moveq	r3, #34	; 0x22
 8051bb2:	4682      	mov	sl, r0
 8051bb4:	468b      	mov	fp, r1
 8051bb6:	bf08      	it	eq
 8051bb8:	6023      	streq	r3, [r4, #0]
 8051bba:	e62b      	b.n	8051814 <_strtod_l+0x4ac>
 8051bbc:	f04f 32ff 	mov.w	r2, #4294967295
 8051bc0:	fa02 f303 	lsl.w	r3, r2, r3
 8051bc4:	ea03 0a0a 	and.w	sl, r3, sl
 8051bc8:	e6de      	b.n	8051988 <_strtod_l+0x620>
 8051bca:	f1c8 487f 	rsb	r8, r8, #4278190080	; 0xff000000
 8051bce:	f508 087f 	add.w	r8, r8, #16711680	; 0xff0000
 8051bd2:	f508 487b 	add.w	r8, r8, #64256	; 0xfb00
 8051bd6:	f108 08e2 	add.w	r8, r8, #226	; 0xe2
 8051bda:	fa01 f308 	lsl.w	r3, r1, r8
 8051bde:	930c      	str	r3, [sp, #48]	; 0x30
 8051be0:	9111      	str	r1, [sp, #68]	; 0x44
 8051be2:	e741      	b.n	8051a68 <_strtod_l+0x700>
 8051be4:	2300      	movs	r3, #0
 8051be6:	930c      	str	r3, [sp, #48]	; 0x30
 8051be8:	2301      	movs	r3, #1
 8051bea:	9311      	str	r3, [sp, #68]	; 0x44
 8051bec:	e73c      	b.n	8051a68 <_strtod_l+0x700>
 8051bee:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051bf0:	4642      	mov	r2, r8
 8051bf2:	4620      	mov	r0, r4
 8051bf4:	f004 fe74 	bl	80568e0 <__lshift>
 8051bf8:	901e      	str	r0, [sp, #120]	; 0x78
 8051bfa:	2800      	cmp	r0, #0
 8051bfc:	f47f af66 	bne.w	8051acc <_strtod_l+0x764>
 8051c00:	e5fe      	b.n	8051800 <_strtod_l+0x498>
 8051c02:	465f      	mov	r7, fp
 8051c04:	d16e      	bne.n	8051ce4 <_strtod_l+0x97c>
 8051c06:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8051c08:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8051c0c:	b342      	cbz	r2, 8051c60 <_strtod_l+0x8f8>
 8051c0e:	4a32      	ldr	r2, [pc, #200]	; (8051cd8 <_strtod_l+0x970>)
 8051c10:	4293      	cmp	r3, r2
 8051c12:	d128      	bne.n	8051c66 <_strtod_l+0x8fe>
 8051c14:	9b04      	ldr	r3, [sp, #16]
 8051c16:	4650      	mov	r0, sl
 8051c18:	b1eb      	cbz	r3, 8051c56 <_strtod_l+0x8ee>
 8051c1a:	4a2d      	ldr	r2, [pc, #180]	; (8051cd0 <_strtod_l+0x968>)
 8051c1c:	403a      	ands	r2, r7
 8051c1e:	f1b2 6fd4 	cmp.w	r2, #111149056	; 0x6a00000
 8051c22:	f04f 31ff 	mov.w	r1, #4294967295
 8051c26:	d819      	bhi.n	8051c5c <_strtod_l+0x8f4>
 8051c28:	0d12      	lsrs	r2, r2, #20
 8051c2a:	f1c2 036b 	rsb	r3, r2, #107	; 0x6b
 8051c2e:	fa01 f303 	lsl.w	r3, r1, r3
 8051c32:	4298      	cmp	r0, r3
 8051c34:	d117      	bne.n	8051c66 <_strtod_l+0x8fe>
 8051c36:	4b29      	ldr	r3, [pc, #164]	; (8051cdc <_strtod_l+0x974>)
 8051c38:	429f      	cmp	r7, r3
 8051c3a:	d102      	bne.n	8051c42 <_strtod_l+0x8da>
 8051c3c:	3001      	adds	r0, #1
 8051c3e:	f43f addf 	beq.w	8051800 <_strtod_l+0x498>
 8051c42:	4b23      	ldr	r3, [pc, #140]	; (8051cd0 <_strtod_l+0x968>)
 8051c44:	403b      	ands	r3, r7
 8051c46:	f503 1b80 	add.w	fp, r3, #1048576	; 0x100000
 8051c4a:	f04f 0a00 	mov.w	sl, #0
 8051c4e:	9b04      	ldr	r3, [sp, #16]
 8051c50:	2b00      	cmp	r3, #0
 8051c52:	d1a0      	bne.n	8051b96 <_strtod_l+0x82e>
 8051c54:	e5de      	b.n	8051814 <_strtod_l+0x4ac>
 8051c56:	f04f 33ff 	mov.w	r3, #4294967295
 8051c5a:	e7ea      	b.n	8051c32 <_strtod_l+0x8ca>
 8051c5c:	460b      	mov	r3, r1
 8051c5e:	e7e8      	b.n	8051c32 <_strtod_l+0x8ca>
 8051c60:	ea53 030a 	orrs.w	r3, r3, sl
 8051c64:	d088      	beq.n	8051b78 <_strtod_l+0x810>
 8051c66:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8051c68:	b1db      	cbz	r3, 8051ca2 <_strtod_l+0x93a>
 8051c6a:	423b      	tst	r3, r7
 8051c6c:	d0ef      	beq.n	8051c4e <_strtod_l+0x8e6>
 8051c6e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051c70:	9a04      	ldr	r2, [sp, #16]
 8051c72:	4650      	mov	r0, sl
 8051c74:	4659      	mov	r1, fp
 8051c76:	b1c3      	cbz	r3, 8051caa <_strtod_l+0x942>
 8051c78:	f7ff fb5a 	bl	8051330 <sulp>
 8051c7c:	4602      	mov	r2, r0
 8051c7e:	460b      	mov	r3, r1
 8051c80:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8051c84:	f7ee fb12 	bl	80402ac <__adddf3>
 8051c88:	4682      	mov	sl, r0
 8051c8a:	468b      	mov	fp, r1
 8051c8c:	e7df      	b.n	8051c4e <_strtod_l+0x8e6>
 8051c8e:	4013      	ands	r3, r2
 8051c90:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
 8051c94:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
 8051c98:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
 8051c9c:	f04f 3aff 	mov.w	sl, #4294967295
 8051ca0:	e7d5      	b.n	8051c4e <_strtod_l+0x8e6>
 8051ca2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8051ca4:	ea13 0f0a 	tst.w	r3, sl
 8051ca8:	e7e0      	b.n	8051c6c <_strtod_l+0x904>
 8051caa:	f7ff fb41 	bl	8051330 <sulp>
 8051cae:	4602      	mov	r2, r0
 8051cb0:	460b      	mov	r3, r1
 8051cb2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8051cb6:	f7ee faf7 	bl	80402a8 <__aeabi_dsub>
 8051cba:	2200      	movs	r2, #0
 8051cbc:	2300      	movs	r3, #0
 8051cbe:	4682      	mov	sl, r0
 8051cc0:	468b      	mov	fp, r1
 8051cc2:	f7ee ff11 	bl	8040ae8 <__aeabi_dcmpeq>
 8051cc6:	2800      	cmp	r0, #0
 8051cc8:	d0c1      	beq.n	8051c4e <_strtod_l+0x8e6>
 8051cca:	e60e      	b.n	80518ea <_strtod_l+0x582>
 8051ccc:	fffffc02 	.word	0xfffffc02
 8051cd0:	7ff00000 	.word	0x7ff00000
 8051cd4:	39500000 	.word	0x39500000
 8051cd8:	000fffff 	.word	0x000fffff
 8051cdc:	7fefffff 	.word	0x7fefffff
 8051ce0:	0805a328 	.word	0x0805a328
 8051ce4:	4631      	mov	r1, r6
 8051ce6:	4628      	mov	r0, r5
 8051ce8:	f004 ffe2 	bl	8056cb0 <__ratio>
 8051cec:	ec59 8b10 	vmov	r8, r9, d0
 8051cf0:	ee10 0a10 	vmov	r0, s0
 8051cf4:	2200      	movs	r2, #0
 8051cf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8051cfa:	4649      	mov	r1, r9
 8051cfc:	f7ee ff08 	bl	8040b10 <__aeabi_dcmple>
 8051d00:	2800      	cmp	r0, #0
 8051d02:	d07c      	beq.n	8051dfe <_strtod_l+0xa96>
 8051d04:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051d06:	2b00      	cmp	r3, #0
 8051d08:	d04c      	beq.n	8051da4 <_strtod_l+0xa3c>
 8051d0a:	4b95      	ldr	r3, [pc, #596]	; (8051f60 <_strtod_l+0xbf8>)
 8051d0c:	2200      	movs	r2, #0
 8051d0e:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8051d12:	f8df 924c 	ldr.w	r9, [pc, #588]	; 8051f60 <_strtod_l+0xbf8>
 8051d16:	f04f 0800 	mov.w	r8, #0
 8051d1a:	4b92      	ldr	r3, [pc, #584]	; (8051f64 <_strtod_l+0xbfc>)
 8051d1c:	403b      	ands	r3, r7
 8051d1e:	9311      	str	r3, [sp, #68]	; 0x44
 8051d20:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8051d22:	4b91      	ldr	r3, [pc, #580]	; (8051f68 <_strtod_l+0xc00>)
 8051d24:	429a      	cmp	r2, r3
 8051d26:	f040 80b2 	bne.w	8051e8e <_strtod_l+0xb26>
 8051d2a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8051d2e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8051d32:	f1a7 7b54 	sub.w	fp, r7, #55574528	; 0x3500000
 8051d36:	ec4b ab10 	vmov	d0, sl, fp
 8051d3a:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
 8051d3e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8051d42:	f004 fedd 	bl	8056b00 <__ulp>
 8051d46:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8051d4a:	ec53 2b10 	vmov	r2, r3, d0
 8051d4e:	f7ee fc63 	bl	8040618 <__aeabi_dmul>
 8051d52:	4652      	mov	r2, sl
 8051d54:	465b      	mov	r3, fp
 8051d56:	f7ee faa9 	bl	80402ac <__adddf3>
 8051d5a:	460b      	mov	r3, r1
 8051d5c:	4981      	ldr	r1, [pc, #516]	; (8051f64 <_strtod_l+0xbfc>)
 8051d5e:	4a83      	ldr	r2, [pc, #524]	; (8051f6c <_strtod_l+0xc04>)
 8051d60:	4019      	ands	r1, r3
 8051d62:	4291      	cmp	r1, r2
 8051d64:	4682      	mov	sl, r0
 8051d66:	d95e      	bls.n	8051e26 <_strtod_l+0xabe>
 8051d68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8051d6a:	f102 7254 	add.w	r2, r2, #55574528	; 0x3500000
 8051d6e:	4293      	cmp	r3, r2
 8051d70:	d103      	bne.n	8051d7a <_strtod_l+0xa12>
 8051d72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8051d74:	3301      	adds	r3, #1
 8051d76:	f43f ad43 	beq.w	8051800 <_strtod_l+0x498>
 8051d7a:	f8df b1fc 	ldr.w	fp, [pc, #508]	; 8051f78 <_strtod_l+0xc10>
 8051d7e:	f04f 3aff 	mov.w	sl, #4294967295
 8051d82:	991e      	ldr	r1, [sp, #120]	; 0x78
 8051d84:	4620      	mov	r0, r4
 8051d86:	f004 fbc2 	bl	805650e <_Bfree>
 8051d8a:	9907      	ldr	r1, [sp, #28]
 8051d8c:	4620      	mov	r0, r4
 8051d8e:	f004 fbbe 	bl	805650e <_Bfree>
 8051d92:	4631      	mov	r1, r6
 8051d94:	4620      	mov	r0, r4
 8051d96:	f004 fbba 	bl	805650e <_Bfree>
 8051d9a:	4629      	mov	r1, r5
 8051d9c:	4620      	mov	r0, r4
 8051d9e:	f004 fbb6 	bl	805650e <_Bfree>
 8051da2:	e613      	b.n	80519cc <_strtod_l+0x664>
 8051da4:	f1ba 0f00 	cmp.w	sl, #0
 8051da8:	d11b      	bne.n	8051de2 <_strtod_l+0xa7a>
 8051daa:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8051dae:	b9f3      	cbnz	r3, 8051dee <_strtod_l+0xa86>
 8051db0:	4b6b      	ldr	r3, [pc, #428]	; (8051f60 <_strtod_l+0xbf8>)
 8051db2:	2200      	movs	r2, #0
 8051db4:	4640      	mov	r0, r8
 8051db6:	4649      	mov	r1, r9
 8051db8:	f7ee fea0 	bl	8040afc <__aeabi_dcmplt>
 8051dbc:	b9d0      	cbnz	r0, 8051df4 <_strtod_l+0xa8c>
 8051dbe:	4640      	mov	r0, r8
 8051dc0:	4649      	mov	r1, r9
 8051dc2:	4b6b      	ldr	r3, [pc, #428]	; (8051f70 <_strtod_l+0xc08>)
 8051dc4:	2200      	movs	r2, #0
 8051dc6:	f7ee fc27 	bl	8040618 <__aeabi_dmul>
 8051dca:	4680      	mov	r8, r0
 8051dcc:	4689      	mov	r9, r1
 8051dce:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 8051dd2:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
 8051dd6:	931b      	str	r3, [sp, #108]	; 0x6c
 8051dd8:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
 8051ddc:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8051de0:	e79b      	b.n	8051d1a <_strtod_l+0x9b2>
 8051de2:	f1ba 0f01 	cmp.w	sl, #1
 8051de6:	d102      	bne.n	8051dee <_strtod_l+0xa86>
 8051de8:	2f00      	cmp	r7, #0
 8051dea:	f43f ad7e 	beq.w	80518ea <_strtod_l+0x582>
 8051dee:	4b61      	ldr	r3, [pc, #388]	; (8051f74 <_strtod_l+0xc0c>)
 8051df0:	2200      	movs	r2, #0
 8051df2:	e78c      	b.n	8051d0e <_strtod_l+0x9a6>
 8051df4:	f8df 9178 	ldr.w	r9, [pc, #376]	; 8051f70 <_strtod_l+0xc08>
 8051df8:	f04f 0800 	mov.w	r8, #0
 8051dfc:	e7e7      	b.n	8051dce <_strtod_l+0xa66>
 8051dfe:	4b5c      	ldr	r3, [pc, #368]	; (8051f70 <_strtod_l+0xc08>)
 8051e00:	4640      	mov	r0, r8
 8051e02:	4649      	mov	r1, r9
 8051e04:	2200      	movs	r2, #0
 8051e06:	f7ee fc07 	bl	8040618 <__aeabi_dmul>
 8051e0a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051e0c:	4680      	mov	r8, r0
 8051e0e:	4689      	mov	r9, r1
 8051e10:	b933      	cbnz	r3, 8051e20 <_strtod_l+0xab8>
 8051e12:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8051e16:	9012      	str	r0, [sp, #72]	; 0x48
 8051e18:	9313      	str	r3, [sp, #76]	; 0x4c
 8051e1a:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
 8051e1e:	e7dd      	b.n	8051ddc <_strtod_l+0xa74>
 8051e20:	e9cd 8912 	strd	r8, r9, [sp, #72]	; 0x48
 8051e24:	e7f9      	b.n	8051e1a <_strtod_l+0xab2>
 8051e26:	f103 7b54 	add.w	fp, r3, #55574528	; 0x3500000
 8051e2a:	9b04      	ldr	r3, [sp, #16]
 8051e2c:	2b00      	cmp	r3, #0
 8051e2e:	d1a8      	bne.n	8051d82 <_strtod_l+0xa1a>
 8051e30:	f02b 4300 	bic.w	r3, fp, #2147483648	; 0x80000000
 8051e34:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8051e36:	0d1b      	lsrs	r3, r3, #20
 8051e38:	051b      	lsls	r3, r3, #20
 8051e3a:	429a      	cmp	r2, r3
 8051e3c:	d1a1      	bne.n	8051d82 <_strtod_l+0xa1a>
 8051e3e:	4640      	mov	r0, r8
 8051e40:	4649      	mov	r1, r9
 8051e42:	f7ee ff49 	bl	8040cd8 <__aeabi_d2lz>
 8051e46:	f7ee fbb9 	bl	80405bc <__aeabi_l2d>
 8051e4a:	4602      	mov	r2, r0
 8051e4c:	460b      	mov	r3, r1
 8051e4e:	4640      	mov	r0, r8
 8051e50:	4649      	mov	r1, r9
 8051e52:	f7ee fa29 	bl	80402a8 <__aeabi_dsub>
 8051e56:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8051e58:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8051e5c:	ea43 030a 	orr.w	r3, r3, sl
 8051e60:	4313      	orrs	r3, r2
 8051e62:	4680      	mov	r8, r0
 8051e64:	4689      	mov	r9, r1
 8051e66:	d053      	beq.n	8051f10 <_strtod_l+0xba8>
 8051e68:	a335      	add	r3, pc, #212	; (adr r3, 8051f40 <_strtod_l+0xbd8>)
 8051e6a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8051e6e:	f7ee fe45 	bl	8040afc <__aeabi_dcmplt>
 8051e72:	2800      	cmp	r0, #0
 8051e74:	f47f acce 	bne.w	8051814 <_strtod_l+0x4ac>
 8051e78:	a333      	add	r3, pc, #204	; (adr r3, 8051f48 <_strtod_l+0xbe0>)
 8051e7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8051e7e:	4640      	mov	r0, r8
 8051e80:	4649      	mov	r1, r9
 8051e82:	f7ee fe59 	bl	8040b38 <__aeabi_dcmpgt>
 8051e86:	2800      	cmp	r0, #0
 8051e88:	f43f af7b 	beq.w	8051d82 <_strtod_l+0xa1a>
 8051e8c:	e4c2      	b.n	8051814 <_strtod_l+0x4ac>
 8051e8e:	9b04      	ldr	r3, [sp, #16]
 8051e90:	b333      	cbz	r3, 8051ee0 <_strtod_l+0xb78>
 8051e92:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8051e94:	f1b3 6fd4 	cmp.w	r3, #111149056	; 0x6a00000
 8051e98:	d822      	bhi.n	8051ee0 <_strtod_l+0xb78>
 8051e9a:	a32d      	add	r3, pc, #180	; (adr r3, 8051f50 <_strtod_l+0xbe8>)
 8051e9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8051ea0:	4640      	mov	r0, r8
 8051ea2:	4649      	mov	r1, r9
 8051ea4:	f7ee fe34 	bl	8040b10 <__aeabi_dcmple>
 8051ea8:	b1a0      	cbz	r0, 8051ed4 <_strtod_l+0xb6c>
 8051eaa:	4649      	mov	r1, r9
 8051eac:	4640      	mov	r0, r8
 8051eae:	f7ee fe8b 	bl	8040bc8 <__aeabi_d2uiz>
 8051eb2:	2801      	cmp	r0, #1
 8051eb4:	bf38      	it	cc
 8051eb6:	2001      	movcc	r0, #1
 8051eb8:	f7ee fb34 	bl	8040524 <__aeabi_ui2d>
 8051ebc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8051ebe:	4680      	mov	r8, r0
 8051ec0:	4689      	mov	r9, r1
 8051ec2:	bb13      	cbnz	r3, 8051f0a <_strtod_l+0xba2>
 8051ec4:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8051ec8:	9014      	str	r0, [sp, #80]	; 0x50
 8051eca:	9315      	str	r3, [sp, #84]	; 0x54
 8051ecc:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 8051ed0:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8051ed4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8051ed6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8051ed8:	f103 63d6 	add.w	r3, r3, #112197632	; 0x6b00000
 8051edc:	1a9b      	subs	r3, r3, r2
 8051ede:	930d      	str	r3, [sp, #52]	; 0x34
 8051ee0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8051ee4:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8051ee8:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8051eec:	f004 fe08 	bl	8056b00 <__ulp>
 8051ef0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8051ef4:	ec53 2b10 	vmov	r2, r3, d0
 8051ef8:	f7ee fb8e 	bl	8040618 <__aeabi_dmul>
 8051efc:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8051f00:	f7ee f9d4 	bl	80402ac <__adddf3>
 8051f04:	4682      	mov	sl, r0
 8051f06:	468b      	mov	fp, r1
 8051f08:	e78f      	b.n	8051e2a <_strtod_l+0xac2>
 8051f0a:	e9cd 8914 	strd	r8, r9, [sp, #80]	; 0x50
 8051f0e:	e7dd      	b.n	8051ecc <_strtod_l+0xb64>
 8051f10:	a311      	add	r3, pc, #68	; (adr r3, 8051f58 <_strtod_l+0xbf0>)
 8051f12:	e9d3 2300 	ldrd	r2, r3, [r3]
 8051f16:	f7ee fdf1 	bl	8040afc <__aeabi_dcmplt>
 8051f1a:	e7b4      	b.n	8051e86 <_strtod_l+0xb1e>
 8051f1c:	2300      	movs	r3, #0
 8051f1e:	930e      	str	r3, [sp, #56]	; 0x38
 8051f20:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8051f22:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8051f24:	6013      	str	r3, [r2, #0]
 8051f26:	f7ff ba65 	b.w	80513f4 <_strtod_l+0x8c>
 8051f2a:	2b65      	cmp	r3, #101	; 0x65
 8051f2c:	f43f ab5d 	beq.w	80515ea <_strtod_l+0x282>
 8051f30:	2b45      	cmp	r3, #69	; 0x45
 8051f32:	f43f ab5a 	beq.w	80515ea <_strtod_l+0x282>
 8051f36:	2201      	movs	r2, #1
 8051f38:	f7ff bb92 	b.w	8051660 <_strtod_l+0x2f8>
 8051f3c:	f3af 8000 	nop.w
 8051f40:	94a03595 	.word	0x94a03595
 8051f44:	3fdfffff 	.word	0x3fdfffff
 8051f48:	35afe535 	.word	0x35afe535
 8051f4c:	3fe00000 	.word	0x3fe00000
 8051f50:	ffc00000 	.word	0xffc00000
 8051f54:	41dfffff 	.word	0x41dfffff
 8051f58:	94a03595 	.word	0x94a03595
 8051f5c:	3fcfffff 	.word	0x3fcfffff
 8051f60:	3ff00000 	.word	0x3ff00000
 8051f64:	7ff00000 	.word	0x7ff00000
 8051f68:	7fe00000 	.word	0x7fe00000
 8051f6c:	7c9fffff 	.word	0x7c9fffff
 8051f70:	3fe00000 	.word	0x3fe00000
 8051f74:	bff00000 	.word	0xbff00000
 8051f78:	7fefffff 	.word	0x7fefffff

08051f7c <strtod>:
 8051f7c:	460a      	mov	r2, r1
 8051f7e:	4601      	mov	r1, r0
 8051f80:	4802      	ldr	r0, [pc, #8]	; (8051f8c <strtod+0x10>)
 8051f82:	4b03      	ldr	r3, [pc, #12]	; (8051f90 <strtod+0x14>)
 8051f84:	6800      	ldr	r0, [r0, #0]
 8051f86:	f7ff b9ef 	b.w	8051368 <_strtod_l>
 8051f8a:	bf00      	nop
 8051f8c:	200038cc 	.word	0x200038cc
 8051f90:	20004110 	.word	0x20004110

08051f94 <strtok>:
 8051f94:	4b02      	ldr	r3, [pc, #8]	; (8051fa0 <strtok+0xc>)
 8051f96:	681a      	ldr	r2, [r3, #0]
 8051f98:	2301      	movs	r3, #1
 8051f9a:	325c      	adds	r2, #92	; 0x5c
 8051f9c:	f000 b802 	b.w	8051fa4 <__strtok_r>
 8051fa0:	200038cc 	.word	0x200038cc

08051fa4 <__strtok_r>:
 8051fa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8051fa6:	b908      	cbnz	r0, 8051fac <__strtok_r+0x8>
 8051fa8:	6810      	ldr	r0, [r2, #0]
 8051faa:	b188      	cbz	r0, 8051fd0 <__strtok_r+0x2c>
 8051fac:	4604      	mov	r4, r0
 8051fae:	4620      	mov	r0, r4
 8051fb0:	f814 5b01 	ldrb.w	r5, [r4], #1
 8051fb4:	460f      	mov	r7, r1
 8051fb6:	f817 6b01 	ldrb.w	r6, [r7], #1
 8051fba:	b91e      	cbnz	r6, 8051fc4 <__strtok_r+0x20>
 8051fbc:	b965      	cbnz	r5, 8051fd8 <__strtok_r+0x34>
 8051fbe:	6015      	str	r5, [r2, #0]
 8051fc0:	4628      	mov	r0, r5
 8051fc2:	e005      	b.n	8051fd0 <__strtok_r+0x2c>
 8051fc4:	42b5      	cmp	r5, r6
 8051fc6:	d1f6      	bne.n	8051fb6 <__strtok_r+0x12>
 8051fc8:	2b00      	cmp	r3, #0
 8051fca:	d1f0      	bne.n	8051fae <__strtok_r+0xa>
 8051fcc:	6014      	str	r4, [r2, #0]
 8051fce:	7003      	strb	r3, [r0, #0]
 8051fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8051fd2:	461c      	mov	r4, r3
 8051fd4:	e00c      	b.n	8051ff0 <__strtok_r+0x4c>
 8051fd6:	b915      	cbnz	r5, 8051fde <__strtok_r+0x3a>
 8051fd8:	f814 3b01 	ldrb.w	r3, [r4], #1
 8051fdc:	460e      	mov	r6, r1
 8051fde:	f816 5b01 	ldrb.w	r5, [r6], #1
 8051fe2:	42ab      	cmp	r3, r5
 8051fe4:	d1f7      	bne.n	8051fd6 <__strtok_r+0x32>
 8051fe6:	2b00      	cmp	r3, #0
 8051fe8:	d0f3      	beq.n	8051fd2 <__strtok_r+0x2e>
 8051fea:	2300      	movs	r3, #0
 8051fec:	f804 3c01 	strb.w	r3, [r4, #-1]
 8051ff0:	6014      	str	r4, [r2, #0]
 8051ff2:	e7ed      	b.n	8051fd0 <__strtok_r+0x2c>

08051ff4 <_strtol_l.isra.0>:
 8051ff4:	2b01      	cmp	r3, #1
 8051ff6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8051ffa:	d001      	beq.n	8052000 <_strtol_l.isra.0+0xc>
 8051ffc:	2b24      	cmp	r3, #36	; 0x24
 8051ffe:	d906      	bls.n	805200e <_strtol_l.isra.0+0x1a>
 8052000:	f003 fbf6 	bl	80557f0 <__errno>
 8052004:	2316      	movs	r3, #22
 8052006:	6003      	str	r3, [r0, #0]
 8052008:	2000      	movs	r0, #0
 805200a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 805200e:	4f3a      	ldr	r7, [pc, #232]	; (80520f8 <_strtol_l.isra.0+0x104>)
 8052010:	468e      	mov	lr, r1
 8052012:	4676      	mov	r6, lr
 8052014:	f81e 4b01 	ldrb.w	r4, [lr], #1
 8052018:	5de5      	ldrb	r5, [r4, r7]
 805201a:	f015 0508 	ands.w	r5, r5, #8
 805201e:	d1f8      	bne.n	8052012 <_strtol_l.isra.0+0x1e>
 8052020:	2c2d      	cmp	r4, #45	; 0x2d
 8052022:	d134      	bne.n	805208e <_strtol_l.isra.0+0x9a>
 8052024:	f89e 4000 	ldrb.w	r4, [lr]
 8052028:	f04f 0801 	mov.w	r8, #1
 805202c:	f106 0e02 	add.w	lr, r6, #2
 8052030:	2b00      	cmp	r3, #0
 8052032:	d05c      	beq.n	80520ee <_strtol_l.isra.0+0xfa>
 8052034:	2b10      	cmp	r3, #16
 8052036:	d10c      	bne.n	8052052 <_strtol_l.isra.0+0x5e>
 8052038:	2c30      	cmp	r4, #48	; 0x30
 805203a:	d10a      	bne.n	8052052 <_strtol_l.isra.0+0x5e>
 805203c:	f89e 4000 	ldrb.w	r4, [lr]
 8052040:	f004 04df 	and.w	r4, r4, #223	; 0xdf
 8052044:	2c58      	cmp	r4, #88	; 0x58
 8052046:	d14d      	bne.n	80520e4 <_strtol_l.isra.0+0xf0>
 8052048:	f89e 4001 	ldrb.w	r4, [lr, #1]
 805204c:	2310      	movs	r3, #16
 805204e:	f10e 0e02 	add.w	lr, lr, #2
 8052052:	f108 4c00 	add.w	ip, r8, #2147483648	; 0x80000000
 8052056:	f10c 3cff 	add.w	ip, ip, #4294967295
 805205a:	2600      	movs	r6, #0
 805205c:	fbbc f9f3 	udiv	r9, ip, r3
 8052060:	4635      	mov	r5, r6
 8052062:	fb03 ca19 	mls	sl, r3, r9, ip
 8052066:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
 805206a:	2f09      	cmp	r7, #9
 805206c:	d818      	bhi.n	80520a0 <_strtol_l.isra.0+0xac>
 805206e:	463c      	mov	r4, r7
 8052070:	42a3      	cmp	r3, r4
 8052072:	dd24      	ble.n	80520be <_strtol_l.isra.0+0xca>
 8052074:	2e00      	cmp	r6, #0
 8052076:	db1f      	blt.n	80520b8 <_strtol_l.isra.0+0xc4>
 8052078:	45a9      	cmp	r9, r5
 805207a:	d31d      	bcc.n	80520b8 <_strtol_l.isra.0+0xc4>
 805207c:	d101      	bne.n	8052082 <_strtol_l.isra.0+0x8e>
 805207e:	45a2      	cmp	sl, r4
 8052080:	db1a      	blt.n	80520b8 <_strtol_l.isra.0+0xc4>
 8052082:	fb05 4503 	mla	r5, r5, r3, r4
 8052086:	2601      	movs	r6, #1
 8052088:	f81e 4b01 	ldrb.w	r4, [lr], #1
 805208c:	e7eb      	b.n	8052066 <_strtol_l.isra.0+0x72>
 805208e:	2c2b      	cmp	r4, #43	; 0x2b
 8052090:	bf08      	it	eq
 8052092:	f89e 4000 	ldrbeq.w	r4, [lr]
 8052096:	46a8      	mov	r8, r5
 8052098:	bf08      	it	eq
 805209a:	f106 0e02 	addeq.w	lr, r6, #2
 805209e:	e7c7      	b.n	8052030 <_strtol_l.isra.0+0x3c>
 80520a0:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
 80520a4:	2f19      	cmp	r7, #25
 80520a6:	d801      	bhi.n	80520ac <_strtol_l.isra.0+0xb8>
 80520a8:	3c37      	subs	r4, #55	; 0x37
 80520aa:	e7e1      	b.n	8052070 <_strtol_l.isra.0+0x7c>
 80520ac:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
 80520b0:	2f19      	cmp	r7, #25
 80520b2:	d804      	bhi.n	80520be <_strtol_l.isra.0+0xca>
 80520b4:	3c57      	subs	r4, #87	; 0x57
 80520b6:	e7db      	b.n	8052070 <_strtol_l.isra.0+0x7c>
 80520b8:	f04f 36ff 	mov.w	r6, #4294967295
 80520bc:	e7e4      	b.n	8052088 <_strtol_l.isra.0+0x94>
 80520be:	2e00      	cmp	r6, #0
 80520c0:	da05      	bge.n	80520ce <_strtol_l.isra.0+0xda>
 80520c2:	2322      	movs	r3, #34	; 0x22
 80520c4:	6003      	str	r3, [r0, #0]
 80520c6:	4665      	mov	r5, ip
 80520c8:	b942      	cbnz	r2, 80520dc <_strtol_l.isra.0+0xe8>
 80520ca:	4628      	mov	r0, r5
 80520cc:	e79d      	b.n	805200a <_strtol_l.isra.0+0x16>
 80520ce:	f1b8 0f00 	cmp.w	r8, #0
 80520d2:	d000      	beq.n	80520d6 <_strtol_l.isra.0+0xe2>
 80520d4:	426d      	negs	r5, r5
 80520d6:	2a00      	cmp	r2, #0
 80520d8:	d0f7      	beq.n	80520ca <_strtol_l.isra.0+0xd6>
 80520da:	b10e      	cbz	r6, 80520e0 <_strtol_l.isra.0+0xec>
 80520dc:	f10e 31ff 	add.w	r1, lr, #4294967295
 80520e0:	6011      	str	r1, [r2, #0]
 80520e2:	e7f2      	b.n	80520ca <_strtol_l.isra.0+0xd6>
 80520e4:	2430      	movs	r4, #48	; 0x30
 80520e6:	2b00      	cmp	r3, #0
 80520e8:	d1b3      	bne.n	8052052 <_strtol_l.isra.0+0x5e>
 80520ea:	2308      	movs	r3, #8
 80520ec:	e7b1      	b.n	8052052 <_strtol_l.isra.0+0x5e>
 80520ee:	2c30      	cmp	r4, #48	; 0x30
 80520f0:	d0a4      	beq.n	805203c <_strtol_l.isra.0+0x48>
 80520f2:	230a      	movs	r3, #10
 80520f4:	e7ad      	b.n	8052052 <_strtol_l.isra.0+0x5e>
 80520f6:	bf00      	nop
 80520f8:	0805a3ea 	.word	0x0805a3ea

080520fc <strtol>:
 80520fc:	4613      	mov	r3, r2
 80520fe:	460a      	mov	r2, r1
 8052100:	4601      	mov	r1, r0
 8052102:	4802      	ldr	r0, [pc, #8]	; (805210c <strtol+0x10>)
 8052104:	6800      	ldr	r0, [r0, #0]
 8052106:	f7ff bf75 	b.w	8051ff4 <_strtol_l.isra.0>
 805210a:	bf00      	nop
 805210c:	200038cc 	.word	0x200038cc

08052110 <_svfprintf_r>:
 8052110:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8052114:	ed2d 8b04 	vpush	{d8-d9}
 8052118:	b0cf      	sub	sp, #316	; 0x13c
 805211a:	4689      	mov	r9, r1
 805211c:	4693      	mov	fp, r2
 805211e:	461e      	mov	r6, r3
 8052120:	4682      	mov	sl, r0
 8052122:	f004 f949 	bl	80563b8 <_localeconv_r>
 8052126:	6803      	ldr	r3, [r0, #0]
 8052128:	9313      	str	r3, [sp, #76]	; 0x4c
 805212a:	4618      	mov	r0, r3
 805212c:	f7ee f860 	bl	80401f0 <strlen>
 8052130:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052134:	900e      	str	r0, [sp, #56]	; 0x38
 8052136:	0618      	lsls	r0, r3, #24
 8052138:	d51a      	bpl.n	8052170 <_svfprintf_r+0x60>
 805213a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 805213e:	b9bb      	cbnz	r3, 8052170 <_svfprintf_r+0x60>
 8052140:	2140      	movs	r1, #64	; 0x40
 8052142:	4650      	mov	r0, sl
 8052144:	f7fe fde0 	bl	8050d08 <_malloc_r>
 8052148:	f8c9 0000 	str.w	r0, [r9]
 805214c:	f8c9 0010 	str.w	r0, [r9, #16]
 8052150:	b958      	cbnz	r0, 805216a <_svfprintf_r+0x5a>
 8052152:	230c      	movs	r3, #12
 8052154:	f8ca 3000 	str.w	r3, [sl]
 8052158:	f04f 33ff 	mov.w	r3, #4294967295
 805215c:	930f      	str	r3, [sp, #60]	; 0x3c
 805215e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8052160:	b04f      	add	sp, #316	; 0x13c
 8052162:	ecbd 8b04 	vpop	{d8-d9}
 8052166:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 805216a:	2340      	movs	r3, #64	; 0x40
 805216c:	f8c9 3014 	str.w	r3, [r9, #20]
 8052170:	ed9f 7b93 	vldr	d7, [pc, #588]	; 80523c0 <_svfprintf_r+0x2b0>
 8052174:	2500      	movs	r5, #0
 8052176:	e9cd 5523 	strd	r5, r5, [sp, #140]	; 0x8c
 805217a:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 805217e:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
 8052182:	ac25      	add	r4, sp, #148	; 0x94
 8052184:	9422      	str	r4, [sp, #136]	; 0x88
 8052186:	9505      	str	r5, [sp, #20]
 8052188:	950a      	str	r5, [sp, #40]	; 0x28
 805218a:	9512      	str	r5, [sp, #72]	; 0x48
 805218c:	9514      	str	r5, [sp, #80]	; 0x50
 805218e:	950f      	str	r5, [sp, #60]	; 0x3c
 8052190:	465b      	mov	r3, fp
 8052192:	461d      	mov	r5, r3
 8052194:	f813 2b01 	ldrb.w	r2, [r3], #1
 8052198:	b10a      	cbz	r2, 805219e <_svfprintf_r+0x8e>
 805219a:	2a25      	cmp	r2, #37	; 0x25
 805219c:	d1f9      	bne.n	8052192 <_svfprintf_r+0x82>
 805219e:	ebb5 070b 	subs.w	r7, r5, fp
 80521a2:	d00d      	beq.n	80521c0 <_svfprintf_r+0xb0>
 80521a4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80521a6:	443b      	add	r3, r7
 80521a8:	9324      	str	r3, [sp, #144]	; 0x90
 80521aa:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80521ac:	3301      	adds	r3, #1
 80521ae:	2b07      	cmp	r3, #7
 80521b0:	e9c4 b700 	strd	fp, r7, [r4]
 80521b4:	9323      	str	r3, [sp, #140]	; 0x8c
 80521b6:	dc79      	bgt.n	80522ac <_svfprintf_r+0x19c>
 80521b8:	3408      	adds	r4, #8
 80521ba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80521bc:	443b      	add	r3, r7
 80521be:	930f      	str	r3, [sp, #60]	; 0x3c
 80521c0:	782b      	ldrb	r3, [r5, #0]
 80521c2:	2b00      	cmp	r3, #0
 80521c4:	f001 8140 	beq.w	8053448 <_svfprintf_r+0x1338>
 80521c8:	2300      	movs	r3, #0
 80521ca:	f04f 32ff 	mov.w	r2, #4294967295
 80521ce:	3501      	adds	r5, #1
 80521d0:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80521d4:	9204      	str	r2, [sp, #16]
 80521d6:	9310      	str	r3, [sp, #64]	; 0x40
 80521d8:	4698      	mov	r8, r3
 80521da:	270a      	movs	r7, #10
 80521dc:	212b      	movs	r1, #43	; 0x2b
 80521de:	462a      	mov	r2, r5
 80521e0:	f812 3b01 	ldrb.w	r3, [r2], #1
 80521e4:	9307      	str	r3, [sp, #28]
 80521e6:	920b      	str	r2, [sp, #44]	; 0x2c
 80521e8:	9b07      	ldr	r3, [sp, #28]
 80521ea:	3b20      	subs	r3, #32
 80521ec:	2b5a      	cmp	r3, #90	; 0x5a
 80521ee:	f200 85b4 	bhi.w	8052d5a <_svfprintf_r+0xc4a>
 80521f2:	e8df f013 	tbh	[pc, r3, lsl #1]
 80521f6:	007e      	.short	0x007e
 80521f8:	05b205b2 	.word	0x05b205b2
 80521fc:	05b20086 	.word	0x05b20086
 8052200:	05b205b2 	.word	0x05b205b2
 8052204:	05b20065 	.word	0x05b20065
 8052208:	008905b2 	.word	0x008905b2
 805220c:	05b20093 	.word	0x05b20093
 8052210:	00960090 	.word	0x00960090
 8052214:	00b305b2 	.word	0x00b305b2
 8052218:	00b600b6 	.word	0x00b600b6
 805221c:	00b600b6 	.word	0x00b600b6
 8052220:	00b600b6 	.word	0x00b600b6
 8052224:	00b600b6 	.word	0x00b600b6
 8052228:	05b200b6 	.word	0x05b200b6
 805222c:	05b205b2 	.word	0x05b205b2
 8052230:	05b205b2 	.word	0x05b205b2
 8052234:	05b205b2 	.word	0x05b205b2
 8052238:	05b20127 	.word	0x05b20127
 805223c:	00fc00e9 	.word	0x00fc00e9
 8052240:	01270127 	.word	0x01270127
 8052244:	05b20127 	.word	0x05b20127
 8052248:	05b205b2 	.word	0x05b205b2
 805224c:	00c605b2 	.word	0x00c605b2
 8052250:	05b205b2 	.word	0x05b205b2
 8052254:	05b20492 	.word	0x05b20492
 8052258:	05b205b2 	.word	0x05b205b2
 805225c:	05b204d9 	.word	0x05b204d9
 8052260:	05b204fa 	.word	0x05b204fa
 8052264:	051905b2 	.word	0x051905b2
 8052268:	05b205b2 	.word	0x05b205b2
 805226c:	05b205b2 	.word	0x05b205b2
 8052270:	05b205b2 	.word	0x05b205b2
 8052274:	05b205b2 	.word	0x05b205b2
 8052278:	05b20127 	.word	0x05b20127
 805227c:	00fe00e9 	.word	0x00fe00e9
 8052280:	01270127 	.word	0x01270127
 8052284:	00c90127 	.word	0x00c90127
 8052288:	00dd00fe 	.word	0x00dd00fe
 805228c:	00d605b2 	.word	0x00d605b2
 8052290:	046f05b2 	.word	0x046f05b2
 8052294:	04c80494 	.word	0x04c80494
 8052298:	05b200dd 	.word	0x05b200dd
 805229c:	007c04d9 	.word	0x007c04d9
 80522a0:	05b204fc 	.word	0x05b204fc
 80522a4:	053605b2 	.word	0x053605b2
 80522a8:	007c05b2 	.word	0x007c05b2
 80522ac:	aa22      	add	r2, sp, #136	; 0x88
 80522ae:	4649      	mov	r1, r9
 80522b0:	4650      	mov	r0, sl
 80522b2:	f004 fdf8 	bl	8056ea6 <__ssprint_r>
 80522b6:	2800      	cmp	r0, #0
 80522b8:	f040 8132 	bne.w	8052520 <_svfprintf_r+0x410>
 80522bc:	ac25      	add	r4, sp, #148	; 0x94
 80522be:	e77c      	b.n	80521ba <_svfprintf_r+0xaa>
 80522c0:	4650      	mov	r0, sl
 80522c2:	f004 f879 	bl	80563b8 <_localeconv_r>
 80522c6:	6843      	ldr	r3, [r0, #4]
 80522c8:	9314      	str	r3, [sp, #80]	; 0x50
 80522ca:	4618      	mov	r0, r3
 80522cc:	f7ed ff90 	bl	80401f0 <strlen>
 80522d0:	9012      	str	r0, [sp, #72]	; 0x48
 80522d2:	4650      	mov	r0, sl
 80522d4:	f004 f870 	bl	80563b8 <_localeconv_r>
 80522d8:	6883      	ldr	r3, [r0, #8]
 80522da:	930a      	str	r3, [sp, #40]	; 0x28
 80522dc:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80522de:	212b      	movs	r1, #43	; 0x2b
 80522e0:	b12b      	cbz	r3, 80522ee <_svfprintf_r+0x1de>
 80522e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80522e4:	b11b      	cbz	r3, 80522ee <_svfprintf_r+0x1de>
 80522e6:	781b      	ldrb	r3, [r3, #0]
 80522e8:	b10b      	cbz	r3, 80522ee <_svfprintf_r+0x1de>
 80522ea:	f448 6880 	orr.w	r8, r8, #1024	; 0x400
 80522ee:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80522f0:	e775      	b.n	80521de <_svfprintf_r+0xce>
 80522f2:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80522f6:	2b00      	cmp	r3, #0
 80522f8:	d1f9      	bne.n	80522ee <_svfprintf_r+0x1de>
 80522fa:	2320      	movs	r3, #32
 80522fc:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052300:	e7f5      	b.n	80522ee <_svfprintf_r+0x1de>
 8052302:	f048 0801 	orr.w	r8, r8, #1
 8052306:	e7f2      	b.n	80522ee <_svfprintf_r+0x1de>
 8052308:	f856 3b04 	ldr.w	r3, [r6], #4
 805230c:	9310      	str	r3, [sp, #64]	; 0x40
 805230e:	2b00      	cmp	r3, #0
 8052310:	daed      	bge.n	80522ee <_svfprintf_r+0x1de>
 8052312:	425b      	negs	r3, r3
 8052314:	9310      	str	r3, [sp, #64]	; 0x40
 8052316:	f048 0804 	orr.w	r8, r8, #4
 805231a:	e7e8      	b.n	80522ee <_svfprintf_r+0x1de>
 805231c:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 8052320:	e7e5      	b.n	80522ee <_svfprintf_r+0x1de>
 8052322:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8052324:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052328:	9307      	str	r3, [sp, #28]
 805232a:	2b2a      	cmp	r3, #42	; 0x2a
 805232c:	d113      	bne.n	8052356 <_svfprintf_r+0x246>
 805232e:	f856 0b04 	ldr.w	r0, [r6], #4
 8052332:	920b      	str	r2, [sp, #44]	; 0x2c
 8052334:	ea40 73e0 	orr.w	r3, r0, r0, asr #31
 8052338:	9304      	str	r3, [sp, #16]
 805233a:	e7d8      	b.n	80522ee <_svfprintf_r+0x1de>
 805233c:	9804      	ldr	r0, [sp, #16]
 805233e:	fb07 3300 	mla	r3, r7, r0, r3
 8052342:	9304      	str	r3, [sp, #16]
 8052344:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052348:	9307      	str	r3, [sp, #28]
 805234a:	9b07      	ldr	r3, [sp, #28]
 805234c:	3b30      	subs	r3, #48	; 0x30
 805234e:	2b09      	cmp	r3, #9
 8052350:	d9f4      	bls.n	805233c <_svfprintf_r+0x22c>
 8052352:	920b      	str	r2, [sp, #44]	; 0x2c
 8052354:	e748      	b.n	80521e8 <_svfprintf_r+0xd8>
 8052356:	2300      	movs	r3, #0
 8052358:	9304      	str	r3, [sp, #16]
 805235a:	e7f6      	b.n	805234a <_svfprintf_r+0x23a>
 805235c:	f048 0880 	orr.w	r8, r8, #128	; 0x80
 8052360:	e7c5      	b.n	80522ee <_svfprintf_r+0x1de>
 8052362:	2300      	movs	r3, #0
 8052364:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8052366:	9310      	str	r3, [sp, #64]	; 0x40
 8052368:	9b07      	ldr	r3, [sp, #28]
 805236a:	9810      	ldr	r0, [sp, #64]	; 0x40
 805236c:	3b30      	subs	r3, #48	; 0x30
 805236e:	fb07 3300 	mla	r3, r7, r0, r3
 8052372:	9310      	str	r3, [sp, #64]	; 0x40
 8052374:	f812 3b01 	ldrb.w	r3, [r2], #1
 8052378:	9307      	str	r3, [sp, #28]
 805237a:	3b30      	subs	r3, #48	; 0x30
 805237c:	2b09      	cmp	r3, #9
 805237e:	d9f3      	bls.n	8052368 <_svfprintf_r+0x258>
 8052380:	e7e7      	b.n	8052352 <_svfprintf_r+0x242>
 8052382:	f048 0808 	orr.w	r8, r8, #8
 8052386:	e7b2      	b.n	80522ee <_svfprintf_r+0x1de>
 8052388:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 805238a:	781b      	ldrb	r3, [r3, #0]
 805238c:	2b68      	cmp	r3, #104	; 0x68
 805238e:	bf01      	itttt	eq
 8052390:	9b0b      	ldreq	r3, [sp, #44]	; 0x2c
 8052392:	3301      	addeq	r3, #1
 8052394:	930b      	streq	r3, [sp, #44]	; 0x2c
 8052396:	f448 7800 	orreq.w	r8, r8, #512	; 0x200
 805239a:	bf18      	it	ne
 805239c:	f048 0840 	orrne.w	r8, r8, #64	; 0x40
 80523a0:	e7a5      	b.n	80522ee <_svfprintf_r+0x1de>
 80523a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80523a4:	781b      	ldrb	r3, [r3, #0]
 80523a6:	2b6c      	cmp	r3, #108	; 0x6c
 80523a8:	d105      	bne.n	80523b6 <_svfprintf_r+0x2a6>
 80523aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80523ac:	3301      	adds	r3, #1
 80523ae:	930b      	str	r3, [sp, #44]	; 0x2c
 80523b0:	f048 0820 	orr.w	r8, r8, #32
 80523b4:	e79b      	b.n	80522ee <_svfprintf_r+0x1de>
 80523b6:	f048 0810 	orr.w	r8, r8, #16
 80523ba:	e798      	b.n	80522ee <_svfprintf_r+0x1de>
 80523bc:	f3af 8000 	nop.w
	...
 80523c8:	4632      	mov	r2, r6
 80523ca:	2000      	movs	r0, #0
 80523cc:	f852 3b04 	ldr.w	r3, [r2], #4
 80523d0:	9206      	str	r2, [sp, #24]
 80523d2:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 80523d6:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 80523da:	2301      	movs	r3, #1
 80523dc:	e9cd 0008 	strd	r0, r0, [sp, #32]
 80523e0:	9003      	str	r0, [sp, #12]
 80523e2:	9304      	str	r3, [sp, #16]
 80523e4:	4606      	mov	r6, r0
 80523e6:	4605      	mov	r5, r0
 80523e8:	f10d 0bd4 	add.w	fp, sp, #212	; 0xd4
 80523ec:	e1b8      	b.n	8052760 <_svfprintf_r+0x650>
 80523ee:	f048 0810 	orr.w	r8, r8, #16
 80523f2:	f018 0f20 	tst.w	r8, #32
 80523f6:	d012      	beq.n	805241e <_svfprintf_r+0x30e>
 80523f8:	3607      	adds	r6, #7
 80523fa:	f026 0307 	bic.w	r3, r6, #7
 80523fe:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8052402:	9306      	str	r3, [sp, #24]
 8052404:	2e00      	cmp	r6, #0
 8052406:	f177 0300 	sbcs.w	r3, r7, #0
 805240a:	da06      	bge.n	805241a <_svfprintf_r+0x30a>
 805240c:	4276      	negs	r6, r6
 805240e:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8052412:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 8052416:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 805241a:	2301      	movs	r3, #1
 805241c:	e38e      	b.n	8052b3c <_svfprintf_r+0xa2c>
 805241e:	1d33      	adds	r3, r6, #4
 8052420:	f018 0f10 	tst.w	r8, #16
 8052424:	9306      	str	r3, [sp, #24]
 8052426:	d002      	beq.n	805242e <_svfprintf_r+0x31e>
 8052428:	6836      	ldr	r6, [r6, #0]
 805242a:	17f7      	asrs	r7, r6, #31
 805242c:	e7ea      	b.n	8052404 <_svfprintf_r+0x2f4>
 805242e:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052432:	6836      	ldr	r6, [r6, #0]
 8052434:	d001      	beq.n	805243a <_svfprintf_r+0x32a>
 8052436:	b236      	sxth	r6, r6
 8052438:	e7f7      	b.n	805242a <_svfprintf_r+0x31a>
 805243a:	f418 7f00 	tst.w	r8, #512	; 0x200
 805243e:	bf18      	it	ne
 8052440:	b276      	sxtbne	r6, r6
 8052442:	e7f2      	b.n	805242a <_svfprintf_r+0x31a>
 8052444:	3607      	adds	r6, #7
 8052446:	f026 0307 	bic.w	r3, r6, #7
 805244a:	ecb3 7b02 	vldmia	r3!, {d7}
 805244e:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8052452:	9306      	str	r3, [sp, #24]
 8052454:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8052456:	ee09 3a10 	vmov	s18, r3
 805245a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 805245c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8052460:	ee09 3a90 	vmov	s19, r3
 8052464:	f04f 32ff 	mov.w	r2, #4294967295
 8052468:	4b3a      	ldr	r3, [pc, #232]	; (8052554 <_svfprintf_r+0x444>)
 805246a:	ec51 0b19 	vmov	r0, r1, d9
 805246e:	f7ee fb6d 	bl	8040b4c <__aeabi_dcmpun>
 8052472:	bb10      	cbnz	r0, 80524ba <_svfprintf_r+0x3aa>
 8052474:	4b37      	ldr	r3, [pc, #220]	; (8052554 <_svfprintf_r+0x444>)
 8052476:	ec51 0b19 	vmov	r0, r1, d9
 805247a:	f04f 32ff 	mov.w	r2, #4294967295
 805247e:	f7ee fb47 	bl	8040b10 <__aeabi_dcmple>
 8052482:	b9d0      	cbnz	r0, 80524ba <_svfprintf_r+0x3aa>
 8052484:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052488:	2200      	movs	r2, #0
 805248a:	2300      	movs	r3, #0
 805248c:	f7ee fb36 	bl	8040afc <__aeabi_dcmplt>
 8052490:	b110      	cbz	r0, 8052498 <_svfprintf_r+0x388>
 8052492:	232d      	movs	r3, #45	; 0x2d
 8052494:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8052498:	4a2f      	ldr	r2, [pc, #188]	; (8052558 <_svfprintf_r+0x448>)
 805249a:	4830      	ldr	r0, [pc, #192]	; (805255c <_svfprintf_r+0x44c>)
 805249c:	9b07      	ldr	r3, [sp, #28]
 805249e:	2100      	movs	r1, #0
 80524a0:	2b47      	cmp	r3, #71	; 0x47
 80524a2:	bfd4      	ite	le
 80524a4:	4693      	movle	fp, r2
 80524a6:	4683      	movgt	fp, r0
 80524a8:	2303      	movs	r3, #3
 80524aa:	e9cd 1303 	strd	r1, r3, [sp, #12]
 80524ae:	f028 0880 	bic.w	r8, r8, #128	; 0x80
 80524b2:	2600      	movs	r6, #0
 80524b4:	4633      	mov	r3, r6
 80524b6:	f001 b802 	b.w	80534be <_svfprintf_r+0x13ae>
 80524ba:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80524be:	4610      	mov	r0, r2
 80524c0:	4619      	mov	r1, r3
 80524c2:	f7ee fb43 	bl	8040b4c <__aeabi_dcmpun>
 80524c6:	b140      	cbz	r0, 80524da <_svfprintf_r+0x3ca>
 80524c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80524ca:	4a25      	ldr	r2, [pc, #148]	; (8052560 <_svfprintf_r+0x450>)
 80524cc:	4825      	ldr	r0, [pc, #148]	; (8052564 <_svfprintf_r+0x454>)
 80524ce:	2b00      	cmp	r3, #0
 80524d0:	bfbc      	itt	lt
 80524d2:	232d      	movlt	r3, #45	; 0x2d
 80524d4:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 80524d8:	e7e0      	b.n	805249c <_svfprintf_r+0x38c>
 80524da:	9b07      	ldr	r3, [sp, #28]
 80524dc:	f023 0320 	bic.w	r3, r3, #32
 80524e0:	2b41      	cmp	r3, #65	; 0x41
 80524e2:	9308      	str	r3, [sp, #32]
 80524e4:	d125      	bne.n	8052532 <_svfprintf_r+0x422>
 80524e6:	2330      	movs	r3, #48	; 0x30
 80524e8:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 80524ec:	9b07      	ldr	r3, [sp, #28]
 80524ee:	2b61      	cmp	r3, #97	; 0x61
 80524f0:	bf0c      	ite	eq
 80524f2:	2378      	moveq	r3, #120	; 0x78
 80524f4:	2358      	movne	r3, #88	; 0x58
 80524f6:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80524fa:	9b04      	ldr	r3, [sp, #16]
 80524fc:	2b63      	cmp	r3, #99	; 0x63
 80524fe:	f048 0802 	orr.w	r8, r8, #2
 8052502:	dd31      	ble.n	8052568 <_svfprintf_r+0x458>
 8052504:	1c59      	adds	r1, r3, #1
 8052506:	4650      	mov	r0, sl
 8052508:	f7fe fbfe 	bl	8050d08 <_malloc_r>
 805250c:	4683      	mov	fp, r0
 805250e:	2800      	cmp	r0, #0
 8052510:	f040 81fe 	bne.w	8052910 <_svfprintf_r+0x800>
 8052514:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052518:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 805251c:	f8a9 300c 	strh.w	r3, [r9, #12]
 8052520:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8052524:	f013 0f40 	tst.w	r3, #64	; 0x40
 8052528:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 805252a:	bf18      	it	ne
 805252c:	f04f 33ff 	movne.w	r3, #4294967295
 8052530:	e614      	b.n	805215c <_svfprintf_r+0x4c>
 8052532:	9b04      	ldr	r3, [sp, #16]
 8052534:	3301      	adds	r3, #1
 8052536:	f000 81ed 	beq.w	8052914 <_svfprintf_r+0x804>
 805253a:	9b08      	ldr	r3, [sp, #32]
 805253c:	2b47      	cmp	r3, #71	; 0x47
 805253e:	f040 81ec 	bne.w	805291a <_svfprintf_r+0x80a>
 8052542:	9b04      	ldr	r3, [sp, #16]
 8052544:	2b00      	cmp	r3, #0
 8052546:	f040 81e8 	bne.w	805291a <_svfprintf_r+0x80a>
 805254a:	9303      	str	r3, [sp, #12]
 805254c:	2301      	movs	r3, #1
 805254e:	9304      	str	r3, [sp, #16]
 8052550:	e00d      	b.n	805256e <_svfprintf_r+0x45e>
 8052552:	bf00      	nop
 8052554:	7fefffff 	.word	0x7fefffff
 8052558:	0805a350 	.word	0x0805a350
 805255c:	0805a354 	.word	0x0805a354
 8052560:	0805a358 	.word	0x0805a358
 8052564:	0805a35c 	.word	0x0805a35c
 8052568:	9003      	str	r0, [sp, #12]
 805256a:	f10d 0bd4 	add.w	fp, sp, #212	; 0xd4
 805256e:	f448 7380 	orr.w	r3, r8, #256	; 0x100
 8052572:	9311      	str	r3, [sp, #68]	; 0x44
 8052574:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052576:	2b00      	cmp	r3, #0
 8052578:	f280 81d1 	bge.w	805291e <_svfprintf_r+0x80e>
 805257c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 805257e:	ee08 3a10 	vmov	s16, r3
 8052582:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8052584:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8052588:	ee08 3a90 	vmov	s17, r3
 805258c:	232d      	movs	r3, #45	; 0x2d
 805258e:	9318      	str	r3, [sp, #96]	; 0x60
 8052590:	9b08      	ldr	r3, [sp, #32]
 8052592:	2b41      	cmp	r3, #65	; 0x41
 8052594:	f040 81e1 	bne.w	805295a <_svfprintf_r+0x84a>
 8052598:	eeb0 0a48 	vmov.f32	s0, s16
 805259c:	eef0 0a68 	vmov.f32	s1, s17
 80525a0:	a81c      	add	r0, sp, #112	; 0x70
 80525a2:	f004 fbfd 	bl	8056da0 <frexp>
 80525a6:	2200      	movs	r2, #0
 80525a8:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 80525ac:	ec51 0b10 	vmov	r0, r1, d0
 80525b0:	f7ee f832 	bl	8040618 <__aeabi_dmul>
 80525b4:	2200      	movs	r2, #0
 80525b6:	2300      	movs	r3, #0
 80525b8:	4606      	mov	r6, r0
 80525ba:	460f      	mov	r7, r1
 80525bc:	f7ee fa94 	bl	8040ae8 <__aeabi_dcmpeq>
 80525c0:	b108      	cbz	r0, 80525c6 <_svfprintf_r+0x4b6>
 80525c2:	2301      	movs	r3, #1
 80525c4:	931c      	str	r3, [sp, #112]	; 0x70
 80525c6:	4bb4      	ldr	r3, [pc, #720]	; (8052898 <_svfprintf_r+0x788>)
 80525c8:	4ab4      	ldr	r2, [pc, #720]	; (805289c <_svfprintf_r+0x78c>)
 80525ca:	9907      	ldr	r1, [sp, #28]
 80525cc:	2961      	cmp	r1, #97	; 0x61
 80525ce:	bf18      	it	ne
 80525d0:	461a      	movne	r2, r3
 80525d2:	9b04      	ldr	r3, [sp, #16]
 80525d4:	9217      	str	r2, [sp, #92]	; 0x5c
 80525d6:	3b01      	subs	r3, #1
 80525d8:	9305      	str	r3, [sp, #20]
 80525da:	465d      	mov	r5, fp
 80525dc:	4bb0      	ldr	r3, [pc, #704]	; (80528a0 <_svfprintf_r+0x790>)
 80525de:	2200      	movs	r2, #0
 80525e0:	4630      	mov	r0, r6
 80525e2:	4639      	mov	r1, r7
 80525e4:	f7ee f818 	bl	8040618 <__aeabi_dmul>
 80525e8:	460f      	mov	r7, r1
 80525ea:	4606      	mov	r6, r0
 80525ec:	f7ee fac4 	bl	8040b78 <__aeabi_d2iz>
 80525f0:	9019      	str	r0, [sp, #100]	; 0x64
 80525f2:	f7ed ffa7 	bl	8040544 <__aeabi_i2d>
 80525f6:	4602      	mov	r2, r0
 80525f8:	460b      	mov	r3, r1
 80525fa:	4630      	mov	r0, r6
 80525fc:	4639      	mov	r1, r7
 80525fe:	f7ed fe53 	bl	80402a8 <__aeabi_dsub>
 8052602:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8052604:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8052606:	5c9b      	ldrb	r3, [r3, r2]
 8052608:	f805 3b01 	strb.w	r3, [r5], #1
 805260c:	9b05      	ldr	r3, [sp, #20]
 805260e:	9309      	str	r3, [sp, #36]	; 0x24
 8052610:	1c5a      	adds	r2, r3, #1
 8052612:	4606      	mov	r6, r0
 8052614:	460f      	mov	r7, r1
 8052616:	d007      	beq.n	8052628 <_svfprintf_r+0x518>
 8052618:	3b01      	subs	r3, #1
 805261a:	9305      	str	r3, [sp, #20]
 805261c:	2200      	movs	r2, #0
 805261e:	2300      	movs	r3, #0
 8052620:	f7ee fa62 	bl	8040ae8 <__aeabi_dcmpeq>
 8052624:	2800      	cmp	r0, #0
 8052626:	d0d9      	beq.n	80525dc <_svfprintf_r+0x4cc>
 8052628:	4b9e      	ldr	r3, [pc, #632]	; (80528a4 <_svfprintf_r+0x794>)
 805262a:	2200      	movs	r2, #0
 805262c:	4630      	mov	r0, r6
 805262e:	4639      	mov	r1, r7
 8052630:	f7ee fa82 	bl	8040b38 <__aeabi_dcmpgt>
 8052634:	b960      	cbnz	r0, 8052650 <_svfprintf_r+0x540>
 8052636:	4b9b      	ldr	r3, [pc, #620]	; (80528a4 <_svfprintf_r+0x794>)
 8052638:	2200      	movs	r2, #0
 805263a:	4630      	mov	r0, r6
 805263c:	4639      	mov	r1, r7
 805263e:	f7ee fa53 	bl	8040ae8 <__aeabi_dcmpeq>
 8052642:	2800      	cmp	r0, #0
 8052644:	f000 8184 	beq.w	8052950 <_svfprintf_r+0x840>
 8052648:	9b19      	ldr	r3, [sp, #100]	; 0x64
 805264a:	07df      	lsls	r7, r3, #31
 805264c:	f140 8180 	bpl.w	8052950 <_svfprintf_r+0x840>
 8052650:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8052652:	9520      	str	r5, [sp, #128]	; 0x80
 8052654:	7bd9      	ldrb	r1, [r3, #15]
 8052656:	2030      	movs	r0, #48	; 0x30
 8052658:	9a20      	ldr	r2, [sp, #128]	; 0x80
 805265a:	1e53      	subs	r3, r2, #1
 805265c:	9320      	str	r3, [sp, #128]	; 0x80
 805265e:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 8052662:	428b      	cmp	r3, r1
 8052664:	f000 8163 	beq.w	805292e <_svfprintf_r+0x81e>
 8052668:	2b39      	cmp	r3, #57	; 0x39
 805266a:	bf0b      	itete	eq
 805266c:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 805266e:	3301      	addne	r3, #1
 8052670:	7a9b      	ldrbeq	r3, [r3, #10]
 8052672:	b2db      	uxtbne	r3, r3
 8052674:	f802 3c01 	strb.w	r3, [r2, #-1]
 8052678:	eba5 030b 	sub.w	r3, r5, fp
 805267c:	9305      	str	r3, [sp, #20]
 805267e:	9b08      	ldr	r3, [sp, #32]
 8052680:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8052682:	2b47      	cmp	r3, #71	; 0x47
 8052684:	f040 81b1 	bne.w	80529ea <_svfprintf_r+0x8da>
 8052688:	1cee      	adds	r6, r5, #3
 805268a:	db03      	blt.n	8052694 <_svfprintf_r+0x584>
 805268c:	9b04      	ldr	r3, [sp, #16]
 805268e:	42ab      	cmp	r3, r5
 8052690:	f280 81d6 	bge.w	8052a40 <_svfprintf_r+0x930>
 8052694:	9b07      	ldr	r3, [sp, #28]
 8052696:	3b02      	subs	r3, #2
 8052698:	9307      	str	r3, [sp, #28]
 805269a:	9907      	ldr	r1, [sp, #28]
 805269c:	f89d 201c 	ldrb.w	r2, [sp, #28]
 80526a0:	f021 0120 	bic.w	r1, r1, #32
 80526a4:	2941      	cmp	r1, #65	; 0x41
 80526a6:	bf08      	it	eq
 80526a8:	320f      	addeq	r2, #15
 80526aa:	f105 33ff 	add.w	r3, r5, #4294967295
 80526ae:	bf06      	itte	eq
 80526b0:	b2d2      	uxtbeq	r2, r2
 80526b2:	2101      	moveq	r1, #1
 80526b4:	2100      	movne	r1, #0
 80526b6:	2b00      	cmp	r3, #0
 80526b8:	931c      	str	r3, [sp, #112]	; 0x70
 80526ba:	bfb8      	it	lt
 80526bc:	f1c5 0301 	rsblt	r3, r5, #1
 80526c0:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 80526c4:	bfb4      	ite	lt
 80526c6:	222d      	movlt	r2, #45	; 0x2d
 80526c8:	222b      	movge	r2, #43	; 0x2b
 80526ca:	2b09      	cmp	r3, #9
 80526cc:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 80526d0:	f340 81a4 	ble.w	8052a1c <_svfprintf_r+0x90c>
 80526d4:	f10d 0287 	add.w	r2, sp, #135	; 0x87
 80526d8:	260a      	movs	r6, #10
 80526da:	4611      	mov	r1, r2
 80526dc:	fb93 f5f6 	sdiv	r5, r3, r6
 80526e0:	fb06 3015 	mls	r0, r6, r5, r3
 80526e4:	3030      	adds	r0, #48	; 0x30
 80526e6:	f801 0c01 	strb.w	r0, [r1, #-1]
 80526ea:	4618      	mov	r0, r3
 80526ec:	2863      	cmp	r0, #99	; 0x63
 80526ee:	f102 32ff 	add.w	r2, r2, #4294967295
 80526f2:	462b      	mov	r3, r5
 80526f4:	dcf1      	bgt.n	80526da <_svfprintf_r+0x5ca>
 80526f6:	3330      	adds	r3, #48	; 0x30
 80526f8:	1e88      	subs	r0, r1, #2
 80526fa:	f802 3c01 	strb.w	r3, [r2, #-1]
 80526fe:	f10d 0587 	add.w	r5, sp, #135	; 0x87
 8052702:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8052706:	4603      	mov	r3, r0
 8052708:	42ab      	cmp	r3, r5
 805270a:	f0c0 8182 	bcc.w	8052a12 <_svfprintf_r+0x902>
 805270e:	f10d 0289 	add.w	r2, sp, #137	; 0x89
 8052712:	1a52      	subs	r2, r2, r1
 8052714:	42a8      	cmp	r0, r5
 8052716:	bf88      	it	hi
 8052718:	2200      	movhi	r2, #0
 805271a:	f10d 037a 	add.w	r3, sp, #122	; 0x7a
 805271e:	441a      	add	r2, r3
 8052720:	ab1e      	add	r3, sp, #120	; 0x78
 8052722:	1ad3      	subs	r3, r2, r3
 8052724:	9a05      	ldr	r2, [sp, #20]
 8052726:	9315      	str	r3, [sp, #84]	; 0x54
 8052728:	2a01      	cmp	r2, #1
 805272a:	4413      	add	r3, r2
 805272c:	9304      	str	r3, [sp, #16]
 805272e:	dc02      	bgt.n	8052736 <_svfprintf_r+0x626>
 8052730:	f018 0f01 	tst.w	r8, #1
 8052734:	d003      	beq.n	805273e <_svfprintf_r+0x62e>
 8052736:	9b04      	ldr	r3, [sp, #16]
 8052738:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 805273a:	4413      	add	r3, r2
 805273c:	9304      	str	r3, [sp, #16]
 805273e:	f428 6380 	bic.w	r3, r8, #1024	; 0x400
 8052742:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8052746:	9311      	str	r3, [sp, #68]	; 0x44
 8052748:	2300      	movs	r3, #0
 805274a:	e9cd 3308 	strd	r3, r3, [sp, #32]
 805274e:	461d      	mov	r5, r3
 8052750:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8052752:	b113      	cbz	r3, 805275a <_svfprintf_r+0x64a>
 8052754:	232d      	movs	r3, #45	; 0x2d
 8052756:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 805275a:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 805275e:	2600      	movs	r6, #0
 8052760:	9b04      	ldr	r3, [sp, #16]
 8052762:	42b3      	cmp	r3, r6
 8052764:	bfb8      	it	lt
 8052766:	4633      	movlt	r3, r6
 8052768:	9311      	str	r3, [sp, #68]	; 0x44
 805276a:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 805276e:	b113      	cbz	r3, 8052776 <_svfprintf_r+0x666>
 8052770:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8052772:	3301      	adds	r3, #1
 8052774:	9311      	str	r3, [sp, #68]	; 0x44
 8052776:	f018 0302 	ands.w	r3, r8, #2
 805277a:	9317      	str	r3, [sp, #92]	; 0x5c
 805277c:	bf1e      	ittt	ne
 805277e:	9b11      	ldrne	r3, [sp, #68]	; 0x44
 8052780:	3302      	addne	r3, #2
 8052782:	9311      	strne	r3, [sp, #68]	; 0x44
 8052784:	f018 0384 	ands.w	r3, r8, #132	; 0x84
 8052788:	9318      	str	r3, [sp, #96]	; 0x60
 805278a:	d11f      	bne.n	80527cc <_svfprintf_r+0x6bc>
 805278c:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8052790:	1a9f      	subs	r7, r3, r2
 8052792:	2f00      	cmp	r7, #0
 8052794:	dd1a      	ble.n	80527cc <_svfprintf_r+0x6bc>
 8052796:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805279a:	4843      	ldr	r0, [pc, #268]	; (80528a8 <_svfprintf_r+0x798>)
 805279c:	6020      	str	r0, [r4, #0]
 805279e:	2f10      	cmp	r7, #16
 80527a0:	f103 0301 	add.w	r3, r3, #1
 80527a4:	f104 0108 	add.w	r1, r4, #8
 80527a8:	f300 82e6 	bgt.w	8052d78 <_svfprintf_r+0xc68>
 80527ac:	6067      	str	r7, [r4, #4]
 80527ae:	2b07      	cmp	r3, #7
 80527b0:	4417      	add	r7, r2
 80527b2:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 80527b6:	f340 82f2 	ble.w	8052d9e <_svfprintf_r+0xc8e>
 80527ba:	aa22      	add	r2, sp, #136	; 0x88
 80527bc:	4649      	mov	r1, r9
 80527be:	4650      	mov	r0, sl
 80527c0:	f004 fb71 	bl	8056ea6 <__ssprint_r>
 80527c4:	2800      	cmp	r0, #0
 80527c6:	f040 861d 	bne.w	8053404 <_svfprintf_r+0x12f4>
 80527ca:	ac25      	add	r4, sp, #148	; 0x94
 80527cc:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80527d0:	b173      	cbz	r3, 80527f0 <_svfprintf_r+0x6e0>
 80527d2:	f10d 036b 	add.w	r3, sp, #107	; 0x6b
 80527d6:	6023      	str	r3, [r4, #0]
 80527d8:	2301      	movs	r3, #1
 80527da:	6063      	str	r3, [r4, #4]
 80527dc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80527de:	3301      	adds	r3, #1
 80527e0:	9324      	str	r3, [sp, #144]	; 0x90
 80527e2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80527e4:	3301      	adds	r3, #1
 80527e6:	2b07      	cmp	r3, #7
 80527e8:	9323      	str	r3, [sp, #140]	; 0x8c
 80527ea:	f300 82da 	bgt.w	8052da2 <_svfprintf_r+0xc92>
 80527ee:	3408      	adds	r4, #8
 80527f0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80527f2:	b16b      	cbz	r3, 8052810 <_svfprintf_r+0x700>
 80527f4:	ab1b      	add	r3, sp, #108	; 0x6c
 80527f6:	6023      	str	r3, [r4, #0]
 80527f8:	2302      	movs	r3, #2
 80527fa:	6063      	str	r3, [r4, #4]
 80527fc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80527fe:	3302      	adds	r3, #2
 8052800:	9324      	str	r3, [sp, #144]	; 0x90
 8052802:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052804:	3301      	adds	r3, #1
 8052806:	2b07      	cmp	r3, #7
 8052808:	9323      	str	r3, [sp, #140]	; 0x8c
 805280a:	f300 82d4 	bgt.w	8052db6 <_svfprintf_r+0xca6>
 805280e:	3408      	adds	r4, #8
 8052810:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8052812:	2b80      	cmp	r3, #128	; 0x80
 8052814:	d11f      	bne.n	8052856 <_svfprintf_r+0x746>
 8052816:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 805281a:	1a9f      	subs	r7, r3, r2
 805281c:	2f00      	cmp	r7, #0
 805281e:	dd1a      	ble.n	8052856 <_svfprintf_r+0x746>
 8052820:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8052824:	4821      	ldr	r0, [pc, #132]	; (80528ac <_svfprintf_r+0x79c>)
 8052826:	6020      	str	r0, [r4, #0]
 8052828:	2f10      	cmp	r7, #16
 805282a:	f103 0301 	add.w	r3, r3, #1
 805282e:	f104 0108 	add.w	r1, r4, #8
 8052832:	f300 82ca 	bgt.w	8052dca <_svfprintf_r+0xcba>
 8052836:	6067      	str	r7, [r4, #4]
 8052838:	2b07      	cmp	r3, #7
 805283a:	4417      	add	r7, r2
 805283c:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8052840:	f340 82d6 	ble.w	8052df0 <_svfprintf_r+0xce0>
 8052844:	aa22      	add	r2, sp, #136	; 0x88
 8052846:	4649      	mov	r1, r9
 8052848:	4650      	mov	r0, sl
 805284a:	f004 fb2c 	bl	8056ea6 <__ssprint_r>
 805284e:	2800      	cmp	r0, #0
 8052850:	f040 85d8 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052854:	ac25      	add	r4, sp, #148	; 0x94
 8052856:	9b04      	ldr	r3, [sp, #16]
 8052858:	1af6      	subs	r6, r6, r3
 805285a:	2e00      	cmp	r6, #0
 805285c:	dd28      	ble.n	80528b0 <_svfprintf_r+0x7a0>
 805285e:	4f13      	ldr	r7, [pc, #76]	; (80528ac <_svfprintf_r+0x79c>)
 8052860:	6027      	str	r7, [r4, #0]
 8052862:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8052866:	2e10      	cmp	r6, #16
 8052868:	f103 0301 	add.w	r3, r3, #1
 805286c:	f104 0108 	add.w	r1, r4, #8
 8052870:	f300 82c0 	bgt.w	8052df4 <_svfprintf_r+0xce4>
 8052874:	6066      	str	r6, [r4, #4]
 8052876:	2b07      	cmp	r3, #7
 8052878:	4416      	add	r6, r2
 805287a:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 805287e:	f340 82cc 	ble.w	8052e1a <_svfprintf_r+0xd0a>
 8052882:	aa22      	add	r2, sp, #136	; 0x88
 8052884:	4649      	mov	r1, r9
 8052886:	4650      	mov	r0, sl
 8052888:	f004 fb0d 	bl	8056ea6 <__ssprint_r>
 805288c:	2800      	cmp	r0, #0
 805288e:	f040 85b9 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052892:	ac25      	add	r4, sp, #148	; 0x94
 8052894:	e00c      	b.n	80528b0 <_svfprintf_r+0x7a0>
 8052896:	bf00      	nop
 8052898:	0805a371 	.word	0x0805a371
 805289c:	0805a360 	.word	0x0805a360
 80528a0:	40300000 	.word	0x40300000
 80528a4:	3fe00000 	.word	0x3fe00000
 80528a8:	0805a384 	.word	0x0805a384
 80528ac:	0805a394 	.word	0x0805a394
 80528b0:	f418 7f80 	tst.w	r8, #256	; 0x100
 80528b4:	9e24      	ldr	r6, [sp, #144]	; 0x90
 80528b6:	f040 82b7 	bne.w	8052e28 <_svfprintf_r+0xd18>
 80528ba:	9b04      	ldr	r3, [sp, #16]
 80528bc:	f8c4 b000 	str.w	fp, [r4]
 80528c0:	441e      	add	r6, r3
 80528c2:	6063      	str	r3, [r4, #4]
 80528c4:	9624      	str	r6, [sp, #144]	; 0x90
 80528c6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80528c8:	3301      	adds	r3, #1
 80528ca:	2b07      	cmp	r3, #7
 80528cc:	9323      	str	r3, [sp, #140]	; 0x8c
 80528ce:	f300 82f0 	bgt.w	8052eb2 <_svfprintf_r+0xda2>
 80528d2:	3408      	adds	r4, #8
 80528d4:	f018 0f04 	tst.w	r8, #4
 80528d8:	f040 8576 	bne.w	80533c8 <_svfprintf_r+0x12b8>
 80528dc:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 80528e0:	9911      	ldr	r1, [sp, #68]	; 0x44
 80528e2:	428a      	cmp	r2, r1
 80528e4:	bfac      	ite	ge
 80528e6:	189b      	addge	r3, r3, r2
 80528e8:	185b      	addlt	r3, r3, r1
 80528ea:	930f      	str	r3, [sp, #60]	; 0x3c
 80528ec:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80528ee:	b13b      	cbz	r3, 8052900 <_svfprintf_r+0x7f0>
 80528f0:	aa22      	add	r2, sp, #136	; 0x88
 80528f2:	4649      	mov	r1, r9
 80528f4:	4650      	mov	r0, sl
 80528f6:	f004 fad6 	bl	8056ea6 <__ssprint_r>
 80528fa:	2800      	cmp	r0, #0
 80528fc:	f040 8582 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052900:	2300      	movs	r3, #0
 8052902:	9323      	str	r3, [sp, #140]	; 0x8c
 8052904:	9b03      	ldr	r3, [sp, #12]
 8052906:	2b00      	cmp	r3, #0
 8052908:	f040 8598 	bne.w	805343c <_svfprintf_r+0x132c>
 805290c:	ac25      	add	r4, sp, #148	; 0x94
 805290e:	e0ed      	b.n	8052aec <_svfprintf_r+0x9dc>
 8052910:	9003      	str	r0, [sp, #12]
 8052912:	e62c      	b.n	805256e <_svfprintf_r+0x45e>
 8052914:	9003      	str	r0, [sp, #12]
 8052916:	2306      	movs	r3, #6
 8052918:	e619      	b.n	805254e <_svfprintf_r+0x43e>
 805291a:	9003      	str	r0, [sp, #12]
 805291c:	e627      	b.n	805256e <_svfprintf_r+0x45e>
 805291e:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8052922:	2300      	movs	r3, #0
 8052924:	eeb0 8a47 	vmov.f32	s16, s14
 8052928:	eef0 8a67 	vmov.f32	s17, s15
 805292c:	e62f      	b.n	805258e <_svfprintf_r+0x47e>
 805292e:	f802 0c01 	strb.w	r0, [r2, #-1]
 8052932:	e691      	b.n	8052658 <_svfprintf_r+0x548>
 8052934:	f803 0b01 	strb.w	r0, [r3], #1
 8052938:	1aca      	subs	r2, r1, r3
 805293a:	2a00      	cmp	r2, #0
 805293c:	dafa      	bge.n	8052934 <_svfprintf_r+0x824>
 805293e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8052940:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8052942:	3201      	adds	r2, #1
 8052944:	f103 0301 	add.w	r3, r3, #1
 8052948:	bfb8      	it	lt
 805294a:	2300      	movlt	r3, #0
 805294c:	441d      	add	r5, r3
 805294e:	e693      	b.n	8052678 <_svfprintf_r+0x568>
 8052950:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8052952:	462b      	mov	r3, r5
 8052954:	18a9      	adds	r1, r5, r2
 8052956:	2030      	movs	r0, #48	; 0x30
 8052958:	e7ee      	b.n	8052938 <_svfprintf_r+0x828>
 805295a:	9b08      	ldr	r3, [sp, #32]
 805295c:	2b46      	cmp	r3, #70	; 0x46
 805295e:	d005      	beq.n	805296c <_svfprintf_r+0x85c>
 8052960:	2b45      	cmp	r3, #69	; 0x45
 8052962:	d11b      	bne.n	805299c <_svfprintf_r+0x88c>
 8052964:	9b04      	ldr	r3, [sp, #16]
 8052966:	1c5d      	adds	r5, r3, #1
 8052968:	2102      	movs	r1, #2
 805296a:	e001      	b.n	8052970 <_svfprintf_r+0x860>
 805296c:	9d04      	ldr	r5, [sp, #16]
 805296e:	2103      	movs	r1, #3
 8052970:	ab20      	add	r3, sp, #128	; 0x80
 8052972:	9301      	str	r3, [sp, #4]
 8052974:	ab1d      	add	r3, sp, #116	; 0x74
 8052976:	9300      	str	r3, [sp, #0]
 8052978:	462a      	mov	r2, r5
 805297a:	ab1c      	add	r3, sp, #112	; 0x70
 805297c:	4650      	mov	r0, sl
 805297e:	eeb0 0a48 	vmov.f32	s0, s16
 8052982:	eef0 0a68 	vmov.f32	s1, s17
 8052986:	f002 f95f 	bl	8054c48 <_dtoa_r>
 805298a:	9b08      	ldr	r3, [sp, #32]
 805298c:	2b47      	cmp	r3, #71	; 0x47
 805298e:	4683      	mov	fp, r0
 8052990:	d106      	bne.n	80529a0 <_svfprintf_r+0x890>
 8052992:	f018 0f01 	tst.w	r8, #1
 8052996:	d103      	bne.n	80529a0 <_svfprintf_r+0x890>
 8052998:	9d20      	ldr	r5, [sp, #128]	; 0x80
 805299a:	e66d      	b.n	8052678 <_svfprintf_r+0x568>
 805299c:	9d04      	ldr	r5, [sp, #16]
 805299e:	e7e3      	b.n	8052968 <_svfprintf_r+0x858>
 80529a0:	9b08      	ldr	r3, [sp, #32]
 80529a2:	2b46      	cmp	r3, #70	; 0x46
 80529a4:	eb0b 0605 	add.w	r6, fp, r5
 80529a8:	d10f      	bne.n	80529ca <_svfprintf_r+0x8ba>
 80529aa:	f89b 3000 	ldrb.w	r3, [fp]
 80529ae:	2b30      	cmp	r3, #48	; 0x30
 80529b0:	d109      	bne.n	80529c6 <_svfprintf_r+0x8b6>
 80529b2:	ec51 0b18 	vmov	r0, r1, d8
 80529b6:	2200      	movs	r2, #0
 80529b8:	2300      	movs	r3, #0
 80529ba:	f7ee f895 	bl	8040ae8 <__aeabi_dcmpeq>
 80529be:	b910      	cbnz	r0, 80529c6 <_svfprintf_r+0x8b6>
 80529c0:	f1c5 0501 	rsb	r5, r5, #1
 80529c4:	951c      	str	r5, [sp, #112]	; 0x70
 80529c6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80529c8:	441e      	add	r6, r3
 80529ca:	ec51 0b18 	vmov	r0, r1, d8
 80529ce:	2200      	movs	r2, #0
 80529d0:	2300      	movs	r3, #0
 80529d2:	f7ee f889 	bl	8040ae8 <__aeabi_dcmpeq>
 80529d6:	b100      	cbz	r0, 80529da <_svfprintf_r+0x8ca>
 80529d8:	9620      	str	r6, [sp, #128]	; 0x80
 80529da:	2230      	movs	r2, #48	; 0x30
 80529dc:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80529de:	429e      	cmp	r6, r3
 80529e0:	d9da      	bls.n	8052998 <_svfprintf_r+0x888>
 80529e2:	1c59      	adds	r1, r3, #1
 80529e4:	9120      	str	r1, [sp, #128]	; 0x80
 80529e6:	701a      	strb	r2, [r3, #0]
 80529e8:	e7f8      	b.n	80529dc <_svfprintf_r+0x8cc>
 80529ea:	9b08      	ldr	r3, [sp, #32]
 80529ec:	2b46      	cmp	r3, #70	; 0x46
 80529ee:	f47f ae54 	bne.w	805269a <_svfprintf_r+0x58a>
 80529f2:	9a04      	ldr	r2, [sp, #16]
 80529f4:	f008 0301 	and.w	r3, r8, #1
 80529f8:	2d00      	cmp	r5, #0
 80529fa:	ea43 0302 	orr.w	r3, r3, r2
 80529fe:	dd1a      	ble.n	8052a36 <_svfprintf_r+0x926>
 8052a00:	2b00      	cmp	r3, #0
 8052a02:	d034      	beq.n	8052a6e <_svfprintf_r+0x95e>
 8052a04:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8052a06:	18eb      	adds	r3, r5, r3
 8052a08:	441a      	add	r2, r3
 8052a0a:	9204      	str	r2, [sp, #16]
 8052a0c:	2366      	movs	r3, #102	; 0x66
 8052a0e:	9307      	str	r3, [sp, #28]
 8052a10:	e033      	b.n	8052a7a <_svfprintf_r+0x96a>
 8052a12:	f813 6b01 	ldrb.w	r6, [r3], #1
 8052a16:	f802 6b01 	strb.w	r6, [r2], #1
 8052a1a:	e675      	b.n	8052708 <_svfprintf_r+0x5f8>
 8052a1c:	b941      	cbnz	r1, 8052a30 <_svfprintf_r+0x920>
 8052a1e:	2230      	movs	r2, #48	; 0x30
 8052a20:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8052a24:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8052a28:	3330      	adds	r3, #48	; 0x30
 8052a2a:	f802 3b01 	strb.w	r3, [r2], #1
 8052a2e:	e677      	b.n	8052720 <_svfprintf_r+0x610>
 8052a30:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8052a34:	e7f8      	b.n	8052a28 <_svfprintf_r+0x918>
 8052a36:	b1e3      	cbz	r3, 8052a72 <_svfprintf_r+0x962>
 8052a38:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8052a3a:	9a04      	ldr	r2, [sp, #16]
 8052a3c:	3301      	adds	r3, #1
 8052a3e:	e7e3      	b.n	8052a08 <_svfprintf_r+0x8f8>
 8052a40:	9b05      	ldr	r3, [sp, #20]
 8052a42:	429d      	cmp	r5, r3
 8052a44:	db07      	blt.n	8052a56 <_svfprintf_r+0x946>
 8052a46:	f018 0f01 	tst.w	r8, #1
 8052a4a:	d02d      	beq.n	8052aa8 <_svfprintf_r+0x998>
 8052a4c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8052a4e:	18eb      	adds	r3, r5, r3
 8052a50:	9304      	str	r3, [sp, #16]
 8052a52:	2367      	movs	r3, #103	; 0x67
 8052a54:	e7db      	b.n	8052a0e <_svfprintf_r+0x8fe>
 8052a56:	9b05      	ldr	r3, [sp, #20]
 8052a58:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8052a5a:	2d00      	cmp	r5, #0
 8052a5c:	4413      	add	r3, r2
 8052a5e:	9304      	str	r3, [sp, #16]
 8052a60:	dcf7      	bgt.n	8052a52 <_svfprintf_r+0x942>
 8052a62:	9a04      	ldr	r2, [sp, #16]
 8052a64:	f1c5 0301 	rsb	r3, r5, #1
 8052a68:	441a      	add	r2, r3
 8052a6a:	4613      	mov	r3, r2
 8052a6c:	e7f0      	b.n	8052a50 <_svfprintf_r+0x940>
 8052a6e:	9504      	str	r5, [sp, #16]
 8052a70:	e7cc      	b.n	8052a0c <_svfprintf_r+0x8fc>
 8052a72:	2366      	movs	r3, #102	; 0x66
 8052a74:	9307      	str	r3, [sp, #28]
 8052a76:	2301      	movs	r3, #1
 8052a78:	9304      	str	r3, [sp, #16]
 8052a7a:	f418 6380 	ands.w	r3, r8, #1024	; 0x400
 8052a7e:	9309      	str	r3, [sp, #36]	; 0x24
 8052a80:	d025      	beq.n	8052ace <_svfprintf_r+0x9be>
 8052a82:	2300      	movs	r3, #0
 8052a84:	2d00      	cmp	r5, #0
 8052a86:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8052a8a:	f77f ae61 	ble.w	8052750 <_svfprintf_r+0x640>
 8052a8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052a90:	781b      	ldrb	r3, [r3, #0]
 8052a92:	2bff      	cmp	r3, #255	; 0xff
 8052a94:	d10a      	bne.n	8052aac <_svfprintf_r+0x99c>
 8052a96:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8052a9a:	9904      	ldr	r1, [sp, #16]
 8052a9c:	4413      	add	r3, r2
 8052a9e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8052aa0:	fb02 1303 	mla	r3, r2, r3, r1
 8052aa4:	9304      	str	r3, [sp, #16]
 8052aa6:	e653      	b.n	8052750 <_svfprintf_r+0x640>
 8052aa8:	9504      	str	r5, [sp, #16]
 8052aaa:	e7d2      	b.n	8052a52 <_svfprintf_r+0x942>
 8052aac:	42ab      	cmp	r3, r5
 8052aae:	daf2      	bge.n	8052a96 <_svfprintf_r+0x986>
 8052ab0:	1aed      	subs	r5, r5, r3
 8052ab2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052ab4:	785b      	ldrb	r3, [r3, #1]
 8052ab6:	b133      	cbz	r3, 8052ac6 <_svfprintf_r+0x9b6>
 8052ab8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8052aba:	3301      	adds	r3, #1
 8052abc:	9309      	str	r3, [sp, #36]	; 0x24
 8052abe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052ac0:	3301      	adds	r3, #1
 8052ac2:	930a      	str	r3, [sp, #40]	; 0x28
 8052ac4:	e7e3      	b.n	8052a8e <_svfprintf_r+0x97e>
 8052ac6:	9b08      	ldr	r3, [sp, #32]
 8052ac8:	3301      	adds	r3, #1
 8052aca:	9308      	str	r3, [sp, #32]
 8052acc:	e7df      	b.n	8052a8e <_svfprintf_r+0x97e>
 8052ace:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8052ad0:	9308      	str	r3, [sp, #32]
 8052ad2:	e63d      	b.n	8052750 <_svfprintf_r+0x640>
 8052ad4:	4632      	mov	r2, r6
 8052ad6:	f018 0f20 	tst.w	r8, #32
 8052ada:	f852 3b04 	ldr.w	r3, [r2], #4
 8052ade:	9206      	str	r2, [sp, #24]
 8052ae0:	d009      	beq.n	8052af6 <_svfprintf_r+0x9e6>
 8052ae2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8052ae4:	4610      	mov	r0, r2
 8052ae6:	17d1      	asrs	r1, r2, #31
 8052ae8:	e9c3 0100 	strd	r0, r1, [r3]
 8052aec:	9e06      	ldr	r6, [sp, #24]
 8052aee:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 8052af2:	f7ff bb4d 	b.w	8052190 <_svfprintf_r+0x80>
 8052af6:	f018 0f10 	tst.w	r8, #16
 8052afa:	d002      	beq.n	8052b02 <_svfprintf_r+0x9f2>
 8052afc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8052afe:	601a      	str	r2, [r3, #0]
 8052b00:	e7f4      	b.n	8052aec <_svfprintf_r+0x9dc>
 8052b02:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052b06:	d002      	beq.n	8052b0e <_svfprintf_r+0x9fe>
 8052b08:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8052b0a:	801a      	strh	r2, [r3, #0]
 8052b0c:	e7ee      	b.n	8052aec <_svfprintf_r+0x9dc>
 8052b0e:	f418 7f00 	tst.w	r8, #512	; 0x200
 8052b12:	d0f3      	beq.n	8052afc <_svfprintf_r+0x9ec>
 8052b14:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8052b16:	701a      	strb	r2, [r3, #0]
 8052b18:	e7e8      	b.n	8052aec <_svfprintf_r+0x9dc>
 8052b1a:	f048 0810 	orr.w	r8, r8, #16
 8052b1e:	f018 0f20 	tst.w	r8, #32
 8052b22:	d01e      	beq.n	8052b62 <_svfprintf_r+0xa52>
 8052b24:	3607      	adds	r6, #7
 8052b26:	f026 0307 	bic.w	r3, r6, #7
 8052b2a:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8052b2e:	9306      	str	r3, [sp, #24]
 8052b30:	f428 6880 	bic.w	r8, r8, #1024	; 0x400
 8052b34:	2300      	movs	r3, #0
 8052b36:	2200      	movs	r2, #0
 8052b38:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 8052b3c:	9a04      	ldr	r2, [sp, #16]
 8052b3e:	3201      	adds	r2, #1
 8052b40:	f000 848d 	beq.w	805345e <_svfprintf_r+0x134e>
 8052b44:	f028 0280 	bic.w	r2, r8, #128	; 0x80
 8052b48:	9203      	str	r2, [sp, #12]
 8052b4a:	ea56 0207 	orrs.w	r2, r6, r7
 8052b4e:	f040 848c 	bne.w	805346a <_svfprintf_r+0x135a>
 8052b52:	9a04      	ldr	r2, [sp, #16]
 8052b54:	2a00      	cmp	r2, #0
 8052b56:	f000 80f5 	beq.w	8052d44 <_svfprintf_r+0xc34>
 8052b5a:	2b01      	cmp	r3, #1
 8052b5c:	f040 8488 	bne.w	8053470 <_svfprintf_r+0x1360>
 8052b60:	e097      	b.n	8052c92 <_svfprintf_r+0xb82>
 8052b62:	1d33      	adds	r3, r6, #4
 8052b64:	f018 0f10 	tst.w	r8, #16
 8052b68:	9306      	str	r3, [sp, #24]
 8052b6a:	d001      	beq.n	8052b70 <_svfprintf_r+0xa60>
 8052b6c:	6836      	ldr	r6, [r6, #0]
 8052b6e:	e003      	b.n	8052b78 <_svfprintf_r+0xa68>
 8052b70:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052b74:	d002      	beq.n	8052b7c <_svfprintf_r+0xa6c>
 8052b76:	8836      	ldrh	r6, [r6, #0]
 8052b78:	2700      	movs	r7, #0
 8052b7a:	e7d9      	b.n	8052b30 <_svfprintf_r+0xa20>
 8052b7c:	f418 7f00 	tst.w	r8, #512	; 0x200
 8052b80:	d0f4      	beq.n	8052b6c <_svfprintf_r+0xa5c>
 8052b82:	7836      	ldrb	r6, [r6, #0]
 8052b84:	e7f8      	b.n	8052b78 <_svfprintf_r+0xa68>
 8052b86:	4633      	mov	r3, r6
 8052b88:	2278      	movs	r2, #120	; 0x78
 8052b8a:	f853 6b04 	ldr.w	r6, [r3], #4
 8052b8e:	9306      	str	r3, [sp, #24]
 8052b90:	f647 0330 	movw	r3, #30768	; 0x7830
 8052b94:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 8052b98:	4ba1      	ldr	r3, [pc, #644]	; (8052e20 <_svfprintf_r+0xd10>)
 8052b9a:	9316      	str	r3, [sp, #88]	; 0x58
 8052b9c:	2700      	movs	r7, #0
 8052b9e:	f048 0802 	orr.w	r8, r8, #2
 8052ba2:	2302      	movs	r3, #2
 8052ba4:	9207      	str	r2, [sp, #28]
 8052ba6:	e7c6      	b.n	8052b36 <_svfprintf_r+0xa26>
 8052ba8:	4633      	mov	r3, r6
 8052baa:	2500      	movs	r5, #0
 8052bac:	f853 bb04 	ldr.w	fp, [r3], #4
 8052bb0:	9306      	str	r3, [sp, #24]
 8052bb2:	9b04      	ldr	r3, [sp, #16]
 8052bb4:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 8052bb8:	1c59      	adds	r1, r3, #1
 8052bba:	d010      	beq.n	8052bde <_svfprintf_r+0xace>
 8052bbc:	461a      	mov	r2, r3
 8052bbe:	4629      	mov	r1, r5
 8052bc0:	4658      	mov	r0, fp
 8052bc2:	f7ed fb1d 	bl	8040200 <memchr>
 8052bc6:	9003      	str	r0, [sp, #12]
 8052bc8:	2800      	cmp	r0, #0
 8052bca:	f000 80d2 	beq.w	8052d72 <_svfprintf_r+0xc62>
 8052bce:	eba0 030b 	sub.w	r3, r0, fp
 8052bd2:	e9cd 5303 	strd	r5, r3, [sp, #12]
 8052bd6:	e9cd 5508 	strd	r5, r5, [sp, #32]
 8052bda:	462e      	mov	r6, r5
 8052bdc:	e5c0      	b.n	8052760 <_svfprintf_r+0x650>
 8052bde:	4658      	mov	r0, fp
 8052be0:	f7ed fb06 	bl	80401f0 <strlen>
 8052be4:	e9cd 5003 	strd	r5, r0, [sp, #12]
 8052be8:	e463      	b.n	80524b2 <_svfprintf_r+0x3a2>
 8052bea:	f048 0810 	orr.w	r8, r8, #16
 8052bee:	f018 0f20 	tst.w	r8, #32
 8052bf2:	d007      	beq.n	8052c04 <_svfprintf_r+0xaf4>
 8052bf4:	3607      	adds	r6, #7
 8052bf6:	f026 0307 	bic.w	r3, r6, #7
 8052bfa:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8052bfe:	9306      	str	r3, [sp, #24]
 8052c00:	2301      	movs	r3, #1
 8052c02:	e798      	b.n	8052b36 <_svfprintf_r+0xa26>
 8052c04:	1d33      	adds	r3, r6, #4
 8052c06:	f018 0f10 	tst.w	r8, #16
 8052c0a:	9306      	str	r3, [sp, #24]
 8052c0c:	d001      	beq.n	8052c12 <_svfprintf_r+0xb02>
 8052c0e:	6836      	ldr	r6, [r6, #0]
 8052c10:	e003      	b.n	8052c1a <_svfprintf_r+0xb0a>
 8052c12:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052c16:	d002      	beq.n	8052c1e <_svfprintf_r+0xb0e>
 8052c18:	8836      	ldrh	r6, [r6, #0]
 8052c1a:	2700      	movs	r7, #0
 8052c1c:	e7f0      	b.n	8052c00 <_svfprintf_r+0xaf0>
 8052c1e:	f418 7f00 	tst.w	r8, #512	; 0x200
 8052c22:	d0f4      	beq.n	8052c0e <_svfprintf_r+0xafe>
 8052c24:	7836      	ldrb	r6, [r6, #0]
 8052c26:	e7f8      	b.n	8052c1a <_svfprintf_r+0xb0a>
 8052c28:	4b7e      	ldr	r3, [pc, #504]	; (8052e24 <_svfprintf_r+0xd14>)
 8052c2a:	9316      	str	r3, [sp, #88]	; 0x58
 8052c2c:	f018 0f20 	tst.w	r8, #32
 8052c30:	d019      	beq.n	8052c66 <_svfprintf_r+0xb56>
 8052c32:	3607      	adds	r6, #7
 8052c34:	f026 0307 	bic.w	r3, r6, #7
 8052c38:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8052c3c:	9306      	str	r3, [sp, #24]
 8052c3e:	f018 0f01 	tst.w	r8, #1
 8052c42:	d00a      	beq.n	8052c5a <_svfprintf_r+0xb4a>
 8052c44:	ea56 0307 	orrs.w	r3, r6, r7
 8052c48:	d007      	beq.n	8052c5a <_svfprintf_r+0xb4a>
 8052c4a:	2330      	movs	r3, #48	; 0x30
 8052c4c:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8052c50:	9b07      	ldr	r3, [sp, #28]
 8052c52:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 8052c56:	f048 0802 	orr.w	r8, r8, #2
 8052c5a:	f428 6880 	bic.w	r8, r8, #1024	; 0x400
 8052c5e:	2302      	movs	r3, #2
 8052c60:	e769      	b.n	8052b36 <_svfprintf_r+0xa26>
 8052c62:	4b6f      	ldr	r3, [pc, #444]	; (8052e20 <_svfprintf_r+0xd10>)
 8052c64:	e7e1      	b.n	8052c2a <_svfprintf_r+0xb1a>
 8052c66:	1d33      	adds	r3, r6, #4
 8052c68:	f018 0f10 	tst.w	r8, #16
 8052c6c:	9306      	str	r3, [sp, #24]
 8052c6e:	d001      	beq.n	8052c74 <_svfprintf_r+0xb64>
 8052c70:	6836      	ldr	r6, [r6, #0]
 8052c72:	e003      	b.n	8052c7c <_svfprintf_r+0xb6c>
 8052c74:	f018 0f40 	tst.w	r8, #64	; 0x40
 8052c78:	d002      	beq.n	8052c80 <_svfprintf_r+0xb70>
 8052c7a:	8836      	ldrh	r6, [r6, #0]
 8052c7c:	2700      	movs	r7, #0
 8052c7e:	e7de      	b.n	8052c3e <_svfprintf_r+0xb2e>
 8052c80:	f418 7f00 	tst.w	r8, #512	; 0x200
 8052c84:	d0f4      	beq.n	8052c70 <_svfprintf_r+0xb60>
 8052c86:	7836      	ldrb	r6, [r6, #0]
 8052c88:	e7f8      	b.n	8052c7c <_svfprintf_r+0xb6c>
 8052c8a:	2f00      	cmp	r7, #0
 8052c8c:	bf08      	it	eq
 8052c8e:	2e0a      	cmpeq	r6, #10
 8052c90:	d206      	bcs.n	8052ca0 <_svfprintf_r+0xb90>
 8052c92:	3630      	adds	r6, #48	; 0x30
 8052c94:	f88d 6137 	strb.w	r6, [sp, #311]	; 0x137
 8052c98:	f20d 1b37 	addw	fp, sp, #311	; 0x137
 8052c9c:	f000 bc06 	b.w	80534ac <_svfprintf_r+0x139c>
 8052ca0:	2300      	movs	r3, #0
 8052ca2:	9305      	str	r3, [sp, #20]
 8052ca4:	9b03      	ldr	r3, [sp, #12]
 8052ca6:	ad4e      	add	r5, sp, #312	; 0x138
 8052ca8:	f403 6880 	and.w	r8, r3, #1024	; 0x400
 8052cac:	220a      	movs	r2, #10
 8052cae:	2300      	movs	r3, #0
 8052cb0:	4630      	mov	r0, r6
 8052cb2:	4639      	mov	r1, r7
 8052cb4:	f7ed fff8 	bl	8040ca8 <__aeabi_uldivmod>
 8052cb8:	9b05      	ldr	r3, [sp, #20]
 8052cba:	3230      	adds	r2, #48	; 0x30
 8052cbc:	3301      	adds	r3, #1
 8052cbe:	f105 3bff 	add.w	fp, r5, #4294967295
 8052cc2:	f805 2c01 	strb.w	r2, [r5, #-1]
 8052cc6:	9305      	str	r3, [sp, #20]
 8052cc8:	f1b8 0f00 	cmp.w	r8, #0
 8052ccc:	d019      	beq.n	8052d02 <_svfprintf_r+0xbf2>
 8052cce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052cd0:	9a05      	ldr	r2, [sp, #20]
 8052cd2:	781b      	ldrb	r3, [r3, #0]
 8052cd4:	429a      	cmp	r2, r3
 8052cd6:	d114      	bne.n	8052d02 <_svfprintf_r+0xbf2>
 8052cd8:	2aff      	cmp	r2, #255	; 0xff
 8052cda:	d012      	beq.n	8052d02 <_svfprintf_r+0xbf2>
 8052cdc:	2f00      	cmp	r7, #0
 8052cde:	bf08      	it	eq
 8052ce0:	2e0a      	cmpeq	r6, #10
 8052ce2:	d30e      	bcc.n	8052d02 <_svfprintf_r+0xbf2>
 8052ce4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8052ce6:	9914      	ldr	r1, [sp, #80]	; 0x50
 8052ce8:	ebab 0b03 	sub.w	fp, fp, r3
 8052cec:	461a      	mov	r2, r3
 8052cee:	4658      	mov	r0, fp
 8052cf0:	f7fe faf4 	bl	80512dc <strncpy>
 8052cf4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8052cf6:	785d      	ldrb	r5, [r3, #1]
 8052cf8:	b195      	cbz	r5, 8052d20 <_svfprintf_r+0xc10>
 8052cfa:	3301      	adds	r3, #1
 8052cfc:	930a      	str	r3, [sp, #40]	; 0x28
 8052cfe:	2300      	movs	r3, #0
 8052d00:	9305      	str	r3, [sp, #20]
 8052d02:	220a      	movs	r2, #10
 8052d04:	2300      	movs	r3, #0
 8052d06:	4630      	mov	r0, r6
 8052d08:	4639      	mov	r1, r7
 8052d0a:	f7ed ffcd 	bl	8040ca8 <__aeabi_uldivmod>
 8052d0e:	2f00      	cmp	r7, #0
 8052d10:	bf08      	it	eq
 8052d12:	2e0a      	cmpeq	r6, #10
 8052d14:	f0c0 83ca 	bcc.w	80534ac <_svfprintf_r+0x139c>
 8052d18:	4606      	mov	r6, r0
 8052d1a:	460f      	mov	r7, r1
 8052d1c:	465d      	mov	r5, fp
 8052d1e:	e7c5      	b.n	8052cac <_svfprintf_r+0xb9c>
 8052d20:	9505      	str	r5, [sp, #20]
 8052d22:	e7ee      	b.n	8052d02 <_svfprintf_r+0xbf2>
 8052d24:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8052d26:	f006 030f 	and.w	r3, r6, #15
 8052d2a:	5cd3      	ldrb	r3, [r2, r3]
 8052d2c:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 8052d30:	0933      	lsrs	r3, r6, #4
 8052d32:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8052d36:	093a      	lsrs	r2, r7, #4
 8052d38:	461e      	mov	r6, r3
 8052d3a:	4617      	mov	r7, r2
 8052d3c:	ea56 0307 	orrs.w	r3, r6, r7
 8052d40:	d1f0      	bne.n	8052d24 <_svfprintf_r+0xc14>
 8052d42:	e3b3      	b.n	80534ac <_svfprintf_r+0x139c>
 8052d44:	b933      	cbnz	r3, 8052d54 <_svfprintf_r+0xc44>
 8052d46:	f018 0f01 	tst.w	r8, #1
 8052d4a:	d003      	beq.n	8052d54 <_svfprintf_r+0xc44>
 8052d4c:	2330      	movs	r3, #48	; 0x30
 8052d4e:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 8052d52:	e7a1      	b.n	8052c98 <_svfprintf_r+0xb88>
 8052d54:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
 8052d58:	e3a8      	b.n	80534ac <_svfprintf_r+0x139c>
 8052d5a:	9b07      	ldr	r3, [sp, #28]
 8052d5c:	2b00      	cmp	r3, #0
 8052d5e:	f000 8373 	beq.w	8053448 <_svfprintf_r+0x1338>
 8052d62:	2000      	movs	r0, #0
 8052d64:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8052d68:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 8052d6c:	9606      	str	r6, [sp, #24]
 8052d6e:	f7ff bb34 	b.w	80523da <_svfprintf_r+0x2ca>
 8052d72:	9e03      	ldr	r6, [sp, #12]
 8052d74:	f7ff bb9e 	b.w	80524b4 <_svfprintf_r+0x3a4>
 8052d78:	2010      	movs	r0, #16
 8052d7a:	4402      	add	r2, r0
 8052d7c:	2b07      	cmp	r3, #7
 8052d7e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8052d82:	6060      	str	r0, [r4, #4]
 8052d84:	dd08      	ble.n	8052d98 <_svfprintf_r+0xc88>
 8052d86:	aa22      	add	r2, sp, #136	; 0x88
 8052d88:	4649      	mov	r1, r9
 8052d8a:	4650      	mov	r0, sl
 8052d8c:	f004 f88b 	bl	8056ea6 <__ssprint_r>
 8052d90:	2800      	cmp	r0, #0
 8052d92:	f040 8337 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052d96:	a925      	add	r1, sp, #148	; 0x94
 8052d98:	3f10      	subs	r7, #16
 8052d9a:	460c      	mov	r4, r1
 8052d9c:	e4fb      	b.n	8052796 <_svfprintf_r+0x686>
 8052d9e:	460c      	mov	r4, r1
 8052da0:	e514      	b.n	80527cc <_svfprintf_r+0x6bc>
 8052da2:	aa22      	add	r2, sp, #136	; 0x88
 8052da4:	4649      	mov	r1, r9
 8052da6:	4650      	mov	r0, sl
 8052da8:	f004 f87d 	bl	8056ea6 <__ssprint_r>
 8052dac:	2800      	cmp	r0, #0
 8052dae:	f040 8329 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052db2:	ac25      	add	r4, sp, #148	; 0x94
 8052db4:	e51c      	b.n	80527f0 <_svfprintf_r+0x6e0>
 8052db6:	aa22      	add	r2, sp, #136	; 0x88
 8052db8:	4649      	mov	r1, r9
 8052dba:	4650      	mov	r0, sl
 8052dbc:	f004 f873 	bl	8056ea6 <__ssprint_r>
 8052dc0:	2800      	cmp	r0, #0
 8052dc2:	f040 831f 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052dc6:	ac25      	add	r4, sp, #148	; 0x94
 8052dc8:	e522      	b.n	8052810 <_svfprintf_r+0x700>
 8052dca:	2010      	movs	r0, #16
 8052dcc:	4402      	add	r2, r0
 8052dce:	2b07      	cmp	r3, #7
 8052dd0:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8052dd4:	6060      	str	r0, [r4, #4]
 8052dd6:	dd08      	ble.n	8052dea <_svfprintf_r+0xcda>
 8052dd8:	aa22      	add	r2, sp, #136	; 0x88
 8052dda:	4649      	mov	r1, r9
 8052ddc:	4650      	mov	r0, sl
 8052dde:	f004 f862 	bl	8056ea6 <__ssprint_r>
 8052de2:	2800      	cmp	r0, #0
 8052de4:	f040 830e 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052de8:	a925      	add	r1, sp, #148	; 0x94
 8052dea:	3f10      	subs	r7, #16
 8052dec:	460c      	mov	r4, r1
 8052dee:	e517      	b.n	8052820 <_svfprintf_r+0x710>
 8052df0:	460c      	mov	r4, r1
 8052df2:	e530      	b.n	8052856 <_svfprintf_r+0x746>
 8052df4:	2010      	movs	r0, #16
 8052df6:	4402      	add	r2, r0
 8052df8:	2b07      	cmp	r3, #7
 8052dfa:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8052dfe:	6060      	str	r0, [r4, #4]
 8052e00:	dd08      	ble.n	8052e14 <_svfprintf_r+0xd04>
 8052e02:	aa22      	add	r2, sp, #136	; 0x88
 8052e04:	4649      	mov	r1, r9
 8052e06:	4650      	mov	r0, sl
 8052e08:	f004 f84d 	bl	8056ea6 <__ssprint_r>
 8052e0c:	2800      	cmp	r0, #0
 8052e0e:	f040 82f9 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052e12:	a925      	add	r1, sp, #148	; 0x94
 8052e14:	3e10      	subs	r6, #16
 8052e16:	460c      	mov	r4, r1
 8052e18:	e522      	b.n	8052860 <_svfprintf_r+0x750>
 8052e1a:	460c      	mov	r4, r1
 8052e1c:	e548      	b.n	80528b0 <_svfprintf_r+0x7a0>
 8052e1e:	bf00      	nop
 8052e20:	0805a360 	.word	0x0805a360
 8052e24:	0805a371 	.word	0x0805a371
 8052e28:	9b07      	ldr	r3, [sp, #28]
 8052e2a:	2b65      	cmp	r3, #101	; 0x65
 8052e2c:	f340 8232 	ble.w	8053294 <_svfprintf_r+0x1184>
 8052e30:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8052e34:	2200      	movs	r2, #0
 8052e36:	2300      	movs	r3, #0
 8052e38:	f7ed fe56 	bl	8040ae8 <__aeabi_dcmpeq>
 8052e3c:	2800      	cmp	r0, #0
 8052e3e:	d068      	beq.n	8052f12 <_svfprintf_r+0xe02>
 8052e40:	4b6d      	ldr	r3, [pc, #436]	; (8052ff8 <_svfprintf_r+0xee8>)
 8052e42:	6023      	str	r3, [r4, #0]
 8052e44:	2301      	movs	r3, #1
 8052e46:	441e      	add	r6, r3
 8052e48:	6063      	str	r3, [r4, #4]
 8052e4a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052e4c:	9624      	str	r6, [sp, #144]	; 0x90
 8052e4e:	3301      	adds	r3, #1
 8052e50:	2b07      	cmp	r3, #7
 8052e52:	9323      	str	r3, [sp, #140]	; 0x8c
 8052e54:	dc37      	bgt.n	8052ec6 <_svfprintf_r+0xdb6>
 8052e56:	3408      	adds	r4, #8
 8052e58:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8052e5a:	9a05      	ldr	r2, [sp, #20]
 8052e5c:	4293      	cmp	r3, r2
 8052e5e:	db03      	blt.n	8052e68 <_svfprintf_r+0xd58>
 8052e60:	f018 0f01 	tst.w	r8, #1
 8052e64:	f43f ad36 	beq.w	80528d4 <_svfprintf_r+0x7c4>
 8052e68:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8052e6a:	6023      	str	r3, [r4, #0]
 8052e6c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8052e6e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8052e70:	6063      	str	r3, [r4, #4]
 8052e72:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8052e74:	4413      	add	r3, r2
 8052e76:	9324      	str	r3, [sp, #144]	; 0x90
 8052e78:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052e7a:	3301      	adds	r3, #1
 8052e7c:	2b07      	cmp	r3, #7
 8052e7e:	9323      	str	r3, [sp, #140]	; 0x8c
 8052e80:	dc2b      	bgt.n	8052eda <_svfprintf_r+0xdca>
 8052e82:	3408      	adds	r4, #8
 8052e84:	9b05      	ldr	r3, [sp, #20]
 8052e86:	1e5d      	subs	r5, r3, #1
 8052e88:	2d00      	cmp	r5, #0
 8052e8a:	f77f ad23 	ble.w	80528d4 <_svfprintf_r+0x7c4>
 8052e8e:	4e5b      	ldr	r6, [pc, #364]	; (8052ffc <_svfprintf_r+0xeec>)
 8052e90:	2710      	movs	r7, #16
 8052e92:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8052e96:	2d10      	cmp	r5, #16
 8052e98:	f103 0301 	add.w	r3, r3, #1
 8052e9c:	f104 0108 	add.w	r1, r4, #8
 8052ea0:	6026      	str	r6, [r4, #0]
 8052ea2:	dc24      	bgt.n	8052eee <_svfprintf_r+0xdde>
 8052ea4:	6065      	str	r5, [r4, #4]
 8052ea6:	2b07      	cmp	r3, #7
 8052ea8:	4415      	add	r5, r2
 8052eaa:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8052eae:	f340 8288 	ble.w	80533c2 <_svfprintf_r+0x12b2>
 8052eb2:	aa22      	add	r2, sp, #136	; 0x88
 8052eb4:	4649      	mov	r1, r9
 8052eb6:	4650      	mov	r0, sl
 8052eb8:	f003 fff5 	bl	8056ea6 <__ssprint_r>
 8052ebc:	2800      	cmp	r0, #0
 8052ebe:	f040 82a1 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052ec2:	ac25      	add	r4, sp, #148	; 0x94
 8052ec4:	e506      	b.n	80528d4 <_svfprintf_r+0x7c4>
 8052ec6:	aa22      	add	r2, sp, #136	; 0x88
 8052ec8:	4649      	mov	r1, r9
 8052eca:	4650      	mov	r0, sl
 8052ecc:	f003 ffeb 	bl	8056ea6 <__ssprint_r>
 8052ed0:	2800      	cmp	r0, #0
 8052ed2:	f040 8297 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052ed6:	ac25      	add	r4, sp, #148	; 0x94
 8052ed8:	e7be      	b.n	8052e58 <_svfprintf_r+0xd48>
 8052eda:	aa22      	add	r2, sp, #136	; 0x88
 8052edc:	4649      	mov	r1, r9
 8052ede:	4650      	mov	r0, sl
 8052ee0:	f003 ffe1 	bl	8056ea6 <__ssprint_r>
 8052ee4:	2800      	cmp	r0, #0
 8052ee6:	f040 828d 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052eea:	ac25      	add	r4, sp, #148	; 0x94
 8052eec:	e7ca      	b.n	8052e84 <_svfprintf_r+0xd74>
 8052eee:	3210      	adds	r2, #16
 8052ef0:	2b07      	cmp	r3, #7
 8052ef2:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8052ef6:	6067      	str	r7, [r4, #4]
 8052ef8:	dd08      	ble.n	8052f0c <_svfprintf_r+0xdfc>
 8052efa:	aa22      	add	r2, sp, #136	; 0x88
 8052efc:	4649      	mov	r1, r9
 8052efe:	4650      	mov	r0, sl
 8052f00:	f003 ffd1 	bl	8056ea6 <__ssprint_r>
 8052f04:	2800      	cmp	r0, #0
 8052f06:	f040 827d 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052f0a:	a925      	add	r1, sp, #148	; 0x94
 8052f0c:	3d10      	subs	r5, #16
 8052f0e:	460c      	mov	r4, r1
 8052f10:	e7bf      	b.n	8052e92 <_svfprintf_r+0xd82>
 8052f12:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8052f14:	2b00      	cmp	r3, #0
 8052f16:	dc73      	bgt.n	8053000 <_svfprintf_r+0xef0>
 8052f18:	4b37      	ldr	r3, [pc, #220]	; (8052ff8 <_svfprintf_r+0xee8>)
 8052f1a:	6023      	str	r3, [r4, #0]
 8052f1c:	2301      	movs	r3, #1
 8052f1e:	441e      	add	r6, r3
 8052f20:	6063      	str	r3, [r4, #4]
 8052f22:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052f24:	9624      	str	r6, [sp, #144]	; 0x90
 8052f26:	3301      	adds	r3, #1
 8052f28:	2b07      	cmp	r3, #7
 8052f2a:	9323      	str	r3, [sp, #140]	; 0x8c
 8052f2c:	dc3d      	bgt.n	8052faa <_svfprintf_r+0xe9a>
 8052f2e:	3408      	adds	r4, #8
 8052f30:	9905      	ldr	r1, [sp, #20]
 8052f32:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8052f34:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8052f36:	430a      	orrs	r2, r1
 8052f38:	f008 0101 	and.w	r1, r8, #1
 8052f3c:	430a      	orrs	r2, r1
 8052f3e:	f43f acc9 	beq.w	80528d4 <_svfprintf_r+0x7c4>
 8052f42:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8052f44:	6022      	str	r2, [r4, #0]
 8052f46:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8052f48:	6062      	str	r2, [r4, #4]
 8052f4a:	4413      	add	r3, r2
 8052f4c:	9324      	str	r3, [sp, #144]	; 0x90
 8052f4e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8052f50:	3301      	adds	r3, #1
 8052f52:	2b07      	cmp	r3, #7
 8052f54:	9323      	str	r3, [sp, #140]	; 0x8c
 8052f56:	dc32      	bgt.n	8052fbe <_svfprintf_r+0xeae>
 8052f58:	3408      	adds	r4, #8
 8052f5a:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8052f5c:	2d00      	cmp	r5, #0
 8052f5e:	da1b      	bge.n	8052f98 <_svfprintf_r+0xe88>
 8052f60:	4e26      	ldr	r6, [pc, #152]	; (8052ffc <_svfprintf_r+0xeec>)
 8052f62:	426d      	negs	r5, r5
 8052f64:	4623      	mov	r3, r4
 8052f66:	2710      	movs	r7, #16
 8052f68:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 8052f6c:	2d10      	cmp	r5, #16
 8052f6e:	f102 0201 	add.w	r2, r2, #1
 8052f72:	f104 0408 	add.w	r4, r4, #8
 8052f76:	601e      	str	r6, [r3, #0]
 8052f78:	dc2b      	bgt.n	8052fd2 <_svfprintf_r+0xec2>
 8052f7a:	605d      	str	r5, [r3, #4]
 8052f7c:	2a07      	cmp	r2, #7
 8052f7e:	440d      	add	r5, r1
 8052f80:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 8052f84:	dd08      	ble.n	8052f98 <_svfprintf_r+0xe88>
 8052f86:	aa22      	add	r2, sp, #136	; 0x88
 8052f88:	4649      	mov	r1, r9
 8052f8a:	4650      	mov	r0, sl
 8052f8c:	f003 ff8b 	bl	8056ea6 <__ssprint_r>
 8052f90:	2800      	cmp	r0, #0
 8052f92:	f040 8237 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052f96:	ac25      	add	r4, sp, #148	; 0x94
 8052f98:	9b05      	ldr	r3, [sp, #20]
 8052f9a:	9a05      	ldr	r2, [sp, #20]
 8052f9c:	6063      	str	r3, [r4, #4]
 8052f9e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8052fa0:	f8c4 b000 	str.w	fp, [r4]
 8052fa4:	4413      	add	r3, r2
 8052fa6:	9324      	str	r3, [sp, #144]	; 0x90
 8052fa8:	e48d      	b.n	80528c6 <_svfprintf_r+0x7b6>
 8052faa:	aa22      	add	r2, sp, #136	; 0x88
 8052fac:	4649      	mov	r1, r9
 8052fae:	4650      	mov	r0, sl
 8052fb0:	f003 ff79 	bl	8056ea6 <__ssprint_r>
 8052fb4:	2800      	cmp	r0, #0
 8052fb6:	f040 8225 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052fba:	ac25      	add	r4, sp, #148	; 0x94
 8052fbc:	e7b8      	b.n	8052f30 <_svfprintf_r+0xe20>
 8052fbe:	aa22      	add	r2, sp, #136	; 0x88
 8052fc0:	4649      	mov	r1, r9
 8052fc2:	4650      	mov	r0, sl
 8052fc4:	f003 ff6f 	bl	8056ea6 <__ssprint_r>
 8052fc8:	2800      	cmp	r0, #0
 8052fca:	f040 821b 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052fce:	ac25      	add	r4, sp, #148	; 0x94
 8052fd0:	e7c3      	b.n	8052f5a <_svfprintf_r+0xe4a>
 8052fd2:	3110      	adds	r1, #16
 8052fd4:	2a07      	cmp	r2, #7
 8052fd6:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 8052fda:	605f      	str	r7, [r3, #4]
 8052fdc:	dd08      	ble.n	8052ff0 <_svfprintf_r+0xee0>
 8052fde:	aa22      	add	r2, sp, #136	; 0x88
 8052fe0:	4649      	mov	r1, r9
 8052fe2:	4650      	mov	r0, sl
 8052fe4:	f003 ff5f 	bl	8056ea6 <__ssprint_r>
 8052fe8:	2800      	cmp	r0, #0
 8052fea:	f040 820b 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8052fee:	ac25      	add	r4, sp, #148	; 0x94
 8052ff0:	3d10      	subs	r5, #16
 8052ff2:	4623      	mov	r3, r4
 8052ff4:	e7b8      	b.n	8052f68 <_svfprintf_r+0xe58>
 8052ff6:	bf00      	nop
 8052ff8:	0805a382 	.word	0x0805a382
 8052ffc:	0805a394 	.word	0x0805a394
 8053000:	9b05      	ldr	r3, [sp, #20]
 8053002:	42ab      	cmp	r3, r5
 8053004:	bfa8      	it	ge
 8053006:	462b      	movge	r3, r5
 8053008:	2b00      	cmp	r3, #0
 805300a:	461f      	mov	r7, r3
 805300c:	dd0a      	ble.n	8053024 <_svfprintf_r+0xf14>
 805300e:	441e      	add	r6, r3
 8053010:	e9c4 b300 	strd	fp, r3, [r4]
 8053014:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053016:	9624      	str	r6, [sp, #144]	; 0x90
 8053018:	3301      	adds	r3, #1
 805301a:	2b07      	cmp	r3, #7
 805301c:	9323      	str	r3, [sp, #140]	; 0x8c
 805301e:	f300 8086 	bgt.w	805312e <_svfprintf_r+0x101e>
 8053022:	3408      	adds	r4, #8
 8053024:	2f00      	cmp	r7, #0
 8053026:	bfac      	ite	ge
 8053028:	1bee      	subge	r6, r5, r7
 805302a:	462e      	movlt	r6, r5
 805302c:	2e00      	cmp	r6, #0
 805302e:	dd19      	ble.n	8053064 <_svfprintf_r+0xf54>
 8053030:	4f97      	ldr	r7, [pc, #604]	; (8053290 <_svfprintf_r+0x1180>)
 8053032:	6027      	str	r7, [r4, #0]
 8053034:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053038:	2e10      	cmp	r6, #16
 805303a:	f103 0301 	add.w	r3, r3, #1
 805303e:	f104 0108 	add.w	r1, r4, #8
 8053042:	dc7e      	bgt.n	8053142 <_svfprintf_r+0x1032>
 8053044:	6066      	str	r6, [r4, #4]
 8053046:	2b07      	cmp	r3, #7
 8053048:	4416      	add	r6, r2
 805304a:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 805304e:	f340 808b 	ble.w	8053168 <_svfprintf_r+0x1058>
 8053052:	aa22      	add	r2, sp, #136	; 0x88
 8053054:	4649      	mov	r1, r9
 8053056:	4650      	mov	r0, sl
 8053058:	f003 ff25 	bl	8056ea6 <__ssprint_r>
 805305c:	2800      	cmp	r0, #0
 805305e:	f040 81d1 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8053062:	ac25      	add	r4, sp, #148	; 0x94
 8053064:	f418 6f80 	tst.w	r8, #1024	; 0x400
 8053068:	445d      	add	r5, fp
 805306a:	d00b      	beq.n	8053084 <_svfprintf_r+0xf74>
 805306c:	4e88      	ldr	r6, [pc, #544]	; (8053290 <_svfprintf_r+0x1180>)
 805306e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053070:	2b00      	cmp	r3, #0
 8053072:	d17b      	bne.n	805316c <_svfprintf_r+0x105c>
 8053074:	9b08      	ldr	r3, [sp, #32]
 8053076:	2b00      	cmp	r3, #0
 8053078:	d17b      	bne.n	8053172 <_svfprintf_r+0x1062>
 805307a:	9b05      	ldr	r3, [sp, #20]
 805307c:	445b      	add	r3, fp
 805307e:	429d      	cmp	r5, r3
 8053080:	bf28      	it	cs
 8053082:	461d      	movcs	r5, r3
 8053084:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8053086:	9a05      	ldr	r2, [sp, #20]
 8053088:	4293      	cmp	r3, r2
 805308a:	db02      	blt.n	8053092 <_svfprintf_r+0xf82>
 805308c:	f018 0f01 	tst.w	r8, #1
 8053090:	d00e      	beq.n	80530b0 <_svfprintf_r+0xfa0>
 8053092:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8053094:	6023      	str	r3, [r4, #0]
 8053096:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053098:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 805309a:	6063      	str	r3, [r4, #4]
 805309c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805309e:	4413      	add	r3, r2
 80530a0:	9324      	str	r3, [sp, #144]	; 0x90
 80530a2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80530a4:	3301      	adds	r3, #1
 80530a6:	2b07      	cmp	r3, #7
 80530a8:	9323      	str	r3, [sp, #140]	; 0x8c
 80530aa:	f300 80dd 	bgt.w	8053268 <_svfprintf_r+0x1158>
 80530ae:	3408      	adds	r4, #8
 80530b0:	9b05      	ldr	r3, [sp, #20]
 80530b2:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 80530b4:	eb0b 0203 	add.w	r2, fp, r3
 80530b8:	1b9e      	subs	r6, r3, r6
 80530ba:	1b52      	subs	r2, r2, r5
 80530bc:	4296      	cmp	r6, r2
 80530be:	bfa8      	it	ge
 80530c0:	4616      	movge	r6, r2
 80530c2:	2e00      	cmp	r6, #0
 80530c4:	dd0b      	ble.n	80530de <_svfprintf_r+0xfce>
 80530c6:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80530c8:	4433      	add	r3, r6
 80530ca:	9324      	str	r3, [sp, #144]	; 0x90
 80530cc:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80530ce:	3301      	adds	r3, #1
 80530d0:	2b07      	cmp	r3, #7
 80530d2:	e9c4 5600 	strd	r5, r6, [r4]
 80530d6:	9323      	str	r3, [sp, #140]	; 0x8c
 80530d8:	f300 80d0 	bgt.w	805327c <_svfprintf_r+0x116c>
 80530dc:	3408      	adds	r4, #8
 80530de:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80530e0:	9b05      	ldr	r3, [sp, #20]
 80530e2:	2e00      	cmp	r6, #0
 80530e4:	eba3 0505 	sub.w	r5, r3, r5
 80530e8:	bfa8      	it	ge
 80530ea:	1bad      	subge	r5, r5, r6
 80530ec:	2d00      	cmp	r5, #0
 80530ee:	f77f abf1 	ble.w	80528d4 <_svfprintf_r+0x7c4>
 80530f2:	4e67      	ldr	r6, [pc, #412]	; (8053290 <_svfprintf_r+0x1180>)
 80530f4:	2710      	movs	r7, #16
 80530f6:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80530fa:	2d10      	cmp	r5, #16
 80530fc:	f103 0301 	add.w	r3, r3, #1
 8053100:	f104 0108 	add.w	r1, r4, #8
 8053104:	6026      	str	r6, [r4, #0]
 8053106:	f77f aecd 	ble.w	8052ea4 <_svfprintf_r+0xd94>
 805310a:	3210      	adds	r2, #16
 805310c:	2b07      	cmp	r3, #7
 805310e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053112:	6067      	str	r7, [r4, #4]
 8053114:	dd08      	ble.n	8053128 <_svfprintf_r+0x1018>
 8053116:	aa22      	add	r2, sp, #136	; 0x88
 8053118:	4649      	mov	r1, r9
 805311a:	4650      	mov	r0, sl
 805311c:	f003 fec3 	bl	8056ea6 <__ssprint_r>
 8053120:	2800      	cmp	r0, #0
 8053122:	f040 816f 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8053126:	a925      	add	r1, sp, #148	; 0x94
 8053128:	3d10      	subs	r5, #16
 805312a:	460c      	mov	r4, r1
 805312c:	e7e3      	b.n	80530f6 <_svfprintf_r+0xfe6>
 805312e:	aa22      	add	r2, sp, #136	; 0x88
 8053130:	4649      	mov	r1, r9
 8053132:	4650      	mov	r0, sl
 8053134:	f003 feb7 	bl	8056ea6 <__ssprint_r>
 8053138:	2800      	cmp	r0, #0
 805313a:	f040 8163 	bne.w	8053404 <_svfprintf_r+0x12f4>
 805313e:	ac25      	add	r4, sp, #148	; 0x94
 8053140:	e770      	b.n	8053024 <_svfprintf_r+0xf14>
 8053142:	2010      	movs	r0, #16
 8053144:	4402      	add	r2, r0
 8053146:	2b07      	cmp	r3, #7
 8053148:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 805314c:	6060      	str	r0, [r4, #4]
 805314e:	dd08      	ble.n	8053162 <_svfprintf_r+0x1052>
 8053150:	aa22      	add	r2, sp, #136	; 0x88
 8053152:	4649      	mov	r1, r9
 8053154:	4650      	mov	r0, sl
 8053156:	f003 fea6 	bl	8056ea6 <__ssprint_r>
 805315a:	2800      	cmp	r0, #0
 805315c:	f040 8152 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8053160:	a925      	add	r1, sp, #148	; 0x94
 8053162:	3e10      	subs	r6, #16
 8053164:	460c      	mov	r4, r1
 8053166:	e764      	b.n	8053032 <_svfprintf_r+0xf22>
 8053168:	460c      	mov	r4, r1
 805316a:	e77b      	b.n	8053064 <_svfprintf_r+0xf54>
 805316c:	9b08      	ldr	r3, [sp, #32]
 805316e:	2b00      	cmp	r3, #0
 8053170:	d04a      	beq.n	8053208 <_svfprintf_r+0x10f8>
 8053172:	9b08      	ldr	r3, [sp, #32]
 8053174:	3b01      	subs	r3, #1
 8053176:	9308      	str	r3, [sp, #32]
 8053178:	9b14      	ldr	r3, [sp, #80]	; 0x50
 805317a:	6023      	str	r3, [r4, #0]
 805317c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 805317e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8053180:	6063      	str	r3, [r4, #4]
 8053182:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053184:	4413      	add	r3, r2
 8053186:	9324      	str	r3, [sp, #144]	; 0x90
 8053188:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805318a:	3301      	adds	r3, #1
 805318c:	2b07      	cmp	r3, #7
 805318e:	9323      	str	r3, [sp, #140]	; 0x8c
 8053190:	dc41      	bgt.n	8053216 <_svfprintf_r+0x1106>
 8053192:	3408      	adds	r4, #8
 8053194:	9b05      	ldr	r3, [sp, #20]
 8053196:	445b      	add	r3, fp
 8053198:	1b5a      	subs	r2, r3, r5
 805319a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 805319c:	781b      	ldrb	r3, [r3, #0]
 805319e:	4293      	cmp	r3, r2
 80531a0:	bfa8      	it	ge
 80531a2:	4613      	movge	r3, r2
 80531a4:	2b00      	cmp	r3, #0
 80531a6:	461f      	mov	r7, r3
 80531a8:	dd0a      	ble.n	80531c0 <_svfprintf_r+0x10b0>
 80531aa:	e9c4 5300 	strd	r5, r3, [r4]
 80531ae:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80531b0:	443b      	add	r3, r7
 80531b2:	9324      	str	r3, [sp, #144]	; 0x90
 80531b4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80531b6:	3301      	adds	r3, #1
 80531b8:	2b07      	cmp	r3, #7
 80531ba:	9323      	str	r3, [sp, #140]	; 0x8c
 80531bc:	dc35      	bgt.n	805322a <_svfprintf_r+0x111a>
 80531be:	3408      	adds	r4, #8
 80531c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80531c2:	781b      	ldrb	r3, [r3, #0]
 80531c4:	2f00      	cmp	r7, #0
 80531c6:	bfac      	ite	ge
 80531c8:	1bdf      	subge	r7, r3, r7
 80531ca:	461f      	movlt	r7, r3
 80531cc:	2f00      	cmp	r7, #0
 80531ce:	dd17      	ble.n	8053200 <_svfprintf_r+0x10f0>
 80531d0:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 80531d4:	2f10      	cmp	r7, #16
 80531d6:	f102 0201 	add.w	r2, r2, #1
 80531da:	f104 0108 	add.w	r1, r4, #8
 80531de:	6026      	str	r6, [r4, #0]
 80531e0:	dc2d      	bgt.n	805323e <_svfprintf_r+0x112e>
 80531e2:	443b      	add	r3, r7
 80531e4:	2a07      	cmp	r2, #7
 80531e6:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 80531ea:	6067      	str	r7, [r4, #4]
 80531ec:	dd3a      	ble.n	8053264 <_svfprintf_r+0x1154>
 80531ee:	aa22      	add	r2, sp, #136	; 0x88
 80531f0:	4649      	mov	r1, r9
 80531f2:	4650      	mov	r0, sl
 80531f4:	f003 fe57 	bl	8056ea6 <__ssprint_r>
 80531f8:	2800      	cmp	r0, #0
 80531fa:	f040 8103 	bne.w	8053404 <_svfprintf_r+0x12f4>
 80531fe:	ac25      	add	r4, sp, #148	; 0x94
 8053200:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053202:	781b      	ldrb	r3, [r3, #0]
 8053204:	441d      	add	r5, r3
 8053206:	e732      	b.n	805306e <_svfprintf_r+0xf5e>
 8053208:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 805320a:	3b01      	subs	r3, #1
 805320c:	930a      	str	r3, [sp, #40]	; 0x28
 805320e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053210:	3b01      	subs	r3, #1
 8053212:	9309      	str	r3, [sp, #36]	; 0x24
 8053214:	e7b0      	b.n	8053178 <_svfprintf_r+0x1068>
 8053216:	aa22      	add	r2, sp, #136	; 0x88
 8053218:	4649      	mov	r1, r9
 805321a:	4650      	mov	r0, sl
 805321c:	f003 fe43 	bl	8056ea6 <__ssprint_r>
 8053220:	2800      	cmp	r0, #0
 8053222:	f040 80ef 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8053226:	ac25      	add	r4, sp, #148	; 0x94
 8053228:	e7b4      	b.n	8053194 <_svfprintf_r+0x1084>
 805322a:	aa22      	add	r2, sp, #136	; 0x88
 805322c:	4649      	mov	r1, r9
 805322e:	4650      	mov	r0, sl
 8053230:	f003 fe39 	bl	8056ea6 <__ssprint_r>
 8053234:	2800      	cmp	r0, #0
 8053236:	f040 80e5 	bne.w	8053404 <_svfprintf_r+0x12f4>
 805323a:	ac25      	add	r4, sp, #148	; 0x94
 805323c:	e7c0      	b.n	80531c0 <_svfprintf_r+0x10b0>
 805323e:	2010      	movs	r0, #16
 8053240:	4403      	add	r3, r0
 8053242:	2a07      	cmp	r2, #7
 8053244:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8053248:	6060      	str	r0, [r4, #4]
 805324a:	dd08      	ble.n	805325e <_svfprintf_r+0x114e>
 805324c:	aa22      	add	r2, sp, #136	; 0x88
 805324e:	4649      	mov	r1, r9
 8053250:	4650      	mov	r0, sl
 8053252:	f003 fe28 	bl	8056ea6 <__ssprint_r>
 8053256:	2800      	cmp	r0, #0
 8053258:	f040 80d4 	bne.w	8053404 <_svfprintf_r+0x12f4>
 805325c:	a925      	add	r1, sp, #148	; 0x94
 805325e:	3f10      	subs	r7, #16
 8053260:	460c      	mov	r4, r1
 8053262:	e7b5      	b.n	80531d0 <_svfprintf_r+0x10c0>
 8053264:	460c      	mov	r4, r1
 8053266:	e7cb      	b.n	8053200 <_svfprintf_r+0x10f0>
 8053268:	aa22      	add	r2, sp, #136	; 0x88
 805326a:	4649      	mov	r1, r9
 805326c:	4650      	mov	r0, sl
 805326e:	f003 fe1a 	bl	8056ea6 <__ssprint_r>
 8053272:	2800      	cmp	r0, #0
 8053274:	f040 80c6 	bne.w	8053404 <_svfprintf_r+0x12f4>
 8053278:	ac25      	add	r4, sp, #148	; 0x94
 805327a:	e719      	b.n	80530b0 <_svfprintf_r+0xfa0>
 805327c:	aa22      	add	r2, sp, #136	; 0x88
 805327e:	4649      	mov	r1, r9
 8053280:	4650      	mov	r0, sl
 8053282:	f003 fe10 	bl	8056ea6 <__ssprint_r>
 8053286:	2800      	cmp	r0, #0
 8053288:	f040 80bc 	bne.w	8053404 <_svfprintf_r+0x12f4>
 805328c:	ac25      	add	r4, sp, #148	; 0x94
 805328e:	e726      	b.n	80530de <_svfprintf_r+0xfce>
 8053290:	0805a394 	.word	0x0805a394
 8053294:	9a05      	ldr	r2, [sp, #20]
 8053296:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053298:	2a01      	cmp	r2, #1
 805329a:	f106 0601 	add.w	r6, r6, #1
 805329e:	f103 0301 	add.w	r3, r3, #1
 80532a2:	f104 0508 	add.w	r5, r4, #8
 80532a6:	dc02      	bgt.n	80532ae <_svfprintf_r+0x119e>
 80532a8:	f018 0f01 	tst.w	r8, #1
 80532ac:	d07e      	beq.n	80533ac <_svfprintf_r+0x129c>
 80532ae:	2201      	movs	r2, #1
 80532b0:	2b07      	cmp	r3, #7
 80532b2:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80532b6:	f8c4 b000 	str.w	fp, [r4]
 80532ba:	6062      	str	r2, [r4, #4]
 80532bc:	dd08      	ble.n	80532d0 <_svfprintf_r+0x11c0>
 80532be:	aa22      	add	r2, sp, #136	; 0x88
 80532c0:	4649      	mov	r1, r9
 80532c2:	4650      	mov	r0, sl
 80532c4:	f003 fdef 	bl	8056ea6 <__ssprint_r>
 80532c8:	2800      	cmp	r0, #0
 80532ca:	f040 809b 	bne.w	8053404 <_svfprintf_r+0x12f4>
 80532ce:	ad25      	add	r5, sp, #148	; 0x94
 80532d0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80532d2:	602b      	str	r3, [r5, #0]
 80532d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80532d6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80532d8:	606b      	str	r3, [r5, #4]
 80532da:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80532dc:	4413      	add	r3, r2
 80532de:	9324      	str	r3, [sp, #144]	; 0x90
 80532e0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80532e2:	3301      	adds	r3, #1
 80532e4:	2b07      	cmp	r3, #7
 80532e6:	9323      	str	r3, [sp, #140]	; 0x8c
 80532e8:	dc32      	bgt.n	8053350 <_svfprintf_r+0x1240>
 80532ea:	3508      	adds	r5, #8
 80532ec:	9b05      	ldr	r3, [sp, #20]
 80532ee:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80532f2:	1e5c      	subs	r4, r3, #1
 80532f4:	2200      	movs	r2, #0
 80532f6:	2300      	movs	r3, #0
 80532f8:	f7ed fbf6 	bl	8040ae8 <__aeabi_dcmpeq>
 80532fc:	2800      	cmp	r0, #0
 80532fe:	d130      	bne.n	8053362 <_svfprintf_r+0x1252>
 8053300:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8053302:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053304:	9a05      	ldr	r2, [sp, #20]
 8053306:	3101      	adds	r1, #1
 8053308:	3b01      	subs	r3, #1
 805330a:	f10b 0001 	add.w	r0, fp, #1
 805330e:	4413      	add	r3, r2
 8053310:	2907      	cmp	r1, #7
 8053312:	e9c5 0400 	strd	r0, r4, [r5]
 8053316:	e9cd 1323 	strd	r1, r3, [sp, #140]	; 0x8c
 805331a:	dd50      	ble.n	80533be <_svfprintf_r+0x12ae>
 805331c:	aa22      	add	r2, sp, #136	; 0x88
 805331e:	4649      	mov	r1, r9
 8053320:	4650      	mov	r0, sl
 8053322:	f003 fdc0 	bl	8056ea6 <__ssprint_r>
 8053326:	2800      	cmp	r0, #0
 8053328:	d16c      	bne.n	8053404 <_svfprintf_r+0x12f4>
 805332a:	ad25      	add	r5, sp, #148	; 0x94
 805332c:	ab1e      	add	r3, sp, #120	; 0x78
 805332e:	602b      	str	r3, [r5, #0]
 8053330:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8053332:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8053334:	606b      	str	r3, [r5, #4]
 8053336:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053338:	4413      	add	r3, r2
 805333a:	9324      	str	r3, [sp, #144]	; 0x90
 805333c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805333e:	3301      	adds	r3, #1
 8053340:	2b07      	cmp	r3, #7
 8053342:	9323      	str	r3, [sp, #140]	; 0x8c
 8053344:	f73f adb5 	bgt.w	8052eb2 <_svfprintf_r+0xda2>
 8053348:	f105 0408 	add.w	r4, r5, #8
 805334c:	f7ff bac2 	b.w	80528d4 <_svfprintf_r+0x7c4>
 8053350:	aa22      	add	r2, sp, #136	; 0x88
 8053352:	4649      	mov	r1, r9
 8053354:	4650      	mov	r0, sl
 8053356:	f003 fda6 	bl	8056ea6 <__ssprint_r>
 805335a:	2800      	cmp	r0, #0
 805335c:	d152      	bne.n	8053404 <_svfprintf_r+0x12f4>
 805335e:	ad25      	add	r5, sp, #148	; 0x94
 8053360:	e7c4      	b.n	80532ec <_svfprintf_r+0x11dc>
 8053362:	2c00      	cmp	r4, #0
 8053364:	dde2      	ble.n	805332c <_svfprintf_r+0x121c>
 8053366:	4e58      	ldr	r6, [pc, #352]	; (80534c8 <_svfprintf_r+0x13b8>)
 8053368:	2710      	movs	r7, #16
 805336a:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805336e:	2c10      	cmp	r4, #16
 8053370:	f103 0301 	add.w	r3, r3, #1
 8053374:	f105 0108 	add.w	r1, r5, #8
 8053378:	602e      	str	r6, [r5, #0]
 805337a:	dc07      	bgt.n	805338c <_svfprintf_r+0x127c>
 805337c:	606c      	str	r4, [r5, #4]
 805337e:	2b07      	cmp	r3, #7
 8053380:	4414      	add	r4, r2
 8053382:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 8053386:	dcc9      	bgt.n	805331c <_svfprintf_r+0x120c>
 8053388:	460d      	mov	r5, r1
 805338a:	e7cf      	b.n	805332c <_svfprintf_r+0x121c>
 805338c:	3210      	adds	r2, #16
 805338e:	2b07      	cmp	r3, #7
 8053390:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053394:	606f      	str	r7, [r5, #4]
 8053396:	dd06      	ble.n	80533a6 <_svfprintf_r+0x1296>
 8053398:	aa22      	add	r2, sp, #136	; 0x88
 805339a:	4649      	mov	r1, r9
 805339c:	4650      	mov	r0, sl
 805339e:	f003 fd82 	bl	8056ea6 <__ssprint_r>
 80533a2:	bb78      	cbnz	r0, 8053404 <_svfprintf_r+0x12f4>
 80533a4:	a925      	add	r1, sp, #148	; 0x94
 80533a6:	3c10      	subs	r4, #16
 80533a8:	460d      	mov	r5, r1
 80533aa:	e7de      	b.n	805336a <_svfprintf_r+0x125a>
 80533ac:	2201      	movs	r2, #1
 80533ae:	2b07      	cmp	r3, #7
 80533b0:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80533b4:	f8c4 b000 	str.w	fp, [r4]
 80533b8:	6062      	str	r2, [r4, #4]
 80533ba:	ddb7      	ble.n	805332c <_svfprintf_r+0x121c>
 80533bc:	e7ae      	b.n	805331c <_svfprintf_r+0x120c>
 80533be:	3508      	adds	r5, #8
 80533c0:	e7b4      	b.n	805332c <_svfprintf_r+0x121c>
 80533c2:	460c      	mov	r4, r1
 80533c4:	f7ff ba86 	b.w	80528d4 <_svfprintf_r+0x7c4>
 80533c8:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 80533cc:	1a9d      	subs	r5, r3, r2
 80533ce:	2d00      	cmp	r5, #0
 80533d0:	f77f aa84 	ble.w	80528dc <_svfprintf_r+0x7cc>
 80533d4:	4e3d      	ldr	r6, [pc, #244]	; (80534cc <_svfprintf_r+0x13bc>)
 80533d6:	2710      	movs	r7, #16
 80533d8:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80533dc:	2d10      	cmp	r5, #16
 80533de:	f103 0301 	add.w	r3, r3, #1
 80533e2:	6026      	str	r6, [r4, #0]
 80533e4:	dc18      	bgt.n	8053418 <_svfprintf_r+0x1308>
 80533e6:	6065      	str	r5, [r4, #4]
 80533e8:	2b07      	cmp	r3, #7
 80533ea:	4415      	add	r5, r2
 80533ec:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 80533f0:	f77f aa74 	ble.w	80528dc <_svfprintf_r+0x7cc>
 80533f4:	aa22      	add	r2, sp, #136	; 0x88
 80533f6:	4649      	mov	r1, r9
 80533f8:	4650      	mov	r0, sl
 80533fa:	f003 fd54 	bl	8056ea6 <__ssprint_r>
 80533fe:	2800      	cmp	r0, #0
 8053400:	f43f aa6c 	beq.w	80528dc <_svfprintf_r+0x7cc>
 8053404:	9b03      	ldr	r3, [sp, #12]
 8053406:	2b00      	cmp	r3, #0
 8053408:	f43f a88a 	beq.w	8052520 <_svfprintf_r+0x410>
 805340c:	4619      	mov	r1, r3
 805340e:	4650      	mov	r0, sl
 8053410:	f002 fb7e 	bl	8055b10 <_free_r>
 8053414:	f7ff b884 	b.w	8052520 <_svfprintf_r+0x410>
 8053418:	3210      	adds	r2, #16
 805341a:	2b07      	cmp	r3, #7
 805341c:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8053420:	6067      	str	r7, [r4, #4]
 8053422:	dc02      	bgt.n	805342a <_svfprintf_r+0x131a>
 8053424:	3408      	adds	r4, #8
 8053426:	3d10      	subs	r5, #16
 8053428:	e7d6      	b.n	80533d8 <_svfprintf_r+0x12c8>
 805342a:	aa22      	add	r2, sp, #136	; 0x88
 805342c:	4649      	mov	r1, r9
 805342e:	4650      	mov	r0, sl
 8053430:	f003 fd39 	bl	8056ea6 <__ssprint_r>
 8053434:	2800      	cmp	r0, #0
 8053436:	d1e5      	bne.n	8053404 <_svfprintf_r+0x12f4>
 8053438:	ac25      	add	r4, sp, #148	; 0x94
 805343a:	e7f4      	b.n	8053426 <_svfprintf_r+0x1316>
 805343c:	9903      	ldr	r1, [sp, #12]
 805343e:	4650      	mov	r0, sl
 8053440:	f002 fb66 	bl	8055b10 <_free_r>
 8053444:	f7ff ba62 	b.w	805290c <_svfprintf_r+0x7fc>
 8053448:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805344a:	2b00      	cmp	r3, #0
 805344c:	f43f a868 	beq.w	8052520 <_svfprintf_r+0x410>
 8053450:	aa22      	add	r2, sp, #136	; 0x88
 8053452:	4649      	mov	r1, r9
 8053454:	4650      	mov	r0, sl
 8053456:	f003 fd26 	bl	8056ea6 <__ssprint_r>
 805345a:	f7ff b861 	b.w	8052520 <_svfprintf_r+0x410>
 805345e:	ea56 0207 	orrs.w	r2, r6, r7
 8053462:	f8cd 800c 	str.w	r8, [sp, #12]
 8053466:	f43f ab78 	beq.w	8052b5a <_svfprintf_r+0xa4a>
 805346a:	2b01      	cmp	r3, #1
 805346c:	f43f ac0d 	beq.w	8052c8a <_svfprintf_r+0xb7a>
 8053470:	2b02      	cmp	r3, #2
 8053472:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
 8053476:	f43f ac55 	beq.w	8052d24 <_svfprintf_r+0xc14>
 805347a:	08f2      	lsrs	r2, r6, #3
 805347c:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 8053480:	08f8      	lsrs	r0, r7, #3
 8053482:	f006 0307 	and.w	r3, r6, #7
 8053486:	4607      	mov	r7, r0
 8053488:	4616      	mov	r6, r2
 805348a:	3330      	adds	r3, #48	; 0x30
 805348c:	ea56 0207 	orrs.w	r2, r6, r7
 8053490:	4659      	mov	r1, fp
 8053492:	f80b 3d01 	strb.w	r3, [fp, #-1]!
 8053496:	d1f0      	bne.n	805347a <_svfprintf_r+0x136a>
 8053498:	9a03      	ldr	r2, [sp, #12]
 805349a:	07d2      	lsls	r2, r2, #31
 805349c:	d506      	bpl.n	80534ac <_svfprintf_r+0x139c>
 805349e:	2b30      	cmp	r3, #48	; 0x30
 80534a0:	d004      	beq.n	80534ac <_svfprintf_r+0x139c>
 80534a2:	2330      	movs	r3, #48	; 0x30
 80534a4:	f80b 3c01 	strb.w	r3, [fp, #-1]
 80534a8:	f1a1 0b02 	sub.w	fp, r1, #2
 80534ac:	ab4e      	add	r3, sp, #312	; 0x138
 80534ae:	eba3 030b 	sub.w	r3, r3, fp
 80534b2:	9e04      	ldr	r6, [sp, #16]
 80534b4:	9304      	str	r3, [sp, #16]
 80534b6:	2300      	movs	r3, #0
 80534b8:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80534bc:	9303      	str	r3, [sp, #12]
 80534be:	e9cd 3308 	strd	r3, r3, [sp, #32]
 80534c2:	461d      	mov	r5, r3
 80534c4:	f7ff b94c 	b.w	8052760 <_svfprintf_r+0x650>
 80534c8:	0805a394 	.word	0x0805a394
 80534cc:	0805a384 	.word	0x0805a384

080534d0 <sysconf>:
 80534d0:	2808      	cmp	r0, #8
 80534d2:	b508      	push	{r3, lr}
 80534d4:	d006      	beq.n	80534e4 <sysconf+0x14>
 80534d6:	f002 f98b 	bl	80557f0 <__errno>
 80534da:	2316      	movs	r3, #22
 80534dc:	6003      	str	r3, [r0, #0]
 80534de:	f04f 30ff 	mov.w	r0, #4294967295
 80534e2:	bd08      	pop	{r3, pc}
 80534e4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80534e8:	e7fb      	b.n	80534e2 <sysconf+0x12>
	...

080534ec <__utoa>:
 80534ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80534ee:	4c1f      	ldr	r4, [pc, #124]	; (805356c <__utoa+0x80>)
 80534f0:	b08b      	sub	sp, #44	; 0x2c
 80534f2:	4605      	mov	r5, r0
 80534f4:	460b      	mov	r3, r1
 80534f6:	466e      	mov	r6, sp
 80534f8:	f104 0c20 	add.w	ip, r4, #32
 80534fc:	6820      	ldr	r0, [r4, #0]
 80534fe:	6861      	ldr	r1, [r4, #4]
 8053500:	4637      	mov	r7, r6
 8053502:	c703      	stmia	r7!, {r0, r1}
 8053504:	3408      	adds	r4, #8
 8053506:	4564      	cmp	r4, ip
 8053508:	463e      	mov	r6, r7
 805350a:	d1f7      	bne.n	80534fc <__utoa+0x10>
 805350c:	7921      	ldrb	r1, [r4, #4]
 805350e:	7139      	strb	r1, [r7, #4]
 8053510:	1e91      	subs	r1, r2, #2
 8053512:	6820      	ldr	r0, [r4, #0]
 8053514:	6038      	str	r0, [r7, #0]
 8053516:	2922      	cmp	r1, #34	; 0x22
 8053518:	f04f 0100 	mov.w	r1, #0
 805351c:	d904      	bls.n	8053528 <__utoa+0x3c>
 805351e:	7019      	strb	r1, [r3, #0]
 8053520:	460b      	mov	r3, r1
 8053522:	4618      	mov	r0, r3
 8053524:	b00b      	add	sp, #44	; 0x2c
 8053526:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8053528:	1e58      	subs	r0, r3, #1
 805352a:	4684      	mov	ip, r0
 805352c:	fbb5 f7f2 	udiv	r7, r5, r2
 8053530:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 8053534:	fb02 5617 	mls	r6, r2, r7, r5
 8053538:	4476      	add	r6, lr
 805353a:	460c      	mov	r4, r1
 805353c:	f816 6c28 	ldrb.w	r6, [r6, #-40]
 8053540:	f80c 6f01 	strb.w	r6, [ip, #1]!
 8053544:	462e      	mov	r6, r5
 8053546:	42b2      	cmp	r2, r6
 8053548:	f101 0101 	add.w	r1, r1, #1
 805354c:	463d      	mov	r5, r7
 805354e:	d9ed      	bls.n	805352c <__utoa+0x40>
 8053550:	2200      	movs	r2, #0
 8053552:	545a      	strb	r2, [r3, r1]
 8053554:	1919      	adds	r1, r3, r4
 8053556:	1aa5      	subs	r5, r4, r2
 8053558:	42aa      	cmp	r2, r5
 805355a:	dae2      	bge.n	8053522 <__utoa+0x36>
 805355c:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8053560:	780e      	ldrb	r6, [r1, #0]
 8053562:	7006      	strb	r6, [r0, #0]
 8053564:	3201      	adds	r2, #1
 8053566:	f801 5901 	strb.w	r5, [r1], #-1
 805356a:	e7f4      	b.n	8053556 <__utoa+0x6a>
 805356c:	0805a3a4 	.word	0x0805a3a4

08053570 <_vfprintf_r>:
 8053570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8053574:	ed2d 8b04 	vpush	{d8-d9}
 8053578:	b0cf      	sub	sp, #316	; 0x13c
 805357a:	4689      	mov	r9, r1
 805357c:	9203      	str	r2, [sp, #12]
 805357e:	461c      	mov	r4, r3
 8053580:	461e      	mov	r6, r3
 8053582:	4682      	mov	sl, r0
 8053584:	f002 ff18 	bl	80563b8 <_localeconv_r>
 8053588:	6803      	ldr	r3, [r0, #0]
 805358a:	9313      	str	r3, [sp, #76]	; 0x4c
 805358c:	4618      	mov	r0, r3
 805358e:	f7ec fe2f 	bl	80401f0 <strlen>
 8053592:	900e      	str	r0, [sp, #56]	; 0x38
 8053594:	f1ba 0f00 	cmp.w	sl, #0
 8053598:	d005      	beq.n	80535a6 <_vfprintf_r+0x36>
 805359a:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 805359e:	b913      	cbnz	r3, 80535a6 <_vfprintf_r+0x36>
 80535a0:	4650      	mov	r0, sl
 80535a2:	f002 fa25 	bl	80559f0 <__sinit>
 80535a6:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 80535aa:	07d8      	lsls	r0, r3, #31
 80535ac:	d407      	bmi.n	80535be <_vfprintf_r+0x4e>
 80535ae:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80535b2:	0599      	lsls	r1, r3, #22
 80535b4:	d403      	bmi.n	80535be <_vfprintf_r+0x4e>
 80535b6:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 80535ba:	f002 ff03 	bl	80563c4 <__retarget_lock_acquire_recursive>
 80535be:	f9b9 300c 	ldrsh.w	r3, [r9, #12]
 80535c2:	049a      	lsls	r2, r3, #18
 80535c4:	d409      	bmi.n	80535da <_vfprintf_r+0x6a>
 80535c6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80535ca:	f8a9 300c 	strh.w	r3, [r9, #12]
 80535ce:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 80535d2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80535d6:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
 80535da:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80535de:	071f      	lsls	r7, r3, #28
 80535e0:	d502      	bpl.n	80535e8 <_vfprintf_r+0x78>
 80535e2:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80535e6:	b9d3      	cbnz	r3, 805361e <_vfprintf_r+0xae>
 80535e8:	4649      	mov	r1, r9
 80535ea:	4650      	mov	r0, sl
 80535ec:	f001 fa36 	bl	8054a5c <__swsetup_r>
 80535f0:	b1a8      	cbz	r0, 805361e <_vfprintf_r+0xae>
 80535f2:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 80535f6:	07dd      	lsls	r5, r3, #31
 80535f8:	d508      	bpl.n	805360c <_vfprintf_r+0x9c>
 80535fa:	f04f 33ff 	mov.w	r3, #4294967295
 80535fe:	930f      	str	r3, [sp, #60]	; 0x3c
 8053600:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8053602:	b04f      	add	sp, #316	; 0x13c
 8053604:	ecbd 8b04 	vpop	{d8-d9}
 8053608:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 805360c:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053610:	059c      	lsls	r4, r3, #22
 8053612:	d4f2      	bmi.n	80535fa <_vfprintf_r+0x8a>
 8053614:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053618:	f002 fed5 	bl	80563c6 <__retarget_lock_release_recursive>
 805361c:	e7ed      	b.n	80535fa <_vfprintf_r+0x8a>
 805361e:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053622:	f003 021a 	and.w	r2, r3, #26
 8053626:	2a0a      	cmp	r2, #10
 8053628:	d115      	bne.n	8053656 <_vfprintf_r+0xe6>
 805362a:	f9b9 200e 	ldrsh.w	r2, [r9, #14]
 805362e:	2a00      	cmp	r2, #0
 8053630:	db11      	blt.n	8053656 <_vfprintf_r+0xe6>
 8053632:	f8d9 2064 	ldr.w	r2, [r9, #100]	; 0x64
 8053636:	07d0      	lsls	r0, r2, #31
 8053638:	d405      	bmi.n	8053646 <_vfprintf_r+0xd6>
 805363a:	0599      	lsls	r1, r3, #22
 805363c:	d403      	bmi.n	8053646 <_vfprintf_r+0xd6>
 805363e:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053642:	f002 fec0 	bl	80563c6 <__retarget_lock_release_recursive>
 8053646:	9a03      	ldr	r2, [sp, #12]
 8053648:	4623      	mov	r3, r4
 805364a:	4649      	mov	r1, r9
 805364c:	4650      	mov	r0, sl
 805364e:	f001 f9c5 	bl	80549dc <__sbprintf>
 8053652:	900f      	str	r0, [sp, #60]	; 0x3c
 8053654:	e7d4      	b.n	8053600 <_vfprintf_r+0x90>
 8053656:	ed9f 7b9a 	vldr	d7, [pc, #616]	; 80538c0 <_vfprintf_r+0x350>
 805365a:	2500      	movs	r5, #0
 805365c:	e9cd 5523 	strd	r5, r5, [sp, #140]	; 0x8c
 8053660:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8053664:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
 8053668:	ac25      	add	r4, sp, #148	; 0x94
 805366a:	9422      	str	r4, [sp, #136]	; 0x88
 805366c:	9505      	str	r5, [sp, #20]
 805366e:	950a      	str	r5, [sp, #40]	; 0x28
 8053670:	9512      	str	r5, [sp, #72]	; 0x48
 8053672:	9514      	str	r5, [sp, #80]	; 0x50
 8053674:	950f      	str	r5, [sp, #60]	; 0x3c
 8053676:	9b03      	ldr	r3, [sp, #12]
 8053678:	461d      	mov	r5, r3
 805367a:	f813 2b01 	ldrb.w	r2, [r3], #1
 805367e:	b10a      	cbz	r2, 8053684 <_vfprintf_r+0x114>
 8053680:	2a25      	cmp	r2, #37	; 0x25
 8053682:	d1f9      	bne.n	8053678 <_vfprintf_r+0x108>
 8053684:	9b03      	ldr	r3, [sp, #12]
 8053686:	1aef      	subs	r7, r5, r3
 8053688:	d00d      	beq.n	80536a6 <_vfprintf_r+0x136>
 805368a:	e9c4 3700 	strd	r3, r7, [r4]
 805368e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053690:	443b      	add	r3, r7
 8053692:	9324      	str	r3, [sp, #144]	; 0x90
 8053694:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053696:	3301      	adds	r3, #1
 8053698:	2b07      	cmp	r3, #7
 805369a:	9323      	str	r3, [sp, #140]	; 0x8c
 805369c:	dc79      	bgt.n	8053792 <_vfprintf_r+0x222>
 805369e:	3408      	adds	r4, #8
 80536a0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80536a2:	443b      	add	r3, r7
 80536a4:	930f      	str	r3, [sp, #60]	; 0x3c
 80536a6:	782b      	ldrb	r3, [r5, #0]
 80536a8:	2b00      	cmp	r3, #0
 80536aa:	f001 8156 	beq.w	805495a <_vfprintf_r+0x13ea>
 80536ae:	2300      	movs	r3, #0
 80536b0:	3501      	adds	r5, #1
 80536b2:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80536b6:	f04f 38ff 	mov.w	r8, #4294967295
 80536ba:	9310      	str	r3, [sp, #64]	; 0x40
 80536bc:	469b      	mov	fp, r3
 80536be:	270a      	movs	r7, #10
 80536c0:	212b      	movs	r1, #43	; 0x2b
 80536c2:	462a      	mov	r2, r5
 80536c4:	f812 3b01 	ldrb.w	r3, [r2], #1
 80536c8:	9307      	str	r3, [sp, #28]
 80536ca:	4613      	mov	r3, r2
 80536cc:	930b      	str	r3, [sp, #44]	; 0x2c
 80536ce:	9b07      	ldr	r3, [sp, #28]
 80536d0:	3b20      	subs	r3, #32
 80536d2:	2b5a      	cmp	r3, #90	; 0x5a
 80536d4:	f200 85c0 	bhi.w	8054258 <_vfprintf_r+0xce8>
 80536d8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80536dc:	05be007e 	.word	0x05be007e
 80536e0:	008605be 	.word	0x008605be
 80536e4:	05be05be 	.word	0x05be05be
 80536e8:	006505be 	.word	0x006505be
 80536ec:	05be05be 	.word	0x05be05be
 80536f0:	00930089 	.word	0x00930089
 80536f4:	009005be 	.word	0x009005be
 80536f8:	05be0096 	.word	0x05be0096
 80536fc:	00b200af 	.word	0x00b200af
 8053700:	00b200b2 	.word	0x00b200b2
 8053704:	00b200b2 	.word	0x00b200b2
 8053708:	00b200b2 	.word	0x00b200b2
 805370c:	00b200b2 	.word	0x00b200b2
 8053710:	05be05be 	.word	0x05be05be
 8053714:	05be05be 	.word	0x05be05be
 8053718:	05be05be 	.word	0x05be05be
 805371c:	012105be 	.word	0x012105be
 8053720:	00df05be 	.word	0x00df05be
 8053724:	012100f6 	.word	0x012100f6
 8053728:	01210121 	.word	0x01210121
 805372c:	05be05be 	.word	0x05be05be
 8053730:	05be05be 	.word	0x05be05be
 8053734:	05be00c2 	.word	0x05be00c2
 8053738:	049005be 	.word	0x049005be
 805373c:	05be05be 	.word	0x05be05be
 8053740:	04d705be 	.word	0x04d705be
 8053744:	04fb05be 	.word	0x04fb05be
 8053748:	05be05be 	.word	0x05be05be
 805374c:	05be051a 	.word	0x05be051a
 8053750:	05be05be 	.word	0x05be05be
 8053754:	05be05be 	.word	0x05be05be
 8053758:	05be05be 	.word	0x05be05be
 805375c:	012105be 	.word	0x012105be
 8053760:	00df05be 	.word	0x00df05be
 8053764:	012100f8 	.word	0x012100f8
 8053768:	01210121 	.word	0x01210121
 805376c:	00f800c5 	.word	0x00f800c5
 8053770:	05be00d9 	.word	0x05be00d9
 8053774:	05be00d2 	.word	0x05be00d2
 8053778:	0492046d 	.word	0x0492046d
 805377c:	00d904c6 	.word	0x00d904c6
 8053780:	04d705be 	.word	0x04d705be
 8053784:	04fd007c 	.word	0x04fd007c
 8053788:	05be05be 	.word	0x05be05be
 805378c:	05be0537 	.word	0x05be0537
 8053790:	007c      	.short	0x007c
 8053792:	aa22      	add	r2, sp, #136	; 0x88
 8053794:	4649      	mov	r1, r9
 8053796:	4650      	mov	r0, sl
 8053798:	f003 fc00 	bl	8056f9c <__sprint_r>
 805379c:	2800      	cmp	r0, #0
 805379e:	f040 8130 	bne.w	8053a02 <_vfprintf_r+0x492>
 80537a2:	ac25      	add	r4, sp, #148	; 0x94
 80537a4:	e77c      	b.n	80536a0 <_vfprintf_r+0x130>
 80537a6:	4650      	mov	r0, sl
 80537a8:	f002 fe06 	bl	80563b8 <_localeconv_r>
 80537ac:	6843      	ldr	r3, [r0, #4]
 80537ae:	9314      	str	r3, [sp, #80]	; 0x50
 80537b0:	4618      	mov	r0, r3
 80537b2:	f7ec fd1d 	bl	80401f0 <strlen>
 80537b6:	9012      	str	r0, [sp, #72]	; 0x48
 80537b8:	4650      	mov	r0, sl
 80537ba:	f002 fdfd 	bl	80563b8 <_localeconv_r>
 80537be:	6883      	ldr	r3, [r0, #8]
 80537c0:	930a      	str	r3, [sp, #40]	; 0x28
 80537c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80537c4:	212b      	movs	r1, #43	; 0x2b
 80537c6:	b12b      	cbz	r3, 80537d4 <_vfprintf_r+0x264>
 80537c8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80537ca:	b11b      	cbz	r3, 80537d4 <_vfprintf_r+0x264>
 80537cc:	781b      	ldrb	r3, [r3, #0]
 80537ce:	b10b      	cbz	r3, 80537d4 <_vfprintf_r+0x264>
 80537d0:	f44b 6b80 	orr.w	fp, fp, #1024	; 0x400
 80537d4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80537d6:	e774      	b.n	80536c2 <_vfprintf_r+0x152>
 80537d8:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80537dc:	2b00      	cmp	r3, #0
 80537de:	d1f9      	bne.n	80537d4 <_vfprintf_r+0x264>
 80537e0:	2320      	movs	r3, #32
 80537e2:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80537e6:	e7f5      	b.n	80537d4 <_vfprintf_r+0x264>
 80537e8:	f04b 0b01 	orr.w	fp, fp, #1
 80537ec:	e7f2      	b.n	80537d4 <_vfprintf_r+0x264>
 80537ee:	f856 3b04 	ldr.w	r3, [r6], #4
 80537f2:	9310      	str	r3, [sp, #64]	; 0x40
 80537f4:	2b00      	cmp	r3, #0
 80537f6:	daed      	bge.n	80537d4 <_vfprintf_r+0x264>
 80537f8:	425b      	negs	r3, r3
 80537fa:	9310      	str	r3, [sp, #64]	; 0x40
 80537fc:	f04b 0b04 	orr.w	fp, fp, #4
 8053800:	e7e8      	b.n	80537d4 <_vfprintf_r+0x264>
 8053802:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 8053806:	e7e5      	b.n	80537d4 <_vfprintf_r+0x264>
 8053808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 805380a:	f813 2b01 	ldrb.w	r2, [r3], #1
 805380e:	9207      	str	r2, [sp, #28]
 8053810:	2a2a      	cmp	r2, #42	; 0x2a
 8053812:	d10f      	bne.n	8053834 <_vfprintf_r+0x2c4>
 8053814:	f856 0b04 	ldr.w	r0, [r6], #4
 8053818:	930b      	str	r3, [sp, #44]	; 0x2c
 805381a:	ea40 78e0 	orr.w	r8, r0, r0, asr #31
 805381e:	e7d9      	b.n	80537d4 <_vfprintf_r+0x264>
 8053820:	fb07 2808 	mla	r8, r7, r8, r2
 8053824:	f813 2b01 	ldrb.w	r2, [r3], #1
 8053828:	9207      	str	r2, [sp, #28]
 805382a:	9a07      	ldr	r2, [sp, #28]
 805382c:	3a30      	subs	r2, #48	; 0x30
 805382e:	2a09      	cmp	r2, #9
 8053830:	d9f6      	bls.n	8053820 <_vfprintf_r+0x2b0>
 8053832:	e74b      	b.n	80536cc <_vfprintf_r+0x15c>
 8053834:	f04f 0800 	mov.w	r8, #0
 8053838:	e7f7      	b.n	805382a <_vfprintf_r+0x2ba>
 805383a:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 805383e:	e7c9      	b.n	80537d4 <_vfprintf_r+0x264>
 8053840:	2200      	movs	r2, #0
 8053842:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8053844:	9210      	str	r2, [sp, #64]	; 0x40
 8053846:	9a07      	ldr	r2, [sp, #28]
 8053848:	9810      	ldr	r0, [sp, #64]	; 0x40
 805384a:	3a30      	subs	r2, #48	; 0x30
 805384c:	fb07 2200 	mla	r2, r7, r0, r2
 8053850:	9210      	str	r2, [sp, #64]	; 0x40
 8053852:	f813 2b01 	ldrb.w	r2, [r3], #1
 8053856:	9207      	str	r2, [sp, #28]
 8053858:	3a30      	subs	r2, #48	; 0x30
 805385a:	2a09      	cmp	r2, #9
 805385c:	d9f3      	bls.n	8053846 <_vfprintf_r+0x2d6>
 805385e:	e735      	b.n	80536cc <_vfprintf_r+0x15c>
 8053860:	f04b 0b08 	orr.w	fp, fp, #8
 8053864:	e7b6      	b.n	80537d4 <_vfprintf_r+0x264>
 8053866:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8053868:	781b      	ldrb	r3, [r3, #0]
 805386a:	2b68      	cmp	r3, #104	; 0x68
 805386c:	bf01      	itttt	eq
 805386e:	9b0b      	ldreq	r3, [sp, #44]	; 0x2c
 8053870:	3301      	addeq	r3, #1
 8053872:	930b      	streq	r3, [sp, #44]	; 0x2c
 8053874:	f44b 7b00 	orreq.w	fp, fp, #512	; 0x200
 8053878:	bf18      	it	ne
 805387a:	f04b 0b40 	orrne.w	fp, fp, #64	; 0x40
 805387e:	e7a9      	b.n	80537d4 <_vfprintf_r+0x264>
 8053880:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8053882:	781b      	ldrb	r3, [r3, #0]
 8053884:	2b6c      	cmp	r3, #108	; 0x6c
 8053886:	d105      	bne.n	8053894 <_vfprintf_r+0x324>
 8053888:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 805388a:	3301      	adds	r3, #1
 805388c:	930b      	str	r3, [sp, #44]	; 0x2c
 805388e:	f04b 0b20 	orr.w	fp, fp, #32
 8053892:	e79f      	b.n	80537d4 <_vfprintf_r+0x264>
 8053894:	f04b 0b10 	orr.w	fp, fp, #16
 8053898:	e79c      	b.n	80537d4 <_vfprintf_r+0x264>
 805389a:	4632      	mov	r2, r6
 805389c:	2000      	movs	r0, #0
 805389e:	f852 3b04 	ldr.w	r3, [r2], #4
 80538a2:	9206      	str	r2, [sp, #24]
 80538a4:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 80538a8:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 80538ac:	ab35      	add	r3, sp, #212	; 0xd4
 80538ae:	e9cd 0008 	strd	r0, r0, [sp, #32]
 80538b2:	9004      	str	r0, [sp, #16]
 80538b4:	f04f 0801 	mov.w	r8, #1
 80538b8:	4606      	mov	r6, r0
 80538ba:	4605      	mov	r5, r0
 80538bc:	9303      	str	r3, [sp, #12]
 80538be:	e1c3      	b.n	8053c48 <_vfprintf_r+0x6d8>
	...
 80538c8:	f04b 0b10 	orr.w	fp, fp, #16
 80538cc:	f01b 0f20 	tst.w	fp, #32
 80538d0:	d012      	beq.n	80538f8 <_vfprintf_r+0x388>
 80538d2:	3607      	adds	r6, #7
 80538d4:	f026 0307 	bic.w	r3, r6, #7
 80538d8:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 80538dc:	9306      	str	r3, [sp, #24]
 80538de:	2e00      	cmp	r6, #0
 80538e0:	f177 0300 	sbcs.w	r3, r7, #0
 80538e4:	da06      	bge.n	80538f4 <_vfprintf_r+0x384>
 80538e6:	4276      	negs	r6, r6
 80538e8:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80538ec:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
 80538f0:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80538f4:	2301      	movs	r3, #1
 80538f6:	e392      	b.n	805401e <_vfprintf_r+0xaae>
 80538f8:	1d33      	adds	r3, r6, #4
 80538fa:	f01b 0f10 	tst.w	fp, #16
 80538fe:	9306      	str	r3, [sp, #24]
 8053900:	d002      	beq.n	8053908 <_vfprintf_r+0x398>
 8053902:	6836      	ldr	r6, [r6, #0]
 8053904:	17f7      	asrs	r7, r6, #31
 8053906:	e7ea      	b.n	80538de <_vfprintf_r+0x36e>
 8053908:	f01b 0f40 	tst.w	fp, #64	; 0x40
 805390c:	6836      	ldr	r6, [r6, #0]
 805390e:	d001      	beq.n	8053914 <_vfprintf_r+0x3a4>
 8053910:	b236      	sxth	r6, r6
 8053912:	e7f7      	b.n	8053904 <_vfprintf_r+0x394>
 8053914:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8053918:	bf18      	it	ne
 805391a:	b276      	sxtbne	r6, r6
 805391c:	e7f2      	b.n	8053904 <_vfprintf_r+0x394>
 805391e:	3607      	adds	r6, #7
 8053920:	f026 0307 	bic.w	r3, r6, #7
 8053924:	ecb3 7b02 	vldmia	r3!, {d7}
 8053928:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 805392c:	9306      	str	r3, [sp, #24]
 805392e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8053930:	ee09 3a10 	vmov	s18, r3
 8053934:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8053936:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 805393a:	ee09 3a90 	vmov	s19, r3
 805393e:	f04f 32ff 	mov.w	r2, #4294967295
 8053942:	4b39      	ldr	r3, [pc, #228]	; (8053a28 <_vfprintf_r+0x4b8>)
 8053944:	ec51 0b19 	vmov	r0, r1, d9
 8053948:	f7ed f900 	bl	8040b4c <__aeabi_dcmpun>
 805394c:	bb20      	cbnz	r0, 8053998 <_vfprintf_r+0x428>
 805394e:	4b36      	ldr	r3, [pc, #216]	; (8053a28 <_vfprintf_r+0x4b8>)
 8053950:	ec51 0b19 	vmov	r0, r1, d9
 8053954:	f04f 32ff 	mov.w	r2, #4294967295
 8053958:	f7ed f8da 	bl	8040b10 <__aeabi_dcmple>
 805395c:	b9e0      	cbnz	r0, 8053998 <_vfprintf_r+0x428>
 805395e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8053962:	2200      	movs	r2, #0
 8053964:	2300      	movs	r3, #0
 8053966:	f7ed f8c9 	bl	8040afc <__aeabi_dcmplt>
 805396a:	b110      	cbz	r0, 8053972 <_vfprintf_r+0x402>
 805396c:	232d      	movs	r3, #45	; 0x2d
 805396e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8053972:	4a2e      	ldr	r2, [pc, #184]	; (8053a2c <_vfprintf_r+0x4bc>)
 8053974:	482e      	ldr	r0, [pc, #184]	; (8053a30 <_vfprintf_r+0x4c0>)
 8053976:	9907      	ldr	r1, [sp, #28]
 8053978:	4613      	mov	r3, r2
 805397a:	2947      	cmp	r1, #71	; 0x47
 805397c:	bfc8      	it	gt
 805397e:	4603      	movgt	r3, r0
 8053980:	9303      	str	r3, [sp, #12]
 8053982:	2300      	movs	r3, #0
 8053984:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
 8053988:	9304      	str	r3, [sp, #16]
 805398a:	f04f 0803 	mov.w	r8, #3
 805398e:	461e      	mov	r6, r3
 8053990:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8053994:	461d      	mov	r5, r3
 8053996:	e157      	b.n	8053c48 <_vfprintf_r+0x6d8>
 8053998:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 805399c:	4610      	mov	r0, r2
 805399e:	4619      	mov	r1, r3
 80539a0:	f7ed f8d4 	bl	8040b4c <__aeabi_dcmpun>
 80539a4:	b140      	cbz	r0, 80539b8 <_vfprintf_r+0x448>
 80539a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80539a8:	4a22      	ldr	r2, [pc, #136]	; (8053a34 <_vfprintf_r+0x4c4>)
 80539aa:	4823      	ldr	r0, [pc, #140]	; (8053a38 <_vfprintf_r+0x4c8>)
 80539ac:	2b00      	cmp	r3, #0
 80539ae:	bfbc      	itt	lt
 80539b0:	232d      	movlt	r3, #45	; 0x2d
 80539b2:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 80539b6:	e7de      	b.n	8053976 <_vfprintf_r+0x406>
 80539b8:	9b07      	ldr	r3, [sp, #28]
 80539ba:	f023 0320 	bic.w	r3, r3, #32
 80539be:	2b41      	cmp	r3, #65	; 0x41
 80539c0:	9308      	str	r3, [sp, #32]
 80539c2:	d13b      	bne.n	8053a3c <_vfprintf_r+0x4cc>
 80539c4:	2330      	movs	r3, #48	; 0x30
 80539c6:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 80539ca:	9b07      	ldr	r3, [sp, #28]
 80539cc:	2b61      	cmp	r3, #97	; 0x61
 80539ce:	bf0c      	ite	eq
 80539d0:	2378      	moveq	r3, #120	; 0x78
 80539d2:	2358      	movne	r3, #88	; 0x58
 80539d4:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
 80539d8:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80539dc:	f04b 0b02 	orr.w	fp, fp, #2
 80539e0:	f340 8209 	ble.w	8053df6 <_vfprintf_r+0x886>
 80539e4:	f108 0101 	add.w	r1, r8, #1
 80539e8:	4650      	mov	r0, sl
 80539ea:	f7fd f98d 	bl	8050d08 <_malloc_r>
 80539ee:	9003      	str	r0, [sp, #12]
 80539f0:	2800      	cmp	r0, #0
 80539f2:	f040 8204 	bne.w	8053dfe <_vfprintf_r+0x88e>
 80539f6:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80539fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80539fe:	f8a9 300c 	strh.w	r3, [r9, #12]
 8053a02:	f8d9 3064 	ldr.w	r3, [r9, #100]	; 0x64
 8053a06:	07d9      	lsls	r1, r3, #31
 8053a08:	d407      	bmi.n	8053a1a <_vfprintf_r+0x4aa>
 8053a0a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053a0e:	059a      	lsls	r2, r3, #22
 8053a10:	d403      	bmi.n	8053a1a <_vfprintf_r+0x4aa>
 8053a12:	f8d9 0058 	ldr.w	r0, [r9, #88]	; 0x58
 8053a16:	f002 fcd6 	bl	80563c6 <__retarget_lock_release_recursive>
 8053a1a:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8053a1e:	065b      	lsls	r3, r3, #25
 8053a20:	f57f adee 	bpl.w	8053600 <_vfprintf_r+0x90>
 8053a24:	e5e9      	b.n	80535fa <_vfprintf_r+0x8a>
 8053a26:	bf00      	nop
 8053a28:	7fefffff 	.word	0x7fefffff
 8053a2c:	0805a350 	.word	0x0805a350
 8053a30:	0805a354 	.word	0x0805a354
 8053a34:	0805a358 	.word	0x0805a358
 8053a38:	0805a35c 	.word	0x0805a35c
 8053a3c:	f1b8 3fff 	cmp.w	r8, #4294967295
 8053a40:	f000 81e0 	beq.w	8053e04 <_vfprintf_r+0x894>
 8053a44:	9b08      	ldr	r3, [sp, #32]
 8053a46:	2b47      	cmp	r3, #71	; 0x47
 8053a48:	f040 81e0 	bne.w	8053e0c <_vfprintf_r+0x89c>
 8053a4c:	f1b8 0f00 	cmp.w	r8, #0
 8053a50:	f040 81dc 	bne.w	8053e0c <_vfprintf_r+0x89c>
 8053a54:	f8cd 8010 	str.w	r8, [sp, #16]
 8053a58:	f04f 0801 	mov.w	r8, #1
 8053a5c:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
 8053a60:	9311      	str	r3, [sp, #68]	; 0x44
 8053a62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8053a64:	2b00      	cmp	r3, #0
 8053a66:	f280 81d3 	bge.w	8053e10 <_vfprintf_r+0x8a0>
 8053a6a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8053a6c:	ee08 3a10 	vmov	s16, r3
 8053a70:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8053a72:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8053a76:	ee08 3a90 	vmov	s17, r3
 8053a7a:	232d      	movs	r3, #45	; 0x2d
 8053a7c:	9318      	str	r3, [sp, #96]	; 0x60
 8053a7e:	9b08      	ldr	r3, [sp, #32]
 8053a80:	2b41      	cmp	r3, #65	; 0x41
 8053a82:	f040 81e3 	bne.w	8053e4c <_vfprintf_r+0x8dc>
 8053a86:	eeb0 0a48 	vmov.f32	s0, s16
 8053a8a:	eef0 0a68 	vmov.f32	s1, s17
 8053a8e:	a81c      	add	r0, sp, #112	; 0x70
 8053a90:	f003 f986 	bl	8056da0 <frexp>
 8053a94:	2200      	movs	r2, #0
 8053a96:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8053a9a:	ec51 0b10 	vmov	r0, r1, d0
 8053a9e:	f7ec fdbb 	bl	8040618 <__aeabi_dmul>
 8053aa2:	2200      	movs	r2, #0
 8053aa4:	2300      	movs	r3, #0
 8053aa6:	4606      	mov	r6, r0
 8053aa8:	460f      	mov	r7, r1
 8053aaa:	f7ed f81d 	bl	8040ae8 <__aeabi_dcmpeq>
 8053aae:	b108      	cbz	r0, 8053ab4 <_vfprintf_r+0x544>
 8053ab0:	2301      	movs	r3, #1
 8053ab2:	931c      	str	r3, [sp, #112]	; 0x70
 8053ab4:	4bb7      	ldr	r3, [pc, #732]	; (8053d94 <_vfprintf_r+0x824>)
 8053ab6:	4ab8      	ldr	r2, [pc, #736]	; (8053d98 <_vfprintf_r+0x828>)
 8053ab8:	9907      	ldr	r1, [sp, #28]
 8053aba:	9d03      	ldr	r5, [sp, #12]
 8053abc:	2961      	cmp	r1, #97	; 0x61
 8053abe:	bf18      	it	ne
 8053ac0:	461a      	movne	r2, r3
 8053ac2:	f108 33ff 	add.w	r3, r8, #4294967295
 8053ac6:	9217      	str	r2, [sp, #92]	; 0x5c
 8053ac8:	9305      	str	r3, [sp, #20]
 8053aca:	4bb4      	ldr	r3, [pc, #720]	; (8053d9c <_vfprintf_r+0x82c>)
 8053acc:	2200      	movs	r2, #0
 8053ace:	4630      	mov	r0, r6
 8053ad0:	4639      	mov	r1, r7
 8053ad2:	f7ec fda1 	bl	8040618 <__aeabi_dmul>
 8053ad6:	460f      	mov	r7, r1
 8053ad8:	4606      	mov	r6, r0
 8053ada:	f7ed f84d 	bl	8040b78 <__aeabi_d2iz>
 8053ade:	9019      	str	r0, [sp, #100]	; 0x64
 8053ae0:	f7ec fd30 	bl	8040544 <__aeabi_i2d>
 8053ae4:	4602      	mov	r2, r0
 8053ae6:	460b      	mov	r3, r1
 8053ae8:	4630      	mov	r0, r6
 8053aea:	4639      	mov	r1, r7
 8053aec:	f7ec fbdc 	bl	80402a8 <__aeabi_dsub>
 8053af0:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8053af2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8053af4:	5c9b      	ldrb	r3, [r3, r2]
 8053af6:	f805 3b01 	strb.w	r3, [r5], #1
 8053afa:	9b05      	ldr	r3, [sp, #20]
 8053afc:	9309      	str	r3, [sp, #36]	; 0x24
 8053afe:	1c5a      	adds	r2, r3, #1
 8053b00:	4606      	mov	r6, r0
 8053b02:	460f      	mov	r7, r1
 8053b04:	d007      	beq.n	8053b16 <_vfprintf_r+0x5a6>
 8053b06:	3b01      	subs	r3, #1
 8053b08:	9305      	str	r3, [sp, #20]
 8053b0a:	2200      	movs	r2, #0
 8053b0c:	2300      	movs	r3, #0
 8053b0e:	f7ec ffeb 	bl	8040ae8 <__aeabi_dcmpeq>
 8053b12:	2800      	cmp	r0, #0
 8053b14:	d0d9      	beq.n	8053aca <_vfprintf_r+0x55a>
 8053b16:	4ba2      	ldr	r3, [pc, #648]	; (8053da0 <_vfprintf_r+0x830>)
 8053b18:	2200      	movs	r2, #0
 8053b1a:	4630      	mov	r0, r6
 8053b1c:	4639      	mov	r1, r7
 8053b1e:	f7ed f80b 	bl	8040b38 <__aeabi_dcmpgt>
 8053b22:	b960      	cbnz	r0, 8053b3e <_vfprintf_r+0x5ce>
 8053b24:	4b9e      	ldr	r3, [pc, #632]	; (8053da0 <_vfprintf_r+0x830>)
 8053b26:	2200      	movs	r2, #0
 8053b28:	4630      	mov	r0, r6
 8053b2a:	4639      	mov	r1, r7
 8053b2c:	f7ec ffdc 	bl	8040ae8 <__aeabi_dcmpeq>
 8053b30:	2800      	cmp	r0, #0
 8053b32:	f000 8186 	beq.w	8053e42 <_vfprintf_r+0x8d2>
 8053b36:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8053b38:	07df      	lsls	r7, r3, #31
 8053b3a:	f140 8182 	bpl.w	8053e42 <_vfprintf_r+0x8d2>
 8053b3e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8053b40:	9520      	str	r5, [sp, #128]	; 0x80
 8053b42:	7bd9      	ldrb	r1, [r3, #15]
 8053b44:	2030      	movs	r0, #48	; 0x30
 8053b46:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8053b48:	1e53      	subs	r3, r2, #1
 8053b4a:	9320      	str	r3, [sp, #128]	; 0x80
 8053b4c:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 8053b50:	428b      	cmp	r3, r1
 8053b52:	f000 8165 	beq.w	8053e20 <_vfprintf_r+0x8b0>
 8053b56:	2b39      	cmp	r3, #57	; 0x39
 8053b58:	bf0b      	itete	eq
 8053b5a:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 8053b5c:	3301      	addne	r3, #1
 8053b5e:	7a9b      	ldrbeq	r3, [r3, #10]
 8053b60:	b2db      	uxtbne	r3, r3
 8053b62:	f802 3c01 	strb.w	r3, [r2, #-1]
 8053b66:	9b03      	ldr	r3, [sp, #12]
 8053b68:	1aeb      	subs	r3, r5, r3
 8053b6a:	9305      	str	r3, [sp, #20]
 8053b6c:	9b08      	ldr	r3, [sp, #32]
 8053b6e:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8053b70:	2b47      	cmp	r3, #71	; 0x47
 8053b72:	f040 81b3 	bne.w	8053edc <_vfprintf_r+0x96c>
 8053b76:	1cee      	adds	r6, r5, #3
 8053b78:	db02      	blt.n	8053b80 <_vfprintf_r+0x610>
 8053b7a:	4545      	cmp	r5, r8
 8053b7c:	f340 81d5 	ble.w	8053f2a <_vfprintf_r+0x9ba>
 8053b80:	9b07      	ldr	r3, [sp, #28]
 8053b82:	3b02      	subs	r3, #2
 8053b84:	9307      	str	r3, [sp, #28]
 8053b86:	9907      	ldr	r1, [sp, #28]
 8053b88:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8053b8c:	f021 0120 	bic.w	r1, r1, #32
 8053b90:	2941      	cmp	r1, #65	; 0x41
 8053b92:	bf08      	it	eq
 8053b94:	320f      	addeq	r2, #15
 8053b96:	f105 33ff 	add.w	r3, r5, #4294967295
 8053b9a:	bf06      	itte	eq
 8053b9c:	b2d2      	uxtbeq	r2, r2
 8053b9e:	2101      	moveq	r1, #1
 8053ba0:	2100      	movne	r1, #0
 8053ba2:	2b00      	cmp	r3, #0
 8053ba4:	931c      	str	r3, [sp, #112]	; 0x70
 8053ba6:	bfb8      	it	lt
 8053ba8:	f1c5 0301 	rsblt	r3, r5, #1
 8053bac:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 8053bb0:	bfb4      	ite	lt
 8053bb2:	222d      	movlt	r2, #45	; 0x2d
 8053bb4:	222b      	movge	r2, #43	; 0x2b
 8053bb6:	2b09      	cmp	r3, #9
 8053bb8:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 8053bbc:	f340 81a4 	ble.w	8053f08 <_vfprintf_r+0x998>
 8053bc0:	f10d 0287 	add.w	r2, sp, #135	; 0x87
 8053bc4:	260a      	movs	r6, #10
 8053bc6:	4611      	mov	r1, r2
 8053bc8:	fb93 f5f6 	sdiv	r5, r3, r6
 8053bcc:	fb06 3015 	mls	r0, r6, r5, r3
 8053bd0:	3030      	adds	r0, #48	; 0x30
 8053bd2:	f801 0c01 	strb.w	r0, [r1, #-1]
 8053bd6:	4618      	mov	r0, r3
 8053bd8:	2863      	cmp	r0, #99	; 0x63
 8053bda:	f102 32ff 	add.w	r2, r2, #4294967295
 8053bde:	462b      	mov	r3, r5
 8053be0:	dcf1      	bgt.n	8053bc6 <_vfprintf_r+0x656>
 8053be2:	3330      	adds	r3, #48	; 0x30
 8053be4:	1e88      	subs	r0, r1, #2
 8053be6:	f802 3c01 	strb.w	r3, [r2, #-1]
 8053bea:	f10d 0587 	add.w	r5, sp, #135	; 0x87
 8053bee:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8053bf2:	4603      	mov	r3, r0
 8053bf4:	42ab      	cmp	r3, r5
 8053bf6:	f0c0 8182 	bcc.w	8053efe <_vfprintf_r+0x98e>
 8053bfa:	f10d 0289 	add.w	r2, sp, #137	; 0x89
 8053bfe:	1a52      	subs	r2, r2, r1
 8053c00:	42a8      	cmp	r0, r5
 8053c02:	bf88      	it	hi
 8053c04:	2200      	movhi	r2, #0
 8053c06:	f10d 037a 	add.w	r3, sp, #122	; 0x7a
 8053c0a:	441a      	add	r2, r3
 8053c0c:	ab1e      	add	r3, sp, #120	; 0x78
 8053c0e:	1ad3      	subs	r3, r2, r3
 8053c10:	9a05      	ldr	r2, [sp, #20]
 8053c12:	9315      	str	r3, [sp, #84]	; 0x54
 8053c14:	2a01      	cmp	r2, #1
 8053c16:	eb03 0802 	add.w	r8, r3, r2
 8053c1a:	dc02      	bgt.n	8053c22 <_vfprintf_r+0x6b2>
 8053c1c:	f01b 0f01 	tst.w	fp, #1
 8053c20:	d001      	beq.n	8053c26 <_vfprintf_r+0x6b6>
 8053c22:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053c24:	4498      	add	r8, r3
 8053c26:	f42b 6380 	bic.w	r3, fp, #1024	; 0x400
 8053c2a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8053c2e:	9311      	str	r3, [sp, #68]	; 0x44
 8053c30:	2300      	movs	r3, #0
 8053c32:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8053c36:	461d      	mov	r5, r3
 8053c38:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8053c3a:	b113      	cbz	r3, 8053c42 <_vfprintf_r+0x6d2>
 8053c3c:	232d      	movs	r3, #45	; 0x2d
 8053c3e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8053c42:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
 8053c46:	2600      	movs	r6, #0
 8053c48:	4546      	cmp	r6, r8
 8053c4a:	4633      	mov	r3, r6
 8053c4c:	bfb8      	it	lt
 8053c4e:	4643      	movlt	r3, r8
 8053c50:	9311      	str	r3, [sp, #68]	; 0x44
 8053c52:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8053c56:	b113      	cbz	r3, 8053c5e <_vfprintf_r+0x6ee>
 8053c58:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8053c5a:	3301      	adds	r3, #1
 8053c5c:	9311      	str	r3, [sp, #68]	; 0x44
 8053c5e:	f01b 0302 	ands.w	r3, fp, #2
 8053c62:	9317      	str	r3, [sp, #92]	; 0x5c
 8053c64:	bf1e      	ittt	ne
 8053c66:	9b11      	ldrne	r3, [sp, #68]	; 0x44
 8053c68:	3302      	addne	r3, #2
 8053c6a:	9311      	strne	r3, [sp, #68]	; 0x44
 8053c6c:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
 8053c70:	9318      	str	r3, [sp, #96]	; 0x60
 8053c72:	d11f      	bne.n	8053cb4 <_vfprintf_r+0x744>
 8053c74:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8053c78:	1a9f      	subs	r7, r3, r2
 8053c7a:	2f00      	cmp	r7, #0
 8053c7c:	dd1a      	ble.n	8053cb4 <_vfprintf_r+0x744>
 8053c7e:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053c82:	4848      	ldr	r0, [pc, #288]	; (8053da4 <_vfprintf_r+0x834>)
 8053c84:	6020      	str	r0, [r4, #0]
 8053c86:	2f10      	cmp	r7, #16
 8053c88:	f103 0301 	add.w	r3, r3, #1
 8053c8c:	f104 0108 	add.w	r1, r4, #8
 8053c90:	f300 82f0 	bgt.w	8054274 <_vfprintf_r+0xd04>
 8053c94:	6067      	str	r7, [r4, #4]
 8053c96:	2b07      	cmp	r3, #7
 8053c98:	4417      	add	r7, r2
 8053c9a:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8053c9e:	f340 82fc 	ble.w	805429a <_vfprintf_r+0xd2a>
 8053ca2:	aa22      	add	r2, sp, #136	; 0x88
 8053ca4:	4649      	mov	r1, r9
 8053ca6:	4650      	mov	r0, sl
 8053ca8:	f003 f978 	bl	8056f9c <__sprint_r>
 8053cac:	2800      	cmp	r0, #0
 8053cae:	f040 8632 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8053cb2:	ac25      	add	r4, sp, #148	; 0x94
 8053cb4:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8053cb8:	b173      	cbz	r3, 8053cd8 <_vfprintf_r+0x768>
 8053cba:	f10d 036b 	add.w	r3, sp, #107	; 0x6b
 8053cbe:	6023      	str	r3, [r4, #0]
 8053cc0:	2301      	movs	r3, #1
 8053cc2:	6063      	str	r3, [r4, #4]
 8053cc4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053cc6:	3301      	adds	r3, #1
 8053cc8:	9324      	str	r3, [sp, #144]	; 0x90
 8053cca:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053ccc:	3301      	adds	r3, #1
 8053cce:	2b07      	cmp	r3, #7
 8053cd0:	9323      	str	r3, [sp, #140]	; 0x8c
 8053cd2:	f300 82e4 	bgt.w	805429e <_vfprintf_r+0xd2e>
 8053cd6:	3408      	adds	r4, #8
 8053cd8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8053cda:	b16b      	cbz	r3, 8053cf8 <_vfprintf_r+0x788>
 8053cdc:	ab1b      	add	r3, sp, #108	; 0x6c
 8053cde:	6023      	str	r3, [r4, #0]
 8053ce0:	2302      	movs	r3, #2
 8053ce2:	6063      	str	r3, [r4, #4]
 8053ce4:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053ce6:	3302      	adds	r3, #2
 8053ce8:	9324      	str	r3, [sp, #144]	; 0x90
 8053cea:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053cec:	3301      	adds	r3, #1
 8053cee:	2b07      	cmp	r3, #7
 8053cf0:	9323      	str	r3, [sp, #140]	; 0x8c
 8053cf2:	f300 82de 	bgt.w	80542b2 <_vfprintf_r+0xd42>
 8053cf6:	3408      	adds	r4, #8
 8053cf8:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8053cfa:	2b80      	cmp	r3, #128	; 0x80
 8053cfc:	d11f      	bne.n	8053d3e <_vfprintf_r+0x7ce>
 8053cfe:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 8053d02:	1a9f      	subs	r7, r3, r2
 8053d04:	2f00      	cmp	r7, #0
 8053d06:	dd1a      	ble.n	8053d3e <_vfprintf_r+0x7ce>
 8053d08:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053d0c:	4826      	ldr	r0, [pc, #152]	; (8053da8 <_vfprintf_r+0x838>)
 8053d0e:	6020      	str	r0, [r4, #0]
 8053d10:	2f10      	cmp	r7, #16
 8053d12:	f103 0301 	add.w	r3, r3, #1
 8053d16:	f104 0108 	add.w	r1, r4, #8
 8053d1a:	f300 82d4 	bgt.w	80542c6 <_vfprintf_r+0xd56>
 8053d1e:	6067      	str	r7, [r4, #4]
 8053d20:	2b07      	cmp	r3, #7
 8053d22:	4417      	add	r7, r2
 8053d24:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8053d28:	f340 82e0 	ble.w	80542ec <_vfprintf_r+0xd7c>
 8053d2c:	aa22      	add	r2, sp, #136	; 0x88
 8053d2e:	4649      	mov	r1, r9
 8053d30:	4650      	mov	r0, sl
 8053d32:	f003 f933 	bl	8056f9c <__sprint_r>
 8053d36:	2800      	cmp	r0, #0
 8053d38:	f040 85ed 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8053d3c:	ac25      	add	r4, sp, #148	; 0x94
 8053d3e:	eba6 0608 	sub.w	r6, r6, r8
 8053d42:	2e00      	cmp	r6, #0
 8053d44:	dd1a      	ble.n	8053d7c <_vfprintf_r+0x80c>
 8053d46:	4f18      	ldr	r7, [pc, #96]	; (8053da8 <_vfprintf_r+0x838>)
 8053d48:	6027      	str	r7, [r4, #0]
 8053d4a:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8053d4e:	2e10      	cmp	r6, #16
 8053d50:	f103 0301 	add.w	r3, r3, #1
 8053d54:	f104 0108 	add.w	r1, r4, #8
 8053d58:	f300 82ca 	bgt.w	80542f0 <_vfprintf_r+0xd80>
 8053d5c:	6066      	str	r6, [r4, #4]
 8053d5e:	2b07      	cmp	r3, #7
 8053d60:	4416      	add	r6, r2
 8053d62:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 8053d66:	f340 82d6 	ble.w	8054316 <_vfprintf_r+0xda6>
 8053d6a:	aa22      	add	r2, sp, #136	; 0x88
 8053d6c:	4649      	mov	r1, r9
 8053d6e:	4650      	mov	r0, sl
 8053d70:	f003 f914 	bl	8056f9c <__sprint_r>
 8053d74:	2800      	cmp	r0, #0
 8053d76:	f040 85ce 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8053d7a:	ac25      	add	r4, sp, #148	; 0x94
 8053d7c:	f41b 7f80 	tst.w	fp, #256	; 0x100
 8053d80:	9e24      	ldr	r6, [sp, #144]	; 0x90
 8053d82:	f040 82cf 	bne.w	8054324 <_vfprintf_r+0xdb4>
 8053d86:	9b03      	ldr	r3, [sp, #12]
 8053d88:	e9c4 3800 	strd	r3, r8, [r4]
 8053d8c:	4446      	add	r6, r8
 8053d8e:	9624      	str	r6, [sp, #144]	; 0x90
 8053d90:	e00c      	b.n	8053dac <_vfprintf_r+0x83c>
 8053d92:	bf00      	nop
 8053d94:	0805a371 	.word	0x0805a371
 8053d98:	0805a360 	.word	0x0805a360
 8053d9c:	40300000 	.word	0x40300000
 8053da0:	3fe00000 	.word	0x3fe00000
 8053da4:	0805a3c9 	.word	0x0805a3c9
 8053da8:	0805a3d9 	.word	0x0805a3d9
 8053dac:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8053dae:	3301      	adds	r3, #1
 8053db0:	2b07      	cmp	r3, #7
 8053db2:	9323      	str	r3, [sp, #140]	; 0x8c
 8053db4:	f300 82fb 	bgt.w	80543ae <_vfprintf_r+0xe3e>
 8053db8:	3408      	adds	r4, #8
 8053dba:	f01b 0f04 	tst.w	fp, #4
 8053dbe:	f040 858c 	bne.w	80548da <_vfprintf_r+0x136a>
 8053dc2:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8053dc6:	9911      	ldr	r1, [sp, #68]	; 0x44
 8053dc8:	428a      	cmp	r2, r1
 8053dca:	bfac      	ite	ge
 8053dcc:	189b      	addge	r3, r3, r2
 8053dce:	185b      	addlt	r3, r3, r1
 8053dd0:	930f      	str	r3, [sp, #60]	; 0x3c
 8053dd2:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8053dd4:	b13b      	cbz	r3, 8053de6 <_vfprintf_r+0x876>
 8053dd6:	aa22      	add	r2, sp, #136	; 0x88
 8053dd8:	4649      	mov	r1, r9
 8053dda:	4650      	mov	r0, sl
 8053ddc:	f003 f8de 	bl	8056f9c <__sprint_r>
 8053de0:	2800      	cmp	r0, #0
 8053de2:	f040 8598 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8053de6:	2300      	movs	r3, #0
 8053de8:	9323      	str	r3, [sp, #140]	; 0x8c
 8053dea:	9b04      	ldr	r3, [sp, #16]
 8053dec:	2b00      	cmp	r3, #0
 8053dee:	f040 85ae 	bne.w	805494e <_vfprintf_r+0x13de>
 8053df2:	ac25      	add	r4, sp, #148	; 0x94
 8053df4:	e0eb      	b.n	8053fce <_vfprintf_r+0xa5e>
 8053df6:	ab35      	add	r3, sp, #212	; 0xd4
 8053df8:	9004      	str	r0, [sp, #16]
 8053dfa:	9303      	str	r3, [sp, #12]
 8053dfc:	e62e      	b.n	8053a5c <_vfprintf_r+0x4ec>
 8053dfe:	9b03      	ldr	r3, [sp, #12]
 8053e00:	9304      	str	r3, [sp, #16]
 8053e02:	e62b      	b.n	8053a5c <_vfprintf_r+0x4ec>
 8053e04:	9004      	str	r0, [sp, #16]
 8053e06:	f04f 0806 	mov.w	r8, #6
 8053e0a:	e627      	b.n	8053a5c <_vfprintf_r+0x4ec>
 8053e0c:	9004      	str	r0, [sp, #16]
 8053e0e:	e625      	b.n	8053a5c <_vfprintf_r+0x4ec>
 8053e10:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 8053e14:	2300      	movs	r3, #0
 8053e16:	eeb0 8a47 	vmov.f32	s16, s14
 8053e1a:	eef0 8a67 	vmov.f32	s17, s15
 8053e1e:	e62d      	b.n	8053a7c <_vfprintf_r+0x50c>
 8053e20:	f802 0c01 	strb.w	r0, [r2, #-1]
 8053e24:	e68f      	b.n	8053b46 <_vfprintf_r+0x5d6>
 8053e26:	f803 0b01 	strb.w	r0, [r3], #1
 8053e2a:	1aca      	subs	r2, r1, r3
 8053e2c:	2a00      	cmp	r2, #0
 8053e2e:	dafa      	bge.n	8053e26 <_vfprintf_r+0x8b6>
 8053e30:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8053e32:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053e34:	3201      	adds	r2, #1
 8053e36:	f103 0301 	add.w	r3, r3, #1
 8053e3a:	bfb8      	it	lt
 8053e3c:	2300      	movlt	r3, #0
 8053e3e:	441d      	add	r5, r3
 8053e40:	e691      	b.n	8053b66 <_vfprintf_r+0x5f6>
 8053e42:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8053e44:	462b      	mov	r3, r5
 8053e46:	18a9      	adds	r1, r5, r2
 8053e48:	2030      	movs	r0, #48	; 0x30
 8053e4a:	e7ee      	b.n	8053e2a <_vfprintf_r+0x8ba>
 8053e4c:	9b08      	ldr	r3, [sp, #32]
 8053e4e:	2b46      	cmp	r3, #70	; 0x46
 8053e50:	d005      	beq.n	8053e5e <_vfprintf_r+0x8ee>
 8053e52:	2b45      	cmp	r3, #69	; 0x45
 8053e54:	d11b      	bne.n	8053e8e <_vfprintf_r+0x91e>
 8053e56:	f108 0501 	add.w	r5, r8, #1
 8053e5a:	2102      	movs	r1, #2
 8053e5c:	e001      	b.n	8053e62 <_vfprintf_r+0x8f2>
 8053e5e:	4645      	mov	r5, r8
 8053e60:	2103      	movs	r1, #3
 8053e62:	ab20      	add	r3, sp, #128	; 0x80
 8053e64:	9301      	str	r3, [sp, #4]
 8053e66:	ab1d      	add	r3, sp, #116	; 0x74
 8053e68:	9300      	str	r3, [sp, #0]
 8053e6a:	462a      	mov	r2, r5
 8053e6c:	ab1c      	add	r3, sp, #112	; 0x70
 8053e6e:	4650      	mov	r0, sl
 8053e70:	eeb0 0a48 	vmov.f32	s0, s16
 8053e74:	eef0 0a68 	vmov.f32	s1, s17
 8053e78:	f000 fee6 	bl	8054c48 <_dtoa_r>
 8053e7c:	9b08      	ldr	r3, [sp, #32]
 8053e7e:	9003      	str	r0, [sp, #12]
 8053e80:	2b47      	cmp	r3, #71	; 0x47
 8053e82:	d106      	bne.n	8053e92 <_vfprintf_r+0x922>
 8053e84:	f01b 0f01 	tst.w	fp, #1
 8053e88:	d103      	bne.n	8053e92 <_vfprintf_r+0x922>
 8053e8a:	9d20      	ldr	r5, [sp, #128]	; 0x80
 8053e8c:	e66b      	b.n	8053b66 <_vfprintf_r+0x5f6>
 8053e8e:	4645      	mov	r5, r8
 8053e90:	e7e3      	b.n	8053e5a <_vfprintf_r+0x8ea>
 8053e92:	9b03      	ldr	r3, [sp, #12]
 8053e94:	195e      	adds	r6, r3, r5
 8053e96:	9b08      	ldr	r3, [sp, #32]
 8053e98:	2b46      	cmp	r3, #70	; 0x46
 8053e9a:	d10f      	bne.n	8053ebc <_vfprintf_r+0x94c>
 8053e9c:	9b03      	ldr	r3, [sp, #12]
 8053e9e:	781b      	ldrb	r3, [r3, #0]
 8053ea0:	2b30      	cmp	r3, #48	; 0x30
 8053ea2:	d109      	bne.n	8053eb8 <_vfprintf_r+0x948>
 8053ea4:	ec51 0b18 	vmov	r0, r1, d8
 8053ea8:	2200      	movs	r2, #0
 8053eaa:	2300      	movs	r3, #0
 8053eac:	f7ec fe1c 	bl	8040ae8 <__aeabi_dcmpeq>
 8053eb0:	b910      	cbnz	r0, 8053eb8 <_vfprintf_r+0x948>
 8053eb2:	f1c5 0501 	rsb	r5, r5, #1
 8053eb6:	951c      	str	r5, [sp, #112]	; 0x70
 8053eb8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8053eba:	441e      	add	r6, r3
 8053ebc:	ec51 0b18 	vmov	r0, r1, d8
 8053ec0:	2200      	movs	r2, #0
 8053ec2:	2300      	movs	r3, #0
 8053ec4:	f7ec fe10 	bl	8040ae8 <__aeabi_dcmpeq>
 8053ec8:	b100      	cbz	r0, 8053ecc <_vfprintf_r+0x95c>
 8053eca:	9620      	str	r6, [sp, #128]	; 0x80
 8053ecc:	2230      	movs	r2, #48	; 0x30
 8053ece:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8053ed0:	429e      	cmp	r6, r3
 8053ed2:	d9da      	bls.n	8053e8a <_vfprintf_r+0x91a>
 8053ed4:	1c59      	adds	r1, r3, #1
 8053ed6:	9120      	str	r1, [sp, #128]	; 0x80
 8053ed8:	701a      	strb	r2, [r3, #0]
 8053eda:	e7f8      	b.n	8053ece <_vfprintf_r+0x95e>
 8053edc:	9b08      	ldr	r3, [sp, #32]
 8053ede:	2b46      	cmp	r3, #70	; 0x46
 8053ee0:	f47f ae51 	bne.w	8053b86 <_vfprintf_r+0x616>
 8053ee4:	f00b 0301 	and.w	r3, fp, #1
 8053ee8:	2d00      	cmp	r5, #0
 8053eea:	ea43 0308 	orr.w	r3, r3, r8
 8053eee:	dd18      	ble.n	8053f22 <_vfprintf_r+0x9b2>
 8053ef0:	b383      	cbz	r3, 8053f54 <_vfprintf_r+0x9e4>
 8053ef2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053ef4:	18eb      	adds	r3, r5, r3
 8053ef6:	4498      	add	r8, r3
 8053ef8:	2366      	movs	r3, #102	; 0x66
 8053efa:	9307      	str	r3, [sp, #28]
 8053efc:	e030      	b.n	8053f60 <_vfprintf_r+0x9f0>
 8053efe:	f813 6b01 	ldrb.w	r6, [r3], #1
 8053f02:	f802 6b01 	strb.w	r6, [r2], #1
 8053f06:	e675      	b.n	8053bf4 <_vfprintf_r+0x684>
 8053f08:	b941      	cbnz	r1, 8053f1c <_vfprintf_r+0x9ac>
 8053f0a:	2230      	movs	r2, #48	; 0x30
 8053f0c:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8053f10:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8053f14:	3330      	adds	r3, #48	; 0x30
 8053f16:	f802 3b01 	strb.w	r3, [r2], #1
 8053f1a:	e677      	b.n	8053c0c <_vfprintf_r+0x69c>
 8053f1c:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8053f20:	e7f8      	b.n	8053f14 <_vfprintf_r+0x9a4>
 8053f22:	b1cb      	cbz	r3, 8053f58 <_vfprintf_r+0x9e8>
 8053f24:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053f26:	3301      	adds	r3, #1
 8053f28:	e7e5      	b.n	8053ef6 <_vfprintf_r+0x986>
 8053f2a:	9b05      	ldr	r3, [sp, #20]
 8053f2c:	429d      	cmp	r5, r3
 8053f2e:	db07      	blt.n	8053f40 <_vfprintf_r+0x9d0>
 8053f30:	f01b 0f01 	tst.w	fp, #1
 8053f34:	d029      	beq.n	8053f8a <_vfprintf_r+0xa1a>
 8053f36:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8053f38:	eb05 0803 	add.w	r8, r5, r3
 8053f3c:	2367      	movs	r3, #103	; 0x67
 8053f3e:	e7dc      	b.n	8053efa <_vfprintf_r+0x98a>
 8053f40:	9b05      	ldr	r3, [sp, #20]
 8053f42:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8053f44:	2d00      	cmp	r5, #0
 8053f46:	eb03 0802 	add.w	r8, r3, r2
 8053f4a:	dcf7      	bgt.n	8053f3c <_vfprintf_r+0x9cc>
 8053f4c:	f1c5 0301 	rsb	r3, r5, #1
 8053f50:	4498      	add	r8, r3
 8053f52:	e7f3      	b.n	8053f3c <_vfprintf_r+0x9cc>
 8053f54:	46a8      	mov	r8, r5
 8053f56:	e7cf      	b.n	8053ef8 <_vfprintf_r+0x988>
 8053f58:	2366      	movs	r3, #102	; 0x66
 8053f5a:	9307      	str	r3, [sp, #28]
 8053f5c:	f04f 0801 	mov.w	r8, #1
 8053f60:	f41b 6380 	ands.w	r3, fp, #1024	; 0x400
 8053f64:	9309      	str	r3, [sp, #36]	; 0x24
 8053f66:	d023      	beq.n	8053fb0 <_vfprintf_r+0xa40>
 8053f68:	2300      	movs	r3, #0
 8053f6a:	2d00      	cmp	r5, #0
 8053f6c:	e9cd 3308 	strd	r3, r3, [sp, #32]
 8053f70:	f77f ae62 	ble.w	8053c38 <_vfprintf_r+0x6c8>
 8053f74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053f76:	781b      	ldrb	r3, [r3, #0]
 8053f78:	2bff      	cmp	r3, #255	; 0xff
 8053f7a:	d108      	bne.n	8053f8e <_vfprintf_r+0xa1e>
 8053f7c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8053f80:	4413      	add	r3, r2
 8053f82:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8053f84:	fb02 8803 	mla	r8, r2, r3, r8
 8053f88:	e656      	b.n	8053c38 <_vfprintf_r+0x6c8>
 8053f8a:	46a8      	mov	r8, r5
 8053f8c:	e7d6      	b.n	8053f3c <_vfprintf_r+0x9cc>
 8053f8e:	42ab      	cmp	r3, r5
 8053f90:	daf4      	bge.n	8053f7c <_vfprintf_r+0xa0c>
 8053f92:	1aed      	subs	r5, r5, r3
 8053f94:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053f96:	785b      	ldrb	r3, [r3, #1]
 8053f98:	b133      	cbz	r3, 8053fa8 <_vfprintf_r+0xa38>
 8053f9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053f9c:	3301      	adds	r3, #1
 8053f9e:	9309      	str	r3, [sp, #36]	; 0x24
 8053fa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8053fa2:	3301      	adds	r3, #1
 8053fa4:	930a      	str	r3, [sp, #40]	; 0x28
 8053fa6:	e7e5      	b.n	8053f74 <_vfprintf_r+0xa04>
 8053fa8:	9b08      	ldr	r3, [sp, #32]
 8053faa:	3301      	adds	r3, #1
 8053fac:	9308      	str	r3, [sp, #32]
 8053fae:	e7e1      	b.n	8053f74 <_vfprintf_r+0xa04>
 8053fb0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8053fb2:	9308      	str	r3, [sp, #32]
 8053fb4:	e640      	b.n	8053c38 <_vfprintf_r+0x6c8>
 8053fb6:	4632      	mov	r2, r6
 8053fb8:	f01b 0f20 	tst.w	fp, #32
 8053fbc:	f852 3b04 	ldr.w	r3, [r2], #4
 8053fc0:	9206      	str	r2, [sp, #24]
 8053fc2:	d009      	beq.n	8053fd8 <_vfprintf_r+0xa68>
 8053fc4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053fc6:	4610      	mov	r0, r2
 8053fc8:	17d1      	asrs	r1, r2, #31
 8053fca:	e9c3 0100 	strd	r0, r1, [r3]
 8053fce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8053fd0:	9e06      	ldr	r6, [sp, #24]
 8053fd2:	9303      	str	r3, [sp, #12]
 8053fd4:	f7ff bb4f 	b.w	8053676 <_vfprintf_r+0x106>
 8053fd8:	f01b 0f10 	tst.w	fp, #16
 8053fdc:	d002      	beq.n	8053fe4 <_vfprintf_r+0xa74>
 8053fde:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053fe0:	601a      	str	r2, [r3, #0]
 8053fe2:	e7f4      	b.n	8053fce <_vfprintf_r+0xa5e>
 8053fe4:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8053fe8:	d002      	beq.n	8053ff0 <_vfprintf_r+0xa80>
 8053fea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053fec:	801a      	strh	r2, [r3, #0]
 8053fee:	e7ee      	b.n	8053fce <_vfprintf_r+0xa5e>
 8053ff0:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8053ff4:	d0f3      	beq.n	8053fde <_vfprintf_r+0xa6e>
 8053ff6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8053ff8:	701a      	strb	r2, [r3, #0]
 8053ffa:	e7e8      	b.n	8053fce <_vfprintf_r+0xa5e>
 8053ffc:	f04b 0b10 	orr.w	fp, fp, #16
 8054000:	f01b 0f20 	tst.w	fp, #32
 8054004:	d01e      	beq.n	8054044 <_vfprintf_r+0xad4>
 8054006:	3607      	adds	r6, #7
 8054008:	f026 0307 	bic.w	r3, r6, #7
 805400c:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8054010:	9306      	str	r3, [sp, #24]
 8054012:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8054016:	2300      	movs	r3, #0
 8054018:	2200      	movs	r2, #0
 805401a:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 805401e:	f1b8 3fff 	cmp.w	r8, #4294967295
 8054022:	f000 84a9 	beq.w	8054978 <_vfprintf_r+0x1408>
 8054026:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
 805402a:	9204      	str	r2, [sp, #16]
 805402c:	ea56 0207 	orrs.w	r2, r6, r7
 8054030:	f040 84a8 	bne.w	8054984 <_vfprintf_r+0x1414>
 8054034:	f1b8 0f00 	cmp.w	r8, #0
 8054038:	f000 8104 	beq.w	8054244 <_vfprintf_r+0xcd4>
 805403c:	2b01      	cmp	r3, #1
 805403e:	f040 84a4 	bne.w	805498a <_vfprintf_r+0x141a>
 8054042:	e09a      	b.n	805417a <_vfprintf_r+0xc0a>
 8054044:	1d33      	adds	r3, r6, #4
 8054046:	f01b 0f10 	tst.w	fp, #16
 805404a:	9306      	str	r3, [sp, #24]
 805404c:	d001      	beq.n	8054052 <_vfprintf_r+0xae2>
 805404e:	6836      	ldr	r6, [r6, #0]
 8054050:	e003      	b.n	805405a <_vfprintf_r+0xaea>
 8054052:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8054056:	d002      	beq.n	805405e <_vfprintf_r+0xaee>
 8054058:	8836      	ldrh	r6, [r6, #0]
 805405a:	2700      	movs	r7, #0
 805405c:	e7d9      	b.n	8054012 <_vfprintf_r+0xaa2>
 805405e:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8054062:	d0f4      	beq.n	805404e <_vfprintf_r+0xade>
 8054064:	7836      	ldrb	r6, [r6, #0]
 8054066:	e7f8      	b.n	805405a <_vfprintf_r+0xaea>
 8054068:	4633      	mov	r3, r6
 805406a:	2278      	movs	r2, #120	; 0x78
 805406c:	f853 6b04 	ldr.w	r6, [r3], #4
 8054070:	9306      	str	r3, [sp, #24]
 8054072:	f647 0330 	movw	r3, #30768	; 0x7830
 8054076:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 805407a:	4ba8      	ldr	r3, [pc, #672]	; (805431c <_vfprintf_r+0xdac>)
 805407c:	9316      	str	r3, [sp, #88]	; 0x58
 805407e:	2700      	movs	r7, #0
 8054080:	f04b 0b02 	orr.w	fp, fp, #2
 8054084:	2302      	movs	r3, #2
 8054086:	9207      	str	r2, [sp, #28]
 8054088:	e7c6      	b.n	8054018 <_vfprintf_r+0xaa8>
 805408a:	4632      	mov	r2, r6
 805408c:	2500      	movs	r5, #0
 805408e:	f852 3b04 	ldr.w	r3, [r2], #4
 8054092:	9303      	str	r3, [sp, #12]
 8054094:	f1b8 3fff 	cmp.w	r8, #4294967295
 8054098:	9206      	str	r2, [sp, #24]
 805409a:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 805409e:	d010      	beq.n	80540c2 <_vfprintf_r+0xb52>
 80540a0:	9803      	ldr	r0, [sp, #12]
 80540a2:	4642      	mov	r2, r8
 80540a4:	4629      	mov	r1, r5
 80540a6:	f7ec f8ab 	bl	8040200 <memchr>
 80540aa:	9004      	str	r0, [sp, #16]
 80540ac:	2800      	cmp	r0, #0
 80540ae:	f000 80df 	beq.w	8054270 <_vfprintf_r+0xd00>
 80540b2:	9a03      	ldr	r2, [sp, #12]
 80540b4:	9504      	str	r5, [sp, #16]
 80540b6:	e9cd 5508 	strd	r5, r5, [sp, #32]
 80540ba:	eba0 0802 	sub.w	r8, r0, r2
 80540be:	462e      	mov	r6, r5
 80540c0:	e5c2      	b.n	8053c48 <_vfprintf_r+0x6d8>
 80540c2:	9803      	ldr	r0, [sp, #12]
 80540c4:	f7ec f894 	bl	80401f0 <strlen>
 80540c8:	462e      	mov	r6, r5
 80540ca:	4680      	mov	r8, r0
 80540cc:	9504      	str	r5, [sp, #16]
 80540ce:	4633      	mov	r3, r6
 80540d0:	e45e      	b.n	8053990 <_vfprintf_r+0x420>
 80540d2:	f04b 0b10 	orr.w	fp, fp, #16
 80540d6:	f01b 0f20 	tst.w	fp, #32
 80540da:	d007      	beq.n	80540ec <_vfprintf_r+0xb7c>
 80540dc:	3607      	adds	r6, #7
 80540de:	f026 0307 	bic.w	r3, r6, #7
 80540e2:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 80540e6:	9306      	str	r3, [sp, #24]
 80540e8:	2301      	movs	r3, #1
 80540ea:	e795      	b.n	8054018 <_vfprintf_r+0xaa8>
 80540ec:	1d33      	adds	r3, r6, #4
 80540ee:	f01b 0f10 	tst.w	fp, #16
 80540f2:	9306      	str	r3, [sp, #24]
 80540f4:	d001      	beq.n	80540fa <_vfprintf_r+0xb8a>
 80540f6:	6836      	ldr	r6, [r6, #0]
 80540f8:	e003      	b.n	8054102 <_vfprintf_r+0xb92>
 80540fa:	f01b 0f40 	tst.w	fp, #64	; 0x40
 80540fe:	d002      	beq.n	8054106 <_vfprintf_r+0xb96>
 8054100:	8836      	ldrh	r6, [r6, #0]
 8054102:	2700      	movs	r7, #0
 8054104:	e7f0      	b.n	80540e8 <_vfprintf_r+0xb78>
 8054106:	f41b 7f00 	tst.w	fp, #512	; 0x200
 805410a:	d0f4      	beq.n	80540f6 <_vfprintf_r+0xb86>
 805410c:	7836      	ldrb	r6, [r6, #0]
 805410e:	e7f8      	b.n	8054102 <_vfprintf_r+0xb92>
 8054110:	4b83      	ldr	r3, [pc, #524]	; (8054320 <_vfprintf_r+0xdb0>)
 8054112:	9316      	str	r3, [sp, #88]	; 0x58
 8054114:	f01b 0f20 	tst.w	fp, #32
 8054118:	d019      	beq.n	805414e <_vfprintf_r+0xbde>
 805411a:	3607      	adds	r6, #7
 805411c:	f026 0307 	bic.w	r3, r6, #7
 8054120:	e8f3 6702 	ldrd	r6, r7, [r3], #8
 8054124:	9306      	str	r3, [sp, #24]
 8054126:	f01b 0f01 	tst.w	fp, #1
 805412a:	d00a      	beq.n	8054142 <_vfprintf_r+0xbd2>
 805412c:	ea56 0307 	orrs.w	r3, r6, r7
 8054130:	d007      	beq.n	8054142 <_vfprintf_r+0xbd2>
 8054132:	2330      	movs	r3, #48	; 0x30
 8054134:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8054138:	9b07      	ldr	r3, [sp, #28]
 805413a:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 805413e:	f04b 0b02 	orr.w	fp, fp, #2
 8054142:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8054146:	2302      	movs	r3, #2
 8054148:	e766      	b.n	8054018 <_vfprintf_r+0xaa8>
 805414a:	4b74      	ldr	r3, [pc, #464]	; (805431c <_vfprintf_r+0xdac>)
 805414c:	e7e1      	b.n	8054112 <_vfprintf_r+0xba2>
 805414e:	1d33      	adds	r3, r6, #4
 8054150:	f01b 0f10 	tst.w	fp, #16
 8054154:	9306      	str	r3, [sp, #24]
 8054156:	d001      	beq.n	805415c <_vfprintf_r+0xbec>
 8054158:	6836      	ldr	r6, [r6, #0]
 805415a:	e003      	b.n	8054164 <_vfprintf_r+0xbf4>
 805415c:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8054160:	d002      	beq.n	8054168 <_vfprintf_r+0xbf8>
 8054162:	8836      	ldrh	r6, [r6, #0]
 8054164:	2700      	movs	r7, #0
 8054166:	e7de      	b.n	8054126 <_vfprintf_r+0xbb6>
 8054168:	f41b 7f00 	tst.w	fp, #512	; 0x200
 805416c:	d0f4      	beq.n	8054158 <_vfprintf_r+0xbe8>
 805416e:	7836      	ldrb	r6, [r6, #0]
 8054170:	e7f8      	b.n	8054164 <_vfprintf_r+0xbf4>
 8054172:	2f00      	cmp	r7, #0
 8054174:	bf08      	it	eq
 8054176:	2e0a      	cmpeq	r6, #10
 8054178:	d206      	bcs.n	8054188 <_vfprintf_r+0xc18>
 805417a:	3630      	adds	r6, #48	; 0x30
 805417c:	f88d 6137 	strb.w	r6, [sp, #311]	; 0x137
 8054180:	f20d 1337 	addw	r3, sp, #311	; 0x137
 8054184:	f000 bc23 	b.w	80549ce <_vfprintf_r+0x145e>
 8054188:	2300      	movs	r3, #0
 805418a:	9305      	str	r3, [sp, #20]
 805418c:	9b04      	ldr	r3, [sp, #16]
 805418e:	ad4e      	add	r5, sp, #312	; 0x138
 8054190:	f403 6b80 	and.w	fp, r3, #1024	; 0x400
 8054194:	1e6b      	subs	r3, r5, #1
 8054196:	9303      	str	r3, [sp, #12]
 8054198:	220a      	movs	r2, #10
 805419a:	2300      	movs	r3, #0
 805419c:	4630      	mov	r0, r6
 805419e:	4639      	mov	r1, r7
 80541a0:	f7ec fd82 	bl	8040ca8 <__aeabi_uldivmod>
 80541a4:	9b05      	ldr	r3, [sp, #20]
 80541a6:	3230      	adds	r2, #48	; 0x30
 80541a8:	3301      	adds	r3, #1
 80541aa:	f805 2c01 	strb.w	r2, [r5, #-1]
 80541ae:	9305      	str	r3, [sp, #20]
 80541b0:	f1bb 0f00 	cmp.w	fp, #0
 80541b4:	d019      	beq.n	80541ea <_vfprintf_r+0xc7a>
 80541b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80541b8:	9a05      	ldr	r2, [sp, #20]
 80541ba:	781b      	ldrb	r3, [r3, #0]
 80541bc:	429a      	cmp	r2, r3
 80541be:	d114      	bne.n	80541ea <_vfprintf_r+0xc7a>
 80541c0:	2aff      	cmp	r2, #255	; 0xff
 80541c2:	d012      	beq.n	80541ea <_vfprintf_r+0xc7a>
 80541c4:	2f00      	cmp	r7, #0
 80541c6:	bf08      	it	eq
 80541c8:	2e0a      	cmpeq	r6, #10
 80541ca:	d30e      	bcc.n	80541ea <_vfprintf_r+0xc7a>
 80541cc:	9b03      	ldr	r3, [sp, #12]
 80541ce:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80541d0:	9914      	ldr	r1, [sp, #80]	; 0x50
 80541d2:	1a9b      	subs	r3, r3, r2
 80541d4:	4618      	mov	r0, r3
 80541d6:	9303      	str	r3, [sp, #12]
 80541d8:	f7fd f880 	bl	80512dc <strncpy>
 80541dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80541de:	785d      	ldrb	r5, [r3, #1]
 80541e0:	b1e5      	cbz	r5, 805421c <_vfprintf_r+0xcac>
 80541e2:	3301      	adds	r3, #1
 80541e4:	930a      	str	r3, [sp, #40]	; 0x28
 80541e6:	2300      	movs	r3, #0
 80541e8:	9305      	str	r3, [sp, #20]
 80541ea:	220a      	movs	r2, #10
 80541ec:	2300      	movs	r3, #0
 80541ee:	4630      	mov	r0, r6
 80541f0:	4639      	mov	r1, r7
 80541f2:	f7ec fd59 	bl	8040ca8 <__aeabi_uldivmod>
 80541f6:	2f00      	cmp	r7, #0
 80541f8:	bf08      	it	eq
 80541fa:	2e0a      	cmpeq	r6, #10
 80541fc:	d20a      	bcs.n	8054214 <_vfprintf_r+0xca4>
 80541fe:	9b03      	ldr	r3, [sp, #12]
 8054200:	f8dd b010 	ldr.w	fp, [sp, #16]
 8054204:	aa4e      	add	r2, sp, #312	; 0x138
 8054206:	4646      	mov	r6, r8
 8054208:	eba2 0803 	sub.w	r8, r2, r3
 805420c:	2300      	movs	r3, #0
 805420e:	9304      	str	r3, [sp, #16]
 8054210:	f7ff bbbe 	b.w	8053990 <_vfprintf_r+0x420>
 8054214:	9d03      	ldr	r5, [sp, #12]
 8054216:	4606      	mov	r6, r0
 8054218:	460f      	mov	r7, r1
 805421a:	e7bb      	b.n	8054194 <_vfprintf_r+0xc24>
 805421c:	9505      	str	r5, [sp, #20]
 805421e:	e7e4      	b.n	80541ea <_vfprintf_r+0xc7a>
 8054220:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8054222:	f006 030f 	and.w	r3, r6, #15
 8054226:	5cd3      	ldrb	r3, [r2, r3]
 8054228:	9a03      	ldr	r2, [sp, #12]
 805422a:	f802 3d01 	strb.w	r3, [r2, #-1]!
 805422e:	0933      	lsrs	r3, r6, #4
 8054230:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
 8054234:	9203      	str	r2, [sp, #12]
 8054236:	093a      	lsrs	r2, r7, #4
 8054238:	461e      	mov	r6, r3
 805423a:	4617      	mov	r7, r2
 805423c:	ea56 0307 	orrs.w	r3, r6, r7
 8054240:	d1ee      	bne.n	8054220 <_vfprintf_r+0xcb0>
 8054242:	e7dc      	b.n	80541fe <_vfprintf_r+0xc8e>
 8054244:	b933      	cbnz	r3, 8054254 <_vfprintf_r+0xce4>
 8054246:	f01b 0f01 	tst.w	fp, #1
 805424a:	d003      	beq.n	8054254 <_vfprintf_r+0xce4>
 805424c:	2330      	movs	r3, #48	; 0x30
 805424e:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 8054252:	e795      	b.n	8054180 <_vfprintf_r+0xc10>
 8054254:	ab4e      	add	r3, sp, #312	; 0x138
 8054256:	e3ba      	b.n	80549ce <_vfprintf_r+0x145e>
 8054258:	9b07      	ldr	r3, [sp, #28]
 805425a:	2b00      	cmp	r3, #0
 805425c:	f000 837d 	beq.w	805495a <_vfprintf_r+0x13ea>
 8054260:	2000      	movs	r0, #0
 8054262:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8054266:	f88d 006b 	strb.w	r0, [sp, #107]	; 0x6b
 805426a:	9606      	str	r6, [sp, #24]
 805426c:	f7ff bb1e 	b.w	80538ac <_vfprintf_r+0x33c>
 8054270:	9e04      	ldr	r6, [sp, #16]
 8054272:	e72c      	b.n	80540ce <_vfprintf_r+0xb5e>
 8054274:	2010      	movs	r0, #16
 8054276:	4402      	add	r2, r0
 8054278:	2b07      	cmp	r3, #7
 805427a:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 805427e:	6060      	str	r0, [r4, #4]
 8054280:	dd08      	ble.n	8054294 <_vfprintf_r+0xd24>
 8054282:	aa22      	add	r2, sp, #136	; 0x88
 8054284:	4649      	mov	r1, r9
 8054286:	4650      	mov	r0, sl
 8054288:	f002 fe88 	bl	8056f9c <__sprint_r>
 805428c:	2800      	cmp	r0, #0
 805428e:	f040 8342 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054292:	a925      	add	r1, sp, #148	; 0x94
 8054294:	3f10      	subs	r7, #16
 8054296:	460c      	mov	r4, r1
 8054298:	e4f1      	b.n	8053c7e <_vfprintf_r+0x70e>
 805429a:	460c      	mov	r4, r1
 805429c:	e50a      	b.n	8053cb4 <_vfprintf_r+0x744>
 805429e:	aa22      	add	r2, sp, #136	; 0x88
 80542a0:	4649      	mov	r1, r9
 80542a2:	4650      	mov	r0, sl
 80542a4:	f002 fe7a 	bl	8056f9c <__sprint_r>
 80542a8:	2800      	cmp	r0, #0
 80542aa:	f040 8334 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80542ae:	ac25      	add	r4, sp, #148	; 0x94
 80542b0:	e512      	b.n	8053cd8 <_vfprintf_r+0x768>
 80542b2:	aa22      	add	r2, sp, #136	; 0x88
 80542b4:	4649      	mov	r1, r9
 80542b6:	4650      	mov	r0, sl
 80542b8:	f002 fe70 	bl	8056f9c <__sprint_r>
 80542bc:	2800      	cmp	r0, #0
 80542be:	f040 832a 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80542c2:	ac25      	add	r4, sp, #148	; 0x94
 80542c4:	e518      	b.n	8053cf8 <_vfprintf_r+0x788>
 80542c6:	2010      	movs	r0, #16
 80542c8:	4402      	add	r2, r0
 80542ca:	2b07      	cmp	r3, #7
 80542cc:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80542d0:	6060      	str	r0, [r4, #4]
 80542d2:	dd08      	ble.n	80542e6 <_vfprintf_r+0xd76>
 80542d4:	aa22      	add	r2, sp, #136	; 0x88
 80542d6:	4649      	mov	r1, r9
 80542d8:	4650      	mov	r0, sl
 80542da:	f002 fe5f 	bl	8056f9c <__sprint_r>
 80542de:	2800      	cmp	r0, #0
 80542e0:	f040 8319 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80542e4:	a925      	add	r1, sp, #148	; 0x94
 80542e6:	3f10      	subs	r7, #16
 80542e8:	460c      	mov	r4, r1
 80542ea:	e50d      	b.n	8053d08 <_vfprintf_r+0x798>
 80542ec:	460c      	mov	r4, r1
 80542ee:	e526      	b.n	8053d3e <_vfprintf_r+0x7ce>
 80542f0:	2010      	movs	r0, #16
 80542f2:	4402      	add	r2, r0
 80542f4:	2b07      	cmp	r3, #7
 80542f6:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80542fa:	6060      	str	r0, [r4, #4]
 80542fc:	dd08      	ble.n	8054310 <_vfprintf_r+0xda0>
 80542fe:	aa22      	add	r2, sp, #136	; 0x88
 8054300:	4649      	mov	r1, r9
 8054302:	4650      	mov	r0, sl
 8054304:	f002 fe4a 	bl	8056f9c <__sprint_r>
 8054308:	2800      	cmp	r0, #0
 805430a:	f040 8304 	bne.w	8054916 <_vfprintf_r+0x13a6>
 805430e:	a925      	add	r1, sp, #148	; 0x94
 8054310:	3e10      	subs	r6, #16
 8054312:	460c      	mov	r4, r1
 8054314:	e518      	b.n	8053d48 <_vfprintf_r+0x7d8>
 8054316:	460c      	mov	r4, r1
 8054318:	e530      	b.n	8053d7c <_vfprintf_r+0x80c>
 805431a:	bf00      	nop
 805431c:	0805a360 	.word	0x0805a360
 8054320:	0805a371 	.word	0x0805a371
 8054324:	9b07      	ldr	r3, [sp, #28]
 8054326:	2b65      	cmp	r3, #101	; 0x65
 8054328:	f340 8242 	ble.w	80547b0 <_vfprintf_r+0x1240>
 805432c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8054330:	2200      	movs	r2, #0
 8054332:	2300      	movs	r3, #0
 8054334:	f7ec fbd8 	bl	8040ae8 <__aeabi_dcmpeq>
 8054338:	2800      	cmp	r0, #0
 805433a:	d068      	beq.n	805440e <_vfprintf_r+0xe9e>
 805433c:	4b6d      	ldr	r3, [pc, #436]	; (80544f4 <_vfprintf_r+0xf84>)
 805433e:	6023      	str	r3, [r4, #0]
 8054340:	2301      	movs	r3, #1
 8054342:	441e      	add	r6, r3
 8054344:	6063      	str	r3, [r4, #4]
 8054346:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054348:	9624      	str	r6, [sp, #144]	; 0x90
 805434a:	3301      	adds	r3, #1
 805434c:	2b07      	cmp	r3, #7
 805434e:	9323      	str	r3, [sp, #140]	; 0x8c
 8054350:	dc37      	bgt.n	80543c2 <_vfprintf_r+0xe52>
 8054352:	3408      	adds	r4, #8
 8054354:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054356:	9a05      	ldr	r2, [sp, #20]
 8054358:	4293      	cmp	r3, r2
 805435a:	db03      	blt.n	8054364 <_vfprintf_r+0xdf4>
 805435c:	f01b 0f01 	tst.w	fp, #1
 8054360:	f43f ad2b 	beq.w	8053dba <_vfprintf_r+0x84a>
 8054364:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8054366:	6023      	str	r3, [r4, #0]
 8054368:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 805436a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 805436c:	6063      	str	r3, [r4, #4]
 805436e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054370:	4413      	add	r3, r2
 8054372:	9324      	str	r3, [sp, #144]	; 0x90
 8054374:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054376:	3301      	adds	r3, #1
 8054378:	2b07      	cmp	r3, #7
 805437a:	9323      	str	r3, [sp, #140]	; 0x8c
 805437c:	dc2b      	bgt.n	80543d6 <_vfprintf_r+0xe66>
 805437e:	3408      	adds	r4, #8
 8054380:	9b05      	ldr	r3, [sp, #20]
 8054382:	1e5d      	subs	r5, r3, #1
 8054384:	2d00      	cmp	r5, #0
 8054386:	f77f ad18 	ble.w	8053dba <_vfprintf_r+0x84a>
 805438a:	4e5b      	ldr	r6, [pc, #364]	; (80544f8 <_vfprintf_r+0xf88>)
 805438c:	2710      	movs	r7, #16
 805438e:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054392:	2d10      	cmp	r5, #16
 8054394:	f103 0301 	add.w	r3, r3, #1
 8054398:	f104 0108 	add.w	r1, r4, #8
 805439c:	6026      	str	r6, [r4, #0]
 805439e:	dc24      	bgt.n	80543ea <_vfprintf_r+0xe7a>
 80543a0:	6065      	str	r5, [r4, #4]
 80543a2:	2b07      	cmp	r3, #7
 80543a4:	4415      	add	r5, r2
 80543a6:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 80543aa:	f340 8293 	ble.w	80548d4 <_vfprintf_r+0x1364>
 80543ae:	aa22      	add	r2, sp, #136	; 0x88
 80543b0:	4649      	mov	r1, r9
 80543b2:	4650      	mov	r0, sl
 80543b4:	f002 fdf2 	bl	8056f9c <__sprint_r>
 80543b8:	2800      	cmp	r0, #0
 80543ba:	f040 82ac 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80543be:	ac25      	add	r4, sp, #148	; 0x94
 80543c0:	e4fb      	b.n	8053dba <_vfprintf_r+0x84a>
 80543c2:	aa22      	add	r2, sp, #136	; 0x88
 80543c4:	4649      	mov	r1, r9
 80543c6:	4650      	mov	r0, sl
 80543c8:	f002 fde8 	bl	8056f9c <__sprint_r>
 80543cc:	2800      	cmp	r0, #0
 80543ce:	f040 82a2 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80543d2:	ac25      	add	r4, sp, #148	; 0x94
 80543d4:	e7be      	b.n	8054354 <_vfprintf_r+0xde4>
 80543d6:	aa22      	add	r2, sp, #136	; 0x88
 80543d8:	4649      	mov	r1, r9
 80543da:	4650      	mov	r0, sl
 80543dc:	f002 fdde 	bl	8056f9c <__sprint_r>
 80543e0:	2800      	cmp	r0, #0
 80543e2:	f040 8298 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80543e6:	ac25      	add	r4, sp, #148	; 0x94
 80543e8:	e7ca      	b.n	8054380 <_vfprintf_r+0xe10>
 80543ea:	3210      	adds	r2, #16
 80543ec:	2b07      	cmp	r3, #7
 80543ee:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80543f2:	6067      	str	r7, [r4, #4]
 80543f4:	dd08      	ble.n	8054408 <_vfprintf_r+0xe98>
 80543f6:	aa22      	add	r2, sp, #136	; 0x88
 80543f8:	4649      	mov	r1, r9
 80543fa:	4650      	mov	r0, sl
 80543fc:	f002 fdce 	bl	8056f9c <__sprint_r>
 8054400:	2800      	cmp	r0, #0
 8054402:	f040 8288 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054406:	a925      	add	r1, sp, #148	; 0x94
 8054408:	3d10      	subs	r5, #16
 805440a:	460c      	mov	r4, r1
 805440c:	e7bf      	b.n	805438e <_vfprintf_r+0xe1e>
 805440e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054410:	2b00      	cmp	r3, #0
 8054412:	dc73      	bgt.n	80544fc <_vfprintf_r+0xf8c>
 8054414:	4b37      	ldr	r3, [pc, #220]	; (80544f4 <_vfprintf_r+0xf84>)
 8054416:	6023      	str	r3, [r4, #0]
 8054418:	2301      	movs	r3, #1
 805441a:	441e      	add	r6, r3
 805441c:	6063      	str	r3, [r4, #4]
 805441e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054420:	9624      	str	r6, [sp, #144]	; 0x90
 8054422:	3301      	adds	r3, #1
 8054424:	2b07      	cmp	r3, #7
 8054426:	9323      	str	r3, [sp, #140]	; 0x8c
 8054428:	dc3d      	bgt.n	80544a6 <_vfprintf_r+0xf36>
 805442a:	3408      	adds	r4, #8
 805442c:	9905      	ldr	r1, [sp, #20]
 805442e:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 8054430:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054432:	430a      	orrs	r2, r1
 8054434:	f00b 0101 	and.w	r1, fp, #1
 8054438:	430a      	orrs	r2, r1
 805443a:	f43f acbe 	beq.w	8053dba <_vfprintf_r+0x84a>
 805443e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8054440:	6022      	str	r2, [r4, #0]
 8054442:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8054444:	6062      	str	r2, [r4, #4]
 8054446:	4413      	add	r3, r2
 8054448:	9324      	str	r3, [sp, #144]	; 0x90
 805444a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805444c:	3301      	adds	r3, #1
 805444e:	2b07      	cmp	r3, #7
 8054450:	9323      	str	r3, [sp, #140]	; 0x8c
 8054452:	dc32      	bgt.n	80544ba <_vfprintf_r+0xf4a>
 8054454:	3408      	adds	r4, #8
 8054456:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 8054458:	2d00      	cmp	r5, #0
 805445a:	da1b      	bge.n	8054494 <_vfprintf_r+0xf24>
 805445c:	4e26      	ldr	r6, [pc, #152]	; (80544f8 <_vfprintf_r+0xf88>)
 805445e:	426d      	negs	r5, r5
 8054460:	4623      	mov	r3, r4
 8054462:	2710      	movs	r7, #16
 8054464:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 8054468:	2d10      	cmp	r5, #16
 805446a:	f102 0201 	add.w	r2, r2, #1
 805446e:	f104 0408 	add.w	r4, r4, #8
 8054472:	601e      	str	r6, [r3, #0]
 8054474:	dc2b      	bgt.n	80544ce <_vfprintf_r+0xf5e>
 8054476:	605d      	str	r5, [r3, #4]
 8054478:	2a07      	cmp	r2, #7
 805447a:	440d      	add	r5, r1
 805447c:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 8054480:	dd08      	ble.n	8054494 <_vfprintf_r+0xf24>
 8054482:	aa22      	add	r2, sp, #136	; 0x88
 8054484:	4649      	mov	r1, r9
 8054486:	4650      	mov	r0, sl
 8054488:	f002 fd88 	bl	8056f9c <__sprint_r>
 805448c:	2800      	cmp	r0, #0
 805448e:	f040 8242 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054492:	ac25      	add	r4, sp, #148	; 0x94
 8054494:	9b03      	ldr	r3, [sp, #12]
 8054496:	6023      	str	r3, [r4, #0]
 8054498:	9b05      	ldr	r3, [sp, #20]
 805449a:	9a05      	ldr	r2, [sp, #20]
 805449c:	6063      	str	r3, [r4, #4]
 805449e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80544a0:	4413      	add	r3, r2
 80544a2:	9324      	str	r3, [sp, #144]	; 0x90
 80544a4:	e482      	b.n	8053dac <_vfprintf_r+0x83c>
 80544a6:	aa22      	add	r2, sp, #136	; 0x88
 80544a8:	4649      	mov	r1, r9
 80544aa:	4650      	mov	r0, sl
 80544ac:	f002 fd76 	bl	8056f9c <__sprint_r>
 80544b0:	2800      	cmp	r0, #0
 80544b2:	f040 8230 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80544b6:	ac25      	add	r4, sp, #148	; 0x94
 80544b8:	e7b8      	b.n	805442c <_vfprintf_r+0xebc>
 80544ba:	aa22      	add	r2, sp, #136	; 0x88
 80544bc:	4649      	mov	r1, r9
 80544be:	4650      	mov	r0, sl
 80544c0:	f002 fd6c 	bl	8056f9c <__sprint_r>
 80544c4:	2800      	cmp	r0, #0
 80544c6:	f040 8226 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80544ca:	ac25      	add	r4, sp, #148	; 0x94
 80544cc:	e7c3      	b.n	8054456 <_vfprintf_r+0xee6>
 80544ce:	3110      	adds	r1, #16
 80544d0:	2a07      	cmp	r2, #7
 80544d2:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 80544d6:	605f      	str	r7, [r3, #4]
 80544d8:	dd08      	ble.n	80544ec <_vfprintf_r+0xf7c>
 80544da:	aa22      	add	r2, sp, #136	; 0x88
 80544dc:	4649      	mov	r1, r9
 80544de:	4650      	mov	r0, sl
 80544e0:	f002 fd5c 	bl	8056f9c <__sprint_r>
 80544e4:	2800      	cmp	r0, #0
 80544e6:	f040 8216 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80544ea:	ac25      	add	r4, sp, #148	; 0x94
 80544ec:	3d10      	subs	r5, #16
 80544ee:	4623      	mov	r3, r4
 80544f0:	e7b8      	b.n	8054464 <_vfprintf_r+0xef4>
 80544f2:	bf00      	nop
 80544f4:	0805a382 	.word	0x0805a382
 80544f8:	0805a3d9 	.word	0x0805a3d9
 80544fc:	9b05      	ldr	r3, [sp, #20]
 80544fe:	42ab      	cmp	r3, r5
 8054500:	bfa8      	it	ge
 8054502:	462b      	movge	r3, r5
 8054504:	2b00      	cmp	r3, #0
 8054506:	461f      	mov	r7, r3
 8054508:	dd0b      	ble.n	8054522 <_vfprintf_r+0xfb2>
 805450a:	9b03      	ldr	r3, [sp, #12]
 805450c:	e9c4 3700 	strd	r3, r7, [r4]
 8054510:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054512:	3301      	adds	r3, #1
 8054514:	443e      	add	r6, r7
 8054516:	2b07      	cmp	r3, #7
 8054518:	9624      	str	r6, [sp, #144]	; 0x90
 805451a:	9323      	str	r3, [sp, #140]	; 0x8c
 805451c:	f300 808c 	bgt.w	8054638 <_vfprintf_r+0x10c8>
 8054520:	3408      	adds	r4, #8
 8054522:	2f00      	cmp	r7, #0
 8054524:	bfac      	ite	ge
 8054526:	1bee      	subge	r6, r5, r7
 8054528:	462e      	movlt	r6, r5
 805452a:	2e00      	cmp	r6, #0
 805452c:	dd1c      	ble.n	8054568 <_vfprintf_r+0xff8>
 805452e:	4f9f      	ldr	r7, [pc, #636]	; (80547ac <_vfprintf_r+0x123c>)
 8054530:	f04f 0810 	mov.w	r8, #16
 8054534:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054538:	2e10      	cmp	r6, #16
 805453a:	f103 0301 	add.w	r3, r3, #1
 805453e:	f104 0108 	add.w	r1, r4, #8
 8054542:	6027      	str	r7, [r4, #0]
 8054544:	f300 8082 	bgt.w	805464c <_vfprintf_r+0x10dc>
 8054548:	6066      	str	r6, [r4, #4]
 805454a:	2b07      	cmp	r3, #7
 805454c:	4416      	add	r6, r2
 805454e:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 8054552:	f340 808e 	ble.w	8054672 <_vfprintf_r+0x1102>
 8054556:	aa22      	add	r2, sp, #136	; 0x88
 8054558:	4649      	mov	r1, r9
 805455a:	4650      	mov	r0, sl
 805455c:	f002 fd1e 	bl	8056f9c <__sprint_r>
 8054560:	2800      	cmp	r0, #0
 8054562:	f040 81d8 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054566:	ac25      	add	r4, sp, #148	; 0x94
 8054568:	9b03      	ldr	r3, [sp, #12]
 805456a:	f41b 6f80 	tst.w	fp, #1024	; 0x400
 805456e:	441d      	add	r5, r3
 8054570:	d00d      	beq.n	805458e <_vfprintf_r+0x101e>
 8054572:	4e8e      	ldr	r6, [pc, #568]	; (80547ac <_vfprintf_r+0x123c>)
 8054574:	2710      	movs	r7, #16
 8054576:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054578:	2b00      	cmp	r3, #0
 805457a:	d17c      	bne.n	8054676 <_vfprintf_r+0x1106>
 805457c:	9b08      	ldr	r3, [sp, #32]
 805457e:	2b00      	cmp	r3, #0
 8054580:	d17c      	bne.n	805467c <_vfprintf_r+0x110c>
 8054582:	9b03      	ldr	r3, [sp, #12]
 8054584:	9a05      	ldr	r2, [sp, #20]
 8054586:	4413      	add	r3, r2
 8054588:	429d      	cmp	r5, r3
 805458a:	bf28      	it	cs
 805458c:	461d      	movcs	r5, r3
 805458e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8054590:	9a05      	ldr	r2, [sp, #20]
 8054592:	4293      	cmp	r3, r2
 8054594:	db02      	blt.n	805459c <_vfprintf_r+0x102c>
 8054596:	f01b 0f01 	tst.w	fp, #1
 805459a:	d00e      	beq.n	80545ba <_vfprintf_r+0x104a>
 805459c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 805459e:	6023      	str	r3, [r4, #0]
 80545a0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80545a2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80545a4:	6063      	str	r3, [r4, #4]
 80545a6:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80545a8:	4413      	add	r3, r2
 80545aa:	9324      	str	r3, [sp, #144]	; 0x90
 80545ac:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80545ae:	3301      	adds	r3, #1
 80545b0:	2b07      	cmp	r3, #7
 80545b2:	9323      	str	r3, [sp, #140]	; 0x8c
 80545b4:	f300 80e5 	bgt.w	8054782 <_vfprintf_r+0x1212>
 80545b8:	3408      	adds	r4, #8
 80545ba:	9905      	ldr	r1, [sp, #20]
 80545bc:	9b03      	ldr	r3, [sp, #12]
 80545be:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 80545c0:	440b      	add	r3, r1
 80545c2:	1b8e      	subs	r6, r1, r6
 80545c4:	1b5a      	subs	r2, r3, r5
 80545c6:	4296      	cmp	r6, r2
 80545c8:	bfa8      	it	ge
 80545ca:	4616      	movge	r6, r2
 80545cc:	2e00      	cmp	r6, #0
 80545ce:	dd0b      	ble.n	80545e8 <_vfprintf_r+0x1078>
 80545d0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80545d2:	4433      	add	r3, r6
 80545d4:	9324      	str	r3, [sp, #144]	; 0x90
 80545d6:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80545d8:	3301      	adds	r3, #1
 80545da:	2b07      	cmp	r3, #7
 80545dc:	e9c4 5600 	strd	r5, r6, [r4]
 80545e0:	9323      	str	r3, [sp, #140]	; 0x8c
 80545e2:	f300 80d8 	bgt.w	8054796 <_vfprintf_r+0x1226>
 80545e6:	3408      	adds	r4, #8
 80545e8:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80545ea:	9b05      	ldr	r3, [sp, #20]
 80545ec:	2e00      	cmp	r6, #0
 80545ee:	eba3 0505 	sub.w	r5, r3, r5
 80545f2:	bfa8      	it	ge
 80545f4:	1bad      	subge	r5, r5, r6
 80545f6:	2d00      	cmp	r5, #0
 80545f8:	f77f abdf 	ble.w	8053dba <_vfprintf_r+0x84a>
 80545fc:	4e6b      	ldr	r6, [pc, #428]	; (80547ac <_vfprintf_r+0x123c>)
 80545fe:	2710      	movs	r7, #16
 8054600:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8054604:	2d10      	cmp	r5, #16
 8054606:	f103 0301 	add.w	r3, r3, #1
 805460a:	f104 0108 	add.w	r1, r4, #8
 805460e:	6026      	str	r6, [r4, #0]
 8054610:	f77f aec6 	ble.w	80543a0 <_vfprintf_r+0xe30>
 8054614:	3210      	adds	r2, #16
 8054616:	2b07      	cmp	r3, #7
 8054618:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 805461c:	6067      	str	r7, [r4, #4]
 805461e:	dd08      	ble.n	8054632 <_vfprintf_r+0x10c2>
 8054620:	aa22      	add	r2, sp, #136	; 0x88
 8054622:	4649      	mov	r1, r9
 8054624:	4650      	mov	r0, sl
 8054626:	f002 fcb9 	bl	8056f9c <__sprint_r>
 805462a:	2800      	cmp	r0, #0
 805462c:	f040 8173 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054630:	a925      	add	r1, sp, #148	; 0x94
 8054632:	3d10      	subs	r5, #16
 8054634:	460c      	mov	r4, r1
 8054636:	e7e3      	b.n	8054600 <_vfprintf_r+0x1090>
 8054638:	aa22      	add	r2, sp, #136	; 0x88
 805463a:	4649      	mov	r1, r9
 805463c:	4650      	mov	r0, sl
 805463e:	f002 fcad 	bl	8056f9c <__sprint_r>
 8054642:	2800      	cmp	r0, #0
 8054644:	f040 8167 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054648:	ac25      	add	r4, sp, #148	; 0x94
 805464a:	e76a      	b.n	8054522 <_vfprintf_r+0xfb2>
 805464c:	3210      	adds	r2, #16
 805464e:	2b07      	cmp	r3, #7
 8054650:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054654:	f8c4 8004 	str.w	r8, [r4, #4]
 8054658:	dd08      	ble.n	805466c <_vfprintf_r+0x10fc>
 805465a:	aa22      	add	r2, sp, #136	; 0x88
 805465c:	4649      	mov	r1, r9
 805465e:	4650      	mov	r0, sl
 8054660:	f002 fc9c 	bl	8056f9c <__sprint_r>
 8054664:	2800      	cmp	r0, #0
 8054666:	f040 8156 	bne.w	8054916 <_vfprintf_r+0x13a6>
 805466a:	a925      	add	r1, sp, #148	; 0x94
 805466c:	3e10      	subs	r6, #16
 805466e:	460c      	mov	r4, r1
 8054670:	e760      	b.n	8054534 <_vfprintf_r+0xfc4>
 8054672:	460c      	mov	r4, r1
 8054674:	e778      	b.n	8054568 <_vfprintf_r+0xff8>
 8054676:	9b08      	ldr	r3, [sp, #32]
 8054678:	2b00      	cmp	r3, #0
 805467a:	d052      	beq.n	8054722 <_vfprintf_r+0x11b2>
 805467c:	9b08      	ldr	r3, [sp, #32]
 805467e:	3b01      	subs	r3, #1
 8054680:	9308      	str	r3, [sp, #32]
 8054682:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8054684:	6023      	str	r3, [r4, #0]
 8054686:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8054688:	9a12      	ldr	r2, [sp, #72]	; 0x48
 805468a:	6063      	str	r3, [r4, #4]
 805468c:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805468e:	4413      	add	r3, r2
 8054690:	9324      	str	r3, [sp, #144]	; 0x90
 8054692:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054694:	3301      	adds	r3, #1
 8054696:	2b07      	cmp	r3, #7
 8054698:	9323      	str	r3, [sp, #140]	; 0x8c
 805469a:	dc49      	bgt.n	8054730 <_vfprintf_r+0x11c0>
 805469c:	3408      	adds	r4, #8
 805469e:	9b03      	ldr	r3, [sp, #12]
 80546a0:	9a05      	ldr	r2, [sp, #20]
 80546a2:	eb03 0802 	add.w	r8, r3, r2
 80546a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80546a8:	781b      	ldrb	r3, [r3, #0]
 80546aa:	eba8 0805 	sub.w	r8, r8, r5
 80546ae:	4598      	cmp	r8, r3
 80546b0:	bfa8      	it	ge
 80546b2:	4698      	movge	r8, r3
 80546b4:	f1b8 0f00 	cmp.w	r8, #0
 80546b8:	dd0a      	ble.n	80546d0 <_vfprintf_r+0x1160>
 80546ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80546bc:	4443      	add	r3, r8
 80546be:	9324      	str	r3, [sp, #144]	; 0x90
 80546c0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80546c2:	3301      	adds	r3, #1
 80546c4:	2b07      	cmp	r3, #7
 80546c6:	e9c4 5800 	strd	r5, r8, [r4]
 80546ca:	9323      	str	r3, [sp, #140]	; 0x8c
 80546cc:	dc3a      	bgt.n	8054744 <_vfprintf_r+0x11d4>
 80546ce:	3408      	adds	r4, #8
 80546d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80546d2:	781b      	ldrb	r3, [r3, #0]
 80546d4:	f1b8 0f00 	cmp.w	r8, #0
 80546d8:	bfac      	ite	ge
 80546da:	eba3 0808 	subge.w	r8, r3, r8
 80546de:	4698      	movlt	r8, r3
 80546e0:	f1b8 0f00 	cmp.w	r8, #0
 80546e4:	dd19      	ble.n	805471a <_vfprintf_r+0x11aa>
 80546e6:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 80546ea:	f1b8 0f10 	cmp.w	r8, #16
 80546ee:	f102 0201 	add.w	r2, r2, #1
 80546f2:	f104 0108 	add.w	r1, r4, #8
 80546f6:	6026      	str	r6, [r4, #0]
 80546f8:	dc2e      	bgt.n	8054758 <_vfprintf_r+0x11e8>
 80546fa:	4443      	add	r3, r8
 80546fc:	2a07      	cmp	r2, #7
 80546fe:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8054702:	f8c4 8004 	str.w	r8, [r4, #4]
 8054706:	dd3a      	ble.n	805477e <_vfprintf_r+0x120e>
 8054708:	aa22      	add	r2, sp, #136	; 0x88
 805470a:	4649      	mov	r1, r9
 805470c:	4650      	mov	r0, sl
 805470e:	f002 fc45 	bl	8056f9c <__sprint_r>
 8054712:	2800      	cmp	r0, #0
 8054714:	f040 80ff 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054718:	ac25      	add	r4, sp, #148	; 0x94
 805471a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 805471c:	781b      	ldrb	r3, [r3, #0]
 805471e:	441d      	add	r5, r3
 8054720:	e729      	b.n	8054576 <_vfprintf_r+0x1006>
 8054722:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8054724:	3b01      	subs	r3, #1
 8054726:	930a      	str	r3, [sp, #40]	; 0x28
 8054728:	9b09      	ldr	r3, [sp, #36]	; 0x24
 805472a:	3b01      	subs	r3, #1
 805472c:	9309      	str	r3, [sp, #36]	; 0x24
 805472e:	e7a8      	b.n	8054682 <_vfprintf_r+0x1112>
 8054730:	aa22      	add	r2, sp, #136	; 0x88
 8054732:	4649      	mov	r1, r9
 8054734:	4650      	mov	r0, sl
 8054736:	f002 fc31 	bl	8056f9c <__sprint_r>
 805473a:	2800      	cmp	r0, #0
 805473c:	f040 80eb 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054740:	ac25      	add	r4, sp, #148	; 0x94
 8054742:	e7ac      	b.n	805469e <_vfprintf_r+0x112e>
 8054744:	aa22      	add	r2, sp, #136	; 0x88
 8054746:	4649      	mov	r1, r9
 8054748:	4650      	mov	r0, sl
 805474a:	f002 fc27 	bl	8056f9c <__sprint_r>
 805474e:	2800      	cmp	r0, #0
 8054750:	f040 80e1 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054754:	ac25      	add	r4, sp, #148	; 0x94
 8054756:	e7bb      	b.n	80546d0 <_vfprintf_r+0x1160>
 8054758:	3310      	adds	r3, #16
 805475a:	2a07      	cmp	r2, #7
 805475c:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8054760:	6067      	str	r7, [r4, #4]
 8054762:	dd08      	ble.n	8054776 <_vfprintf_r+0x1206>
 8054764:	aa22      	add	r2, sp, #136	; 0x88
 8054766:	4649      	mov	r1, r9
 8054768:	4650      	mov	r0, sl
 805476a:	f002 fc17 	bl	8056f9c <__sprint_r>
 805476e:	2800      	cmp	r0, #0
 8054770:	f040 80d1 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054774:	a925      	add	r1, sp, #148	; 0x94
 8054776:	f1a8 0810 	sub.w	r8, r8, #16
 805477a:	460c      	mov	r4, r1
 805477c:	e7b3      	b.n	80546e6 <_vfprintf_r+0x1176>
 805477e:	460c      	mov	r4, r1
 8054780:	e7cb      	b.n	805471a <_vfprintf_r+0x11aa>
 8054782:	aa22      	add	r2, sp, #136	; 0x88
 8054784:	4649      	mov	r1, r9
 8054786:	4650      	mov	r0, sl
 8054788:	f002 fc08 	bl	8056f9c <__sprint_r>
 805478c:	2800      	cmp	r0, #0
 805478e:	f040 80c2 	bne.w	8054916 <_vfprintf_r+0x13a6>
 8054792:	ac25      	add	r4, sp, #148	; 0x94
 8054794:	e711      	b.n	80545ba <_vfprintf_r+0x104a>
 8054796:	aa22      	add	r2, sp, #136	; 0x88
 8054798:	4649      	mov	r1, r9
 805479a:	4650      	mov	r0, sl
 805479c:	f002 fbfe 	bl	8056f9c <__sprint_r>
 80547a0:	2800      	cmp	r0, #0
 80547a2:	f040 80b8 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80547a6:	ac25      	add	r4, sp, #148	; 0x94
 80547a8:	e71e      	b.n	80545e8 <_vfprintf_r+0x1078>
 80547aa:	bf00      	nop
 80547ac:	0805a3d9 	.word	0x0805a3d9
 80547b0:	9a05      	ldr	r2, [sp, #20]
 80547b2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80547b4:	2a01      	cmp	r2, #1
 80547b6:	9a03      	ldr	r2, [sp, #12]
 80547b8:	6022      	str	r2, [r4, #0]
 80547ba:	f106 0601 	add.w	r6, r6, #1
 80547be:	f103 0301 	add.w	r3, r3, #1
 80547c2:	f04f 0201 	mov.w	r2, #1
 80547c6:	e9cd 3623 	strd	r3, r6, [sp, #140]	; 0x8c
 80547ca:	f104 0508 	add.w	r5, r4, #8
 80547ce:	6062      	str	r2, [r4, #4]
 80547d0:	dc02      	bgt.n	80547d8 <_vfprintf_r+0x1268>
 80547d2:	f01b 0f01 	tst.w	fp, #1
 80547d6:	d078      	beq.n	80548ca <_vfprintf_r+0x135a>
 80547d8:	2b07      	cmp	r3, #7
 80547da:	dd08      	ble.n	80547ee <_vfprintf_r+0x127e>
 80547dc:	aa22      	add	r2, sp, #136	; 0x88
 80547de:	4649      	mov	r1, r9
 80547e0:	4650      	mov	r0, sl
 80547e2:	f002 fbdb 	bl	8056f9c <__sprint_r>
 80547e6:	2800      	cmp	r0, #0
 80547e8:	f040 8095 	bne.w	8054916 <_vfprintf_r+0x13a6>
 80547ec:	ad25      	add	r5, sp, #148	; 0x94
 80547ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80547f0:	602b      	str	r3, [r5, #0]
 80547f2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80547f4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80547f6:	606b      	str	r3, [r5, #4]
 80547f8:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80547fa:	4413      	add	r3, r2
 80547fc:	9324      	str	r3, [sp, #144]	; 0x90
 80547fe:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8054800:	3301      	adds	r3, #1
 8054802:	2b07      	cmp	r3, #7
 8054804:	9323      	str	r3, [sp, #140]	; 0x8c
 8054806:	dc32      	bgt.n	805486e <_vfprintf_r+0x12fe>
 8054808:	3508      	adds	r5, #8
 805480a:	9b05      	ldr	r3, [sp, #20]
 805480c:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8054810:	1e5c      	subs	r4, r3, #1
 8054812:	2200      	movs	r2, #0
 8054814:	2300      	movs	r3, #0
 8054816:	f7ec f967 	bl	8040ae8 <__aeabi_dcmpeq>
 805481a:	2800      	cmp	r0, #0
 805481c:	d130      	bne.n	8054880 <_vfprintf_r+0x1310>
 805481e:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8054820:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054822:	9803      	ldr	r0, [sp, #12]
 8054824:	9a05      	ldr	r2, [sp, #20]
 8054826:	3101      	adds	r1, #1
 8054828:	3b01      	subs	r3, #1
 805482a:	3001      	adds	r0, #1
 805482c:	4413      	add	r3, r2
 805482e:	2907      	cmp	r1, #7
 8054830:	e9c5 0400 	strd	r0, r4, [r5]
 8054834:	e9cd 1323 	strd	r1, r3, [sp, #140]	; 0x8c
 8054838:	dd4a      	ble.n	80548d0 <_vfprintf_r+0x1360>
 805483a:	aa22      	add	r2, sp, #136	; 0x88
 805483c:	4649      	mov	r1, r9
 805483e:	4650      	mov	r0, sl
 8054840:	f002 fbac 	bl	8056f9c <__sprint_r>
 8054844:	2800      	cmp	r0, #0
 8054846:	d166      	bne.n	8054916 <_vfprintf_r+0x13a6>
 8054848:	ad25      	add	r5, sp, #148	; 0x94
 805484a:	ab1e      	add	r3, sp, #120	; 0x78
 805484c:	602b      	str	r3, [r5, #0]
 805484e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8054850:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8054852:	606b      	str	r3, [r5, #4]
 8054854:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8054856:	4413      	add	r3, r2
 8054858:	9324      	str	r3, [sp, #144]	; 0x90
 805485a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 805485c:	3301      	adds	r3, #1
 805485e:	2b07      	cmp	r3, #7
 8054860:	9323      	str	r3, [sp, #140]	; 0x8c
 8054862:	f73f ada4 	bgt.w	80543ae <_vfprintf_r+0xe3e>
 8054866:	f105 0408 	add.w	r4, r5, #8
 805486a:	f7ff baa6 	b.w	8053dba <_vfprintf_r+0x84a>
 805486e:	aa22      	add	r2, sp, #136	; 0x88
 8054870:	4649      	mov	r1, r9
 8054872:	4650      	mov	r0, sl
 8054874:	f002 fb92 	bl	8056f9c <__sprint_r>
 8054878:	2800      	cmp	r0, #0
 805487a:	d14c      	bne.n	8054916 <_vfprintf_r+0x13a6>
 805487c:	ad25      	add	r5, sp, #148	; 0x94
 805487e:	e7c4      	b.n	805480a <_vfprintf_r+0x129a>
 8054880:	2c00      	cmp	r4, #0
 8054882:	dde2      	ble.n	805484a <_vfprintf_r+0x12da>
 8054884:	4e53      	ldr	r6, [pc, #332]	; (80549d4 <_vfprintf_r+0x1464>)
 8054886:	2710      	movs	r7, #16
 8054888:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 805488c:	2c10      	cmp	r4, #16
 805488e:	f103 0301 	add.w	r3, r3, #1
 8054892:	f105 0108 	add.w	r1, r5, #8
 8054896:	602e      	str	r6, [r5, #0]
 8054898:	dc07      	bgt.n	80548aa <_vfprintf_r+0x133a>
 805489a:	606c      	str	r4, [r5, #4]
 805489c:	2b07      	cmp	r3, #7
 805489e:	4414      	add	r4, r2
 80548a0:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 80548a4:	dcc9      	bgt.n	805483a <_vfprintf_r+0x12ca>
 80548a6:	460d      	mov	r5, r1
 80548a8:	e7cf      	b.n	805484a <_vfprintf_r+0x12da>
 80548aa:	3210      	adds	r2, #16
 80548ac:	2b07      	cmp	r3, #7
 80548ae:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80548b2:	606f      	str	r7, [r5, #4]
 80548b4:	dd06      	ble.n	80548c4 <_vfprintf_r+0x1354>
 80548b6:	aa22      	add	r2, sp, #136	; 0x88
 80548b8:	4649      	mov	r1, r9
 80548ba:	4650      	mov	r0, sl
 80548bc:	f002 fb6e 	bl	8056f9c <__sprint_r>
 80548c0:	bb48      	cbnz	r0, 8054916 <_vfprintf_r+0x13a6>
 80548c2:	a925      	add	r1, sp, #148	; 0x94
 80548c4:	3c10      	subs	r4, #16
 80548c6:	460d      	mov	r5, r1
 80548c8:	e7de      	b.n	8054888 <_vfprintf_r+0x1318>
 80548ca:	2b07      	cmp	r3, #7
 80548cc:	ddbd      	ble.n	805484a <_vfprintf_r+0x12da>
 80548ce:	e7b4      	b.n	805483a <_vfprintf_r+0x12ca>
 80548d0:	3508      	adds	r5, #8
 80548d2:	e7ba      	b.n	805484a <_vfprintf_r+0x12da>
 80548d4:	460c      	mov	r4, r1
 80548d6:	f7ff ba70 	b.w	8053dba <_vfprintf_r+0x84a>
 80548da:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 80548de:	1a9d      	subs	r5, r3, r2
 80548e0:	2d00      	cmp	r5, #0
 80548e2:	f77f aa6e 	ble.w	8053dc2 <_vfprintf_r+0x852>
 80548e6:	4e3c      	ldr	r6, [pc, #240]	; (80549d8 <_vfprintf_r+0x1468>)
 80548e8:	2710      	movs	r7, #16
 80548ea:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80548ee:	2d10      	cmp	r5, #16
 80548f0:	f103 0301 	add.w	r3, r3, #1
 80548f4:	6026      	str	r6, [r4, #0]
 80548f6:	dc18      	bgt.n	805492a <_vfprintf_r+0x13ba>
 80548f8:	6065      	str	r5, [r4, #4]
 80548fa:	2b07      	cmp	r3, #7
 80548fc:	4415      	add	r5, r2
 80548fe:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 8054902:	f77f aa5e 	ble.w	8053dc2 <_vfprintf_r+0x852>
 8054906:	aa22      	add	r2, sp, #136	; 0x88
 8054908:	4649      	mov	r1, r9
 805490a:	4650      	mov	r0, sl
 805490c:	f002 fb46 	bl	8056f9c <__sprint_r>
 8054910:	2800      	cmp	r0, #0
 8054912:	f43f aa56 	beq.w	8053dc2 <_vfprintf_r+0x852>
 8054916:	9b04      	ldr	r3, [sp, #16]
 8054918:	2b00      	cmp	r3, #0
 805491a:	f43f a872 	beq.w	8053a02 <_vfprintf_r+0x492>
 805491e:	4619      	mov	r1, r3
 8054920:	4650      	mov	r0, sl
 8054922:	f001 f8f5 	bl	8055b10 <_free_r>
 8054926:	f7ff b86c 	b.w	8053a02 <_vfprintf_r+0x492>
 805492a:	3210      	adds	r2, #16
 805492c:	2b07      	cmp	r3, #7
 805492e:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8054932:	6067      	str	r7, [r4, #4]
 8054934:	dc02      	bgt.n	805493c <_vfprintf_r+0x13cc>
 8054936:	3408      	adds	r4, #8
 8054938:	3d10      	subs	r5, #16
 805493a:	e7d6      	b.n	80548ea <_vfprintf_r+0x137a>
 805493c:	aa22      	add	r2, sp, #136	; 0x88
 805493e:	4649      	mov	r1, r9
 8054940:	4650      	mov	r0, sl
 8054942:	f002 fb2b 	bl	8056f9c <__sprint_r>
 8054946:	2800      	cmp	r0, #0
 8054948:	d1e5      	bne.n	8054916 <_vfprintf_r+0x13a6>
 805494a:	ac25      	add	r4, sp, #148	; 0x94
 805494c:	e7f4      	b.n	8054938 <_vfprintf_r+0x13c8>
 805494e:	9904      	ldr	r1, [sp, #16]
 8054950:	4650      	mov	r0, sl
 8054952:	f001 f8dd 	bl	8055b10 <_free_r>
 8054956:	f7ff ba4c 	b.w	8053df2 <_vfprintf_r+0x882>
 805495a:	9b24      	ldr	r3, [sp, #144]	; 0x90
 805495c:	b91b      	cbnz	r3, 8054966 <_vfprintf_r+0x13f6>
 805495e:	2300      	movs	r3, #0
 8054960:	9323      	str	r3, [sp, #140]	; 0x8c
 8054962:	f7ff b84e 	b.w	8053a02 <_vfprintf_r+0x492>
 8054966:	aa22      	add	r2, sp, #136	; 0x88
 8054968:	4649      	mov	r1, r9
 805496a:	4650      	mov	r0, sl
 805496c:	f002 fb16 	bl	8056f9c <__sprint_r>
 8054970:	2800      	cmp	r0, #0
 8054972:	d0f4      	beq.n	805495e <_vfprintf_r+0x13ee>
 8054974:	f7ff b845 	b.w	8053a02 <_vfprintf_r+0x492>
 8054978:	ea56 0207 	orrs.w	r2, r6, r7
 805497c:	f8cd b010 	str.w	fp, [sp, #16]
 8054980:	f43f ab5c 	beq.w	805403c <_vfprintf_r+0xacc>
 8054984:	2b01      	cmp	r3, #1
 8054986:	f43f abf4 	beq.w	8054172 <_vfprintf_r+0xc02>
 805498a:	2b02      	cmp	r3, #2
 805498c:	ab4e      	add	r3, sp, #312	; 0x138
 805498e:	9303      	str	r3, [sp, #12]
 8054990:	f43f ac46 	beq.w	8054220 <_vfprintf_r+0xcb0>
 8054994:	9903      	ldr	r1, [sp, #12]
 8054996:	f006 0307 	and.w	r3, r6, #7
 805499a:	460a      	mov	r2, r1
 805499c:	3330      	adds	r3, #48	; 0x30
 805499e:	f802 3d01 	strb.w	r3, [r2, #-1]!
 80549a2:	9203      	str	r2, [sp, #12]
 80549a4:	08f2      	lsrs	r2, r6, #3
 80549a6:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
 80549aa:	08f8      	lsrs	r0, r7, #3
 80549ac:	4616      	mov	r6, r2
 80549ae:	4607      	mov	r7, r0
 80549b0:	ea56 0207 	orrs.w	r2, r6, r7
 80549b4:	d1ee      	bne.n	8054994 <_vfprintf_r+0x1424>
 80549b6:	9a04      	ldr	r2, [sp, #16]
 80549b8:	07d0      	lsls	r0, r2, #31
 80549ba:	f57f ac20 	bpl.w	80541fe <_vfprintf_r+0xc8e>
 80549be:	2b30      	cmp	r3, #48	; 0x30
 80549c0:	f43f ac1d 	beq.w	80541fe <_vfprintf_r+0xc8e>
 80549c4:	9a03      	ldr	r2, [sp, #12]
 80549c6:	2330      	movs	r3, #48	; 0x30
 80549c8:	f802 3c01 	strb.w	r3, [r2, #-1]
 80549cc:	1e8b      	subs	r3, r1, #2
 80549ce:	9303      	str	r3, [sp, #12]
 80549d0:	e415      	b.n	80541fe <_vfprintf_r+0xc8e>
 80549d2:	bf00      	nop
 80549d4:	0805a3d9 	.word	0x0805a3d9
 80549d8:	0805a3c9 	.word	0x0805a3c9

080549dc <__sbprintf>:
 80549dc:	b570      	push	{r4, r5, r6, lr}
 80549de:	460c      	mov	r4, r1
 80549e0:	8989      	ldrh	r1, [r1, #12]
 80549e2:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 80549e6:	f021 0102 	bic.w	r1, r1, #2
 80549ea:	f8ad 1014 	strh.w	r1, [sp, #20]
 80549ee:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80549f0:	911b      	str	r1, [sp, #108]	; 0x6c
 80549f2:	89e1      	ldrh	r1, [r4, #14]
 80549f4:	f8ad 1016 	strh.w	r1, [sp, #22]
 80549f8:	69e1      	ldr	r1, [r4, #28]
 80549fa:	9109      	str	r1, [sp, #36]	; 0x24
 80549fc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80549fe:	910b      	str	r1, [sp, #44]	; 0x2c
 8054a00:	a91c      	add	r1, sp, #112	; 0x70
 8054a02:	9102      	str	r1, [sp, #8]
 8054a04:	9106      	str	r1, [sp, #24]
 8054a06:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8054a0a:	4606      	mov	r6, r0
 8054a0c:	9104      	str	r1, [sp, #16]
 8054a0e:	9107      	str	r1, [sp, #28]
 8054a10:	a818      	add	r0, sp, #96	; 0x60
 8054a12:	2100      	movs	r1, #0
 8054a14:	e9cd 3200 	strd	r3, r2, [sp]
 8054a18:	9108      	str	r1, [sp, #32]
 8054a1a:	f001 fcd1 	bl	80563c0 <__retarget_lock_init_recursive>
 8054a1e:	e9dd 3200 	ldrd	r3, r2, [sp]
 8054a22:	a902      	add	r1, sp, #8
 8054a24:	4630      	mov	r0, r6
 8054a26:	f7fe fda3 	bl	8053570 <_vfprintf_r>
 8054a2a:	1e05      	subs	r5, r0, #0
 8054a2c:	db07      	blt.n	8054a3e <__sbprintf+0x62>
 8054a2e:	a902      	add	r1, sp, #8
 8054a30:	4630      	mov	r0, r6
 8054a32:	f000 ff71 	bl	8055918 <_fflush_r>
 8054a36:	2800      	cmp	r0, #0
 8054a38:	bf18      	it	ne
 8054a3a:	f04f 35ff 	movne.w	r5, #4294967295
 8054a3e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8054a42:	9818      	ldr	r0, [sp, #96]	; 0x60
 8054a44:	065b      	lsls	r3, r3, #25
 8054a46:	bf42      	ittt	mi
 8054a48:	89a3      	ldrhmi	r3, [r4, #12]
 8054a4a:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 8054a4e:	81a3      	strhmi	r3, [r4, #12]
 8054a50:	f001 fcb7 	bl	80563c2 <__retarget_lock_close_recursive>
 8054a54:	4628      	mov	r0, r5
 8054a56:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 8054a5a:	bd70      	pop	{r4, r5, r6, pc}

08054a5c <__swsetup_r>:
 8054a5c:	b538      	push	{r3, r4, r5, lr}
 8054a5e:	4b2a      	ldr	r3, [pc, #168]	; (8054b08 <__swsetup_r+0xac>)
 8054a60:	4605      	mov	r5, r0
 8054a62:	6818      	ldr	r0, [r3, #0]
 8054a64:	460c      	mov	r4, r1
 8054a66:	b118      	cbz	r0, 8054a70 <__swsetup_r+0x14>
 8054a68:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8054a6a:	b90b      	cbnz	r3, 8054a70 <__swsetup_r+0x14>
 8054a6c:	f000 ffc0 	bl	80559f0 <__sinit>
 8054a70:	89a3      	ldrh	r3, [r4, #12]
 8054a72:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8054a76:	0718      	lsls	r0, r3, #28
 8054a78:	d422      	bmi.n	8054ac0 <__swsetup_r+0x64>
 8054a7a:	06d9      	lsls	r1, r3, #27
 8054a7c:	d407      	bmi.n	8054a8e <__swsetup_r+0x32>
 8054a7e:	2309      	movs	r3, #9
 8054a80:	602b      	str	r3, [r5, #0]
 8054a82:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 8054a86:	81a3      	strh	r3, [r4, #12]
 8054a88:	f04f 30ff 	mov.w	r0, #4294967295
 8054a8c:	e034      	b.n	8054af8 <__swsetup_r+0x9c>
 8054a8e:	0758      	lsls	r0, r3, #29
 8054a90:	d512      	bpl.n	8054ab8 <__swsetup_r+0x5c>
 8054a92:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8054a94:	b141      	cbz	r1, 8054aa8 <__swsetup_r+0x4c>
 8054a96:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8054a9a:	4299      	cmp	r1, r3
 8054a9c:	d002      	beq.n	8054aa4 <__swsetup_r+0x48>
 8054a9e:	4628      	mov	r0, r5
 8054aa0:	f001 f836 	bl	8055b10 <_free_r>
 8054aa4:	2300      	movs	r3, #0
 8054aa6:	6323      	str	r3, [r4, #48]	; 0x30
 8054aa8:	89a3      	ldrh	r3, [r4, #12]
 8054aaa:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8054aae:	81a3      	strh	r3, [r4, #12]
 8054ab0:	2300      	movs	r3, #0
 8054ab2:	6063      	str	r3, [r4, #4]
 8054ab4:	6923      	ldr	r3, [r4, #16]
 8054ab6:	6023      	str	r3, [r4, #0]
 8054ab8:	89a3      	ldrh	r3, [r4, #12]
 8054aba:	f043 0308 	orr.w	r3, r3, #8
 8054abe:	81a3      	strh	r3, [r4, #12]
 8054ac0:	6923      	ldr	r3, [r4, #16]
 8054ac2:	b94b      	cbnz	r3, 8054ad8 <__swsetup_r+0x7c>
 8054ac4:	89a3      	ldrh	r3, [r4, #12]
 8054ac6:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8054aca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8054ace:	d003      	beq.n	8054ad8 <__swsetup_r+0x7c>
 8054ad0:	4621      	mov	r1, r4
 8054ad2:	4628      	mov	r0, r5
 8054ad4:	f001 fca4 	bl	8056420 <__smakebuf_r>
 8054ad8:	89a0      	ldrh	r0, [r4, #12]
 8054ada:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 8054ade:	f010 0301 	ands.w	r3, r0, #1
 8054ae2:	d00a      	beq.n	8054afa <__swsetup_r+0x9e>
 8054ae4:	2300      	movs	r3, #0
 8054ae6:	60a3      	str	r3, [r4, #8]
 8054ae8:	6963      	ldr	r3, [r4, #20]
 8054aea:	425b      	negs	r3, r3
 8054aec:	61a3      	str	r3, [r4, #24]
 8054aee:	6923      	ldr	r3, [r4, #16]
 8054af0:	b943      	cbnz	r3, 8054b04 <__swsetup_r+0xa8>
 8054af2:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 8054af6:	d1c4      	bne.n	8054a82 <__swsetup_r+0x26>
 8054af8:	bd38      	pop	{r3, r4, r5, pc}
 8054afa:	0781      	lsls	r1, r0, #30
 8054afc:	bf58      	it	pl
 8054afe:	6963      	ldrpl	r3, [r4, #20]
 8054b00:	60a3      	str	r3, [r4, #8]
 8054b02:	e7f4      	b.n	8054aee <__swsetup_r+0x92>
 8054b04:	2000      	movs	r0, #0
 8054b06:	e7f7      	b.n	8054af8 <__swsetup_r+0x9c>
 8054b08:	200038cc 	.word	0x200038cc

08054b0c <register_fini>:
 8054b0c:	4b02      	ldr	r3, [pc, #8]	; (8054b18 <register_fini+0xc>)
 8054b0e:	b113      	cbz	r3, 8054b16 <register_fini+0xa>
 8054b10:	4802      	ldr	r0, [pc, #8]	; (8054b1c <register_fini+0x10>)
 8054b12:	f000 b805 	b.w	8054b20 <atexit>
 8054b16:	4770      	bx	lr
 8054b18:	00000000 	.word	0x00000000
 8054b1c:	08055a41 	.word	0x08055a41

08054b20 <atexit>:
 8054b20:	2300      	movs	r3, #0
 8054b22:	4601      	mov	r1, r0
 8054b24:	461a      	mov	r2, r3
 8054b26:	4618      	mov	r0, r3
 8054b28:	f002 bf52 	b.w	80579d0 <__register_exitproc>

08054b2c <quorem>:
 8054b2c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8054b30:	6903      	ldr	r3, [r0, #16]
 8054b32:	690c      	ldr	r4, [r1, #16]
 8054b34:	42a3      	cmp	r3, r4
 8054b36:	4607      	mov	r7, r0
 8054b38:	f2c0 8081 	blt.w	8054c3e <quorem+0x112>
 8054b3c:	3c01      	subs	r4, #1
 8054b3e:	f101 0814 	add.w	r8, r1, #20
 8054b42:	f100 0514 	add.w	r5, r0, #20
 8054b46:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8054b4a:	9301      	str	r3, [sp, #4]
 8054b4c:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8054b50:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8054b54:	3301      	adds	r3, #1
 8054b56:	429a      	cmp	r2, r3
 8054b58:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 8054b5c:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 8054b60:	fbb2 f6f3 	udiv	r6, r2, r3
 8054b64:	d331      	bcc.n	8054bca <quorem+0x9e>
 8054b66:	f04f 0e00 	mov.w	lr, #0
 8054b6a:	4640      	mov	r0, r8
 8054b6c:	46ac      	mov	ip, r5
 8054b6e:	46f2      	mov	sl, lr
 8054b70:	f850 2b04 	ldr.w	r2, [r0], #4
 8054b74:	b293      	uxth	r3, r2
 8054b76:	fb06 e303 	mla	r3, r6, r3, lr
 8054b7a:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 8054b7e:	b29b      	uxth	r3, r3
 8054b80:	ebaa 0303 	sub.w	r3, sl, r3
 8054b84:	0c12      	lsrs	r2, r2, #16
 8054b86:	f8dc a000 	ldr.w	sl, [ip]
 8054b8a:	fb06 e202 	mla	r2, r6, r2, lr
 8054b8e:	fa13 f38a 	uxtah	r3, r3, sl
 8054b92:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 8054b96:	fa1f fa82 	uxth.w	sl, r2
 8054b9a:	f8dc 2000 	ldr.w	r2, [ip]
 8054b9e:	ebca 4212 	rsb	r2, sl, r2, lsr #16
 8054ba2:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8054ba6:	b29b      	uxth	r3, r3
 8054ba8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8054bac:	4581      	cmp	r9, r0
 8054bae:	f84c 3b04 	str.w	r3, [ip], #4
 8054bb2:	ea4f 4a22 	mov.w	sl, r2, asr #16
 8054bb6:	d2db      	bcs.n	8054b70 <quorem+0x44>
 8054bb8:	f855 300b 	ldr.w	r3, [r5, fp]
 8054bbc:	b92b      	cbnz	r3, 8054bca <quorem+0x9e>
 8054bbe:	9b01      	ldr	r3, [sp, #4]
 8054bc0:	3b04      	subs	r3, #4
 8054bc2:	429d      	cmp	r5, r3
 8054bc4:	461a      	mov	r2, r3
 8054bc6:	d32e      	bcc.n	8054c26 <quorem+0xfa>
 8054bc8:	613c      	str	r4, [r7, #16]
 8054bca:	4638      	mov	r0, r7
 8054bcc:	f001 fef4 	bl	80569b8 <__mcmp>
 8054bd0:	2800      	cmp	r0, #0
 8054bd2:	db24      	blt.n	8054c1e <quorem+0xf2>
 8054bd4:	3601      	adds	r6, #1
 8054bd6:	4628      	mov	r0, r5
 8054bd8:	f04f 0c00 	mov.w	ip, #0
 8054bdc:	f858 2b04 	ldr.w	r2, [r8], #4
 8054be0:	f8d0 e000 	ldr.w	lr, [r0]
 8054be4:	b293      	uxth	r3, r2
 8054be6:	ebac 0303 	sub.w	r3, ip, r3
 8054bea:	0c12      	lsrs	r2, r2, #16
 8054bec:	fa13 f38e 	uxtah	r3, r3, lr
 8054bf0:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 8054bf4:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8054bf8:	b29b      	uxth	r3, r3
 8054bfa:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8054bfe:	45c1      	cmp	r9, r8
 8054c00:	f840 3b04 	str.w	r3, [r0], #4
 8054c04:	ea4f 4c22 	mov.w	ip, r2, asr #16
 8054c08:	d2e8      	bcs.n	8054bdc <quorem+0xb0>
 8054c0a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8054c0e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8054c12:	b922      	cbnz	r2, 8054c1e <quorem+0xf2>
 8054c14:	3b04      	subs	r3, #4
 8054c16:	429d      	cmp	r5, r3
 8054c18:	461a      	mov	r2, r3
 8054c1a:	d30a      	bcc.n	8054c32 <quorem+0x106>
 8054c1c:	613c      	str	r4, [r7, #16]
 8054c1e:	4630      	mov	r0, r6
 8054c20:	b003      	add	sp, #12
 8054c22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8054c26:	6812      	ldr	r2, [r2, #0]
 8054c28:	3b04      	subs	r3, #4
 8054c2a:	2a00      	cmp	r2, #0
 8054c2c:	d1cc      	bne.n	8054bc8 <quorem+0x9c>
 8054c2e:	3c01      	subs	r4, #1
 8054c30:	e7c7      	b.n	8054bc2 <quorem+0x96>
 8054c32:	6812      	ldr	r2, [r2, #0]
 8054c34:	3b04      	subs	r3, #4
 8054c36:	2a00      	cmp	r2, #0
 8054c38:	d1f0      	bne.n	8054c1c <quorem+0xf0>
 8054c3a:	3c01      	subs	r4, #1
 8054c3c:	e7eb      	b.n	8054c16 <quorem+0xea>
 8054c3e:	2000      	movs	r0, #0
 8054c40:	e7ee      	b.n	8054c20 <quorem+0xf4>
 8054c42:	0000      	movs	r0, r0
 8054c44:	0000      	movs	r0, r0
	...

08054c48 <_dtoa_r>:
 8054c48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8054c4c:	ed2d 8b02 	vpush	{d8}
 8054c50:	b095      	sub	sp, #84	; 0x54
 8054c52:	ec57 6b10 	vmov	r6, r7, d0
 8054c56:	9105      	str	r1, [sp, #20]
 8054c58:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8054c5a:	9d20      	ldr	r5, [sp, #128]	; 0x80
 8054c5c:	9209      	str	r2, [sp, #36]	; 0x24
 8054c5e:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8054c62:	4604      	mov	r4, r0
 8054c64:	930f      	str	r3, [sp, #60]	; 0x3c
 8054c66:	b141      	cbz	r1, 8054c7a <_dtoa_r+0x32>
 8054c68:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8054c6a:	604a      	str	r2, [r1, #4]
 8054c6c:	2301      	movs	r3, #1
 8054c6e:	4093      	lsls	r3, r2
 8054c70:	608b      	str	r3, [r1, #8]
 8054c72:	f001 fc4c 	bl	805650e <_Bfree>
 8054c76:	2300      	movs	r3, #0
 8054c78:	6423      	str	r3, [r4, #64]	; 0x40
 8054c7a:	1e3b      	subs	r3, r7, #0
 8054c7c:	bfb9      	ittee	lt
 8054c7e:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 8054c82:	9303      	strlt	r3, [sp, #12]
 8054c84:	2300      	movge	r3, #0
 8054c86:	602b      	strge	r3, [r5, #0]
 8054c88:	f8dd 900c 	ldr.w	r9, [sp, #12]
 8054c8c:	4ba2      	ldr	r3, [pc, #648]	; (8054f18 <_dtoa_r+0x2d0>)
 8054c8e:	bfbc      	itt	lt
 8054c90:	2201      	movlt	r2, #1
 8054c92:	602a      	strlt	r2, [r5, #0]
 8054c94:	ea33 0309 	bics.w	r3, r3, r9
 8054c98:	d11b      	bne.n	8054cd2 <_dtoa_r+0x8a>
 8054c9a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8054c9c:	f242 730f 	movw	r3, #9999	; 0x270f
 8054ca0:	6013      	str	r3, [r2, #0]
 8054ca2:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8054ca6:	4333      	orrs	r3, r6
 8054ca8:	f000 8578 	beq.w	805579c <_dtoa_r+0xb54>
 8054cac:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8054cae:	b90b      	cbnz	r3, 8054cb4 <_dtoa_r+0x6c>
 8054cb0:	4b9a      	ldr	r3, [pc, #616]	; (8054f1c <_dtoa_r+0x2d4>)
 8054cb2:	e024      	b.n	8054cfe <_dtoa_r+0xb6>
 8054cb4:	4b99      	ldr	r3, [pc, #612]	; (8054f1c <_dtoa_r+0x2d4>)
 8054cb6:	9300      	str	r3, [sp, #0]
 8054cb8:	3303      	adds	r3, #3
 8054cba:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8054cbc:	6013      	str	r3, [r2, #0]
 8054cbe:	9800      	ldr	r0, [sp, #0]
 8054cc0:	b015      	add	sp, #84	; 0x54
 8054cc2:	ecbd 8b02 	vpop	{d8}
 8054cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8054cca:	4b95      	ldr	r3, [pc, #596]	; (8054f20 <_dtoa_r+0x2d8>)
 8054ccc:	9300      	str	r3, [sp, #0]
 8054cce:	3308      	adds	r3, #8
 8054cd0:	e7f3      	b.n	8054cba <_dtoa_r+0x72>
 8054cd2:	ed9d 7b02 	vldr	d7, [sp, #8]
 8054cd6:	2200      	movs	r2, #0
 8054cd8:	ec51 0b17 	vmov	r0, r1, d7
 8054cdc:	2300      	movs	r3, #0
 8054cde:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 8054ce2:	f7eb ff01 	bl	8040ae8 <__aeabi_dcmpeq>
 8054ce6:	4680      	mov	r8, r0
 8054ce8:	b158      	cbz	r0, 8054d02 <_dtoa_r+0xba>
 8054cea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8054cec:	2301      	movs	r3, #1
 8054cee:	6013      	str	r3, [r2, #0]
 8054cf0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8054cf2:	2b00      	cmp	r3, #0
 8054cf4:	f000 854f 	beq.w	8055796 <_dtoa_r+0xb4e>
 8054cf8:	488a      	ldr	r0, [pc, #552]	; (8054f24 <_dtoa_r+0x2dc>)
 8054cfa:	6018      	str	r0, [r3, #0]
 8054cfc:	1e43      	subs	r3, r0, #1
 8054cfe:	9300      	str	r3, [sp, #0]
 8054d00:	e7dd      	b.n	8054cbe <_dtoa_r+0x76>
 8054d02:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
 8054d06:	aa12      	add	r2, sp, #72	; 0x48
 8054d08:	a913      	add	r1, sp, #76	; 0x4c
 8054d0a:	4620      	mov	r0, r4
 8054d0c:	f001 ff74 	bl	8056bf8 <__d2b>
 8054d10:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8054d14:	4683      	mov	fp, r0
 8054d16:	2d00      	cmp	r5, #0
 8054d18:	d07c      	beq.n	8054e14 <_dtoa_r+0x1cc>
 8054d1a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8054d1c:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
 8054d20:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8054d24:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8054d28:	f043 577f 	orr.w	r7, r3, #1069547520	; 0x3fc00000
 8054d2c:	f447 1740 	orr.w	r7, r7, #3145728	; 0x300000
 8054d30:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8054d34:	4b7c      	ldr	r3, [pc, #496]	; (8054f28 <_dtoa_r+0x2e0>)
 8054d36:	2200      	movs	r2, #0
 8054d38:	4630      	mov	r0, r6
 8054d3a:	4639      	mov	r1, r7
 8054d3c:	f7eb fab4 	bl	80402a8 <__aeabi_dsub>
 8054d40:	a36f      	add	r3, pc, #444	; (adr r3, 8054f00 <_dtoa_r+0x2b8>)
 8054d42:	e9d3 2300 	ldrd	r2, r3, [r3]
 8054d46:	f7eb fc67 	bl	8040618 <__aeabi_dmul>
 8054d4a:	a36f      	add	r3, pc, #444	; (adr r3, 8054f08 <_dtoa_r+0x2c0>)
 8054d4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8054d50:	f7eb faac 	bl	80402ac <__adddf3>
 8054d54:	4606      	mov	r6, r0
 8054d56:	4628      	mov	r0, r5
 8054d58:	460f      	mov	r7, r1
 8054d5a:	f7eb fbf3 	bl	8040544 <__aeabi_i2d>
 8054d5e:	a36c      	add	r3, pc, #432	; (adr r3, 8054f10 <_dtoa_r+0x2c8>)
 8054d60:	e9d3 2300 	ldrd	r2, r3, [r3]
 8054d64:	f7eb fc58 	bl	8040618 <__aeabi_dmul>
 8054d68:	4602      	mov	r2, r0
 8054d6a:	460b      	mov	r3, r1
 8054d6c:	4630      	mov	r0, r6
 8054d6e:	4639      	mov	r1, r7
 8054d70:	f7eb fa9c 	bl	80402ac <__adddf3>
 8054d74:	4606      	mov	r6, r0
 8054d76:	460f      	mov	r7, r1
 8054d78:	f7eb fefe 	bl	8040b78 <__aeabi_d2iz>
 8054d7c:	2200      	movs	r2, #0
 8054d7e:	4682      	mov	sl, r0
 8054d80:	2300      	movs	r3, #0
 8054d82:	4630      	mov	r0, r6
 8054d84:	4639      	mov	r1, r7
 8054d86:	f7eb feb9 	bl	8040afc <__aeabi_dcmplt>
 8054d8a:	b148      	cbz	r0, 8054da0 <_dtoa_r+0x158>
 8054d8c:	4650      	mov	r0, sl
 8054d8e:	f7eb fbd9 	bl	8040544 <__aeabi_i2d>
 8054d92:	4632      	mov	r2, r6
 8054d94:	463b      	mov	r3, r7
 8054d96:	f7eb fea7 	bl	8040ae8 <__aeabi_dcmpeq>
 8054d9a:	b908      	cbnz	r0, 8054da0 <_dtoa_r+0x158>
 8054d9c:	f10a 3aff 	add.w	sl, sl, #4294967295
 8054da0:	f1ba 0f16 	cmp.w	sl, #22
 8054da4:	d854      	bhi.n	8054e50 <_dtoa_r+0x208>
 8054da6:	4b61      	ldr	r3, [pc, #388]	; (8054f2c <_dtoa_r+0x2e4>)
 8054da8:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8054dac:	e9d3 2300 	ldrd	r2, r3, [r3]
 8054db0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8054db4:	f7eb fea2 	bl	8040afc <__aeabi_dcmplt>
 8054db8:	2800      	cmp	r0, #0
 8054dba:	d04b      	beq.n	8054e54 <_dtoa_r+0x20c>
 8054dbc:	f10a 3aff 	add.w	sl, sl, #4294967295
 8054dc0:	2300      	movs	r3, #0
 8054dc2:	930e      	str	r3, [sp, #56]	; 0x38
 8054dc4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8054dc6:	1b5d      	subs	r5, r3, r5
 8054dc8:	1e6b      	subs	r3, r5, #1
 8054dca:	9304      	str	r3, [sp, #16]
 8054dcc:	bf43      	ittte	mi
 8054dce:	2300      	movmi	r3, #0
 8054dd0:	f1c5 0801 	rsbmi	r8, r5, #1
 8054dd4:	9304      	strmi	r3, [sp, #16]
 8054dd6:	f04f 0800 	movpl.w	r8, #0
 8054dda:	f1ba 0f00 	cmp.w	sl, #0
 8054dde:	db3b      	blt.n	8054e58 <_dtoa_r+0x210>
 8054de0:	9b04      	ldr	r3, [sp, #16]
 8054de2:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8054de6:	4453      	add	r3, sl
 8054de8:	9304      	str	r3, [sp, #16]
 8054dea:	2300      	movs	r3, #0
 8054dec:	9306      	str	r3, [sp, #24]
 8054dee:	9b05      	ldr	r3, [sp, #20]
 8054df0:	2b09      	cmp	r3, #9
 8054df2:	d86a      	bhi.n	8054eca <_dtoa_r+0x282>
 8054df4:	2b05      	cmp	r3, #5
 8054df6:	bfc4      	itt	gt
 8054df8:	3b04      	subgt	r3, #4
 8054dfa:	9305      	strgt	r3, [sp, #20]
 8054dfc:	9b05      	ldr	r3, [sp, #20]
 8054dfe:	f1a3 0302 	sub.w	r3, r3, #2
 8054e02:	bfcc      	ite	gt
 8054e04:	2500      	movgt	r5, #0
 8054e06:	2501      	movle	r5, #1
 8054e08:	2b03      	cmp	r3, #3
 8054e0a:	d86a      	bhi.n	8054ee2 <_dtoa_r+0x29a>
 8054e0c:	e8df f003 	tbb	[pc, r3]
 8054e10:	5b4d4f2c 	.word	0x5b4d4f2c
 8054e14:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48
 8054e18:	441d      	add	r5, r3
 8054e1a:	f205 4332 	addw	r3, r5, #1074	; 0x432
 8054e1e:	2b20      	cmp	r3, #32
 8054e20:	bfc1      	itttt	gt
 8054e22:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 8054e26:	f205 4012 	addwgt	r0, r5, #1042	; 0x412
 8054e2a:	fa09 f303 	lslgt.w	r3, r9, r3
 8054e2e:	fa26 f000 	lsrgt.w	r0, r6, r0
 8054e32:	bfda      	itte	le
 8054e34:	f1c3 0320 	rsble	r3, r3, #32
 8054e38:	fa06 f003 	lslle.w	r0, r6, r3
 8054e3c:	4318      	orrgt	r0, r3
 8054e3e:	f7eb fb71 	bl	8040524 <__aeabi_ui2d>
 8054e42:	2301      	movs	r3, #1
 8054e44:	4606      	mov	r6, r0
 8054e46:	f1a1 77f8 	sub.w	r7, r1, #32505856	; 0x1f00000
 8054e4a:	3d01      	subs	r5, #1
 8054e4c:	9310      	str	r3, [sp, #64]	; 0x40
 8054e4e:	e771      	b.n	8054d34 <_dtoa_r+0xec>
 8054e50:	2301      	movs	r3, #1
 8054e52:	e7b6      	b.n	8054dc2 <_dtoa_r+0x17a>
 8054e54:	900e      	str	r0, [sp, #56]	; 0x38
 8054e56:	e7b5      	b.n	8054dc4 <_dtoa_r+0x17c>
 8054e58:	f1ca 0300 	rsb	r3, sl, #0
 8054e5c:	9306      	str	r3, [sp, #24]
 8054e5e:	2300      	movs	r3, #0
 8054e60:	eba8 080a 	sub.w	r8, r8, sl
 8054e64:	930d      	str	r3, [sp, #52]	; 0x34
 8054e66:	e7c2      	b.n	8054dee <_dtoa_r+0x1a6>
 8054e68:	2300      	movs	r3, #0
 8054e6a:	9308      	str	r3, [sp, #32]
 8054e6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054e6e:	2b00      	cmp	r3, #0
 8054e70:	dc3a      	bgt.n	8054ee8 <_dtoa_r+0x2a0>
 8054e72:	f04f 0901 	mov.w	r9, #1
 8054e76:	f8cd 9004 	str.w	r9, [sp, #4]
 8054e7a:	464b      	mov	r3, r9
 8054e7c:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 8054e80:	2200      	movs	r2, #0
 8054e82:	6462      	str	r2, [r4, #68]	; 0x44
 8054e84:	2204      	movs	r2, #4
 8054e86:	f102 0014 	add.w	r0, r2, #20
 8054e8a:	4298      	cmp	r0, r3
 8054e8c:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8054e8e:	d931      	bls.n	8054ef4 <_dtoa_r+0x2ac>
 8054e90:	4620      	mov	r0, r4
 8054e92:	f001 fb17 	bl	80564c4 <_Balloc>
 8054e96:	9000      	str	r0, [sp, #0]
 8054e98:	2800      	cmp	r0, #0
 8054e9a:	d14d      	bne.n	8054f38 <_dtoa_r+0x2f0>
 8054e9c:	4b24      	ldr	r3, [pc, #144]	; (8054f30 <_dtoa_r+0x2e8>)
 8054e9e:	4602      	mov	r2, r0
 8054ea0:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8054ea4:	4823      	ldr	r0, [pc, #140]	; (8054f34 <_dtoa_r+0x2ec>)
 8054ea6:	f002 fdd3 	bl	8057a50 <__assert_func>
 8054eaa:	2301      	movs	r3, #1
 8054eac:	e7dd      	b.n	8054e6a <_dtoa_r+0x222>
 8054eae:	2300      	movs	r3, #0
 8054eb0:	9308      	str	r3, [sp, #32]
 8054eb2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8054eb4:	eb0a 0903 	add.w	r9, sl, r3
 8054eb8:	f109 0301 	add.w	r3, r9, #1
 8054ebc:	2b01      	cmp	r3, #1
 8054ebe:	9301      	str	r3, [sp, #4]
 8054ec0:	bfb8      	it	lt
 8054ec2:	2301      	movlt	r3, #1
 8054ec4:	e7dc      	b.n	8054e80 <_dtoa_r+0x238>
 8054ec6:	2301      	movs	r3, #1
 8054ec8:	e7f2      	b.n	8054eb0 <_dtoa_r+0x268>
 8054eca:	2501      	movs	r5, #1
 8054ecc:	2300      	movs	r3, #0
 8054ece:	9305      	str	r3, [sp, #20]
 8054ed0:	9508      	str	r5, [sp, #32]
 8054ed2:	f04f 39ff 	mov.w	r9, #4294967295
 8054ed6:	2200      	movs	r2, #0
 8054ed8:	f8cd 9004 	str.w	r9, [sp, #4]
 8054edc:	2312      	movs	r3, #18
 8054ede:	9209      	str	r2, [sp, #36]	; 0x24
 8054ee0:	e7ce      	b.n	8054e80 <_dtoa_r+0x238>
 8054ee2:	2301      	movs	r3, #1
 8054ee4:	9308      	str	r3, [sp, #32]
 8054ee6:	e7f4      	b.n	8054ed2 <_dtoa_r+0x28a>
 8054ee8:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 8054eec:	f8cd 9004 	str.w	r9, [sp, #4]
 8054ef0:	464b      	mov	r3, r9
 8054ef2:	e7c5      	b.n	8054e80 <_dtoa_r+0x238>
 8054ef4:	3101      	adds	r1, #1
 8054ef6:	6461      	str	r1, [r4, #68]	; 0x44
 8054ef8:	0052      	lsls	r2, r2, #1
 8054efa:	e7c4      	b.n	8054e86 <_dtoa_r+0x23e>
 8054efc:	f3af 8000 	nop.w
 8054f00:	636f4361 	.word	0x636f4361
 8054f04:	3fd287a7 	.word	0x3fd287a7
 8054f08:	8b60c8b3 	.word	0x8b60c8b3
 8054f0c:	3fc68a28 	.word	0x3fc68a28
 8054f10:	509f79fb 	.word	0x509f79fb
 8054f14:	3fd34413 	.word	0x3fd34413
 8054f18:	7ff00000 	.word	0x7ff00000
 8054f1c:	0805a4ea 	.word	0x0805a4ea
 8054f20:	0805a4ee 	.word	0x0805a4ee
 8054f24:	0805a383 	.word	0x0805a383
 8054f28:	3ff80000 	.word	0x3ff80000
 8054f2c:	0805a670 	.word	0x0805a670
 8054f30:	0805a4f7 	.word	0x0805a4f7
 8054f34:	0805a508 	.word	0x0805a508
 8054f38:	9b00      	ldr	r3, [sp, #0]
 8054f3a:	6423      	str	r3, [r4, #64]	; 0x40
 8054f3c:	9b01      	ldr	r3, [sp, #4]
 8054f3e:	2b0e      	cmp	r3, #14
 8054f40:	f200 80ad 	bhi.w	805509e <_dtoa_r+0x456>
 8054f44:	2d00      	cmp	r5, #0
 8054f46:	f000 80aa 	beq.w	805509e <_dtoa_r+0x456>
 8054f4a:	f1ba 0f00 	cmp.w	sl, #0
 8054f4e:	dd36      	ble.n	8054fbe <_dtoa_r+0x376>
 8054f50:	4ac2      	ldr	r2, [pc, #776]	; (805525c <_dtoa_r+0x614>)
 8054f52:	f00a 030f 	and.w	r3, sl, #15
 8054f56:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8054f5a:	ed93 7b00 	vldr	d7, [r3]
 8054f5e:	f41a 7f80 	tst.w	sl, #256	; 0x100
 8054f62:	ea4f 172a 	mov.w	r7, sl, asr #4
 8054f66:	eeb0 8a47 	vmov.f32	s16, s14
 8054f6a:	eef0 8a67 	vmov.f32	s17, s15
 8054f6e:	d016      	beq.n	8054f9e <_dtoa_r+0x356>
 8054f70:	4bbb      	ldr	r3, [pc, #748]	; (8055260 <_dtoa_r+0x618>)
 8054f72:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8054f76:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8054f7a:	f7eb fc77 	bl	804086c <__aeabi_ddiv>
 8054f7e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8054f82:	f007 070f 	and.w	r7, r7, #15
 8054f86:	2503      	movs	r5, #3
 8054f88:	4eb5      	ldr	r6, [pc, #724]	; (8055260 <_dtoa_r+0x618>)
 8054f8a:	b957      	cbnz	r7, 8054fa2 <_dtoa_r+0x35a>
 8054f8c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8054f90:	ec53 2b18 	vmov	r2, r3, d8
 8054f94:	f7eb fc6a 	bl	804086c <__aeabi_ddiv>
 8054f98:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8054f9c:	e029      	b.n	8054ff2 <_dtoa_r+0x3aa>
 8054f9e:	2502      	movs	r5, #2
 8054fa0:	e7f2      	b.n	8054f88 <_dtoa_r+0x340>
 8054fa2:	07f9      	lsls	r1, r7, #31
 8054fa4:	d508      	bpl.n	8054fb8 <_dtoa_r+0x370>
 8054fa6:	ec51 0b18 	vmov	r0, r1, d8
 8054faa:	e9d6 2300 	ldrd	r2, r3, [r6]
 8054fae:	f7eb fb33 	bl	8040618 <__aeabi_dmul>
 8054fb2:	ec41 0b18 	vmov	d8, r0, r1
 8054fb6:	3501      	adds	r5, #1
 8054fb8:	107f      	asrs	r7, r7, #1
 8054fba:	3608      	adds	r6, #8
 8054fbc:	e7e5      	b.n	8054f8a <_dtoa_r+0x342>
 8054fbe:	f000 80a6 	beq.w	805510e <_dtoa_r+0x4c6>
 8054fc2:	f1ca 0600 	rsb	r6, sl, #0
 8054fc6:	4ba5      	ldr	r3, [pc, #660]	; (805525c <_dtoa_r+0x614>)
 8054fc8:	4fa5      	ldr	r7, [pc, #660]	; (8055260 <_dtoa_r+0x618>)
 8054fca:	f006 020f 	and.w	r2, r6, #15
 8054fce:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8054fd2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8054fd6:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8054fda:	f7eb fb1d 	bl	8040618 <__aeabi_dmul>
 8054fde:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8054fe2:	1136      	asrs	r6, r6, #4
 8054fe4:	2300      	movs	r3, #0
 8054fe6:	2502      	movs	r5, #2
 8054fe8:	2e00      	cmp	r6, #0
 8054fea:	f040 8085 	bne.w	80550f8 <_dtoa_r+0x4b0>
 8054fee:	2b00      	cmp	r3, #0
 8054ff0:	d1d2      	bne.n	8054f98 <_dtoa_r+0x350>
 8054ff2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8054ff4:	2b00      	cmp	r3, #0
 8054ff6:	f000 808c 	beq.w	8055112 <_dtoa_r+0x4ca>
 8054ffa:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8054ffe:	4b99      	ldr	r3, [pc, #612]	; (8055264 <_dtoa_r+0x61c>)
 8055000:	2200      	movs	r2, #0
 8055002:	4630      	mov	r0, r6
 8055004:	4639      	mov	r1, r7
 8055006:	f7eb fd79 	bl	8040afc <__aeabi_dcmplt>
 805500a:	2800      	cmp	r0, #0
 805500c:	f000 8081 	beq.w	8055112 <_dtoa_r+0x4ca>
 8055010:	9b01      	ldr	r3, [sp, #4]
 8055012:	2b00      	cmp	r3, #0
 8055014:	d07d      	beq.n	8055112 <_dtoa_r+0x4ca>
 8055016:	f1b9 0f00 	cmp.w	r9, #0
 805501a:	dd3c      	ble.n	8055096 <_dtoa_r+0x44e>
 805501c:	f10a 33ff 	add.w	r3, sl, #4294967295
 8055020:	9307      	str	r3, [sp, #28]
 8055022:	2200      	movs	r2, #0
 8055024:	4b90      	ldr	r3, [pc, #576]	; (8055268 <_dtoa_r+0x620>)
 8055026:	4630      	mov	r0, r6
 8055028:	4639      	mov	r1, r7
 805502a:	f7eb faf5 	bl	8040618 <__aeabi_dmul>
 805502e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8055032:	3501      	adds	r5, #1
 8055034:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
 8055038:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 805503c:	4628      	mov	r0, r5
 805503e:	f7eb fa81 	bl	8040544 <__aeabi_i2d>
 8055042:	4632      	mov	r2, r6
 8055044:	463b      	mov	r3, r7
 8055046:	f7eb fae7 	bl	8040618 <__aeabi_dmul>
 805504a:	4b88      	ldr	r3, [pc, #544]	; (805526c <_dtoa_r+0x624>)
 805504c:	2200      	movs	r2, #0
 805504e:	f7eb f92d 	bl	80402ac <__adddf3>
 8055052:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 8055056:	e9cd 0102 	strd	r0, r1, [sp, #8]
 805505a:	9303      	str	r3, [sp, #12]
 805505c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 805505e:	2b00      	cmp	r3, #0
 8055060:	d15c      	bne.n	805511c <_dtoa_r+0x4d4>
 8055062:	4b83      	ldr	r3, [pc, #524]	; (8055270 <_dtoa_r+0x628>)
 8055064:	2200      	movs	r2, #0
 8055066:	4630      	mov	r0, r6
 8055068:	4639      	mov	r1, r7
 805506a:	f7eb f91d 	bl	80402a8 <__aeabi_dsub>
 805506e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8055072:	4606      	mov	r6, r0
 8055074:	460f      	mov	r7, r1
 8055076:	f7eb fd5f 	bl	8040b38 <__aeabi_dcmpgt>
 805507a:	2800      	cmp	r0, #0
 805507c:	f040 8295 	bne.w	80555aa <_dtoa_r+0x962>
 8055080:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 8055084:	4630      	mov	r0, r6
 8055086:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 805508a:	4639      	mov	r1, r7
 805508c:	f7eb fd36 	bl	8040afc <__aeabi_dcmplt>
 8055090:	2800      	cmp	r0, #0
 8055092:	f040 8287 	bne.w	80555a4 <_dtoa_r+0x95c>
 8055096:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 805509a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 805509e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80550a0:	2b00      	cmp	r3, #0
 80550a2:	f2c0 8157 	blt.w	8055354 <_dtoa_r+0x70c>
 80550a6:	f1ba 0f0e 	cmp.w	sl, #14
 80550aa:	f300 8153 	bgt.w	8055354 <_dtoa_r+0x70c>
 80550ae:	4b6b      	ldr	r3, [pc, #428]	; (805525c <_dtoa_r+0x614>)
 80550b0:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 80550b4:	e9d3 8900 	ldrd	r8, r9, [r3]
 80550b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80550ba:	2b00      	cmp	r3, #0
 80550bc:	f280 80e2 	bge.w	8055284 <_dtoa_r+0x63c>
 80550c0:	9b01      	ldr	r3, [sp, #4]
 80550c2:	2b00      	cmp	r3, #0
 80550c4:	f300 80de 	bgt.w	8055284 <_dtoa_r+0x63c>
 80550c8:	f040 826c 	bne.w	80555a4 <_dtoa_r+0x95c>
 80550cc:	4b68      	ldr	r3, [pc, #416]	; (8055270 <_dtoa_r+0x628>)
 80550ce:	2200      	movs	r2, #0
 80550d0:	4640      	mov	r0, r8
 80550d2:	4649      	mov	r1, r9
 80550d4:	f7eb faa0 	bl	8040618 <__aeabi_dmul>
 80550d8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80550dc:	f7eb fd22 	bl	8040b24 <__aeabi_dcmpge>
 80550e0:	9e01      	ldr	r6, [sp, #4]
 80550e2:	4637      	mov	r7, r6
 80550e4:	2800      	cmp	r0, #0
 80550e6:	f040 8242 	bne.w	805556e <_dtoa_r+0x926>
 80550ea:	9d00      	ldr	r5, [sp, #0]
 80550ec:	2331      	movs	r3, #49	; 0x31
 80550ee:	f805 3b01 	strb.w	r3, [r5], #1
 80550f2:	f10a 0a01 	add.w	sl, sl, #1
 80550f6:	e23e      	b.n	8055576 <_dtoa_r+0x92e>
 80550f8:	07f2      	lsls	r2, r6, #31
 80550fa:	d505      	bpl.n	8055108 <_dtoa_r+0x4c0>
 80550fc:	e9d7 2300 	ldrd	r2, r3, [r7]
 8055100:	f7eb fa8a 	bl	8040618 <__aeabi_dmul>
 8055104:	3501      	adds	r5, #1
 8055106:	2301      	movs	r3, #1
 8055108:	1076      	asrs	r6, r6, #1
 805510a:	3708      	adds	r7, #8
 805510c:	e76c      	b.n	8054fe8 <_dtoa_r+0x3a0>
 805510e:	2502      	movs	r5, #2
 8055110:	e76f      	b.n	8054ff2 <_dtoa_r+0x3aa>
 8055112:	9b01      	ldr	r3, [sp, #4]
 8055114:	f8cd a01c 	str.w	sl, [sp, #28]
 8055118:	930c      	str	r3, [sp, #48]	; 0x30
 805511a:	e78d      	b.n	8055038 <_dtoa_r+0x3f0>
 805511c:	9900      	ldr	r1, [sp, #0]
 805511e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8055120:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8055122:	4b4e      	ldr	r3, [pc, #312]	; (805525c <_dtoa_r+0x614>)
 8055124:	ed9d 7b02 	vldr	d7, [sp, #8]
 8055128:	4401      	add	r1, r0
 805512a:	9102      	str	r1, [sp, #8]
 805512c:	9908      	ldr	r1, [sp, #32]
 805512e:	eeb0 8a47 	vmov.f32	s16, s14
 8055132:	eef0 8a67 	vmov.f32	s17, s15
 8055136:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 805513a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 805513e:	2900      	cmp	r1, #0
 8055140:	d045      	beq.n	80551ce <_dtoa_r+0x586>
 8055142:	494c      	ldr	r1, [pc, #304]	; (8055274 <_dtoa_r+0x62c>)
 8055144:	2000      	movs	r0, #0
 8055146:	f7eb fb91 	bl	804086c <__aeabi_ddiv>
 805514a:	ec53 2b18 	vmov	r2, r3, d8
 805514e:	f7eb f8ab 	bl	80402a8 <__aeabi_dsub>
 8055152:	9d00      	ldr	r5, [sp, #0]
 8055154:	ec41 0b18 	vmov	d8, r0, r1
 8055158:	4639      	mov	r1, r7
 805515a:	4630      	mov	r0, r6
 805515c:	f7eb fd0c 	bl	8040b78 <__aeabi_d2iz>
 8055160:	900c      	str	r0, [sp, #48]	; 0x30
 8055162:	f7eb f9ef 	bl	8040544 <__aeabi_i2d>
 8055166:	4602      	mov	r2, r0
 8055168:	460b      	mov	r3, r1
 805516a:	4630      	mov	r0, r6
 805516c:	4639      	mov	r1, r7
 805516e:	f7eb f89b 	bl	80402a8 <__aeabi_dsub>
 8055172:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8055174:	3330      	adds	r3, #48	; 0x30
 8055176:	f805 3b01 	strb.w	r3, [r5], #1
 805517a:	ec53 2b18 	vmov	r2, r3, d8
 805517e:	4606      	mov	r6, r0
 8055180:	460f      	mov	r7, r1
 8055182:	f7eb fcbb 	bl	8040afc <__aeabi_dcmplt>
 8055186:	2800      	cmp	r0, #0
 8055188:	d165      	bne.n	8055256 <_dtoa_r+0x60e>
 805518a:	4632      	mov	r2, r6
 805518c:	463b      	mov	r3, r7
 805518e:	4935      	ldr	r1, [pc, #212]	; (8055264 <_dtoa_r+0x61c>)
 8055190:	2000      	movs	r0, #0
 8055192:	f7eb f889 	bl	80402a8 <__aeabi_dsub>
 8055196:	ec53 2b18 	vmov	r2, r3, d8
 805519a:	f7eb fcaf 	bl	8040afc <__aeabi_dcmplt>
 805519e:	2800      	cmp	r0, #0
 80551a0:	f040 80b8 	bne.w	8055314 <_dtoa_r+0x6cc>
 80551a4:	9b02      	ldr	r3, [sp, #8]
 80551a6:	429d      	cmp	r5, r3
 80551a8:	f43f af75 	beq.w	8055096 <_dtoa_r+0x44e>
 80551ac:	4b2e      	ldr	r3, [pc, #184]	; (8055268 <_dtoa_r+0x620>)
 80551ae:	ec51 0b18 	vmov	r0, r1, d8
 80551b2:	2200      	movs	r2, #0
 80551b4:	f7eb fa30 	bl	8040618 <__aeabi_dmul>
 80551b8:	4b2b      	ldr	r3, [pc, #172]	; (8055268 <_dtoa_r+0x620>)
 80551ba:	ec41 0b18 	vmov	d8, r0, r1
 80551be:	2200      	movs	r2, #0
 80551c0:	4630      	mov	r0, r6
 80551c2:	4639      	mov	r1, r7
 80551c4:	f7eb fa28 	bl	8040618 <__aeabi_dmul>
 80551c8:	4606      	mov	r6, r0
 80551ca:	460f      	mov	r7, r1
 80551cc:	e7c4      	b.n	8055158 <_dtoa_r+0x510>
 80551ce:	ec51 0b17 	vmov	r0, r1, d7
 80551d2:	f7eb fa21 	bl	8040618 <__aeabi_dmul>
 80551d6:	9b02      	ldr	r3, [sp, #8]
 80551d8:	9d00      	ldr	r5, [sp, #0]
 80551da:	930c      	str	r3, [sp, #48]	; 0x30
 80551dc:	ec41 0b18 	vmov	d8, r0, r1
 80551e0:	4639      	mov	r1, r7
 80551e2:	4630      	mov	r0, r6
 80551e4:	f7eb fcc8 	bl	8040b78 <__aeabi_d2iz>
 80551e8:	9011      	str	r0, [sp, #68]	; 0x44
 80551ea:	f7eb f9ab 	bl	8040544 <__aeabi_i2d>
 80551ee:	4602      	mov	r2, r0
 80551f0:	460b      	mov	r3, r1
 80551f2:	4630      	mov	r0, r6
 80551f4:	4639      	mov	r1, r7
 80551f6:	f7eb f857 	bl	80402a8 <__aeabi_dsub>
 80551fa:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80551fc:	3330      	adds	r3, #48	; 0x30
 80551fe:	f805 3b01 	strb.w	r3, [r5], #1
 8055202:	9b02      	ldr	r3, [sp, #8]
 8055204:	429d      	cmp	r5, r3
 8055206:	4606      	mov	r6, r0
 8055208:	460f      	mov	r7, r1
 805520a:	f04f 0200 	mov.w	r2, #0
 805520e:	d133      	bne.n	8055278 <_dtoa_r+0x630>
 8055210:	4b18      	ldr	r3, [pc, #96]	; (8055274 <_dtoa_r+0x62c>)
 8055212:	ec51 0b18 	vmov	r0, r1, d8
 8055216:	f7eb f849 	bl	80402ac <__adddf3>
 805521a:	4602      	mov	r2, r0
 805521c:	460b      	mov	r3, r1
 805521e:	4630      	mov	r0, r6
 8055220:	4639      	mov	r1, r7
 8055222:	f7eb fc89 	bl	8040b38 <__aeabi_dcmpgt>
 8055226:	2800      	cmp	r0, #0
 8055228:	d174      	bne.n	8055314 <_dtoa_r+0x6cc>
 805522a:	ec53 2b18 	vmov	r2, r3, d8
 805522e:	4911      	ldr	r1, [pc, #68]	; (8055274 <_dtoa_r+0x62c>)
 8055230:	2000      	movs	r0, #0
 8055232:	f7eb f839 	bl	80402a8 <__aeabi_dsub>
 8055236:	4602      	mov	r2, r0
 8055238:	460b      	mov	r3, r1
 805523a:	4630      	mov	r0, r6
 805523c:	4639      	mov	r1, r7
 805523e:	f7eb fc5d 	bl	8040afc <__aeabi_dcmplt>
 8055242:	2800      	cmp	r0, #0
 8055244:	f43f af27 	beq.w	8055096 <_dtoa_r+0x44e>
 8055248:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 805524a:	1e6b      	subs	r3, r5, #1
 805524c:	930c      	str	r3, [sp, #48]	; 0x30
 805524e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8055252:	2b30      	cmp	r3, #48	; 0x30
 8055254:	d0f8      	beq.n	8055248 <_dtoa_r+0x600>
 8055256:	f8dd a01c 	ldr.w	sl, [sp, #28]
 805525a:	e049      	b.n	80552f0 <_dtoa_r+0x6a8>
 805525c:	0805a670 	.word	0x0805a670
 8055260:	0805a648 	.word	0x0805a648
 8055264:	3ff00000 	.word	0x3ff00000
 8055268:	40240000 	.word	0x40240000
 805526c:	401c0000 	.word	0x401c0000
 8055270:	40140000 	.word	0x40140000
 8055274:	3fe00000 	.word	0x3fe00000
 8055278:	4baf      	ldr	r3, [pc, #700]	; (8055538 <_dtoa_r+0x8f0>)
 805527a:	f7eb f9cd 	bl	8040618 <__aeabi_dmul>
 805527e:	4606      	mov	r6, r0
 8055280:	460f      	mov	r7, r1
 8055282:	e7ad      	b.n	80551e0 <_dtoa_r+0x598>
 8055284:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8055288:	9d00      	ldr	r5, [sp, #0]
 805528a:	4642      	mov	r2, r8
 805528c:	464b      	mov	r3, r9
 805528e:	4630      	mov	r0, r6
 8055290:	4639      	mov	r1, r7
 8055292:	f7eb faeb 	bl	804086c <__aeabi_ddiv>
 8055296:	f7eb fc6f 	bl	8040b78 <__aeabi_d2iz>
 805529a:	9002      	str	r0, [sp, #8]
 805529c:	f7eb f952 	bl	8040544 <__aeabi_i2d>
 80552a0:	4642      	mov	r2, r8
 80552a2:	464b      	mov	r3, r9
 80552a4:	f7eb f9b8 	bl	8040618 <__aeabi_dmul>
 80552a8:	4602      	mov	r2, r0
 80552aa:	460b      	mov	r3, r1
 80552ac:	4630      	mov	r0, r6
 80552ae:	4639      	mov	r1, r7
 80552b0:	f7ea fffa 	bl	80402a8 <__aeabi_dsub>
 80552b4:	9e02      	ldr	r6, [sp, #8]
 80552b6:	9f01      	ldr	r7, [sp, #4]
 80552b8:	3630      	adds	r6, #48	; 0x30
 80552ba:	f805 6b01 	strb.w	r6, [r5], #1
 80552be:	9e00      	ldr	r6, [sp, #0]
 80552c0:	1bae      	subs	r6, r5, r6
 80552c2:	42b7      	cmp	r7, r6
 80552c4:	4602      	mov	r2, r0
 80552c6:	460b      	mov	r3, r1
 80552c8:	d137      	bne.n	805533a <_dtoa_r+0x6f2>
 80552ca:	f7ea ffef 	bl	80402ac <__adddf3>
 80552ce:	4642      	mov	r2, r8
 80552d0:	464b      	mov	r3, r9
 80552d2:	4606      	mov	r6, r0
 80552d4:	460f      	mov	r7, r1
 80552d6:	f7eb fc2f 	bl	8040b38 <__aeabi_dcmpgt>
 80552da:	b9c8      	cbnz	r0, 8055310 <_dtoa_r+0x6c8>
 80552dc:	4642      	mov	r2, r8
 80552de:	464b      	mov	r3, r9
 80552e0:	4630      	mov	r0, r6
 80552e2:	4639      	mov	r1, r7
 80552e4:	f7eb fc00 	bl	8040ae8 <__aeabi_dcmpeq>
 80552e8:	b110      	cbz	r0, 80552f0 <_dtoa_r+0x6a8>
 80552ea:	9b02      	ldr	r3, [sp, #8]
 80552ec:	07d9      	lsls	r1, r3, #31
 80552ee:	d40f      	bmi.n	8055310 <_dtoa_r+0x6c8>
 80552f0:	4620      	mov	r0, r4
 80552f2:	4659      	mov	r1, fp
 80552f4:	f001 f90b 	bl	805650e <_Bfree>
 80552f8:	2300      	movs	r3, #0
 80552fa:	702b      	strb	r3, [r5, #0]
 80552fc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80552fe:	f10a 0001 	add.w	r0, sl, #1
 8055302:	6018      	str	r0, [r3, #0]
 8055304:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8055306:	2b00      	cmp	r3, #0
 8055308:	f43f acd9 	beq.w	8054cbe <_dtoa_r+0x76>
 805530c:	601d      	str	r5, [r3, #0]
 805530e:	e4d6      	b.n	8054cbe <_dtoa_r+0x76>
 8055310:	f8cd a01c 	str.w	sl, [sp, #28]
 8055314:	462b      	mov	r3, r5
 8055316:	461d      	mov	r5, r3
 8055318:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 805531c:	2a39      	cmp	r2, #57	; 0x39
 805531e:	d108      	bne.n	8055332 <_dtoa_r+0x6ea>
 8055320:	9a00      	ldr	r2, [sp, #0]
 8055322:	429a      	cmp	r2, r3
 8055324:	d1f7      	bne.n	8055316 <_dtoa_r+0x6ce>
 8055326:	9a07      	ldr	r2, [sp, #28]
 8055328:	9900      	ldr	r1, [sp, #0]
 805532a:	3201      	adds	r2, #1
 805532c:	9207      	str	r2, [sp, #28]
 805532e:	2230      	movs	r2, #48	; 0x30
 8055330:	700a      	strb	r2, [r1, #0]
 8055332:	781a      	ldrb	r2, [r3, #0]
 8055334:	3201      	adds	r2, #1
 8055336:	701a      	strb	r2, [r3, #0]
 8055338:	e78d      	b.n	8055256 <_dtoa_r+0x60e>
 805533a:	4b7f      	ldr	r3, [pc, #508]	; (8055538 <_dtoa_r+0x8f0>)
 805533c:	2200      	movs	r2, #0
 805533e:	f7eb f96b 	bl	8040618 <__aeabi_dmul>
 8055342:	2200      	movs	r2, #0
 8055344:	2300      	movs	r3, #0
 8055346:	4606      	mov	r6, r0
 8055348:	460f      	mov	r7, r1
 805534a:	f7eb fbcd 	bl	8040ae8 <__aeabi_dcmpeq>
 805534e:	2800      	cmp	r0, #0
 8055350:	d09b      	beq.n	805528a <_dtoa_r+0x642>
 8055352:	e7cd      	b.n	80552f0 <_dtoa_r+0x6a8>
 8055354:	9a08      	ldr	r2, [sp, #32]
 8055356:	2a00      	cmp	r2, #0
 8055358:	f000 80c4 	beq.w	80554e4 <_dtoa_r+0x89c>
 805535c:	9a05      	ldr	r2, [sp, #20]
 805535e:	2a01      	cmp	r2, #1
 8055360:	f300 80a8 	bgt.w	80554b4 <_dtoa_r+0x86c>
 8055364:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8055366:	2a00      	cmp	r2, #0
 8055368:	f000 80a0 	beq.w	80554ac <_dtoa_r+0x864>
 805536c:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8055370:	9e06      	ldr	r6, [sp, #24]
 8055372:	4645      	mov	r5, r8
 8055374:	9a04      	ldr	r2, [sp, #16]
 8055376:	2101      	movs	r1, #1
 8055378:	441a      	add	r2, r3
 805537a:	4620      	mov	r0, r4
 805537c:	4498      	add	r8, r3
 805537e:	9204      	str	r2, [sp, #16]
 8055380:	f001 f9b2 	bl	80566e8 <__i2b>
 8055384:	4607      	mov	r7, r0
 8055386:	2d00      	cmp	r5, #0
 8055388:	dd0b      	ble.n	80553a2 <_dtoa_r+0x75a>
 805538a:	9b04      	ldr	r3, [sp, #16]
 805538c:	2b00      	cmp	r3, #0
 805538e:	dd08      	ble.n	80553a2 <_dtoa_r+0x75a>
 8055390:	42ab      	cmp	r3, r5
 8055392:	9a04      	ldr	r2, [sp, #16]
 8055394:	bfa8      	it	ge
 8055396:	462b      	movge	r3, r5
 8055398:	eba8 0803 	sub.w	r8, r8, r3
 805539c:	1aed      	subs	r5, r5, r3
 805539e:	1ad3      	subs	r3, r2, r3
 80553a0:	9304      	str	r3, [sp, #16]
 80553a2:	9b06      	ldr	r3, [sp, #24]
 80553a4:	b1fb      	cbz	r3, 80553e6 <_dtoa_r+0x79e>
 80553a6:	9b08      	ldr	r3, [sp, #32]
 80553a8:	2b00      	cmp	r3, #0
 80553aa:	f000 809f 	beq.w	80554ec <_dtoa_r+0x8a4>
 80553ae:	2e00      	cmp	r6, #0
 80553b0:	dd11      	ble.n	80553d6 <_dtoa_r+0x78e>
 80553b2:	4639      	mov	r1, r7
 80553b4:	4632      	mov	r2, r6
 80553b6:	4620      	mov	r0, r4
 80553b8:	f001 fa52 	bl	8056860 <__pow5mult>
 80553bc:	465a      	mov	r2, fp
 80553be:	4601      	mov	r1, r0
 80553c0:	4607      	mov	r7, r0
 80553c2:	4620      	mov	r0, r4
 80553c4:	f001 f9a6 	bl	8056714 <__multiply>
 80553c8:	4659      	mov	r1, fp
 80553ca:	9007      	str	r0, [sp, #28]
 80553cc:	4620      	mov	r0, r4
 80553ce:	f001 f89e 	bl	805650e <_Bfree>
 80553d2:	9b07      	ldr	r3, [sp, #28]
 80553d4:	469b      	mov	fp, r3
 80553d6:	9b06      	ldr	r3, [sp, #24]
 80553d8:	1b9a      	subs	r2, r3, r6
 80553da:	d004      	beq.n	80553e6 <_dtoa_r+0x79e>
 80553dc:	4659      	mov	r1, fp
 80553de:	4620      	mov	r0, r4
 80553e0:	f001 fa3e 	bl	8056860 <__pow5mult>
 80553e4:	4683      	mov	fp, r0
 80553e6:	2101      	movs	r1, #1
 80553e8:	4620      	mov	r0, r4
 80553ea:	f001 f97d 	bl	80566e8 <__i2b>
 80553ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80553f0:	2b00      	cmp	r3, #0
 80553f2:	4606      	mov	r6, r0
 80553f4:	dd7c      	ble.n	80554f0 <_dtoa_r+0x8a8>
 80553f6:	461a      	mov	r2, r3
 80553f8:	4601      	mov	r1, r0
 80553fa:	4620      	mov	r0, r4
 80553fc:	f001 fa30 	bl	8056860 <__pow5mult>
 8055400:	9b05      	ldr	r3, [sp, #20]
 8055402:	2b01      	cmp	r3, #1
 8055404:	4606      	mov	r6, r0
 8055406:	dd76      	ble.n	80554f6 <_dtoa_r+0x8ae>
 8055408:	2300      	movs	r3, #0
 805540a:	9306      	str	r3, [sp, #24]
 805540c:	6933      	ldr	r3, [r6, #16]
 805540e:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8055412:	6918      	ldr	r0, [r3, #16]
 8055414:	f001 f918 	bl	8056648 <__hi0bits>
 8055418:	f1c0 0020 	rsb	r0, r0, #32
 805541c:	9b04      	ldr	r3, [sp, #16]
 805541e:	4418      	add	r0, r3
 8055420:	f010 001f 	ands.w	r0, r0, #31
 8055424:	f000 8086 	beq.w	8055534 <_dtoa_r+0x8ec>
 8055428:	f1c0 0320 	rsb	r3, r0, #32
 805542c:	2b04      	cmp	r3, #4
 805542e:	dd7f      	ble.n	8055530 <_dtoa_r+0x8e8>
 8055430:	f1c0 001c 	rsb	r0, r0, #28
 8055434:	9b04      	ldr	r3, [sp, #16]
 8055436:	4403      	add	r3, r0
 8055438:	4480      	add	r8, r0
 805543a:	4405      	add	r5, r0
 805543c:	9304      	str	r3, [sp, #16]
 805543e:	f1b8 0f00 	cmp.w	r8, #0
 8055442:	dd05      	ble.n	8055450 <_dtoa_r+0x808>
 8055444:	4659      	mov	r1, fp
 8055446:	4642      	mov	r2, r8
 8055448:	4620      	mov	r0, r4
 805544a:	f001 fa49 	bl	80568e0 <__lshift>
 805544e:	4683      	mov	fp, r0
 8055450:	9b04      	ldr	r3, [sp, #16]
 8055452:	2b00      	cmp	r3, #0
 8055454:	dd05      	ble.n	8055462 <_dtoa_r+0x81a>
 8055456:	4631      	mov	r1, r6
 8055458:	461a      	mov	r2, r3
 805545a:	4620      	mov	r0, r4
 805545c:	f001 fa40 	bl	80568e0 <__lshift>
 8055460:	4606      	mov	r6, r0
 8055462:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8055464:	2b00      	cmp	r3, #0
 8055466:	d069      	beq.n	805553c <_dtoa_r+0x8f4>
 8055468:	4631      	mov	r1, r6
 805546a:	4658      	mov	r0, fp
 805546c:	f001 faa4 	bl	80569b8 <__mcmp>
 8055470:	2800      	cmp	r0, #0
 8055472:	da63      	bge.n	805553c <_dtoa_r+0x8f4>
 8055474:	2300      	movs	r3, #0
 8055476:	4659      	mov	r1, fp
 8055478:	220a      	movs	r2, #10
 805547a:	4620      	mov	r0, r4
 805547c:	f001 f850 	bl	8056520 <__multadd>
 8055480:	9b08      	ldr	r3, [sp, #32]
 8055482:	f10a 3aff 	add.w	sl, sl, #4294967295
 8055486:	4683      	mov	fp, r0
 8055488:	2b00      	cmp	r3, #0
 805548a:	f000 818e 	beq.w	80557aa <_dtoa_r+0xb62>
 805548e:	4639      	mov	r1, r7
 8055490:	2300      	movs	r3, #0
 8055492:	220a      	movs	r2, #10
 8055494:	4620      	mov	r0, r4
 8055496:	f001 f843 	bl	8056520 <__multadd>
 805549a:	f1b9 0f00 	cmp.w	r9, #0
 805549e:	4607      	mov	r7, r0
 80554a0:	f300 808e 	bgt.w	80555c0 <_dtoa_r+0x978>
 80554a4:	9b05      	ldr	r3, [sp, #20]
 80554a6:	2b02      	cmp	r3, #2
 80554a8:	dc50      	bgt.n	805554c <_dtoa_r+0x904>
 80554aa:	e089      	b.n	80555c0 <_dtoa_r+0x978>
 80554ac:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80554ae:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80554b2:	e75d      	b.n	8055370 <_dtoa_r+0x728>
 80554b4:	9b01      	ldr	r3, [sp, #4]
 80554b6:	1e5e      	subs	r6, r3, #1
 80554b8:	9b06      	ldr	r3, [sp, #24]
 80554ba:	42b3      	cmp	r3, r6
 80554bc:	bfbf      	itttt	lt
 80554be:	9b06      	ldrlt	r3, [sp, #24]
 80554c0:	9606      	strlt	r6, [sp, #24]
 80554c2:	1af2      	sublt	r2, r6, r3
 80554c4:	9b0d      	ldrlt	r3, [sp, #52]	; 0x34
 80554c6:	bfb6      	itet	lt
 80554c8:	189b      	addlt	r3, r3, r2
 80554ca:	1b9e      	subge	r6, r3, r6
 80554cc:	930d      	strlt	r3, [sp, #52]	; 0x34
 80554ce:	9b01      	ldr	r3, [sp, #4]
 80554d0:	bfb8      	it	lt
 80554d2:	2600      	movlt	r6, #0
 80554d4:	2b00      	cmp	r3, #0
 80554d6:	bfb5      	itete	lt
 80554d8:	eba8 0503 	sublt.w	r5, r8, r3
 80554dc:	9b01      	ldrge	r3, [sp, #4]
 80554de:	2300      	movlt	r3, #0
 80554e0:	4645      	movge	r5, r8
 80554e2:	e747      	b.n	8055374 <_dtoa_r+0x72c>
 80554e4:	9e06      	ldr	r6, [sp, #24]
 80554e6:	9f08      	ldr	r7, [sp, #32]
 80554e8:	4645      	mov	r5, r8
 80554ea:	e74c      	b.n	8055386 <_dtoa_r+0x73e>
 80554ec:	9a06      	ldr	r2, [sp, #24]
 80554ee:	e775      	b.n	80553dc <_dtoa_r+0x794>
 80554f0:	9b05      	ldr	r3, [sp, #20]
 80554f2:	2b01      	cmp	r3, #1
 80554f4:	dc18      	bgt.n	8055528 <_dtoa_r+0x8e0>
 80554f6:	9b02      	ldr	r3, [sp, #8]
 80554f8:	b9b3      	cbnz	r3, 8055528 <_dtoa_r+0x8e0>
 80554fa:	9b03      	ldr	r3, [sp, #12]
 80554fc:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8055500:	b9a3      	cbnz	r3, 805552c <_dtoa_r+0x8e4>
 8055502:	9b03      	ldr	r3, [sp, #12]
 8055504:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8055508:	0d1b      	lsrs	r3, r3, #20
 805550a:	051b      	lsls	r3, r3, #20
 805550c:	b12b      	cbz	r3, 805551a <_dtoa_r+0x8d2>
 805550e:	9b04      	ldr	r3, [sp, #16]
 8055510:	3301      	adds	r3, #1
 8055512:	9304      	str	r3, [sp, #16]
 8055514:	f108 0801 	add.w	r8, r8, #1
 8055518:	2301      	movs	r3, #1
 805551a:	9306      	str	r3, [sp, #24]
 805551c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 805551e:	2b00      	cmp	r3, #0
 8055520:	f47f af74 	bne.w	805540c <_dtoa_r+0x7c4>
 8055524:	2001      	movs	r0, #1
 8055526:	e779      	b.n	805541c <_dtoa_r+0x7d4>
 8055528:	2300      	movs	r3, #0
 805552a:	e7f6      	b.n	805551a <_dtoa_r+0x8d2>
 805552c:	9b02      	ldr	r3, [sp, #8]
 805552e:	e7f4      	b.n	805551a <_dtoa_r+0x8d2>
 8055530:	d085      	beq.n	805543e <_dtoa_r+0x7f6>
 8055532:	4618      	mov	r0, r3
 8055534:	301c      	adds	r0, #28
 8055536:	e77d      	b.n	8055434 <_dtoa_r+0x7ec>
 8055538:	40240000 	.word	0x40240000
 805553c:	9b01      	ldr	r3, [sp, #4]
 805553e:	2b00      	cmp	r3, #0
 8055540:	dc38      	bgt.n	80555b4 <_dtoa_r+0x96c>
 8055542:	9b05      	ldr	r3, [sp, #20]
 8055544:	2b02      	cmp	r3, #2
 8055546:	dd35      	ble.n	80555b4 <_dtoa_r+0x96c>
 8055548:	f8dd 9004 	ldr.w	r9, [sp, #4]
 805554c:	f1b9 0f00 	cmp.w	r9, #0
 8055550:	d10d      	bne.n	805556e <_dtoa_r+0x926>
 8055552:	4631      	mov	r1, r6
 8055554:	464b      	mov	r3, r9
 8055556:	2205      	movs	r2, #5
 8055558:	4620      	mov	r0, r4
 805555a:	f000 ffe1 	bl	8056520 <__multadd>
 805555e:	4601      	mov	r1, r0
 8055560:	4606      	mov	r6, r0
 8055562:	4658      	mov	r0, fp
 8055564:	f001 fa28 	bl	80569b8 <__mcmp>
 8055568:	2800      	cmp	r0, #0
 805556a:	f73f adbe 	bgt.w	80550ea <_dtoa_r+0x4a2>
 805556e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8055570:	9d00      	ldr	r5, [sp, #0]
 8055572:	ea6f 0a03 	mvn.w	sl, r3
 8055576:	f04f 0800 	mov.w	r8, #0
 805557a:	4631      	mov	r1, r6
 805557c:	4620      	mov	r0, r4
 805557e:	f000 ffc6 	bl	805650e <_Bfree>
 8055582:	2f00      	cmp	r7, #0
 8055584:	f43f aeb4 	beq.w	80552f0 <_dtoa_r+0x6a8>
 8055588:	f1b8 0f00 	cmp.w	r8, #0
 805558c:	d005      	beq.n	805559a <_dtoa_r+0x952>
 805558e:	45b8      	cmp	r8, r7
 8055590:	d003      	beq.n	805559a <_dtoa_r+0x952>
 8055592:	4641      	mov	r1, r8
 8055594:	4620      	mov	r0, r4
 8055596:	f000 ffba 	bl	805650e <_Bfree>
 805559a:	4639      	mov	r1, r7
 805559c:	4620      	mov	r0, r4
 805559e:	f000 ffb6 	bl	805650e <_Bfree>
 80555a2:	e6a5      	b.n	80552f0 <_dtoa_r+0x6a8>
 80555a4:	2600      	movs	r6, #0
 80555a6:	4637      	mov	r7, r6
 80555a8:	e7e1      	b.n	805556e <_dtoa_r+0x926>
 80555aa:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80555ac:	f8dd a01c 	ldr.w	sl, [sp, #28]
 80555b0:	4637      	mov	r7, r6
 80555b2:	e59a      	b.n	80550ea <_dtoa_r+0x4a2>
 80555b4:	9b08      	ldr	r3, [sp, #32]
 80555b6:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80555ba:	2b00      	cmp	r3, #0
 80555bc:	f000 80fc 	beq.w	80557b8 <_dtoa_r+0xb70>
 80555c0:	2d00      	cmp	r5, #0
 80555c2:	dd05      	ble.n	80555d0 <_dtoa_r+0x988>
 80555c4:	4639      	mov	r1, r7
 80555c6:	462a      	mov	r2, r5
 80555c8:	4620      	mov	r0, r4
 80555ca:	f001 f989 	bl	80568e0 <__lshift>
 80555ce:	4607      	mov	r7, r0
 80555d0:	9b06      	ldr	r3, [sp, #24]
 80555d2:	2b00      	cmp	r3, #0
 80555d4:	d05b      	beq.n	805568e <_dtoa_r+0xa46>
 80555d6:	6879      	ldr	r1, [r7, #4]
 80555d8:	4620      	mov	r0, r4
 80555da:	f000 ff73 	bl	80564c4 <_Balloc>
 80555de:	4605      	mov	r5, r0
 80555e0:	b920      	cbnz	r0, 80555ec <_dtoa_r+0x9a4>
 80555e2:	4b80      	ldr	r3, [pc, #512]	; (80557e4 <_dtoa_r+0xb9c>)
 80555e4:	4602      	mov	r2, r0
 80555e6:	f240 21ea 	movw	r1, #746	; 0x2ea
 80555ea:	e45b      	b.n	8054ea4 <_dtoa_r+0x25c>
 80555ec:	693a      	ldr	r2, [r7, #16]
 80555ee:	3202      	adds	r2, #2
 80555f0:	0092      	lsls	r2, r2, #2
 80555f2:	f107 010c 	add.w	r1, r7, #12
 80555f6:	300c      	adds	r0, #12
 80555f8:	f7fb fdd6 	bl	80511a8 <memcpy>
 80555fc:	2201      	movs	r2, #1
 80555fe:	4629      	mov	r1, r5
 8055600:	4620      	mov	r0, r4
 8055602:	f001 f96d 	bl	80568e0 <__lshift>
 8055606:	9b00      	ldr	r3, [sp, #0]
 8055608:	3301      	adds	r3, #1
 805560a:	9301      	str	r3, [sp, #4]
 805560c:	9b00      	ldr	r3, [sp, #0]
 805560e:	444b      	add	r3, r9
 8055610:	9307      	str	r3, [sp, #28]
 8055612:	9b02      	ldr	r3, [sp, #8]
 8055614:	f003 0301 	and.w	r3, r3, #1
 8055618:	46b8      	mov	r8, r7
 805561a:	9306      	str	r3, [sp, #24]
 805561c:	4607      	mov	r7, r0
 805561e:	9b01      	ldr	r3, [sp, #4]
 8055620:	4631      	mov	r1, r6
 8055622:	3b01      	subs	r3, #1
 8055624:	4658      	mov	r0, fp
 8055626:	9302      	str	r3, [sp, #8]
 8055628:	f7ff fa80 	bl	8054b2c <quorem>
 805562c:	4603      	mov	r3, r0
 805562e:	3330      	adds	r3, #48	; 0x30
 8055630:	9004      	str	r0, [sp, #16]
 8055632:	4641      	mov	r1, r8
 8055634:	4658      	mov	r0, fp
 8055636:	9308      	str	r3, [sp, #32]
 8055638:	f001 f9be 	bl	80569b8 <__mcmp>
 805563c:	463a      	mov	r2, r7
 805563e:	4681      	mov	r9, r0
 8055640:	4631      	mov	r1, r6
 8055642:	4620      	mov	r0, r4
 8055644:	f001 f9d4 	bl	80569f0 <__mdiff>
 8055648:	68c2      	ldr	r2, [r0, #12]
 805564a:	9b08      	ldr	r3, [sp, #32]
 805564c:	4605      	mov	r5, r0
 805564e:	bb02      	cbnz	r2, 8055692 <_dtoa_r+0xa4a>
 8055650:	4601      	mov	r1, r0
 8055652:	4658      	mov	r0, fp
 8055654:	f001 f9b0 	bl	80569b8 <__mcmp>
 8055658:	9b08      	ldr	r3, [sp, #32]
 805565a:	4602      	mov	r2, r0
 805565c:	4629      	mov	r1, r5
 805565e:	4620      	mov	r0, r4
 8055660:	e9cd 3208 	strd	r3, r2, [sp, #32]
 8055664:	f000 ff53 	bl	805650e <_Bfree>
 8055668:	9b05      	ldr	r3, [sp, #20]
 805566a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 805566c:	9d01      	ldr	r5, [sp, #4]
 805566e:	ea43 0102 	orr.w	r1, r3, r2
 8055672:	9b06      	ldr	r3, [sp, #24]
 8055674:	430b      	orrs	r3, r1
 8055676:	9b08      	ldr	r3, [sp, #32]
 8055678:	d10d      	bne.n	8055696 <_dtoa_r+0xa4e>
 805567a:	2b39      	cmp	r3, #57	; 0x39
 805567c:	d029      	beq.n	80556d2 <_dtoa_r+0xa8a>
 805567e:	f1b9 0f00 	cmp.w	r9, #0
 8055682:	dd01      	ble.n	8055688 <_dtoa_r+0xa40>
 8055684:	9b04      	ldr	r3, [sp, #16]
 8055686:	3331      	adds	r3, #49	; 0x31
 8055688:	9a02      	ldr	r2, [sp, #8]
 805568a:	7013      	strb	r3, [r2, #0]
 805568c:	e775      	b.n	805557a <_dtoa_r+0x932>
 805568e:	4638      	mov	r0, r7
 8055690:	e7b9      	b.n	8055606 <_dtoa_r+0x9be>
 8055692:	2201      	movs	r2, #1
 8055694:	e7e2      	b.n	805565c <_dtoa_r+0xa14>
 8055696:	f1b9 0f00 	cmp.w	r9, #0
 805569a:	db06      	blt.n	80556aa <_dtoa_r+0xa62>
 805569c:	9905      	ldr	r1, [sp, #20]
 805569e:	ea41 0909 	orr.w	r9, r1, r9
 80556a2:	9906      	ldr	r1, [sp, #24]
 80556a4:	ea59 0101 	orrs.w	r1, r9, r1
 80556a8:	d120      	bne.n	80556ec <_dtoa_r+0xaa4>
 80556aa:	2a00      	cmp	r2, #0
 80556ac:	ddec      	ble.n	8055688 <_dtoa_r+0xa40>
 80556ae:	4659      	mov	r1, fp
 80556b0:	2201      	movs	r2, #1
 80556b2:	4620      	mov	r0, r4
 80556b4:	9301      	str	r3, [sp, #4]
 80556b6:	f001 f913 	bl	80568e0 <__lshift>
 80556ba:	4631      	mov	r1, r6
 80556bc:	4683      	mov	fp, r0
 80556be:	f001 f97b 	bl	80569b8 <__mcmp>
 80556c2:	2800      	cmp	r0, #0
 80556c4:	9b01      	ldr	r3, [sp, #4]
 80556c6:	dc02      	bgt.n	80556ce <_dtoa_r+0xa86>
 80556c8:	d1de      	bne.n	8055688 <_dtoa_r+0xa40>
 80556ca:	07da      	lsls	r2, r3, #31
 80556cc:	d5dc      	bpl.n	8055688 <_dtoa_r+0xa40>
 80556ce:	2b39      	cmp	r3, #57	; 0x39
 80556d0:	d1d8      	bne.n	8055684 <_dtoa_r+0xa3c>
 80556d2:	9a02      	ldr	r2, [sp, #8]
 80556d4:	2339      	movs	r3, #57	; 0x39
 80556d6:	7013      	strb	r3, [r2, #0]
 80556d8:	462b      	mov	r3, r5
 80556da:	461d      	mov	r5, r3
 80556dc:	3b01      	subs	r3, #1
 80556de:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80556e2:	2a39      	cmp	r2, #57	; 0x39
 80556e4:	d050      	beq.n	8055788 <_dtoa_r+0xb40>
 80556e6:	3201      	adds	r2, #1
 80556e8:	701a      	strb	r2, [r3, #0]
 80556ea:	e746      	b.n	805557a <_dtoa_r+0x932>
 80556ec:	2a00      	cmp	r2, #0
 80556ee:	dd03      	ble.n	80556f8 <_dtoa_r+0xab0>
 80556f0:	2b39      	cmp	r3, #57	; 0x39
 80556f2:	d0ee      	beq.n	80556d2 <_dtoa_r+0xa8a>
 80556f4:	3301      	adds	r3, #1
 80556f6:	e7c7      	b.n	8055688 <_dtoa_r+0xa40>
 80556f8:	9a01      	ldr	r2, [sp, #4]
 80556fa:	9907      	ldr	r1, [sp, #28]
 80556fc:	f802 3c01 	strb.w	r3, [r2, #-1]
 8055700:	428a      	cmp	r2, r1
 8055702:	d02a      	beq.n	805575a <_dtoa_r+0xb12>
 8055704:	4659      	mov	r1, fp
 8055706:	2300      	movs	r3, #0
 8055708:	220a      	movs	r2, #10
 805570a:	4620      	mov	r0, r4
 805570c:	f000 ff08 	bl	8056520 <__multadd>
 8055710:	45b8      	cmp	r8, r7
 8055712:	4683      	mov	fp, r0
 8055714:	f04f 0300 	mov.w	r3, #0
 8055718:	f04f 020a 	mov.w	r2, #10
 805571c:	4641      	mov	r1, r8
 805571e:	4620      	mov	r0, r4
 8055720:	d107      	bne.n	8055732 <_dtoa_r+0xaea>
 8055722:	f000 fefd 	bl	8056520 <__multadd>
 8055726:	4680      	mov	r8, r0
 8055728:	4607      	mov	r7, r0
 805572a:	9b01      	ldr	r3, [sp, #4]
 805572c:	3301      	adds	r3, #1
 805572e:	9301      	str	r3, [sp, #4]
 8055730:	e775      	b.n	805561e <_dtoa_r+0x9d6>
 8055732:	f000 fef5 	bl	8056520 <__multadd>
 8055736:	4639      	mov	r1, r7
 8055738:	4680      	mov	r8, r0
 805573a:	2300      	movs	r3, #0
 805573c:	220a      	movs	r2, #10
 805573e:	4620      	mov	r0, r4
 8055740:	f000 feee 	bl	8056520 <__multadd>
 8055744:	4607      	mov	r7, r0
 8055746:	e7f0      	b.n	805572a <_dtoa_r+0xae2>
 8055748:	f1b9 0f00 	cmp.w	r9, #0
 805574c:	9a00      	ldr	r2, [sp, #0]
 805574e:	bfcc      	ite	gt
 8055750:	464d      	movgt	r5, r9
 8055752:	2501      	movle	r5, #1
 8055754:	4415      	add	r5, r2
 8055756:	f04f 0800 	mov.w	r8, #0
 805575a:	4659      	mov	r1, fp
 805575c:	2201      	movs	r2, #1
 805575e:	4620      	mov	r0, r4
 8055760:	9301      	str	r3, [sp, #4]
 8055762:	f001 f8bd 	bl	80568e0 <__lshift>
 8055766:	4631      	mov	r1, r6
 8055768:	4683      	mov	fp, r0
 805576a:	f001 f925 	bl	80569b8 <__mcmp>
 805576e:	2800      	cmp	r0, #0
 8055770:	dcb2      	bgt.n	80556d8 <_dtoa_r+0xa90>
 8055772:	d102      	bne.n	805577a <_dtoa_r+0xb32>
 8055774:	9b01      	ldr	r3, [sp, #4]
 8055776:	07db      	lsls	r3, r3, #31
 8055778:	d4ae      	bmi.n	80556d8 <_dtoa_r+0xa90>
 805577a:	462b      	mov	r3, r5
 805577c:	461d      	mov	r5, r3
 805577e:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8055782:	2a30      	cmp	r2, #48	; 0x30
 8055784:	d0fa      	beq.n	805577c <_dtoa_r+0xb34>
 8055786:	e6f8      	b.n	805557a <_dtoa_r+0x932>
 8055788:	9a00      	ldr	r2, [sp, #0]
 805578a:	429a      	cmp	r2, r3
 805578c:	d1a5      	bne.n	80556da <_dtoa_r+0xa92>
 805578e:	f10a 0a01 	add.w	sl, sl, #1
 8055792:	2331      	movs	r3, #49	; 0x31
 8055794:	e779      	b.n	805568a <_dtoa_r+0xa42>
 8055796:	4b14      	ldr	r3, [pc, #80]	; (80557e8 <_dtoa_r+0xba0>)
 8055798:	f7ff bab1 	b.w	8054cfe <_dtoa_r+0xb6>
 805579c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 805579e:	2b00      	cmp	r3, #0
 80557a0:	f47f aa93 	bne.w	8054cca <_dtoa_r+0x82>
 80557a4:	4b11      	ldr	r3, [pc, #68]	; (80557ec <_dtoa_r+0xba4>)
 80557a6:	f7ff baaa 	b.w	8054cfe <_dtoa_r+0xb6>
 80557aa:	f1b9 0f00 	cmp.w	r9, #0
 80557ae:	dc03      	bgt.n	80557b8 <_dtoa_r+0xb70>
 80557b0:	9b05      	ldr	r3, [sp, #20]
 80557b2:	2b02      	cmp	r3, #2
 80557b4:	f73f aeca 	bgt.w	805554c <_dtoa_r+0x904>
 80557b8:	9d00      	ldr	r5, [sp, #0]
 80557ba:	4631      	mov	r1, r6
 80557bc:	4658      	mov	r0, fp
 80557be:	f7ff f9b5 	bl	8054b2c <quorem>
 80557c2:	f100 0330 	add.w	r3, r0, #48	; 0x30
 80557c6:	f805 3b01 	strb.w	r3, [r5], #1
 80557ca:	9a00      	ldr	r2, [sp, #0]
 80557cc:	1aaa      	subs	r2, r5, r2
 80557ce:	4591      	cmp	r9, r2
 80557d0:	ddba      	ble.n	8055748 <_dtoa_r+0xb00>
 80557d2:	4659      	mov	r1, fp
 80557d4:	2300      	movs	r3, #0
 80557d6:	220a      	movs	r2, #10
 80557d8:	4620      	mov	r0, r4
 80557da:	f000 fea1 	bl	8056520 <__multadd>
 80557de:	4683      	mov	fp, r0
 80557e0:	e7eb      	b.n	80557ba <_dtoa_r+0xb72>
 80557e2:	bf00      	nop
 80557e4:	0805a4f7 	.word	0x0805a4f7
 80557e8:	0805a382 	.word	0x0805a382
 80557ec:	0805a4ee 	.word	0x0805a4ee

080557f0 <__errno>:
 80557f0:	4b01      	ldr	r3, [pc, #4]	; (80557f8 <__errno+0x8>)
 80557f2:	6818      	ldr	r0, [r3, #0]
 80557f4:	4770      	bx	lr
 80557f6:	bf00      	nop
 80557f8:	200038cc 	.word	0x200038cc

080557fc <__sflush_r>:
 80557fc:	898b      	ldrh	r3, [r1, #12]
 80557fe:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8055802:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8055806:	4605      	mov	r5, r0
 8055808:	0718      	lsls	r0, r3, #28
 805580a:	460c      	mov	r4, r1
 805580c:	d45f      	bmi.n	80558ce <__sflush_r+0xd2>
 805580e:	684b      	ldr	r3, [r1, #4]
 8055810:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8055814:	2b00      	cmp	r3, #0
 8055816:	818a      	strh	r2, [r1, #12]
 8055818:	dc05      	bgt.n	8055826 <__sflush_r+0x2a>
 805581a:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 805581c:	2b00      	cmp	r3, #0
 805581e:	dc02      	bgt.n	8055826 <__sflush_r+0x2a>
 8055820:	2000      	movs	r0, #0
 8055822:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8055826:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8055828:	2e00      	cmp	r6, #0
 805582a:	d0f9      	beq.n	8055820 <__sflush_r+0x24>
 805582c:	2300      	movs	r3, #0
 805582e:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8055832:	682f      	ldr	r7, [r5, #0]
 8055834:	602b      	str	r3, [r5, #0]
 8055836:	d036      	beq.n	80558a6 <__sflush_r+0xaa>
 8055838:	6d20      	ldr	r0, [r4, #80]	; 0x50
 805583a:	89a3      	ldrh	r3, [r4, #12]
 805583c:	075a      	lsls	r2, r3, #29
 805583e:	d505      	bpl.n	805584c <__sflush_r+0x50>
 8055840:	6863      	ldr	r3, [r4, #4]
 8055842:	1ac0      	subs	r0, r0, r3
 8055844:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8055846:	b10b      	cbz	r3, 805584c <__sflush_r+0x50>
 8055848:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 805584a:	1ac0      	subs	r0, r0, r3
 805584c:	2300      	movs	r3, #0
 805584e:	4602      	mov	r2, r0
 8055850:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8055852:	69e1      	ldr	r1, [r4, #28]
 8055854:	4628      	mov	r0, r5
 8055856:	47b0      	blx	r6
 8055858:	1c43      	adds	r3, r0, #1
 805585a:	89a3      	ldrh	r3, [r4, #12]
 805585c:	d106      	bne.n	805586c <__sflush_r+0x70>
 805585e:	6829      	ldr	r1, [r5, #0]
 8055860:	291d      	cmp	r1, #29
 8055862:	d830      	bhi.n	80558c6 <__sflush_r+0xca>
 8055864:	4a2b      	ldr	r2, [pc, #172]	; (8055914 <__sflush_r+0x118>)
 8055866:	40ca      	lsrs	r2, r1
 8055868:	07d6      	lsls	r6, r2, #31
 805586a:	d52c      	bpl.n	80558c6 <__sflush_r+0xca>
 805586c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8055870:	b21b      	sxth	r3, r3
 8055872:	2200      	movs	r2, #0
 8055874:	6062      	str	r2, [r4, #4]
 8055876:	04d9      	lsls	r1, r3, #19
 8055878:	6922      	ldr	r2, [r4, #16]
 805587a:	81a3      	strh	r3, [r4, #12]
 805587c:	6022      	str	r2, [r4, #0]
 805587e:	d504      	bpl.n	805588a <__sflush_r+0x8e>
 8055880:	1c42      	adds	r2, r0, #1
 8055882:	d101      	bne.n	8055888 <__sflush_r+0x8c>
 8055884:	682b      	ldr	r3, [r5, #0]
 8055886:	b903      	cbnz	r3, 805588a <__sflush_r+0x8e>
 8055888:	6520      	str	r0, [r4, #80]	; 0x50
 805588a:	6b21      	ldr	r1, [r4, #48]	; 0x30
 805588c:	602f      	str	r7, [r5, #0]
 805588e:	2900      	cmp	r1, #0
 8055890:	d0c6      	beq.n	8055820 <__sflush_r+0x24>
 8055892:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8055896:	4299      	cmp	r1, r3
 8055898:	d002      	beq.n	80558a0 <__sflush_r+0xa4>
 805589a:	4628      	mov	r0, r5
 805589c:	f000 f938 	bl	8055b10 <_free_r>
 80558a0:	2000      	movs	r0, #0
 80558a2:	6320      	str	r0, [r4, #48]	; 0x30
 80558a4:	e7bd      	b.n	8055822 <__sflush_r+0x26>
 80558a6:	69e1      	ldr	r1, [r4, #28]
 80558a8:	2301      	movs	r3, #1
 80558aa:	4628      	mov	r0, r5
 80558ac:	47b0      	blx	r6
 80558ae:	1c41      	adds	r1, r0, #1
 80558b0:	d1c3      	bne.n	805583a <__sflush_r+0x3e>
 80558b2:	682b      	ldr	r3, [r5, #0]
 80558b4:	2b00      	cmp	r3, #0
 80558b6:	d0c0      	beq.n	805583a <__sflush_r+0x3e>
 80558b8:	2b1d      	cmp	r3, #29
 80558ba:	d001      	beq.n	80558c0 <__sflush_r+0xc4>
 80558bc:	2b16      	cmp	r3, #22
 80558be:	d101      	bne.n	80558c4 <__sflush_r+0xc8>
 80558c0:	602f      	str	r7, [r5, #0]
 80558c2:	e7ad      	b.n	8055820 <__sflush_r+0x24>
 80558c4:	89a3      	ldrh	r3, [r4, #12]
 80558c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80558ca:	81a3      	strh	r3, [r4, #12]
 80558cc:	e7a9      	b.n	8055822 <__sflush_r+0x26>
 80558ce:	690f      	ldr	r7, [r1, #16]
 80558d0:	2f00      	cmp	r7, #0
 80558d2:	d0a5      	beq.n	8055820 <__sflush_r+0x24>
 80558d4:	079b      	lsls	r3, r3, #30
 80558d6:	680e      	ldr	r6, [r1, #0]
 80558d8:	bf08      	it	eq
 80558da:	694b      	ldreq	r3, [r1, #20]
 80558dc:	600f      	str	r7, [r1, #0]
 80558de:	bf18      	it	ne
 80558e0:	2300      	movne	r3, #0
 80558e2:	eba6 0807 	sub.w	r8, r6, r7
 80558e6:	608b      	str	r3, [r1, #8]
 80558e8:	f1b8 0f00 	cmp.w	r8, #0
 80558ec:	dd98      	ble.n	8055820 <__sflush_r+0x24>
 80558ee:	69e1      	ldr	r1, [r4, #28]
 80558f0:	6a66      	ldr	r6, [r4, #36]	; 0x24
 80558f2:	4643      	mov	r3, r8
 80558f4:	463a      	mov	r2, r7
 80558f6:	4628      	mov	r0, r5
 80558f8:	47b0      	blx	r6
 80558fa:	2800      	cmp	r0, #0
 80558fc:	dc06      	bgt.n	805590c <__sflush_r+0x110>
 80558fe:	89a3      	ldrh	r3, [r4, #12]
 8055900:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8055904:	81a3      	strh	r3, [r4, #12]
 8055906:	f04f 30ff 	mov.w	r0, #4294967295
 805590a:	e78a      	b.n	8055822 <__sflush_r+0x26>
 805590c:	4407      	add	r7, r0
 805590e:	eba8 0800 	sub.w	r8, r8, r0
 8055912:	e7e9      	b.n	80558e8 <__sflush_r+0xec>
 8055914:	20400001 	.word	0x20400001

08055918 <_fflush_r>:
 8055918:	b538      	push	{r3, r4, r5, lr}
 805591a:	460c      	mov	r4, r1
 805591c:	4605      	mov	r5, r0
 805591e:	b118      	cbz	r0, 8055928 <_fflush_r+0x10>
 8055920:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8055922:	b90b      	cbnz	r3, 8055928 <_fflush_r+0x10>
 8055924:	f000 f864 	bl	80559f0 <__sinit>
 8055928:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 805592c:	b1bb      	cbz	r3, 805595e <_fflush_r+0x46>
 805592e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8055930:	07d0      	lsls	r0, r2, #31
 8055932:	d404      	bmi.n	805593e <_fflush_r+0x26>
 8055934:	0599      	lsls	r1, r3, #22
 8055936:	d402      	bmi.n	805593e <_fflush_r+0x26>
 8055938:	6da0      	ldr	r0, [r4, #88]	; 0x58
 805593a:	f000 fd43 	bl	80563c4 <__retarget_lock_acquire_recursive>
 805593e:	4628      	mov	r0, r5
 8055940:	4621      	mov	r1, r4
 8055942:	f7ff ff5b 	bl	80557fc <__sflush_r>
 8055946:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8055948:	07da      	lsls	r2, r3, #31
 805594a:	4605      	mov	r5, r0
 805594c:	d405      	bmi.n	805595a <_fflush_r+0x42>
 805594e:	89a3      	ldrh	r3, [r4, #12]
 8055950:	059b      	lsls	r3, r3, #22
 8055952:	d402      	bmi.n	805595a <_fflush_r+0x42>
 8055954:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8055956:	f000 fd36 	bl	80563c6 <__retarget_lock_release_recursive>
 805595a:	4628      	mov	r0, r5
 805595c:	bd38      	pop	{r3, r4, r5, pc}
 805595e:	461d      	mov	r5, r3
 8055960:	e7fb      	b.n	805595a <_fflush_r+0x42>
	...

08055964 <std>:
 8055964:	2300      	movs	r3, #0
 8055966:	b510      	push	{r4, lr}
 8055968:	4604      	mov	r4, r0
 805596a:	e9c0 3300 	strd	r3, r3, [r0]
 805596e:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8055972:	6083      	str	r3, [r0, #8]
 8055974:	8181      	strh	r1, [r0, #12]
 8055976:	6643      	str	r3, [r0, #100]	; 0x64
 8055978:	81c2      	strh	r2, [r0, #14]
 805597a:	6183      	str	r3, [r0, #24]
 805597c:	4619      	mov	r1, r3
 805597e:	2208      	movs	r2, #8
 8055980:	305c      	adds	r0, #92	; 0x5c
 8055982:	f7fb fc1f 	bl	80511c4 <memset>
 8055986:	4b07      	ldr	r3, [pc, #28]	; (80559a4 <std+0x40>)
 8055988:	6223      	str	r3, [r4, #32]
 805598a:	4b07      	ldr	r3, [pc, #28]	; (80559a8 <std+0x44>)
 805598c:	6263      	str	r3, [r4, #36]	; 0x24
 805598e:	4b07      	ldr	r3, [pc, #28]	; (80559ac <std+0x48>)
 8055990:	62a3      	str	r3, [r4, #40]	; 0x28
 8055992:	4b07      	ldr	r3, [pc, #28]	; (80559b0 <std+0x4c>)
 8055994:	61e4      	str	r4, [r4, #28]
 8055996:	62e3      	str	r3, [r4, #44]	; 0x2c
 8055998:	f104 0058 	add.w	r0, r4, #88	; 0x58
 805599c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80559a0:	f000 bd0e 	b.w	80563c0 <__retarget_lock_init_recursive>
 80559a4:	08056e21 	.word	0x08056e21
 80559a8:	08056e43 	.word	0x08056e43
 80559ac:	08056e7b 	.word	0x08056e7b
 80559b0:	08056e9f 	.word	0x08056e9f

080559b4 <_cleanup_r>:
 80559b4:	4901      	ldr	r1, [pc, #4]	; (80559bc <_cleanup_r+0x8>)
 80559b6:	f000 b96b 	b.w	8055c90 <_fwalk_reent>
 80559ba:	bf00      	nop
 80559bc:	08057b09 	.word	0x08057b09

080559c0 <__sfp_lock_acquire>:
 80559c0:	4801      	ldr	r0, [pc, #4]	; (80559c8 <__sfp_lock_acquire+0x8>)
 80559c2:	f000 bcff 	b.w	80563c4 <__retarget_lock_acquire_recursive>
 80559c6:	bf00      	nop
 80559c8:	2001033c 	.word	0x2001033c

080559cc <__sfp_lock_release>:
 80559cc:	4801      	ldr	r0, [pc, #4]	; (80559d4 <__sfp_lock_release+0x8>)
 80559ce:	f000 bcfa 	b.w	80563c6 <__retarget_lock_release_recursive>
 80559d2:	bf00      	nop
 80559d4:	2001033c 	.word	0x2001033c

080559d8 <__sinit_lock_acquire>:
 80559d8:	4801      	ldr	r0, [pc, #4]	; (80559e0 <__sinit_lock_acquire+0x8>)
 80559da:	f000 bcf3 	b.w	80563c4 <__retarget_lock_acquire_recursive>
 80559de:	bf00      	nop
 80559e0:	20010337 	.word	0x20010337

080559e4 <__sinit_lock_release>:
 80559e4:	4801      	ldr	r0, [pc, #4]	; (80559ec <__sinit_lock_release+0x8>)
 80559e6:	f000 bcee 	b.w	80563c6 <__retarget_lock_release_recursive>
 80559ea:	bf00      	nop
 80559ec:	20010337 	.word	0x20010337

080559f0 <__sinit>:
 80559f0:	b510      	push	{r4, lr}
 80559f2:	4604      	mov	r4, r0
 80559f4:	f7ff fff0 	bl	80559d8 <__sinit_lock_acquire>
 80559f8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80559fa:	b11a      	cbz	r2, 8055a04 <__sinit+0x14>
 80559fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8055a00:	f7ff bff0 	b.w	80559e4 <__sinit_lock_release>
 8055a04:	4b0d      	ldr	r3, [pc, #52]	; (8055a3c <__sinit+0x4c>)
 8055a06:	63e3      	str	r3, [r4, #60]	; 0x3c
 8055a08:	2303      	movs	r3, #3
 8055a0a:	f8c4 32e4 	str.w	r3, [r4, #740]	; 0x2e4
 8055a0e:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
 8055a12:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
 8055a16:	6860      	ldr	r0, [r4, #4]
 8055a18:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
 8055a1c:	2104      	movs	r1, #4
 8055a1e:	f7ff ffa1 	bl	8055964 <std>
 8055a22:	68a0      	ldr	r0, [r4, #8]
 8055a24:	2201      	movs	r2, #1
 8055a26:	2109      	movs	r1, #9
 8055a28:	f7ff ff9c 	bl	8055964 <std>
 8055a2c:	68e0      	ldr	r0, [r4, #12]
 8055a2e:	2202      	movs	r2, #2
 8055a30:	2112      	movs	r1, #18
 8055a32:	f7ff ff97 	bl	8055964 <std>
 8055a36:	2301      	movs	r3, #1
 8055a38:	63a3      	str	r3, [r4, #56]	; 0x38
 8055a3a:	e7df      	b.n	80559fc <__sinit+0xc>
 8055a3c:	080559b5 	.word	0x080559b5

08055a40 <__libc_fini_array>:
 8055a40:	b538      	push	{r3, r4, r5, lr}
 8055a42:	4d07      	ldr	r5, [pc, #28]	; (8055a60 <__libc_fini_array+0x20>)
 8055a44:	4c07      	ldr	r4, [pc, #28]	; (8055a64 <__libc_fini_array+0x24>)
 8055a46:	1b64      	subs	r4, r4, r5
 8055a48:	10a4      	asrs	r4, r4, #2
 8055a4a:	b91c      	cbnz	r4, 8055a54 <__libc_fini_array+0x14>
 8055a4c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8055a50:	f002 bd32 	b.w	80584b8 <_fini>
 8055a54:	3c01      	subs	r4, #1
 8055a56:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8055a5a:	4798      	blx	r3
 8055a5c:	e7f5      	b.n	8055a4a <__libc_fini_array+0xa>
 8055a5e:	bf00      	nop
 8055a60:	0805a7b0 	.word	0x0805a7b0
 8055a64:	0805a7b4 	.word	0x0805a7b4

08055a68 <_malloc_trim_r>:
 8055a68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8055a6c:	4606      	mov	r6, r0
 8055a6e:	2008      	movs	r0, #8
 8055a70:	460c      	mov	r4, r1
 8055a72:	f7fd fd2d 	bl	80534d0 <sysconf>
 8055a76:	4f23      	ldr	r7, [pc, #140]	; (8055b04 <_malloc_trim_r+0x9c>)
 8055a78:	4680      	mov	r8, r0
 8055a7a:	4630      	mov	r0, r6
 8055a7c:	f7fb fbaa 	bl	80511d4 <__malloc_lock>
 8055a80:	68bb      	ldr	r3, [r7, #8]
 8055a82:	685d      	ldr	r5, [r3, #4]
 8055a84:	f025 0503 	bic.w	r5, r5, #3
 8055a88:	1b2c      	subs	r4, r5, r4
 8055a8a:	3c11      	subs	r4, #17
 8055a8c:	4444      	add	r4, r8
 8055a8e:	fbb4 f4f8 	udiv	r4, r4, r8
 8055a92:	3c01      	subs	r4, #1
 8055a94:	fb08 f404 	mul.w	r4, r8, r4
 8055a98:	45a0      	cmp	r8, r4
 8055a9a:	dd05      	ble.n	8055aa8 <_malloc_trim_r+0x40>
 8055a9c:	4630      	mov	r0, r6
 8055a9e:	f7fb fb9f 	bl	80511e0 <__malloc_unlock>
 8055aa2:	2000      	movs	r0, #0
 8055aa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8055aa8:	2100      	movs	r1, #0
 8055aaa:	4630      	mov	r0, r6
 8055aac:	f7fb fbb0 	bl	8051210 <_sbrk_r>
 8055ab0:	68bb      	ldr	r3, [r7, #8]
 8055ab2:	442b      	add	r3, r5
 8055ab4:	4298      	cmp	r0, r3
 8055ab6:	d1f1      	bne.n	8055a9c <_malloc_trim_r+0x34>
 8055ab8:	4261      	negs	r1, r4
 8055aba:	4630      	mov	r0, r6
 8055abc:	f7fb fba8 	bl	8051210 <_sbrk_r>
 8055ac0:	3001      	adds	r0, #1
 8055ac2:	d110      	bne.n	8055ae6 <_malloc_trim_r+0x7e>
 8055ac4:	2100      	movs	r1, #0
 8055ac6:	4630      	mov	r0, r6
 8055ac8:	f7fb fba2 	bl	8051210 <_sbrk_r>
 8055acc:	68ba      	ldr	r2, [r7, #8]
 8055ace:	1a83      	subs	r3, r0, r2
 8055ad0:	2b0f      	cmp	r3, #15
 8055ad2:	dde3      	ble.n	8055a9c <_malloc_trim_r+0x34>
 8055ad4:	490c      	ldr	r1, [pc, #48]	; (8055b08 <_malloc_trim_r+0xa0>)
 8055ad6:	6809      	ldr	r1, [r1, #0]
 8055ad8:	1a40      	subs	r0, r0, r1
 8055ada:	490c      	ldr	r1, [pc, #48]	; (8055b0c <_malloc_trim_r+0xa4>)
 8055adc:	f043 0301 	orr.w	r3, r3, #1
 8055ae0:	6008      	str	r0, [r1, #0]
 8055ae2:	6053      	str	r3, [r2, #4]
 8055ae4:	e7da      	b.n	8055a9c <_malloc_trim_r+0x34>
 8055ae6:	68bb      	ldr	r3, [r7, #8]
 8055ae8:	4a08      	ldr	r2, [pc, #32]	; (8055b0c <_malloc_trim_r+0xa4>)
 8055aea:	1b2d      	subs	r5, r5, r4
 8055aec:	f045 0501 	orr.w	r5, r5, #1
 8055af0:	605d      	str	r5, [r3, #4]
 8055af2:	6813      	ldr	r3, [r2, #0]
 8055af4:	4630      	mov	r0, r6
 8055af6:	1b1c      	subs	r4, r3, r4
 8055af8:	6014      	str	r4, [r2, #0]
 8055afa:	f7fb fb71 	bl	80511e0 <__malloc_unlock>
 8055afe:	2001      	movs	r0, #1
 8055b00:	e7d0      	b.n	8055aa4 <_malloc_trim_r+0x3c>
 8055b02:	bf00      	nop
 8055b04:	20003cf8 	.word	0x20003cf8
 8055b08:	20004100 	.word	0x20004100
 8055b0c:	20005414 	.word	0x20005414

08055b10 <_free_r>:
 8055b10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8055b12:	4605      	mov	r5, r0
 8055b14:	460f      	mov	r7, r1
 8055b16:	2900      	cmp	r1, #0
 8055b18:	f000 80b1 	beq.w	8055c7e <_free_r+0x16e>
 8055b1c:	f7fb fb5a 	bl	80511d4 <__malloc_lock>
 8055b20:	f857 2c04 	ldr.w	r2, [r7, #-4]
 8055b24:	4856      	ldr	r0, [pc, #344]	; (8055c80 <_free_r+0x170>)
 8055b26:	f022 0401 	bic.w	r4, r2, #1
 8055b2a:	f1a7 0308 	sub.w	r3, r7, #8
 8055b2e:	eb03 0c04 	add.w	ip, r3, r4
 8055b32:	6881      	ldr	r1, [r0, #8]
 8055b34:	f8dc 6004 	ldr.w	r6, [ip, #4]
 8055b38:	4561      	cmp	r1, ip
 8055b3a:	f026 0603 	bic.w	r6, r6, #3
 8055b3e:	f002 0201 	and.w	r2, r2, #1
 8055b42:	d11b      	bne.n	8055b7c <_free_r+0x6c>
 8055b44:	4434      	add	r4, r6
 8055b46:	b93a      	cbnz	r2, 8055b58 <_free_r+0x48>
 8055b48:	f857 2c08 	ldr.w	r2, [r7, #-8]
 8055b4c:	1a9b      	subs	r3, r3, r2
 8055b4e:	4414      	add	r4, r2
 8055b50:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
 8055b54:	60ca      	str	r2, [r1, #12]
 8055b56:	6091      	str	r1, [r2, #8]
 8055b58:	f044 0201 	orr.w	r2, r4, #1
 8055b5c:	605a      	str	r2, [r3, #4]
 8055b5e:	6083      	str	r3, [r0, #8]
 8055b60:	4b48      	ldr	r3, [pc, #288]	; (8055c84 <_free_r+0x174>)
 8055b62:	681b      	ldr	r3, [r3, #0]
 8055b64:	42a3      	cmp	r3, r4
 8055b66:	d804      	bhi.n	8055b72 <_free_r+0x62>
 8055b68:	4b47      	ldr	r3, [pc, #284]	; (8055c88 <_free_r+0x178>)
 8055b6a:	4628      	mov	r0, r5
 8055b6c:	6819      	ldr	r1, [r3, #0]
 8055b6e:	f7ff ff7b 	bl	8055a68 <_malloc_trim_r>
 8055b72:	4628      	mov	r0, r5
 8055b74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8055b78:	f7fb bb32 	b.w	80511e0 <__malloc_unlock>
 8055b7c:	f8cc 6004 	str.w	r6, [ip, #4]
 8055b80:	2a00      	cmp	r2, #0
 8055b82:	d138      	bne.n	8055bf6 <_free_r+0xe6>
 8055b84:	f857 1c08 	ldr.w	r1, [r7, #-8]
 8055b88:	1a5b      	subs	r3, r3, r1
 8055b8a:	440c      	add	r4, r1
 8055b8c:	6899      	ldr	r1, [r3, #8]
 8055b8e:	f100 0708 	add.w	r7, r0, #8
 8055b92:	42b9      	cmp	r1, r7
 8055b94:	d031      	beq.n	8055bfa <_free_r+0xea>
 8055b96:	68df      	ldr	r7, [r3, #12]
 8055b98:	60cf      	str	r7, [r1, #12]
 8055b9a:	60b9      	str	r1, [r7, #8]
 8055b9c:	eb0c 0106 	add.w	r1, ip, r6
 8055ba0:	6849      	ldr	r1, [r1, #4]
 8055ba2:	07c9      	lsls	r1, r1, #31
 8055ba4:	d40b      	bmi.n	8055bbe <_free_r+0xae>
 8055ba6:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8055baa:	4434      	add	r4, r6
 8055bac:	bb3a      	cbnz	r2, 8055bfe <_free_r+0xee>
 8055bae:	4e37      	ldr	r6, [pc, #220]	; (8055c8c <_free_r+0x17c>)
 8055bb0:	42b1      	cmp	r1, r6
 8055bb2:	d124      	bne.n	8055bfe <_free_r+0xee>
 8055bb4:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8055bb8:	e9c3 1102 	strd	r1, r1, [r3, #8]
 8055bbc:	2201      	movs	r2, #1
 8055bbe:	f044 0101 	orr.w	r1, r4, #1
 8055bc2:	6059      	str	r1, [r3, #4]
 8055bc4:	511c      	str	r4, [r3, r4]
 8055bc6:	2a00      	cmp	r2, #0
 8055bc8:	d1d3      	bne.n	8055b72 <_free_r+0x62>
 8055bca:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 8055bce:	d21b      	bcs.n	8055c08 <_free_r+0xf8>
 8055bd0:	0961      	lsrs	r1, r4, #5
 8055bd2:	08e2      	lsrs	r2, r4, #3
 8055bd4:	2401      	movs	r4, #1
 8055bd6:	408c      	lsls	r4, r1
 8055bd8:	6841      	ldr	r1, [r0, #4]
 8055bda:	3201      	adds	r2, #1
 8055bdc:	430c      	orrs	r4, r1
 8055bde:	6044      	str	r4, [r0, #4]
 8055be0:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8055be4:	f850 4032 	ldr.w	r4, [r0, r2, lsl #3]
 8055be8:	3908      	subs	r1, #8
 8055bea:	e9c3 4102 	strd	r4, r1, [r3, #8]
 8055bee:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
 8055bf2:	60e3      	str	r3, [r4, #12]
 8055bf4:	e7bd      	b.n	8055b72 <_free_r+0x62>
 8055bf6:	2200      	movs	r2, #0
 8055bf8:	e7d0      	b.n	8055b9c <_free_r+0x8c>
 8055bfa:	2201      	movs	r2, #1
 8055bfc:	e7ce      	b.n	8055b9c <_free_r+0x8c>
 8055bfe:	f8dc 600c 	ldr.w	r6, [ip, #12]
 8055c02:	60ce      	str	r6, [r1, #12]
 8055c04:	60b1      	str	r1, [r6, #8]
 8055c06:	e7da      	b.n	8055bbe <_free_r+0xae>
 8055c08:	f5b4 6f20 	cmp.w	r4, #2560	; 0xa00
 8055c0c:	ea4f 2254 	mov.w	r2, r4, lsr #9
 8055c10:	d214      	bcs.n	8055c3c <_free_r+0x12c>
 8055c12:	09a2      	lsrs	r2, r4, #6
 8055c14:	3238      	adds	r2, #56	; 0x38
 8055c16:	1c51      	adds	r1, r2, #1
 8055c18:	eb00 06c2 	add.w	r6, r0, r2, lsl #3
 8055c1c:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
 8055c20:	428e      	cmp	r6, r1
 8055c22:	d125      	bne.n	8055c70 <_free_r+0x160>
 8055c24:	2401      	movs	r4, #1
 8055c26:	1092      	asrs	r2, r2, #2
 8055c28:	fa04 f202 	lsl.w	r2, r4, r2
 8055c2c:	6844      	ldr	r4, [r0, #4]
 8055c2e:	4322      	orrs	r2, r4
 8055c30:	6042      	str	r2, [r0, #4]
 8055c32:	e9c3 1602 	strd	r1, r6, [r3, #8]
 8055c36:	60b3      	str	r3, [r6, #8]
 8055c38:	60cb      	str	r3, [r1, #12]
 8055c3a:	e79a      	b.n	8055b72 <_free_r+0x62>
 8055c3c:	2a14      	cmp	r2, #20
 8055c3e:	d801      	bhi.n	8055c44 <_free_r+0x134>
 8055c40:	325b      	adds	r2, #91	; 0x5b
 8055c42:	e7e8      	b.n	8055c16 <_free_r+0x106>
 8055c44:	2a54      	cmp	r2, #84	; 0x54
 8055c46:	d802      	bhi.n	8055c4e <_free_r+0x13e>
 8055c48:	0b22      	lsrs	r2, r4, #12
 8055c4a:	326e      	adds	r2, #110	; 0x6e
 8055c4c:	e7e3      	b.n	8055c16 <_free_r+0x106>
 8055c4e:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8055c52:	d802      	bhi.n	8055c5a <_free_r+0x14a>
 8055c54:	0be2      	lsrs	r2, r4, #15
 8055c56:	3277      	adds	r2, #119	; 0x77
 8055c58:	e7dd      	b.n	8055c16 <_free_r+0x106>
 8055c5a:	f240 5154 	movw	r1, #1364	; 0x554
 8055c5e:	428a      	cmp	r2, r1
 8055c60:	bf9a      	itte	ls
 8055c62:	0ca2      	lsrls	r2, r4, #18
 8055c64:	327c      	addls	r2, #124	; 0x7c
 8055c66:	227e      	movhi	r2, #126	; 0x7e
 8055c68:	e7d5      	b.n	8055c16 <_free_r+0x106>
 8055c6a:	6889      	ldr	r1, [r1, #8]
 8055c6c:	428e      	cmp	r6, r1
 8055c6e:	d004      	beq.n	8055c7a <_free_r+0x16a>
 8055c70:	684a      	ldr	r2, [r1, #4]
 8055c72:	f022 0203 	bic.w	r2, r2, #3
 8055c76:	42a2      	cmp	r2, r4
 8055c78:	d8f7      	bhi.n	8055c6a <_free_r+0x15a>
 8055c7a:	68ce      	ldr	r6, [r1, #12]
 8055c7c:	e7d9      	b.n	8055c32 <_free_r+0x122>
 8055c7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8055c80:	20003cf8 	.word	0x20003cf8
 8055c84:	20004104 	.word	0x20004104
 8055c88:	20005444 	.word	0x20005444
 8055c8c:	20003d00 	.word	0x20003d00

08055c90 <_fwalk_reent>:
 8055c90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8055c94:	4606      	mov	r6, r0
 8055c96:	4688      	mov	r8, r1
 8055c98:	f500 7438 	add.w	r4, r0, #736	; 0x2e0
 8055c9c:	2700      	movs	r7, #0
 8055c9e:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8055ca2:	f1b9 0901 	subs.w	r9, r9, #1
 8055ca6:	d505      	bpl.n	8055cb4 <_fwalk_reent+0x24>
 8055ca8:	6824      	ldr	r4, [r4, #0]
 8055caa:	2c00      	cmp	r4, #0
 8055cac:	d1f7      	bne.n	8055c9e <_fwalk_reent+0xe>
 8055cae:	4638      	mov	r0, r7
 8055cb0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8055cb4:	89ab      	ldrh	r3, [r5, #12]
 8055cb6:	2b01      	cmp	r3, #1
 8055cb8:	d907      	bls.n	8055cca <_fwalk_reent+0x3a>
 8055cba:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8055cbe:	3301      	adds	r3, #1
 8055cc0:	d003      	beq.n	8055cca <_fwalk_reent+0x3a>
 8055cc2:	4629      	mov	r1, r5
 8055cc4:	4630      	mov	r0, r6
 8055cc6:	47c0      	blx	r8
 8055cc8:	4307      	orrs	r7, r0
 8055cca:	3568      	adds	r5, #104	; 0x68
 8055ccc:	e7e9      	b.n	8055ca2 <_fwalk_reent+0x12>

08055cce <rshift>:
 8055cce:	6903      	ldr	r3, [r0, #16]
 8055cd0:	ebb3 1f61 	cmp.w	r3, r1, asr #5
 8055cd4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8055cd8:	ea4f 1261 	mov.w	r2, r1, asr #5
 8055cdc:	f100 0414 	add.w	r4, r0, #20
 8055ce0:	dd45      	ble.n	8055d6e <rshift+0xa0>
 8055ce2:	f011 011f 	ands.w	r1, r1, #31
 8055ce6:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 8055cea:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 8055cee:	d10c      	bne.n	8055d0a <rshift+0x3c>
 8055cf0:	f100 0710 	add.w	r7, r0, #16
 8055cf4:	4629      	mov	r1, r5
 8055cf6:	42b1      	cmp	r1, r6
 8055cf8:	d334      	bcc.n	8055d64 <rshift+0x96>
 8055cfa:	1a9b      	subs	r3, r3, r2
 8055cfc:	009b      	lsls	r3, r3, #2
 8055cfe:	1eea      	subs	r2, r5, #3
 8055d00:	4296      	cmp	r6, r2
 8055d02:	bf38      	it	cc
 8055d04:	2300      	movcc	r3, #0
 8055d06:	4423      	add	r3, r4
 8055d08:	e015      	b.n	8055d36 <rshift+0x68>
 8055d0a:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
 8055d0e:	f1c1 0820 	rsb	r8, r1, #32
 8055d12:	40cf      	lsrs	r7, r1
 8055d14:	f105 0e04 	add.w	lr, r5, #4
 8055d18:	46a1      	mov	r9, r4
 8055d1a:	4576      	cmp	r6, lr
 8055d1c:	46f4      	mov	ip, lr
 8055d1e:	d815      	bhi.n	8055d4c <rshift+0x7e>
 8055d20:	1a9b      	subs	r3, r3, r2
 8055d22:	009a      	lsls	r2, r3, #2
 8055d24:	3a04      	subs	r2, #4
 8055d26:	3501      	adds	r5, #1
 8055d28:	42ae      	cmp	r6, r5
 8055d2a:	bf38      	it	cc
 8055d2c:	2200      	movcc	r2, #0
 8055d2e:	18a3      	adds	r3, r4, r2
 8055d30:	50a7      	str	r7, [r4, r2]
 8055d32:	b107      	cbz	r7, 8055d36 <rshift+0x68>
 8055d34:	3304      	adds	r3, #4
 8055d36:	1b1a      	subs	r2, r3, r4
 8055d38:	42a3      	cmp	r3, r4
 8055d3a:	ea4f 02a2 	mov.w	r2, r2, asr #2
 8055d3e:	bf08      	it	eq
 8055d40:	2300      	moveq	r3, #0
 8055d42:	6102      	str	r2, [r0, #16]
 8055d44:	bf08      	it	eq
 8055d46:	6143      	streq	r3, [r0, #20]
 8055d48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8055d4c:	f8dc c000 	ldr.w	ip, [ip]
 8055d50:	fa0c fc08 	lsl.w	ip, ip, r8
 8055d54:	ea4c 0707 	orr.w	r7, ip, r7
 8055d58:	f849 7b04 	str.w	r7, [r9], #4
 8055d5c:	f85e 7b04 	ldr.w	r7, [lr], #4
 8055d60:	40cf      	lsrs	r7, r1
 8055d62:	e7da      	b.n	8055d1a <rshift+0x4c>
 8055d64:	f851 cb04 	ldr.w	ip, [r1], #4
 8055d68:	f847 cf04 	str.w	ip, [r7, #4]!
 8055d6c:	e7c3      	b.n	8055cf6 <rshift+0x28>
 8055d6e:	4623      	mov	r3, r4
 8055d70:	e7e1      	b.n	8055d36 <rshift+0x68>

08055d72 <__hexdig_fun>:
 8055d72:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 8055d76:	2b09      	cmp	r3, #9
 8055d78:	d802      	bhi.n	8055d80 <__hexdig_fun+0xe>
 8055d7a:	3820      	subs	r0, #32
 8055d7c:	b2c0      	uxtb	r0, r0
 8055d7e:	4770      	bx	lr
 8055d80:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 8055d84:	2b05      	cmp	r3, #5
 8055d86:	d801      	bhi.n	8055d8c <__hexdig_fun+0x1a>
 8055d88:	3847      	subs	r0, #71	; 0x47
 8055d8a:	e7f7      	b.n	8055d7c <__hexdig_fun+0xa>
 8055d8c:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 8055d90:	2b05      	cmp	r3, #5
 8055d92:	d801      	bhi.n	8055d98 <__hexdig_fun+0x26>
 8055d94:	3827      	subs	r0, #39	; 0x27
 8055d96:	e7f1      	b.n	8055d7c <__hexdig_fun+0xa>
 8055d98:	2000      	movs	r0, #0
 8055d9a:	4770      	bx	lr

08055d9c <__gethex>:
 8055d9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8055da0:	ed2d 8b02 	vpush	{d8}
 8055da4:	b089      	sub	sp, #36	; 0x24
 8055da6:	ee08 0a10 	vmov	s16, r0
 8055daa:	9304      	str	r3, [sp, #16]
 8055dac:	4bbc      	ldr	r3, [pc, #752]	; (80560a0 <__gethex+0x304>)
 8055dae:	681b      	ldr	r3, [r3, #0]
 8055db0:	9301      	str	r3, [sp, #4]
 8055db2:	4618      	mov	r0, r3
 8055db4:	468b      	mov	fp, r1
 8055db6:	4690      	mov	r8, r2
 8055db8:	f7ea fa1a 	bl	80401f0 <strlen>
 8055dbc:	9b01      	ldr	r3, [sp, #4]
 8055dbe:	f8db 2000 	ldr.w	r2, [fp]
 8055dc2:	4403      	add	r3, r0
 8055dc4:	4682      	mov	sl, r0
 8055dc6:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8055dca:	9305      	str	r3, [sp, #20]
 8055dcc:	1c93      	adds	r3, r2, #2
 8055dce:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
 8055dd2:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 8055dd6:	32fe      	adds	r2, #254	; 0xfe
 8055dd8:	18d1      	adds	r1, r2, r3
 8055dda:	461f      	mov	r7, r3
 8055ddc:	f813 0b01 	ldrb.w	r0, [r3], #1
 8055de0:	9100      	str	r1, [sp, #0]
 8055de2:	2830      	cmp	r0, #48	; 0x30
 8055de4:	d0f8      	beq.n	8055dd8 <__gethex+0x3c>
 8055de6:	f7ff ffc4 	bl	8055d72 <__hexdig_fun>
 8055dea:	4604      	mov	r4, r0
 8055dec:	2800      	cmp	r0, #0
 8055dee:	d13a      	bne.n	8055e66 <__gethex+0xca>
 8055df0:	9901      	ldr	r1, [sp, #4]
 8055df2:	4652      	mov	r2, sl
 8055df4:	4638      	mov	r0, r7
 8055df6:	f7fb fa5f 	bl	80512b8 <strncmp>
 8055dfa:	4605      	mov	r5, r0
 8055dfc:	2800      	cmp	r0, #0
 8055dfe:	d168      	bne.n	8055ed2 <__gethex+0x136>
 8055e00:	f817 000a 	ldrb.w	r0, [r7, sl]
 8055e04:	eb07 060a 	add.w	r6, r7, sl
 8055e08:	f7ff ffb3 	bl	8055d72 <__hexdig_fun>
 8055e0c:	2800      	cmp	r0, #0
 8055e0e:	d062      	beq.n	8055ed6 <__gethex+0x13a>
 8055e10:	4633      	mov	r3, r6
 8055e12:	7818      	ldrb	r0, [r3, #0]
 8055e14:	2830      	cmp	r0, #48	; 0x30
 8055e16:	461f      	mov	r7, r3
 8055e18:	f103 0301 	add.w	r3, r3, #1
 8055e1c:	d0f9      	beq.n	8055e12 <__gethex+0x76>
 8055e1e:	f7ff ffa8 	bl	8055d72 <__hexdig_fun>
 8055e22:	2301      	movs	r3, #1
 8055e24:	fab0 f480 	clz	r4, r0
 8055e28:	0964      	lsrs	r4, r4, #5
 8055e2a:	4635      	mov	r5, r6
 8055e2c:	9300      	str	r3, [sp, #0]
 8055e2e:	463a      	mov	r2, r7
 8055e30:	4616      	mov	r6, r2
 8055e32:	3201      	adds	r2, #1
 8055e34:	7830      	ldrb	r0, [r6, #0]
 8055e36:	f7ff ff9c 	bl	8055d72 <__hexdig_fun>
 8055e3a:	2800      	cmp	r0, #0
 8055e3c:	d1f8      	bne.n	8055e30 <__gethex+0x94>
 8055e3e:	9901      	ldr	r1, [sp, #4]
 8055e40:	4652      	mov	r2, sl
 8055e42:	4630      	mov	r0, r6
 8055e44:	f7fb fa38 	bl	80512b8 <strncmp>
 8055e48:	b980      	cbnz	r0, 8055e6c <__gethex+0xd0>
 8055e4a:	b94d      	cbnz	r5, 8055e60 <__gethex+0xc4>
 8055e4c:	eb06 050a 	add.w	r5, r6, sl
 8055e50:	462a      	mov	r2, r5
 8055e52:	4616      	mov	r6, r2
 8055e54:	3201      	adds	r2, #1
 8055e56:	7830      	ldrb	r0, [r6, #0]
 8055e58:	f7ff ff8b 	bl	8055d72 <__hexdig_fun>
 8055e5c:	2800      	cmp	r0, #0
 8055e5e:	d1f8      	bne.n	8055e52 <__gethex+0xb6>
 8055e60:	1bad      	subs	r5, r5, r6
 8055e62:	00ad      	lsls	r5, r5, #2
 8055e64:	e004      	b.n	8055e70 <__gethex+0xd4>
 8055e66:	2400      	movs	r4, #0
 8055e68:	4625      	mov	r5, r4
 8055e6a:	e7e0      	b.n	8055e2e <__gethex+0x92>
 8055e6c:	2d00      	cmp	r5, #0
 8055e6e:	d1f7      	bne.n	8055e60 <__gethex+0xc4>
 8055e70:	7833      	ldrb	r3, [r6, #0]
 8055e72:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8055e76:	2b50      	cmp	r3, #80	; 0x50
 8055e78:	d13b      	bne.n	8055ef2 <__gethex+0x156>
 8055e7a:	7873      	ldrb	r3, [r6, #1]
 8055e7c:	2b2b      	cmp	r3, #43	; 0x2b
 8055e7e:	d02c      	beq.n	8055eda <__gethex+0x13e>
 8055e80:	2b2d      	cmp	r3, #45	; 0x2d
 8055e82:	d02e      	beq.n	8055ee2 <__gethex+0x146>
 8055e84:	1c71      	adds	r1, r6, #1
 8055e86:	f04f 0900 	mov.w	r9, #0
 8055e8a:	7808      	ldrb	r0, [r1, #0]
 8055e8c:	f7ff ff71 	bl	8055d72 <__hexdig_fun>
 8055e90:	1e43      	subs	r3, r0, #1
 8055e92:	b2db      	uxtb	r3, r3
 8055e94:	2b18      	cmp	r3, #24
 8055e96:	d82c      	bhi.n	8055ef2 <__gethex+0x156>
 8055e98:	f1a0 0210 	sub.w	r2, r0, #16
 8055e9c:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8055ea0:	f7ff ff67 	bl	8055d72 <__hexdig_fun>
 8055ea4:	1e43      	subs	r3, r0, #1
 8055ea6:	b2db      	uxtb	r3, r3
 8055ea8:	2b18      	cmp	r3, #24
 8055eaa:	d91d      	bls.n	8055ee8 <__gethex+0x14c>
 8055eac:	f1b9 0f00 	cmp.w	r9, #0
 8055eb0:	d000      	beq.n	8055eb4 <__gethex+0x118>
 8055eb2:	4252      	negs	r2, r2
 8055eb4:	4415      	add	r5, r2
 8055eb6:	f8cb 1000 	str.w	r1, [fp]
 8055eba:	b1e4      	cbz	r4, 8055ef6 <__gethex+0x15a>
 8055ebc:	9b00      	ldr	r3, [sp, #0]
 8055ebe:	2b00      	cmp	r3, #0
 8055ec0:	bf14      	ite	ne
 8055ec2:	2700      	movne	r7, #0
 8055ec4:	2706      	moveq	r7, #6
 8055ec6:	4638      	mov	r0, r7
 8055ec8:	b009      	add	sp, #36	; 0x24
 8055eca:	ecbd 8b02 	vpop	{d8}
 8055ece:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8055ed2:	463e      	mov	r6, r7
 8055ed4:	4625      	mov	r5, r4
 8055ed6:	2401      	movs	r4, #1
 8055ed8:	e7ca      	b.n	8055e70 <__gethex+0xd4>
 8055eda:	f04f 0900 	mov.w	r9, #0
 8055ede:	1cb1      	adds	r1, r6, #2
 8055ee0:	e7d3      	b.n	8055e8a <__gethex+0xee>
 8055ee2:	f04f 0901 	mov.w	r9, #1
 8055ee6:	e7fa      	b.n	8055ede <__gethex+0x142>
 8055ee8:	230a      	movs	r3, #10
 8055eea:	fb03 0202 	mla	r2, r3, r2, r0
 8055eee:	3a10      	subs	r2, #16
 8055ef0:	e7d4      	b.n	8055e9c <__gethex+0x100>
 8055ef2:	4631      	mov	r1, r6
 8055ef4:	e7df      	b.n	8055eb6 <__gethex+0x11a>
 8055ef6:	1bf3      	subs	r3, r6, r7
 8055ef8:	3b01      	subs	r3, #1
 8055efa:	4621      	mov	r1, r4
 8055efc:	2b07      	cmp	r3, #7
 8055efe:	dc0b      	bgt.n	8055f18 <__gethex+0x17c>
 8055f00:	ee18 0a10 	vmov	r0, s16
 8055f04:	f000 fade 	bl	80564c4 <_Balloc>
 8055f08:	4604      	mov	r4, r0
 8055f0a:	b940      	cbnz	r0, 8055f1e <__gethex+0x182>
 8055f0c:	4b65      	ldr	r3, [pc, #404]	; (80560a4 <__gethex+0x308>)
 8055f0e:	4602      	mov	r2, r0
 8055f10:	21de      	movs	r1, #222	; 0xde
 8055f12:	4865      	ldr	r0, [pc, #404]	; (80560a8 <__gethex+0x30c>)
 8055f14:	f001 fd9c 	bl	8057a50 <__assert_func>
 8055f18:	3101      	adds	r1, #1
 8055f1a:	105b      	asrs	r3, r3, #1
 8055f1c:	e7ee      	b.n	8055efc <__gethex+0x160>
 8055f1e:	f100 0914 	add.w	r9, r0, #20
 8055f22:	f04f 0b00 	mov.w	fp, #0
 8055f26:	f1ca 0301 	rsb	r3, sl, #1
 8055f2a:	f8cd 9008 	str.w	r9, [sp, #8]
 8055f2e:	f8cd b000 	str.w	fp, [sp]
 8055f32:	9306      	str	r3, [sp, #24]
 8055f34:	42b7      	cmp	r7, r6
 8055f36:	d340      	bcc.n	8055fba <__gethex+0x21e>
 8055f38:	9802      	ldr	r0, [sp, #8]
 8055f3a:	9b00      	ldr	r3, [sp, #0]
 8055f3c:	f840 3b04 	str.w	r3, [r0], #4
 8055f40:	eba0 0009 	sub.w	r0, r0, r9
 8055f44:	1080      	asrs	r0, r0, #2
 8055f46:	0146      	lsls	r6, r0, #5
 8055f48:	6120      	str	r0, [r4, #16]
 8055f4a:	4618      	mov	r0, r3
 8055f4c:	f000 fb7c 	bl	8056648 <__hi0bits>
 8055f50:	1a30      	subs	r0, r6, r0
 8055f52:	f8d8 6000 	ldr.w	r6, [r8]
 8055f56:	42b0      	cmp	r0, r6
 8055f58:	dd63      	ble.n	8056022 <__gethex+0x286>
 8055f5a:	1b87      	subs	r7, r0, r6
 8055f5c:	4639      	mov	r1, r7
 8055f5e:	4620      	mov	r0, r4
 8055f60:	f000 fefc 	bl	8056d5c <__any_on>
 8055f64:	4682      	mov	sl, r0
 8055f66:	b1a8      	cbz	r0, 8055f94 <__gethex+0x1f8>
 8055f68:	1e7b      	subs	r3, r7, #1
 8055f6a:	1159      	asrs	r1, r3, #5
 8055f6c:	f003 021f 	and.w	r2, r3, #31
 8055f70:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
 8055f74:	f04f 0a01 	mov.w	sl, #1
 8055f78:	fa0a f202 	lsl.w	r2, sl, r2
 8055f7c:	420a      	tst	r2, r1
 8055f7e:	d009      	beq.n	8055f94 <__gethex+0x1f8>
 8055f80:	4553      	cmp	r3, sl
 8055f82:	dd05      	ble.n	8055f90 <__gethex+0x1f4>
 8055f84:	1eb9      	subs	r1, r7, #2
 8055f86:	4620      	mov	r0, r4
 8055f88:	f000 fee8 	bl	8056d5c <__any_on>
 8055f8c:	2800      	cmp	r0, #0
 8055f8e:	d145      	bne.n	805601c <__gethex+0x280>
 8055f90:	f04f 0a02 	mov.w	sl, #2
 8055f94:	4639      	mov	r1, r7
 8055f96:	4620      	mov	r0, r4
 8055f98:	f7ff fe99 	bl	8055cce <rshift>
 8055f9c:	443d      	add	r5, r7
 8055f9e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8055fa2:	42ab      	cmp	r3, r5
 8055fa4:	da4c      	bge.n	8056040 <__gethex+0x2a4>
 8055fa6:	ee18 0a10 	vmov	r0, s16
 8055faa:	4621      	mov	r1, r4
 8055fac:	f000 faaf 	bl	805650e <_Bfree>
 8055fb0:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8055fb2:	2300      	movs	r3, #0
 8055fb4:	6013      	str	r3, [r2, #0]
 8055fb6:	27a3      	movs	r7, #163	; 0xa3
 8055fb8:	e785      	b.n	8055ec6 <__gethex+0x12a>
 8055fba:	1e73      	subs	r3, r6, #1
 8055fbc:	9a05      	ldr	r2, [sp, #20]
 8055fbe:	9303      	str	r3, [sp, #12]
 8055fc0:	f816 3c01 	ldrb.w	r3, [r6, #-1]
 8055fc4:	4293      	cmp	r3, r2
 8055fc6:	d019      	beq.n	8055ffc <__gethex+0x260>
 8055fc8:	f1bb 0f20 	cmp.w	fp, #32
 8055fcc:	d107      	bne.n	8055fde <__gethex+0x242>
 8055fce:	9b02      	ldr	r3, [sp, #8]
 8055fd0:	9a00      	ldr	r2, [sp, #0]
 8055fd2:	f843 2b04 	str.w	r2, [r3], #4
 8055fd6:	9302      	str	r3, [sp, #8]
 8055fd8:	2300      	movs	r3, #0
 8055fda:	9300      	str	r3, [sp, #0]
 8055fdc:	469b      	mov	fp, r3
 8055fde:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 8055fe2:	f7ff fec6 	bl	8055d72 <__hexdig_fun>
 8055fe6:	9b00      	ldr	r3, [sp, #0]
 8055fe8:	f000 000f 	and.w	r0, r0, #15
 8055fec:	fa00 f00b 	lsl.w	r0, r0, fp
 8055ff0:	4303      	orrs	r3, r0
 8055ff2:	9300      	str	r3, [sp, #0]
 8055ff4:	f10b 0b04 	add.w	fp, fp, #4
 8055ff8:	9b03      	ldr	r3, [sp, #12]
 8055ffa:	e00d      	b.n	8056018 <__gethex+0x27c>
 8055ffc:	9b03      	ldr	r3, [sp, #12]
 8055ffe:	9a06      	ldr	r2, [sp, #24]
 8056000:	4413      	add	r3, r2
 8056002:	42bb      	cmp	r3, r7
 8056004:	d3e0      	bcc.n	8055fc8 <__gethex+0x22c>
 8056006:	4618      	mov	r0, r3
 8056008:	9901      	ldr	r1, [sp, #4]
 805600a:	9307      	str	r3, [sp, #28]
 805600c:	4652      	mov	r2, sl
 805600e:	f7fb f953 	bl	80512b8 <strncmp>
 8056012:	9b07      	ldr	r3, [sp, #28]
 8056014:	2800      	cmp	r0, #0
 8056016:	d1d7      	bne.n	8055fc8 <__gethex+0x22c>
 8056018:	461e      	mov	r6, r3
 805601a:	e78b      	b.n	8055f34 <__gethex+0x198>
 805601c:	f04f 0a03 	mov.w	sl, #3
 8056020:	e7b8      	b.n	8055f94 <__gethex+0x1f8>
 8056022:	da0a      	bge.n	805603a <__gethex+0x29e>
 8056024:	1a37      	subs	r7, r6, r0
 8056026:	4621      	mov	r1, r4
 8056028:	ee18 0a10 	vmov	r0, s16
 805602c:	463a      	mov	r2, r7
 805602e:	f000 fc57 	bl	80568e0 <__lshift>
 8056032:	1bed      	subs	r5, r5, r7
 8056034:	4604      	mov	r4, r0
 8056036:	f100 0914 	add.w	r9, r0, #20
 805603a:	f04f 0a00 	mov.w	sl, #0
 805603e:	e7ae      	b.n	8055f9e <__gethex+0x202>
 8056040:	f8d8 0004 	ldr.w	r0, [r8, #4]
 8056044:	42a8      	cmp	r0, r5
 8056046:	dd72      	ble.n	805612e <__gethex+0x392>
 8056048:	1b45      	subs	r5, r0, r5
 805604a:	42ae      	cmp	r6, r5
 805604c:	dc36      	bgt.n	80560bc <__gethex+0x320>
 805604e:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8056052:	2b02      	cmp	r3, #2
 8056054:	d02a      	beq.n	80560ac <__gethex+0x310>
 8056056:	2b03      	cmp	r3, #3
 8056058:	d02c      	beq.n	80560b4 <__gethex+0x318>
 805605a:	2b01      	cmp	r3, #1
 805605c:	d115      	bne.n	805608a <__gethex+0x2ee>
 805605e:	42ae      	cmp	r6, r5
 8056060:	d113      	bne.n	805608a <__gethex+0x2ee>
 8056062:	2e01      	cmp	r6, #1
 8056064:	d10b      	bne.n	805607e <__gethex+0x2e2>
 8056066:	9a04      	ldr	r2, [sp, #16]
 8056068:	f8d8 3004 	ldr.w	r3, [r8, #4]
 805606c:	6013      	str	r3, [r2, #0]
 805606e:	2301      	movs	r3, #1
 8056070:	6123      	str	r3, [r4, #16]
 8056072:	f8c9 3000 	str.w	r3, [r9]
 8056076:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8056078:	2762      	movs	r7, #98	; 0x62
 805607a:	601c      	str	r4, [r3, #0]
 805607c:	e723      	b.n	8055ec6 <__gethex+0x12a>
 805607e:	1e71      	subs	r1, r6, #1
 8056080:	4620      	mov	r0, r4
 8056082:	f000 fe6b 	bl	8056d5c <__any_on>
 8056086:	2800      	cmp	r0, #0
 8056088:	d1ed      	bne.n	8056066 <__gethex+0x2ca>
 805608a:	ee18 0a10 	vmov	r0, s16
 805608e:	4621      	mov	r1, r4
 8056090:	f000 fa3d 	bl	805650e <_Bfree>
 8056094:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8056096:	2300      	movs	r3, #0
 8056098:	6013      	str	r3, [r2, #0]
 805609a:	2750      	movs	r7, #80	; 0x50
 805609c:	e713      	b.n	8055ec6 <__gethex+0x12a>
 805609e:	bf00      	nop
 80560a0:	0805a5d0 	.word	0x0805a5d0
 80560a4:	0805a4f7 	.word	0x0805a4f7
 80560a8:	0805a567 	.word	0x0805a567
 80560ac:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80560ae:	2b00      	cmp	r3, #0
 80560b0:	d1eb      	bne.n	805608a <__gethex+0x2ee>
 80560b2:	e7d8      	b.n	8056066 <__gethex+0x2ca>
 80560b4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80560b6:	2b00      	cmp	r3, #0
 80560b8:	d1d5      	bne.n	8056066 <__gethex+0x2ca>
 80560ba:	e7e6      	b.n	805608a <__gethex+0x2ee>
 80560bc:	1e6f      	subs	r7, r5, #1
 80560be:	f1ba 0f00 	cmp.w	sl, #0
 80560c2:	d131      	bne.n	8056128 <__gethex+0x38c>
 80560c4:	b127      	cbz	r7, 80560d0 <__gethex+0x334>
 80560c6:	4639      	mov	r1, r7
 80560c8:	4620      	mov	r0, r4
 80560ca:	f000 fe47 	bl	8056d5c <__any_on>
 80560ce:	4682      	mov	sl, r0
 80560d0:	117b      	asrs	r3, r7, #5
 80560d2:	2101      	movs	r1, #1
 80560d4:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 80560d8:	f007 071f 	and.w	r7, r7, #31
 80560dc:	fa01 f707 	lsl.w	r7, r1, r7
 80560e0:	421f      	tst	r7, r3
 80560e2:	4629      	mov	r1, r5
 80560e4:	4620      	mov	r0, r4
 80560e6:	bf18      	it	ne
 80560e8:	f04a 0a02 	orrne.w	sl, sl, #2
 80560ec:	1b76      	subs	r6, r6, r5
 80560ee:	f7ff fdee 	bl	8055cce <rshift>
 80560f2:	f8d8 5004 	ldr.w	r5, [r8, #4]
 80560f6:	2702      	movs	r7, #2
 80560f8:	f1ba 0f00 	cmp.w	sl, #0
 80560fc:	d048      	beq.n	8056190 <__gethex+0x3f4>
 80560fe:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8056102:	2b02      	cmp	r3, #2
 8056104:	d015      	beq.n	8056132 <__gethex+0x396>
 8056106:	2b03      	cmp	r3, #3
 8056108:	d017      	beq.n	805613a <__gethex+0x39e>
 805610a:	2b01      	cmp	r3, #1
 805610c:	d109      	bne.n	8056122 <__gethex+0x386>
 805610e:	f01a 0f02 	tst.w	sl, #2
 8056112:	d006      	beq.n	8056122 <__gethex+0x386>
 8056114:	f8d9 0000 	ldr.w	r0, [r9]
 8056118:	ea4a 0a00 	orr.w	sl, sl, r0
 805611c:	f01a 0f01 	tst.w	sl, #1
 8056120:	d10e      	bne.n	8056140 <__gethex+0x3a4>
 8056122:	f047 0710 	orr.w	r7, r7, #16
 8056126:	e033      	b.n	8056190 <__gethex+0x3f4>
 8056128:	f04f 0a01 	mov.w	sl, #1
 805612c:	e7d0      	b.n	80560d0 <__gethex+0x334>
 805612e:	2701      	movs	r7, #1
 8056130:	e7e2      	b.n	80560f8 <__gethex+0x35c>
 8056132:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8056134:	f1c3 0301 	rsb	r3, r3, #1
 8056138:	9315      	str	r3, [sp, #84]	; 0x54
 805613a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 805613c:	2b00      	cmp	r3, #0
 805613e:	d0f0      	beq.n	8056122 <__gethex+0x386>
 8056140:	f8d4 b010 	ldr.w	fp, [r4, #16]
 8056144:	f104 0314 	add.w	r3, r4, #20
 8056148:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 805614c:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 8056150:	f04f 0c00 	mov.w	ip, #0
 8056154:	4618      	mov	r0, r3
 8056156:	f853 2b04 	ldr.w	r2, [r3], #4
 805615a:	f1b2 3fff 	cmp.w	r2, #4294967295
 805615e:	d01c      	beq.n	805619a <__gethex+0x3fe>
 8056160:	3201      	adds	r2, #1
 8056162:	6002      	str	r2, [r0, #0]
 8056164:	2f02      	cmp	r7, #2
 8056166:	f104 0314 	add.w	r3, r4, #20
 805616a:	d13f      	bne.n	80561ec <__gethex+0x450>
 805616c:	f8d8 2000 	ldr.w	r2, [r8]
 8056170:	3a01      	subs	r2, #1
 8056172:	42b2      	cmp	r2, r6
 8056174:	d10a      	bne.n	805618c <__gethex+0x3f0>
 8056176:	1171      	asrs	r1, r6, #5
 8056178:	2201      	movs	r2, #1
 805617a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 805617e:	f006 061f 	and.w	r6, r6, #31
 8056182:	fa02 f606 	lsl.w	r6, r2, r6
 8056186:	421e      	tst	r6, r3
 8056188:	bf18      	it	ne
 805618a:	4617      	movne	r7, r2
 805618c:	f047 0720 	orr.w	r7, r7, #32
 8056190:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8056192:	601c      	str	r4, [r3, #0]
 8056194:	9b04      	ldr	r3, [sp, #16]
 8056196:	601d      	str	r5, [r3, #0]
 8056198:	e695      	b.n	8055ec6 <__gethex+0x12a>
 805619a:	4299      	cmp	r1, r3
 805619c:	f843 cc04 	str.w	ip, [r3, #-4]
 80561a0:	d8d8      	bhi.n	8056154 <__gethex+0x3b8>
 80561a2:	68a3      	ldr	r3, [r4, #8]
 80561a4:	459b      	cmp	fp, r3
 80561a6:	db19      	blt.n	80561dc <__gethex+0x440>
 80561a8:	6861      	ldr	r1, [r4, #4]
 80561aa:	ee18 0a10 	vmov	r0, s16
 80561ae:	3101      	adds	r1, #1
 80561b0:	f000 f988 	bl	80564c4 <_Balloc>
 80561b4:	4681      	mov	r9, r0
 80561b6:	b918      	cbnz	r0, 80561c0 <__gethex+0x424>
 80561b8:	4b1a      	ldr	r3, [pc, #104]	; (8056224 <__gethex+0x488>)
 80561ba:	4602      	mov	r2, r0
 80561bc:	2184      	movs	r1, #132	; 0x84
 80561be:	e6a8      	b.n	8055f12 <__gethex+0x176>
 80561c0:	6922      	ldr	r2, [r4, #16]
 80561c2:	3202      	adds	r2, #2
 80561c4:	f104 010c 	add.w	r1, r4, #12
 80561c8:	0092      	lsls	r2, r2, #2
 80561ca:	300c      	adds	r0, #12
 80561cc:	f7fa ffec 	bl	80511a8 <memcpy>
 80561d0:	4621      	mov	r1, r4
 80561d2:	ee18 0a10 	vmov	r0, s16
 80561d6:	f000 f99a 	bl	805650e <_Bfree>
 80561da:	464c      	mov	r4, r9
 80561dc:	6923      	ldr	r3, [r4, #16]
 80561de:	1c5a      	adds	r2, r3, #1
 80561e0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 80561e4:	6122      	str	r2, [r4, #16]
 80561e6:	2201      	movs	r2, #1
 80561e8:	615a      	str	r2, [r3, #20]
 80561ea:	e7bb      	b.n	8056164 <__gethex+0x3c8>
 80561ec:	6922      	ldr	r2, [r4, #16]
 80561ee:	455a      	cmp	r2, fp
 80561f0:	dd0b      	ble.n	805620a <__gethex+0x46e>
 80561f2:	2101      	movs	r1, #1
 80561f4:	4620      	mov	r0, r4
 80561f6:	f7ff fd6a 	bl	8055cce <rshift>
 80561fa:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80561fe:	3501      	adds	r5, #1
 8056200:	42ab      	cmp	r3, r5
 8056202:	f6ff aed0 	blt.w	8055fa6 <__gethex+0x20a>
 8056206:	2701      	movs	r7, #1
 8056208:	e7c0      	b.n	805618c <__gethex+0x3f0>
 805620a:	f016 061f 	ands.w	r6, r6, #31
 805620e:	d0fa      	beq.n	8056206 <__gethex+0x46a>
 8056210:	449a      	add	sl, r3
 8056212:	f1c6 0620 	rsb	r6, r6, #32
 8056216:	f85a 0c04 	ldr.w	r0, [sl, #-4]
 805621a:	f000 fa15 	bl	8056648 <__hi0bits>
 805621e:	42b0      	cmp	r0, r6
 8056220:	dbe7      	blt.n	80561f2 <__gethex+0x456>
 8056222:	e7f0      	b.n	8056206 <__gethex+0x46a>
 8056224:	0805a4f7 	.word	0x0805a4f7

08056228 <L_shift>:
 8056228:	f1c2 0208 	rsb	r2, r2, #8
 805622c:	0092      	lsls	r2, r2, #2
 805622e:	b570      	push	{r4, r5, r6, lr}
 8056230:	f1c2 0620 	rsb	r6, r2, #32
 8056234:	6843      	ldr	r3, [r0, #4]
 8056236:	6804      	ldr	r4, [r0, #0]
 8056238:	fa03 f506 	lsl.w	r5, r3, r6
 805623c:	432c      	orrs	r4, r5
 805623e:	40d3      	lsrs	r3, r2
 8056240:	6004      	str	r4, [r0, #0]
 8056242:	f840 3f04 	str.w	r3, [r0, #4]!
 8056246:	4288      	cmp	r0, r1
 8056248:	d3f4      	bcc.n	8056234 <L_shift+0xc>
 805624a:	bd70      	pop	{r4, r5, r6, pc}

0805624c <__match>:
 805624c:	b530      	push	{r4, r5, lr}
 805624e:	6803      	ldr	r3, [r0, #0]
 8056250:	3301      	adds	r3, #1
 8056252:	f811 4b01 	ldrb.w	r4, [r1], #1
 8056256:	b914      	cbnz	r4, 805625e <__match+0x12>
 8056258:	6003      	str	r3, [r0, #0]
 805625a:	2001      	movs	r0, #1
 805625c:	bd30      	pop	{r4, r5, pc}
 805625e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8056262:	f1a2 0541 	sub.w	r5, r2, #65	; 0x41
 8056266:	2d19      	cmp	r5, #25
 8056268:	bf98      	it	ls
 805626a:	3220      	addls	r2, #32
 805626c:	42a2      	cmp	r2, r4
 805626e:	d0f0      	beq.n	8056252 <__match+0x6>
 8056270:	2000      	movs	r0, #0
 8056272:	e7f3      	b.n	805625c <__match+0x10>

08056274 <__hexnan>:
 8056274:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056278:	680b      	ldr	r3, [r1, #0]
 805627a:	6801      	ldr	r1, [r0, #0]
 805627c:	115e      	asrs	r6, r3, #5
 805627e:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8056282:	f013 031f 	ands.w	r3, r3, #31
 8056286:	b087      	sub	sp, #28
 8056288:	bf18      	it	ne
 805628a:	3604      	addne	r6, #4
 805628c:	2500      	movs	r5, #0
 805628e:	1f37      	subs	r7, r6, #4
 8056290:	4682      	mov	sl, r0
 8056292:	4690      	mov	r8, r2
 8056294:	9301      	str	r3, [sp, #4]
 8056296:	f846 5c04 	str.w	r5, [r6, #-4]
 805629a:	46b9      	mov	r9, r7
 805629c:	463c      	mov	r4, r7
 805629e:	9502      	str	r5, [sp, #8]
 80562a0:	46ab      	mov	fp, r5
 80562a2:	784a      	ldrb	r2, [r1, #1]
 80562a4:	1c4b      	adds	r3, r1, #1
 80562a6:	9303      	str	r3, [sp, #12]
 80562a8:	b342      	cbz	r2, 80562fc <__hexnan+0x88>
 80562aa:	4610      	mov	r0, r2
 80562ac:	9105      	str	r1, [sp, #20]
 80562ae:	9204      	str	r2, [sp, #16]
 80562b0:	f7ff fd5f 	bl	8055d72 <__hexdig_fun>
 80562b4:	2800      	cmp	r0, #0
 80562b6:	d14f      	bne.n	8056358 <__hexnan+0xe4>
 80562b8:	9a04      	ldr	r2, [sp, #16]
 80562ba:	9905      	ldr	r1, [sp, #20]
 80562bc:	2a20      	cmp	r2, #32
 80562be:	d818      	bhi.n	80562f2 <__hexnan+0x7e>
 80562c0:	9b02      	ldr	r3, [sp, #8]
 80562c2:	459b      	cmp	fp, r3
 80562c4:	dd13      	ble.n	80562ee <__hexnan+0x7a>
 80562c6:	454c      	cmp	r4, r9
 80562c8:	d206      	bcs.n	80562d8 <__hexnan+0x64>
 80562ca:	2d07      	cmp	r5, #7
 80562cc:	dc04      	bgt.n	80562d8 <__hexnan+0x64>
 80562ce:	462a      	mov	r2, r5
 80562d0:	4649      	mov	r1, r9
 80562d2:	4620      	mov	r0, r4
 80562d4:	f7ff ffa8 	bl	8056228 <L_shift>
 80562d8:	4544      	cmp	r4, r8
 80562da:	d950      	bls.n	805637e <__hexnan+0x10a>
 80562dc:	2300      	movs	r3, #0
 80562de:	f1a4 0904 	sub.w	r9, r4, #4
 80562e2:	f844 3c04 	str.w	r3, [r4, #-4]
 80562e6:	f8cd b008 	str.w	fp, [sp, #8]
 80562ea:	464c      	mov	r4, r9
 80562ec:	461d      	mov	r5, r3
 80562ee:	9903      	ldr	r1, [sp, #12]
 80562f0:	e7d7      	b.n	80562a2 <__hexnan+0x2e>
 80562f2:	2a29      	cmp	r2, #41	; 0x29
 80562f4:	d156      	bne.n	80563a4 <__hexnan+0x130>
 80562f6:	3102      	adds	r1, #2
 80562f8:	f8ca 1000 	str.w	r1, [sl]
 80562fc:	f1bb 0f00 	cmp.w	fp, #0
 8056300:	d050      	beq.n	80563a4 <__hexnan+0x130>
 8056302:	454c      	cmp	r4, r9
 8056304:	d206      	bcs.n	8056314 <__hexnan+0xa0>
 8056306:	2d07      	cmp	r5, #7
 8056308:	dc04      	bgt.n	8056314 <__hexnan+0xa0>
 805630a:	462a      	mov	r2, r5
 805630c:	4649      	mov	r1, r9
 805630e:	4620      	mov	r0, r4
 8056310:	f7ff ff8a 	bl	8056228 <L_shift>
 8056314:	4544      	cmp	r4, r8
 8056316:	d934      	bls.n	8056382 <__hexnan+0x10e>
 8056318:	f1a8 0204 	sub.w	r2, r8, #4
 805631c:	4623      	mov	r3, r4
 805631e:	f853 1b04 	ldr.w	r1, [r3], #4
 8056322:	f842 1f04 	str.w	r1, [r2, #4]!
 8056326:	429f      	cmp	r7, r3
 8056328:	d2f9      	bcs.n	805631e <__hexnan+0xaa>
 805632a:	1b3b      	subs	r3, r7, r4
 805632c:	f023 0303 	bic.w	r3, r3, #3
 8056330:	3304      	adds	r3, #4
 8056332:	3401      	adds	r4, #1
 8056334:	3e03      	subs	r6, #3
 8056336:	42b4      	cmp	r4, r6
 8056338:	bf88      	it	hi
 805633a:	2304      	movhi	r3, #4
 805633c:	4443      	add	r3, r8
 805633e:	2200      	movs	r2, #0
 8056340:	f843 2b04 	str.w	r2, [r3], #4
 8056344:	429f      	cmp	r7, r3
 8056346:	d2fb      	bcs.n	8056340 <__hexnan+0xcc>
 8056348:	683b      	ldr	r3, [r7, #0]
 805634a:	b91b      	cbnz	r3, 8056354 <__hexnan+0xe0>
 805634c:	4547      	cmp	r7, r8
 805634e:	d127      	bne.n	80563a0 <__hexnan+0x12c>
 8056350:	2301      	movs	r3, #1
 8056352:	603b      	str	r3, [r7, #0]
 8056354:	2005      	movs	r0, #5
 8056356:	e026      	b.n	80563a6 <__hexnan+0x132>
 8056358:	3501      	adds	r5, #1
 805635a:	2d08      	cmp	r5, #8
 805635c:	f10b 0b01 	add.w	fp, fp, #1
 8056360:	dd06      	ble.n	8056370 <__hexnan+0xfc>
 8056362:	4544      	cmp	r4, r8
 8056364:	d9c3      	bls.n	80562ee <__hexnan+0x7a>
 8056366:	2300      	movs	r3, #0
 8056368:	f844 3c04 	str.w	r3, [r4, #-4]
 805636c:	2501      	movs	r5, #1
 805636e:	3c04      	subs	r4, #4
 8056370:	6822      	ldr	r2, [r4, #0]
 8056372:	f000 000f 	and.w	r0, r0, #15
 8056376:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 805637a:	6022      	str	r2, [r4, #0]
 805637c:	e7b7      	b.n	80562ee <__hexnan+0x7a>
 805637e:	2508      	movs	r5, #8
 8056380:	e7b5      	b.n	80562ee <__hexnan+0x7a>
 8056382:	9b01      	ldr	r3, [sp, #4]
 8056384:	2b00      	cmp	r3, #0
 8056386:	d0df      	beq.n	8056348 <__hexnan+0xd4>
 8056388:	f04f 32ff 	mov.w	r2, #4294967295
 805638c:	f1c3 0320 	rsb	r3, r3, #32
 8056390:	fa22 f303 	lsr.w	r3, r2, r3
 8056394:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8056398:	401a      	ands	r2, r3
 805639a:	f846 2c04 	str.w	r2, [r6, #-4]
 805639e:	e7d3      	b.n	8056348 <__hexnan+0xd4>
 80563a0:	3f04      	subs	r7, #4
 80563a2:	e7d1      	b.n	8056348 <__hexnan+0xd4>
 80563a4:	2004      	movs	r0, #4
 80563a6:	b007      	add	sp, #28
 80563a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080563ac <__locale_mb_cur_max>:
 80563ac:	4b01      	ldr	r3, [pc, #4]	; (80563b4 <__locale_mb_cur_max+0x8>)
 80563ae:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 80563b2:	4770      	bx	lr
 80563b4:	20004110 	.word	0x20004110

080563b8 <_localeconv_r>:
 80563b8:	4800      	ldr	r0, [pc, #0]	; (80563bc <_localeconv_r+0x4>)
 80563ba:	4770      	bx	lr
 80563bc:	20004200 	.word	0x20004200

080563c0 <__retarget_lock_init_recursive>:
 80563c0:	4770      	bx	lr

080563c2 <__retarget_lock_close_recursive>:
 80563c2:	4770      	bx	lr

080563c4 <__retarget_lock_acquire_recursive>:
 80563c4:	4770      	bx	lr

080563c6 <__retarget_lock_release_recursive>:
 80563c6:	4770      	bx	lr

080563c8 <__swhatbuf_r>:
 80563c8:	b570      	push	{r4, r5, r6, lr}
 80563ca:	460e      	mov	r6, r1
 80563cc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80563d0:	2900      	cmp	r1, #0
 80563d2:	b096      	sub	sp, #88	; 0x58
 80563d4:	4614      	mov	r4, r2
 80563d6:	461d      	mov	r5, r3
 80563d8:	da09      	bge.n	80563ee <__swhatbuf_r+0x26>
 80563da:	89b3      	ldrh	r3, [r6, #12]
 80563dc:	2200      	movs	r2, #0
 80563de:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 80563e2:	602a      	str	r2, [r5, #0]
 80563e4:	d116      	bne.n	8056414 <__swhatbuf_r+0x4c>
 80563e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80563ea:	6023      	str	r3, [r4, #0]
 80563ec:	e015      	b.n	805641a <__swhatbuf_r+0x52>
 80563ee:	466a      	mov	r2, sp
 80563f0:	f001 fc60 	bl	8057cb4 <_fstat_r>
 80563f4:	2800      	cmp	r0, #0
 80563f6:	dbf0      	blt.n	80563da <__swhatbuf_r+0x12>
 80563f8:	9a01      	ldr	r2, [sp, #4]
 80563fa:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80563fe:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8056402:	425a      	negs	r2, r3
 8056404:	415a      	adcs	r2, r3
 8056406:	f44f 6380 	mov.w	r3, #1024	; 0x400
 805640a:	602a      	str	r2, [r5, #0]
 805640c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8056410:	6023      	str	r3, [r4, #0]
 8056412:	e002      	b.n	805641a <__swhatbuf_r+0x52>
 8056414:	2340      	movs	r3, #64	; 0x40
 8056416:	6023      	str	r3, [r4, #0]
 8056418:	4610      	mov	r0, r2
 805641a:	b016      	add	sp, #88	; 0x58
 805641c:	bd70      	pop	{r4, r5, r6, pc}
	...

08056420 <__smakebuf_r>:
 8056420:	898b      	ldrh	r3, [r1, #12]
 8056422:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8056424:	079d      	lsls	r5, r3, #30
 8056426:	4606      	mov	r6, r0
 8056428:	460c      	mov	r4, r1
 805642a:	d507      	bpl.n	805643c <__smakebuf_r+0x1c>
 805642c:	f104 0343 	add.w	r3, r4, #67	; 0x43
 8056430:	6023      	str	r3, [r4, #0]
 8056432:	6123      	str	r3, [r4, #16]
 8056434:	2301      	movs	r3, #1
 8056436:	6163      	str	r3, [r4, #20]
 8056438:	b002      	add	sp, #8
 805643a:	bd70      	pop	{r4, r5, r6, pc}
 805643c:	ab01      	add	r3, sp, #4
 805643e:	466a      	mov	r2, sp
 8056440:	f7ff ffc2 	bl	80563c8 <__swhatbuf_r>
 8056444:	9900      	ldr	r1, [sp, #0]
 8056446:	4605      	mov	r5, r0
 8056448:	4630      	mov	r0, r6
 805644a:	f7fa fc5d 	bl	8050d08 <_malloc_r>
 805644e:	b948      	cbnz	r0, 8056464 <__smakebuf_r+0x44>
 8056450:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8056454:	059a      	lsls	r2, r3, #22
 8056456:	d4ef      	bmi.n	8056438 <__smakebuf_r+0x18>
 8056458:	f023 0303 	bic.w	r3, r3, #3
 805645c:	f043 0302 	orr.w	r3, r3, #2
 8056460:	81a3      	strh	r3, [r4, #12]
 8056462:	e7e3      	b.n	805642c <__smakebuf_r+0xc>
 8056464:	4b0d      	ldr	r3, [pc, #52]	; (805649c <__smakebuf_r+0x7c>)
 8056466:	63f3      	str	r3, [r6, #60]	; 0x3c
 8056468:	89a3      	ldrh	r3, [r4, #12]
 805646a:	6020      	str	r0, [r4, #0]
 805646c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8056470:	81a3      	strh	r3, [r4, #12]
 8056472:	9b00      	ldr	r3, [sp, #0]
 8056474:	6163      	str	r3, [r4, #20]
 8056476:	9b01      	ldr	r3, [sp, #4]
 8056478:	6120      	str	r0, [r4, #16]
 805647a:	b15b      	cbz	r3, 8056494 <__smakebuf_r+0x74>
 805647c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8056480:	4630      	mov	r0, r6
 8056482:	f001 fd73 	bl	8057f6c <_isatty_r>
 8056486:	b128      	cbz	r0, 8056494 <__smakebuf_r+0x74>
 8056488:	89a3      	ldrh	r3, [r4, #12]
 805648a:	f023 0303 	bic.w	r3, r3, #3
 805648e:	f043 0301 	orr.w	r3, r3, #1
 8056492:	81a3      	strh	r3, [r4, #12]
 8056494:	89a0      	ldrh	r0, [r4, #12]
 8056496:	4305      	orrs	r5, r0
 8056498:	81a5      	strh	r5, [r4, #12]
 805649a:	e7cd      	b.n	8056438 <__smakebuf_r+0x18>
 805649c:	080559b5 	.word	0x080559b5

080564a0 <__ascii_mbtowc>:
 80564a0:	b082      	sub	sp, #8
 80564a2:	b901      	cbnz	r1, 80564a6 <__ascii_mbtowc+0x6>
 80564a4:	a901      	add	r1, sp, #4
 80564a6:	b142      	cbz	r2, 80564ba <__ascii_mbtowc+0x1a>
 80564a8:	b14b      	cbz	r3, 80564be <__ascii_mbtowc+0x1e>
 80564aa:	7813      	ldrb	r3, [r2, #0]
 80564ac:	600b      	str	r3, [r1, #0]
 80564ae:	7812      	ldrb	r2, [r2, #0]
 80564b0:	1e10      	subs	r0, r2, #0
 80564b2:	bf18      	it	ne
 80564b4:	2001      	movne	r0, #1
 80564b6:	b002      	add	sp, #8
 80564b8:	4770      	bx	lr
 80564ba:	4610      	mov	r0, r2
 80564bc:	e7fb      	b.n	80564b6 <__ascii_mbtowc+0x16>
 80564be:	f06f 0001 	mvn.w	r0, #1
 80564c2:	e7f8      	b.n	80564b6 <__ascii_mbtowc+0x16>

080564c4 <_Balloc>:
 80564c4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80564c6:	b570      	push	{r4, r5, r6, lr}
 80564c8:	4605      	mov	r5, r0
 80564ca:	460c      	mov	r4, r1
 80564cc:	b17b      	cbz	r3, 80564ee <_Balloc+0x2a>
 80564ce:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 80564d0:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 80564d4:	b9a0      	cbnz	r0, 8056500 <_Balloc+0x3c>
 80564d6:	2101      	movs	r1, #1
 80564d8:	fa01 f604 	lsl.w	r6, r1, r4
 80564dc:	1d72      	adds	r2, r6, #5
 80564de:	0092      	lsls	r2, r2, #2
 80564e0:	4628      	mov	r0, r5
 80564e2:	f001 fad3 	bl	8057a8c <_calloc_r>
 80564e6:	b148      	cbz	r0, 80564fc <_Balloc+0x38>
 80564e8:	e9c0 4601 	strd	r4, r6, [r0, #4]
 80564ec:	e00b      	b.n	8056506 <_Balloc+0x42>
 80564ee:	2221      	movs	r2, #33	; 0x21
 80564f0:	2104      	movs	r1, #4
 80564f2:	f001 facb 	bl	8057a8c <_calloc_r>
 80564f6:	64e8      	str	r0, [r5, #76]	; 0x4c
 80564f8:	2800      	cmp	r0, #0
 80564fa:	d1e8      	bne.n	80564ce <_Balloc+0xa>
 80564fc:	2000      	movs	r0, #0
 80564fe:	bd70      	pop	{r4, r5, r6, pc}
 8056500:	6802      	ldr	r2, [r0, #0]
 8056502:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8056506:	2300      	movs	r3, #0
 8056508:	e9c0 3303 	strd	r3, r3, [r0, #12]
 805650c:	e7f7      	b.n	80564fe <_Balloc+0x3a>

0805650e <_Bfree>:
 805650e:	b131      	cbz	r1, 805651e <_Bfree+0x10>
 8056510:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8056512:	684a      	ldr	r2, [r1, #4]
 8056514:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8056518:	6008      	str	r0, [r1, #0]
 805651a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 805651e:	4770      	bx	lr

08056520 <__multadd>:
 8056520:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8056524:	690e      	ldr	r6, [r1, #16]
 8056526:	4607      	mov	r7, r0
 8056528:	4698      	mov	r8, r3
 805652a:	460c      	mov	r4, r1
 805652c:	f101 0014 	add.w	r0, r1, #20
 8056530:	2300      	movs	r3, #0
 8056532:	6805      	ldr	r5, [r0, #0]
 8056534:	b2a9      	uxth	r1, r5
 8056536:	fb02 8101 	mla	r1, r2, r1, r8
 805653a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
 805653e:	0c2d      	lsrs	r5, r5, #16
 8056540:	fb02 c505 	mla	r5, r2, r5, ip
 8056544:	b289      	uxth	r1, r1
 8056546:	3301      	adds	r3, #1
 8056548:	eb01 4105 	add.w	r1, r1, r5, lsl #16
 805654c:	429e      	cmp	r6, r3
 805654e:	f840 1b04 	str.w	r1, [r0], #4
 8056552:	ea4f 4815 	mov.w	r8, r5, lsr #16
 8056556:	dcec      	bgt.n	8056532 <__multadd+0x12>
 8056558:	f1b8 0f00 	cmp.w	r8, #0
 805655c:	d022      	beq.n	80565a4 <__multadd+0x84>
 805655e:	68a3      	ldr	r3, [r4, #8]
 8056560:	42b3      	cmp	r3, r6
 8056562:	dc19      	bgt.n	8056598 <__multadd+0x78>
 8056564:	6861      	ldr	r1, [r4, #4]
 8056566:	4638      	mov	r0, r7
 8056568:	3101      	adds	r1, #1
 805656a:	f7ff ffab 	bl	80564c4 <_Balloc>
 805656e:	4605      	mov	r5, r0
 8056570:	b928      	cbnz	r0, 805657e <__multadd+0x5e>
 8056572:	4602      	mov	r2, r0
 8056574:	4b0d      	ldr	r3, [pc, #52]	; (80565ac <__multadd+0x8c>)
 8056576:	480e      	ldr	r0, [pc, #56]	; (80565b0 <__multadd+0x90>)
 8056578:	21b5      	movs	r1, #181	; 0xb5
 805657a:	f001 fa69 	bl	8057a50 <__assert_func>
 805657e:	6922      	ldr	r2, [r4, #16]
 8056580:	3202      	adds	r2, #2
 8056582:	f104 010c 	add.w	r1, r4, #12
 8056586:	0092      	lsls	r2, r2, #2
 8056588:	300c      	adds	r0, #12
 805658a:	f7fa fe0d 	bl	80511a8 <memcpy>
 805658e:	4621      	mov	r1, r4
 8056590:	4638      	mov	r0, r7
 8056592:	f7ff ffbc 	bl	805650e <_Bfree>
 8056596:	462c      	mov	r4, r5
 8056598:	eb04 0386 	add.w	r3, r4, r6, lsl #2
 805659c:	3601      	adds	r6, #1
 805659e:	f8c3 8014 	str.w	r8, [r3, #20]
 80565a2:	6126      	str	r6, [r4, #16]
 80565a4:	4620      	mov	r0, r4
 80565a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80565aa:	bf00      	nop
 80565ac:	0805a4f7 	.word	0x0805a4f7
 80565b0:	0805a5e4 	.word	0x0805a5e4

080565b4 <__s2b>:
 80565b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80565b8:	460c      	mov	r4, r1
 80565ba:	4615      	mov	r5, r2
 80565bc:	461f      	mov	r7, r3
 80565be:	2209      	movs	r2, #9
 80565c0:	3308      	adds	r3, #8
 80565c2:	4606      	mov	r6, r0
 80565c4:	fb93 f3f2 	sdiv	r3, r3, r2
 80565c8:	2100      	movs	r1, #0
 80565ca:	2201      	movs	r2, #1
 80565cc:	429a      	cmp	r2, r3
 80565ce:	db09      	blt.n	80565e4 <__s2b+0x30>
 80565d0:	4630      	mov	r0, r6
 80565d2:	f7ff ff77 	bl	80564c4 <_Balloc>
 80565d6:	b940      	cbnz	r0, 80565ea <__s2b+0x36>
 80565d8:	4602      	mov	r2, r0
 80565da:	4b19      	ldr	r3, [pc, #100]	; (8056640 <__s2b+0x8c>)
 80565dc:	4819      	ldr	r0, [pc, #100]	; (8056644 <__s2b+0x90>)
 80565de:	21ce      	movs	r1, #206	; 0xce
 80565e0:	f001 fa36 	bl	8057a50 <__assert_func>
 80565e4:	0052      	lsls	r2, r2, #1
 80565e6:	3101      	adds	r1, #1
 80565e8:	e7f0      	b.n	80565cc <__s2b+0x18>
 80565ea:	9b08      	ldr	r3, [sp, #32]
 80565ec:	6143      	str	r3, [r0, #20]
 80565ee:	2d09      	cmp	r5, #9
 80565f0:	f04f 0301 	mov.w	r3, #1
 80565f4:	6103      	str	r3, [r0, #16]
 80565f6:	dd16      	ble.n	8056626 <__s2b+0x72>
 80565f8:	f104 0909 	add.w	r9, r4, #9
 80565fc:	46c8      	mov	r8, r9
 80565fe:	442c      	add	r4, r5
 8056600:	f818 3b01 	ldrb.w	r3, [r8], #1
 8056604:	4601      	mov	r1, r0
 8056606:	3b30      	subs	r3, #48	; 0x30
 8056608:	220a      	movs	r2, #10
 805660a:	4630      	mov	r0, r6
 805660c:	f7ff ff88 	bl	8056520 <__multadd>
 8056610:	45a0      	cmp	r8, r4
 8056612:	d1f5      	bne.n	8056600 <__s2b+0x4c>
 8056614:	f1a5 0408 	sub.w	r4, r5, #8
 8056618:	444c      	add	r4, r9
 805661a:	1b2d      	subs	r5, r5, r4
 805661c:	1963      	adds	r3, r4, r5
 805661e:	42bb      	cmp	r3, r7
 8056620:	db04      	blt.n	805662c <__s2b+0x78>
 8056622:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8056626:	340a      	adds	r4, #10
 8056628:	2509      	movs	r5, #9
 805662a:	e7f6      	b.n	805661a <__s2b+0x66>
 805662c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8056630:	4601      	mov	r1, r0
 8056632:	3b30      	subs	r3, #48	; 0x30
 8056634:	220a      	movs	r2, #10
 8056636:	4630      	mov	r0, r6
 8056638:	f7ff ff72 	bl	8056520 <__multadd>
 805663c:	e7ee      	b.n	805661c <__s2b+0x68>
 805663e:	bf00      	nop
 8056640:	0805a4f7 	.word	0x0805a4f7
 8056644:	0805a5e4 	.word	0x0805a5e4

08056648 <__hi0bits>:
 8056648:	0c03      	lsrs	r3, r0, #16
 805664a:	041b      	lsls	r3, r3, #16
 805664c:	b9d3      	cbnz	r3, 8056684 <__hi0bits+0x3c>
 805664e:	0400      	lsls	r0, r0, #16
 8056650:	2310      	movs	r3, #16
 8056652:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 8056656:	bf04      	itt	eq
 8056658:	0200      	lsleq	r0, r0, #8
 805665a:	3308      	addeq	r3, #8
 805665c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8056660:	bf04      	itt	eq
 8056662:	0100      	lsleq	r0, r0, #4
 8056664:	3304      	addeq	r3, #4
 8056666:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 805666a:	bf04      	itt	eq
 805666c:	0080      	lsleq	r0, r0, #2
 805666e:	3302      	addeq	r3, #2
 8056670:	2800      	cmp	r0, #0
 8056672:	db05      	blt.n	8056680 <__hi0bits+0x38>
 8056674:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8056678:	f103 0301 	add.w	r3, r3, #1
 805667c:	bf08      	it	eq
 805667e:	2320      	moveq	r3, #32
 8056680:	4618      	mov	r0, r3
 8056682:	4770      	bx	lr
 8056684:	2300      	movs	r3, #0
 8056686:	e7e4      	b.n	8056652 <__hi0bits+0xa>

08056688 <__lo0bits>:
 8056688:	6803      	ldr	r3, [r0, #0]
 805668a:	f013 0207 	ands.w	r2, r3, #7
 805668e:	4601      	mov	r1, r0
 8056690:	d00b      	beq.n	80566aa <__lo0bits+0x22>
 8056692:	07da      	lsls	r2, r3, #31
 8056694:	d424      	bmi.n	80566e0 <__lo0bits+0x58>
 8056696:	0798      	lsls	r0, r3, #30
 8056698:	bf49      	itett	mi
 805669a:	085b      	lsrmi	r3, r3, #1
 805669c:	089b      	lsrpl	r3, r3, #2
 805669e:	2001      	movmi	r0, #1
 80566a0:	600b      	strmi	r3, [r1, #0]
 80566a2:	bf5c      	itt	pl
 80566a4:	600b      	strpl	r3, [r1, #0]
 80566a6:	2002      	movpl	r0, #2
 80566a8:	4770      	bx	lr
 80566aa:	b298      	uxth	r0, r3
 80566ac:	b9b0      	cbnz	r0, 80566dc <__lo0bits+0x54>
 80566ae:	0c1b      	lsrs	r3, r3, #16
 80566b0:	2010      	movs	r0, #16
 80566b2:	f013 0fff 	tst.w	r3, #255	; 0xff
 80566b6:	bf04      	itt	eq
 80566b8:	0a1b      	lsreq	r3, r3, #8
 80566ba:	3008      	addeq	r0, #8
 80566bc:	071a      	lsls	r2, r3, #28
 80566be:	bf04      	itt	eq
 80566c0:	091b      	lsreq	r3, r3, #4
 80566c2:	3004      	addeq	r0, #4
 80566c4:	079a      	lsls	r2, r3, #30
 80566c6:	bf04      	itt	eq
 80566c8:	089b      	lsreq	r3, r3, #2
 80566ca:	3002      	addeq	r0, #2
 80566cc:	07da      	lsls	r2, r3, #31
 80566ce:	d403      	bmi.n	80566d8 <__lo0bits+0x50>
 80566d0:	085b      	lsrs	r3, r3, #1
 80566d2:	f100 0001 	add.w	r0, r0, #1
 80566d6:	d005      	beq.n	80566e4 <__lo0bits+0x5c>
 80566d8:	600b      	str	r3, [r1, #0]
 80566da:	4770      	bx	lr
 80566dc:	4610      	mov	r0, r2
 80566de:	e7e8      	b.n	80566b2 <__lo0bits+0x2a>
 80566e0:	2000      	movs	r0, #0
 80566e2:	4770      	bx	lr
 80566e4:	2020      	movs	r0, #32
 80566e6:	4770      	bx	lr

080566e8 <__i2b>:
 80566e8:	b510      	push	{r4, lr}
 80566ea:	460c      	mov	r4, r1
 80566ec:	2101      	movs	r1, #1
 80566ee:	f7ff fee9 	bl	80564c4 <_Balloc>
 80566f2:	4602      	mov	r2, r0
 80566f4:	b928      	cbnz	r0, 8056702 <__i2b+0x1a>
 80566f6:	4b05      	ldr	r3, [pc, #20]	; (805670c <__i2b+0x24>)
 80566f8:	4805      	ldr	r0, [pc, #20]	; (8056710 <__i2b+0x28>)
 80566fa:	f44f 71a0 	mov.w	r1, #320	; 0x140
 80566fe:	f001 f9a7 	bl	8057a50 <__assert_func>
 8056702:	2301      	movs	r3, #1
 8056704:	6144      	str	r4, [r0, #20]
 8056706:	6103      	str	r3, [r0, #16]
 8056708:	bd10      	pop	{r4, pc}
 805670a:	bf00      	nop
 805670c:	0805a4f7 	.word	0x0805a4f7
 8056710:	0805a5e4 	.word	0x0805a5e4

08056714 <__multiply>:
 8056714:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056718:	4614      	mov	r4, r2
 805671a:	690a      	ldr	r2, [r1, #16]
 805671c:	6923      	ldr	r3, [r4, #16]
 805671e:	429a      	cmp	r2, r3
 8056720:	bfb8      	it	lt
 8056722:	460b      	movlt	r3, r1
 8056724:	460d      	mov	r5, r1
 8056726:	bfbc      	itt	lt
 8056728:	4625      	movlt	r5, r4
 805672a:	461c      	movlt	r4, r3
 805672c:	f8d5 a010 	ldr.w	sl, [r5, #16]
 8056730:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8056734:	68ab      	ldr	r3, [r5, #8]
 8056736:	6869      	ldr	r1, [r5, #4]
 8056738:	eb0a 0709 	add.w	r7, sl, r9
 805673c:	42bb      	cmp	r3, r7
 805673e:	b085      	sub	sp, #20
 8056740:	bfb8      	it	lt
 8056742:	3101      	addlt	r1, #1
 8056744:	f7ff febe 	bl	80564c4 <_Balloc>
 8056748:	b930      	cbnz	r0, 8056758 <__multiply+0x44>
 805674a:	4602      	mov	r2, r0
 805674c:	4b42      	ldr	r3, [pc, #264]	; (8056858 <__multiply+0x144>)
 805674e:	4843      	ldr	r0, [pc, #268]	; (805685c <__multiply+0x148>)
 8056750:	f240 115d 	movw	r1, #349	; 0x15d
 8056754:	f001 f97c 	bl	8057a50 <__assert_func>
 8056758:	f100 0614 	add.w	r6, r0, #20
 805675c:	eb06 0887 	add.w	r8, r6, r7, lsl #2
 8056760:	4633      	mov	r3, r6
 8056762:	2200      	movs	r2, #0
 8056764:	4543      	cmp	r3, r8
 8056766:	d31e      	bcc.n	80567a6 <__multiply+0x92>
 8056768:	f105 0c14 	add.w	ip, r5, #20
 805676c:	f104 0314 	add.w	r3, r4, #20
 8056770:	eb0c 0c8a 	add.w	ip, ip, sl, lsl #2
 8056774:	eb03 0289 	add.w	r2, r3, r9, lsl #2
 8056778:	9202      	str	r2, [sp, #8]
 805677a:	ebac 0205 	sub.w	r2, ip, r5
 805677e:	3a15      	subs	r2, #21
 8056780:	f022 0203 	bic.w	r2, r2, #3
 8056784:	3204      	adds	r2, #4
 8056786:	f105 0115 	add.w	r1, r5, #21
 805678a:	458c      	cmp	ip, r1
 805678c:	bf38      	it	cc
 805678e:	2204      	movcc	r2, #4
 8056790:	9201      	str	r2, [sp, #4]
 8056792:	9a02      	ldr	r2, [sp, #8]
 8056794:	9303      	str	r3, [sp, #12]
 8056796:	429a      	cmp	r2, r3
 8056798:	d808      	bhi.n	80567ac <__multiply+0x98>
 805679a:	2f00      	cmp	r7, #0
 805679c:	dc55      	bgt.n	805684a <__multiply+0x136>
 805679e:	6107      	str	r7, [r0, #16]
 80567a0:	b005      	add	sp, #20
 80567a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80567a6:	f843 2b04 	str.w	r2, [r3], #4
 80567aa:	e7db      	b.n	8056764 <__multiply+0x50>
 80567ac:	f8b3 a000 	ldrh.w	sl, [r3]
 80567b0:	f1ba 0f00 	cmp.w	sl, #0
 80567b4:	d020      	beq.n	80567f8 <__multiply+0xe4>
 80567b6:	f105 0e14 	add.w	lr, r5, #20
 80567ba:	46b1      	mov	r9, r6
 80567bc:	2200      	movs	r2, #0
 80567be:	f85e 4b04 	ldr.w	r4, [lr], #4
 80567c2:	f8d9 b000 	ldr.w	fp, [r9]
 80567c6:	b2a1      	uxth	r1, r4
 80567c8:	fa1f fb8b 	uxth.w	fp, fp
 80567cc:	fb0a b101 	mla	r1, sl, r1, fp
 80567d0:	4411      	add	r1, r2
 80567d2:	f8d9 2000 	ldr.w	r2, [r9]
 80567d6:	0c24      	lsrs	r4, r4, #16
 80567d8:	0c12      	lsrs	r2, r2, #16
 80567da:	fb0a 2404 	mla	r4, sl, r4, r2
 80567de:	eb04 4411 	add.w	r4, r4, r1, lsr #16
 80567e2:	b289      	uxth	r1, r1
 80567e4:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
 80567e8:	45f4      	cmp	ip, lr
 80567ea:	f849 1b04 	str.w	r1, [r9], #4
 80567ee:	ea4f 4214 	mov.w	r2, r4, lsr #16
 80567f2:	d8e4      	bhi.n	80567be <__multiply+0xaa>
 80567f4:	9901      	ldr	r1, [sp, #4]
 80567f6:	5072      	str	r2, [r6, r1]
 80567f8:	9a03      	ldr	r2, [sp, #12]
 80567fa:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 80567fe:	3304      	adds	r3, #4
 8056800:	f1b9 0f00 	cmp.w	r9, #0
 8056804:	d01f      	beq.n	8056846 <__multiply+0x132>
 8056806:	6834      	ldr	r4, [r6, #0]
 8056808:	f105 0114 	add.w	r1, r5, #20
 805680c:	46b6      	mov	lr, r6
 805680e:	f04f 0a00 	mov.w	sl, #0
 8056812:	880a      	ldrh	r2, [r1, #0]
 8056814:	f8be b002 	ldrh.w	fp, [lr, #2]
 8056818:	fb09 b202 	mla	r2, r9, r2, fp
 805681c:	4492      	add	sl, r2
 805681e:	b2a4      	uxth	r4, r4
 8056820:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
 8056824:	f84e 4b04 	str.w	r4, [lr], #4
 8056828:	f851 4b04 	ldr.w	r4, [r1], #4
 805682c:	f8be 2000 	ldrh.w	r2, [lr]
 8056830:	0c24      	lsrs	r4, r4, #16
 8056832:	fb09 2404 	mla	r4, r9, r4, r2
 8056836:	eb04 441a 	add.w	r4, r4, sl, lsr #16
 805683a:	458c      	cmp	ip, r1
 805683c:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 8056840:	d8e7      	bhi.n	8056812 <__multiply+0xfe>
 8056842:	9a01      	ldr	r2, [sp, #4]
 8056844:	50b4      	str	r4, [r6, r2]
 8056846:	3604      	adds	r6, #4
 8056848:	e7a3      	b.n	8056792 <__multiply+0x7e>
 805684a:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 805684e:	2b00      	cmp	r3, #0
 8056850:	d1a5      	bne.n	805679e <__multiply+0x8a>
 8056852:	3f01      	subs	r7, #1
 8056854:	e7a1      	b.n	805679a <__multiply+0x86>
 8056856:	bf00      	nop
 8056858:	0805a4f7 	.word	0x0805a4f7
 805685c:	0805a5e4 	.word	0x0805a5e4

08056860 <__pow5mult>:
 8056860:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8056864:	4615      	mov	r5, r2
 8056866:	f012 0203 	ands.w	r2, r2, #3
 805686a:	4606      	mov	r6, r0
 805686c:	460f      	mov	r7, r1
 805686e:	d007      	beq.n	8056880 <__pow5mult+0x20>
 8056870:	4c1a      	ldr	r4, [pc, #104]	; (80568dc <__pow5mult+0x7c>)
 8056872:	3a01      	subs	r2, #1
 8056874:	2300      	movs	r3, #0
 8056876:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 805687a:	f7ff fe51 	bl	8056520 <__multadd>
 805687e:	4607      	mov	r7, r0
 8056880:	10ad      	asrs	r5, r5, #2
 8056882:	d027      	beq.n	80568d4 <__pow5mult+0x74>
 8056884:	6cb4      	ldr	r4, [r6, #72]	; 0x48
 8056886:	b944      	cbnz	r4, 805689a <__pow5mult+0x3a>
 8056888:	f240 2171 	movw	r1, #625	; 0x271
 805688c:	4630      	mov	r0, r6
 805688e:	f7ff ff2b 	bl	80566e8 <__i2b>
 8056892:	2300      	movs	r3, #0
 8056894:	64b0      	str	r0, [r6, #72]	; 0x48
 8056896:	4604      	mov	r4, r0
 8056898:	6003      	str	r3, [r0, #0]
 805689a:	f04f 0900 	mov.w	r9, #0
 805689e:	07eb      	lsls	r3, r5, #31
 80568a0:	d50a      	bpl.n	80568b8 <__pow5mult+0x58>
 80568a2:	4639      	mov	r1, r7
 80568a4:	4622      	mov	r2, r4
 80568a6:	4630      	mov	r0, r6
 80568a8:	f7ff ff34 	bl	8056714 <__multiply>
 80568ac:	4639      	mov	r1, r7
 80568ae:	4680      	mov	r8, r0
 80568b0:	4630      	mov	r0, r6
 80568b2:	f7ff fe2c 	bl	805650e <_Bfree>
 80568b6:	4647      	mov	r7, r8
 80568b8:	106d      	asrs	r5, r5, #1
 80568ba:	d00b      	beq.n	80568d4 <__pow5mult+0x74>
 80568bc:	6820      	ldr	r0, [r4, #0]
 80568be:	b938      	cbnz	r0, 80568d0 <__pow5mult+0x70>
 80568c0:	4622      	mov	r2, r4
 80568c2:	4621      	mov	r1, r4
 80568c4:	4630      	mov	r0, r6
 80568c6:	f7ff ff25 	bl	8056714 <__multiply>
 80568ca:	6020      	str	r0, [r4, #0]
 80568cc:	f8c0 9000 	str.w	r9, [r0]
 80568d0:	4604      	mov	r4, r0
 80568d2:	e7e4      	b.n	805689e <__pow5mult+0x3e>
 80568d4:	4638      	mov	r0, r7
 80568d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80568da:	bf00      	nop
 80568dc:	0805a738 	.word	0x0805a738

080568e0 <__lshift>:
 80568e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80568e4:	460c      	mov	r4, r1
 80568e6:	6849      	ldr	r1, [r1, #4]
 80568e8:	6923      	ldr	r3, [r4, #16]
 80568ea:	eb03 1862 	add.w	r8, r3, r2, asr #5
 80568ee:	68a3      	ldr	r3, [r4, #8]
 80568f0:	4607      	mov	r7, r0
 80568f2:	4691      	mov	r9, r2
 80568f4:	ea4f 1a62 	mov.w	sl, r2, asr #5
 80568f8:	f108 0601 	add.w	r6, r8, #1
 80568fc:	42b3      	cmp	r3, r6
 80568fe:	db0b      	blt.n	8056918 <__lshift+0x38>
 8056900:	4638      	mov	r0, r7
 8056902:	f7ff fddf 	bl	80564c4 <_Balloc>
 8056906:	4605      	mov	r5, r0
 8056908:	b948      	cbnz	r0, 805691e <__lshift+0x3e>
 805690a:	4602      	mov	r2, r0
 805690c:	4b28      	ldr	r3, [pc, #160]	; (80569b0 <__lshift+0xd0>)
 805690e:	4829      	ldr	r0, [pc, #164]	; (80569b4 <__lshift+0xd4>)
 8056910:	f240 11d9 	movw	r1, #473	; 0x1d9
 8056914:	f001 f89c 	bl	8057a50 <__assert_func>
 8056918:	3101      	adds	r1, #1
 805691a:	005b      	lsls	r3, r3, #1
 805691c:	e7ee      	b.n	80568fc <__lshift+0x1c>
 805691e:	2300      	movs	r3, #0
 8056920:	f100 0114 	add.w	r1, r0, #20
 8056924:	f100 0210 	add.w	r2, r0, #16
 8056928:	4618      	mov	r0, r3
 805692a:	4553      	cmp	r3, sl
 805692c:	db33      	blt.n	8056996 <__lshift+0xb6>
 805692e:	6920      	ldr	r0, [r4, #16]
 8056930:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8056934:	f104 0314 	add.w	r3, r4, #20
 8056938:	f019 091f 	ands.w	r9, r9, #31
 805693c:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8056940:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8056944:	d02b      	beq.n	805699e <__lshift+0xbe>
 8056946:	f1c9 0e20 	rsb	lr, r9, #32
 805694a:	468a      	mov	sl, r1
 805694c:	2200      	movs	r2, #0
 805694e:	6818      	ldr	r0, [r3, #0]
 8056950:	fa00 f009 	lsl.w	r0, r0, r9
 8056954:	4302      	orrs	r2, r0
 8056956:	f84a 2b04 	str.w	r2, [sl], #4
 805695a:	f853 2b04 	ldr.w	r2, [r3], #4
 805695e:	459c      	cmp	ip, r3
 8056960:	fa22 f20e 	lsr.w	r2, r2, lr
 8056964:	d8f3      	bhi.n	805694e <__lshift+0x6e>
 8056966:	ebac 0304 	sub.w	r3, ip, r4
 805696a:	3b15      	subs	r3, #21
 805696c:	f023 0303 	bic.w	r3, r3, #3
 8056970:	3304      	adds	r3, #4
 8056972:	f104 0015 	add.w	r0, r4, #21
 8056976:	4584      	cmp	ip, r0
 8056978:	bf38      	it	cc
 805697a:	2304      	movcc	r3, #4
 805697c:	50ca      	str	r2, [r1, r3]
 805697e:	b10a      	cbz	r2, 8056984 <__lshift+0xa4>
 8056980:	f108 0602 	add.w	r6, r8, #2
 8056984:	3e01      	subs	r6, #1
 8056986:	4638      	mov	r0, r7
 8056988:	612e      	str	r6, [r5, #16]
 805698a:	4621      	mov	r1, r4
 805698c:	f7ff fdbf 	bl	805650e <_Bfree>
 8056990:	4628      	mov	r0, r5
 8056992:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8056996:	f842 0f04 	str.w	r0, [r2, #4]!
 805699a:	3301      	adds	r3, #1
 805699c:	e7c5      	b.n	805692a <__lshift+0x4a>
 805699e:	3904      	subs	r1, #4
 80569a0:	f853 2b04 	ldr.w	r2, [r3], #4
 80569a4:	f841 2f04 	str.w	r2, [r1, #4]!
 80569a8:	459c      	cmp	ip, r3
 80569aa:	d8f9      	bhi.n	80569a0 <__lshift+0xc0>
 80569ac:	e7ea      	b.n	8056984 <__lshift+0xa4>
 80569ae:	bf00      	nop
 80569b0:	0805a4f7 	.word	0x0805a4f7
 80569b4:	0805a5e4 	.word	0x0805a5e4

080569b8 <__mcmp>:
 80569b8:	b530      	push	{r4, r5, lr}
 80569ba:	6902      	ldr	r2, [r0, #16]
 80569bc:	690c      	ldr	r4, [r1, #16]
 80569be:	1b12      	subs	r2, r2, r4
 80569c0:	d10e      	bne.n	80569e0 <__mcmp+0x28>
 80569c2:	f100 0314 	add.w	r3, r0, #20
 80569c6:	3114      	adds	r1, #20
 80569c8:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 80569cc:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 80569d0:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 80569d4:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 80569d8:	42a5      	cmp	r5, r4
 80569da:	d003      	beq.n	80569e4 <__mcmp+0x2c>
 80569dc:	d305      	bcc.n	80569ea <__mcmp+0x32>
 80569de:	2201      	movs	r2, #1
 80569e0:	4610      	mov	r0, r2
 80569e2:	bd30      	pop	{r4, r5, pc}
 80569e4:	4283      	cmp	r3, r0
 80569e6:	d3f3      	bcc.n	80569d0 <__mcmp+0x18>
 80569e8:	e7fa      	b.n	80569e0 <__mcmp+0x28>
 80569ea:	f04f 32ff 	mov.w	r2, #4294967295
 80569ee:	e7f7      	b.n	80569e0 <__mcmp+0x28>

080569f0 <__mdiff>:
 80569f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80569f4:	460c      	mov	r4, r1
 80569f6:	4606      	mov	r6, r0
 80569f8:	4611      	mov	r1, r2
 80569fa:	4620      	mov	r0, r4
 80569fc:	4617      	mov	r7, r2
 80569fe:	f7ff ffdb 	bl	80569b8 <__mcmp>
 8056a02:	1e05      	subs	r5, r0, #0
 8056a04:	d110      	bne.n	8056a28 <__mdiff+0x38>
 8056a06:	4629      	mov	r1, r5
 8056a08:	4630      	mov	r0, r6
 8056a0a:	f7ff fd5b 	bl	80564c4 <_Balloc>
 8056a0e:	b930      	cbnz	r0, 8056a1e <__mdiff+0x2e>
 8056a10:	4b39      	ldr	r3, [pc, #228]	; (8056af8 <__mdiff+0x108>)
 8056a12:	4602      	mov	r2, r0
 8056a14:	f240 2132 	movw	r1, #562	; 0x232
 8056a18:	4838      	ldr	r0, [pc, #224]	; (8056afc <__mdiff+0x10c>)
 8056a1a:	f001 f819 	bl	8057a50 <__assert_func>
 8056a1e:	2301      	movs	r3, #1
 8056a20:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8056a24:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8056a28:	bfa4      	itt	ge
 8056a2a:	463b      	movge	r3, r7
 8056a2c:	4627      	movge	r7, r4
 8056a2e:	4630      	mov	r0, r6
 8056a30:	6879      	ldr	r1, [r7, #4]
 8056a32:	bfa6      	itte	ge
 8056a34:	461c      	movge	r4, r3
 8056a36:	2500      	movge	r5, #0
 8056a38:	2501      	movlt	r5, #1
 8056a3a:	f7ff fd43 	bl	80564c4 <_Balloc>
 8056a3e:	b920      	cbnz	r0, 8056a4a <__mdiff+0x5a>
 8056a40:	4b2d      	ldr	r3, [pc, #180]	; (8056af8 <__mdiff+0x108>)
 8056a42:	4602      	mov	r2, r0
 8056a44:	f44f 7110 	mov.w	r1, #576	; 0x240
 8056a48:	e7e6      	b.n	8056a18 <__mdiff+0x28>
 8056a4a:	693e      	ldr	r6, [r7, #16]
 8056a4c:	60c5      	str	r5, [r0, #12]
 8056a4e:	6925      	ldr	r5, [r4, #16]
 8056a50:	f107 0114 	add.w	r1, r7, #20
 8056a54:	f104 0914 	add.w	r9, r4, #20
 8056a58:	f100 0e14 	add.w	lr, r0, #20
 8056a5c:	f107 0210 	add.w	r2, r7, #16
 8056a60:	eb01 0c86 	add.w	ip, r1, r6, lsl #2
 8056a64:	eb09 0585 	add.w	r5, r9, r5, lsl #2
 8056a68:	46f2      	mov	sl, lr
 8056a6a:	2700      	movs	r7, #0
 8056a6c:	f859 3b04 	ldr.w	r3, [r9], #4
 8056a70:	f852 bf04 	ldr.w	fp, [r2, #4]!
 8056a74:	fa1f f883 	uxth.w	r8, r3
 8056a78:	fa17 f78b 	uxtah	r7, r7, fp
 8056a7c:	0c1b      	lsrs	r3, r3, #16
 8056a7e:	eba7 0808 	sub.w	r8, r7, r8
 8056a82:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 8056a86:	eb03 4328 	add.w	r3, r3, r8, asr #16
 8056a8a:	fa1f f888 	uxth.w	r8, r8
 8056a8e:	141f      	asrs	r7, r3, #16
 8056a90:	454d      	cmp	r5, r9
 8056a92:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 8056a96:	f84a 3b04 	str.w	r3, [sl], #4
 8056a9a:	d8e7      	bhi.n	8056a6c <__mdiff+0x7c>
 8056a9c:	1b2b      	subs	r3, r5, r4
 8056a9e:	3b15      	subs	r3, #21
 8056aa0:	f023 0303 	bic.w	r3, r3, #3
 8056aa4:	3304      	adds	r3, #4
 8056aa6:	3415      	adds	r4, #21
 8056aa8:	42a5      	cmp	r5, r4
 8056aaa:	bf38      	it	cc
 8056aac:	2304      	movcc	r3, #4
 8056aae:	4419      	add	r1, r3
 8056ab0:	4473      	add	r3, lr
 8056ab2:	469e      	mov	lr, r3
 8056ab4:	460d      	mov	r5, r1
 8056ab6:	4565      	cmp	r5, ip
 8056ab8:	d30e      	bcc.n	8056ad8 <__mdiff+0xe8>
 8056aba:	f10c 0203 	add.w	r2, ip, #3
 8056abe:	1a52      	subs	r2, r2, r1
 8056ac0:	f022 0203 	bic.w	r2, r2, #3
 8056ac4:	3903      	subs	r1, #3
 8056ac6:	458c      	cmp	ip, r1
 8056ac8:	bf38      	it	cc
 8056aca:	2200      	movcc	r2, #0
 8056acc:	441a      	add	r2, r3
 8056ace:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 8056ad2:	b17b      	cbz	r3, 8056af4 <__mdiff+0x104>
 8056ad4:	6106      	str	r6, [r0, #16]
 8056ad6:	e7a5      	b.n	8056a24 <__mdiff+0x34>
 8056ad8:	f855 8b04 	ldr.w	r8, [r5], #4
 8056adc:	fa17 f488 	uxtah	r4, r7, r8
 8056ae0:	1422      	asrs	r2, r4, #16
 8056ae2:	eb02 4218 	add.w	r2, r2, r8, lsr #16
 8056ae6:	b2a4      	uxth	r4, r4
 8056ae8:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8056aec:	f84e 4b04 	str.w	r4, [lr], #4
 8056af0:	1417      	asrs	r7, r2, #16
 8056af2:	e7e0      	b.n	8056ab6 <__mdiff+0xc6>
 8056af4:	3e01      	subs	r6, #1
 8056af6:	e7ea      	b.n	8056ace <__mdiff+0xde>
 8056af8:	0805a4f7 	.word	0x0805a4f7
 8056afc:	0805a5e4 	.word	0x0805a5e4

08056b00 <__ulp>:
 8056b00:	b082      	sub	sp, #8
 8056b02:	ed8d 0b00 	vstr	d0, [sp]
 8056b06:	9b01      	ldr	r3, [sp, #4]
 8056b08:	4912      	ldr	r1, [pc, #72]	; (8056b54 <__ulp+0x54>)
 8056b0a:	4019      	ands	r1, r3
 8056b0c:	f1a1 7150 	sub.w	r1, r1, #54525952	; 0x3400000
 8056b10:	2900      	cmp	r1, #0
 8056b12:	dd05      	ble.n	8056b20 <__ulp+0x20>
 8056b14:	2200      	movs	r2, #0
 8056b16:	460b      	mov	r3, r1
 8056b18:	ec43 2b10 	vmov	d0, r2, r3
 8056b1c:	b002      	add	sp, #8
 8056b1e:	4770      	bx	lr
 8056b20:	4249      	negs	r1, r1
 8056b22:	f1b1 7fa0 	cmp.w	r1, #20971520	; 0x1400000
 8056b26:	ea4f 5021 	mov.w	r0, r1, asr #20
 8056b2a:	f04f 0200 	mov.w	r2, #0
 8056b2e:	f04f 0300 	mov.w	r3, #0
 8056b32:	da04      	bge.n	8056b3e <__ulp+0x3e>
 8056b34:	f44f 2100 	mov.w	r1, #524288	; 0x80000
 8056b38:	fa41 f300 	asr.w	r3, r1, r0
 8056b3c:	e7ec      	b.n	8056b18 <__ulp+0x18>
 8056b3e:	f1a0 0114 	sub.w	r1, r0, #20
 8056b42:	291e      	cmp	r1, #30
 8056b44:	bfda      	itte	le
 8056b46:	f04f 4000 	movle.w	r0, #2147483648	; 0x80000000
 8056b4a:	fa20 f101 	lsrle.w	r1, r0, r1
 8056b4e:	2101      	movgt	r1, #1
 8056b50:	460a      	mov	r2, r1
 8056b52:	e7e1      	b.n	8056b18 <__ulp+0x18>
 8056b54:	7ff00000 	.word	0x7ff00000

08056b58 <__b2d>:
 8056b58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8056b5a:	6905      	ldr	r5, [r0, #16]
 8056b5c:	f100 0714 	add.w	r7, r0, #20
 8056b60:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8056b64:	1f2e      	subs	r6, r5, #4
 8056b66:	f855 4c04 	ldr.w	r4, [r5, #-4]
 8056b6a:	4620      	mov	r0, r4
 8056b6c:	f7ff fd6c 	bl	8056648 <__hi0bits>
 8056b70:	f1c0 0320 	rsb	r3, r0, #32
 8056b74:	280a      	cmp	r0, #10
 8056b76:	f8df c07c 	ldr.w	ip, [pc, #124]	; 8056bf4 <__b2d+0x9c>
 8056b7a:	600b      	str	r3, [r1, #0]
 8056b7c:	dc14      	bgt.n	8056ba8 <__b2d+0x50>
 8056b7e:	f1c0 0e0b 	rsb	lr, r0, #11
 8056b82:	fa24 f10e 	lsr.w	r1, r4, lr
 8056b86:	42b7      	cmp	r7, r6
 8056b88:	ea41 030c 	orr.w	r3, r1, ip
 8056b8c:	bf34      	ite	cc
 8056b8e:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 8056b92:	2100      	movcs	r1, #0
 8056b94:	3015      	adds	r0, #21
 8056b96:	fa04 f000 	lsl.w	r0, r4, r0
 8056b9a:	fa21 f10e 	lsr.w	r1, r1, lr
 8056b9e:	ea40 0201 	orr.w	r2, r0, r1
 8056ba2:	ec43 2b10 	vmov	d0, r2, r3
 8056ba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8056ba8:	42b7      	cmp	r7, r6
 8056baa:	bf3a      	itte	cc
 8056bac:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
 8056bb0:	f1a5 0608 	subcc.w	r6, r5, #8
 8056bb4:	2100      	movcs	r1, #0
 8056bb6:	380b      	subs	r0, #11
 8056bb8:	d017      	beq.n	8056bea <__b2d+0x92>
 8056bba:	f1c0 0c20 	rsb	ip, r0, #32
 8056bbe:	fa04 f500 	lsl.w	r5, r4, r0
 8056bc2:	42be      	cmp	r6, r7
 8056bc4:	fa21 f40c 	lsr.w	r4, r1, ip
 8056bc8:	ea45 0504 	orr.w	r5, r5, r4
 8056bcc:	bf8c      	ite	hi
 8056bce:	f856 4c04 	ldrhi.w	r4, [r6, #-4]
 8056bd2:	2400      	movls	r4, #0
 8056bd4:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
 8056bd8:	fa01 f000 	lsl.w	r0, r1, r0
 8056bdc:	fa24 f40c 	lsr.w	r4, r4, ip
 8056be0:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8056be4:	ea40 0204 	orr.w	r2, r0, r4
 8056be8:	e7db      	b.n	8056ba2 <__b2d+0x4a>
 8056bea:	ea44 030c 	orr.w	r3, r4, ip
 8056bee:	460a      	mov	r2, r1
 8056bf0:	e7d7      	b.n	8056ba2 <__b2d+0x4a>
 8056bf2:	bf00      	nop
 8056bf4:	3ff00000 	.word	0x3ff00000

08056bf8 <__d2b>:
 8056bf8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8056bfc:	4689      	mov	r9, r1
 8056bfe:	2101      	movs	r1, #1
 8056c00:	ec57 6b10 	vmov	r6, r7, d0
 8056c04:	4690      	mov	r8, r2
 8056c06:	f7ff fc5d 	bl	80564c4 <_Balloc>
 8056c0a:	4604      	mov	r4, r0
 8056c0c:	b930      	cbnz	r0, 8056c1c <__d2b+0x24>
 8056c0e:	4602      	mov	r2, r0
 8056c10:	4b25      	ldr	r3, [pc, #148]	; (8056ca8 <__d2b+0xb0>)
 8056c12:	4826      	ldr	r0, [pc, #152]	; (8056cac <__d2b+0xb4>)
 8056c14:	f240 310a 	movw	r1, #778	; 0x30a
 8056c18:	f000 ff1a 	bl	8057a50 <__assert_func>
 8056c1c:	f3c7 550a 	ubfx	r5, r7, #20, #11
 8056c20:	f3c7 0313 	ubfx	r3, r7, #0, #20
 8056c24:	bb35      	cbnz	r5, 8056c74 <__d2b+0x7c>
 8056c26:	2e00      	cmp	r6, #0
 8056c28:	9301      	str	r3, [sp, #4]
 8056c2a:	d028      	beq.n	8056c7e <__d2b+0x86>
 8056c2c:	4668      	mov	r0, sp
 8056c2e:	9600      	str	r6, [sp, #0]
 8056c30:	f7ff fd2a 	bl	8056688 <__lo0bits>
 8056c34:	9900      	ldr	r1, [sp, #0]
 8056c36:	b300      	cbz	r0, 8056c7a <__d2b+0x82>
 8056c38:	9a01      	ldr	r2, [sp, #4]
 8056c3a:	f1c0 0320 	rsb	r3, r0, #32
 8056c3e:	fa02 f303 	lsl.w	r3, r2, r3
 8056c42:	430b      	orrs	r3, r1
 8056c44:	40c2      	lsrs	r2, r0
 8056c46:	6163      	str	r3, [r4, #20]
 8056c48:	9201      	str	r2, [sp, #4]
 8056c4a:	9b01      	ldr	r3, [sp, #4]
 8056c4c:	61a3      	str	r3, [r4, #24]
 8056c4e:	2b00      	cmp	r3, #0
 8056c50:	bf14      	ite	ne
 8056c52:	2202      	movne	r2, #2
 8056c54:	2201      	moveq	r2, #1
 8056c56:	6122      	str	r2, [r4, #16]
 8056c58:	b1d5      	cbz	r5, 8056c90 <__d2b+0x98>
 8056c5a:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8056c5e:	4405      	add	r5, r0
 8056c60:	f8c9 5000 	str.w	r5, [r9]
 8056c64:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8056c68:	f8c8 0000 	str.w	r0, [r8]
 8056c6c:	4620      	mov	r0, r4
 8056c6e:	b003      	add	sp, #12
 8056c70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8056c74:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8056c78:	e7d5      	b.n	8056c26 <__d2b+0x2e>
 8056c7a:	6161      	str	r1, [r4, #20]
 8056c7c:	e7e5      	b.n	8056c4a <__d2b+0x52>
 8056c7e:	a801      	add	r0, sp, #4
 8056c80:	f7ff fd02 	bl	8056688 <__lo0bits>
 8056c84:	9b01      	ldr	r3, [sp, #4]
 8056c86:	6163      	str	r3, [r4, #20]
 8056c88:	2201      	movs	r2, #1
 8056c8a:	6122      	str	r2, [r4, #16]
 8056c8c:	3020      	adds	r0, #32
 8056c8e:	e7e3      	b.n	8056c58 <__d2b+0x60>
 8056c90:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8056c94:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8056c98:	f8c9 0000 	str.w	r0, [r9]
 8056c9c:	6918      	ldr	r0, [r3, #16]
 8056c9e:	f7ff fcd3 	bl	8056648 <__hi0bits>
 8056ca2:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8056ca6:	e7df      	b.n	8056c68 <__d2b+0x70>
 8056ca8:	0805a4f7 	.word	0x0805a4f7
 8056cac:	0805a5e4 	.word	0x0805a5e4

08056cb0 <__ratio>:
 8056cb0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056cb4:	4688      	mov	r8, r1
 8056cb6:	4669      	mov	r1, sp
 8056cb8:	4681      	mov	r9, r0
 8056cba:	f7ff ff4d 	bl	8056b58 <__b2d>
 8056cbe:	a901      	add	r1, sp, #4
 8056cc0:	4640      	mov	r0, r8
 8056cc2:	ec55 4b10 	vmov	r4, r5, d0
 8056cc6:	f7ff ff47 	bl	8056b58 <__b2d>
 8056cca:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8056cce:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8056cd2:	eba3 0c02 	sub.w	ip, r3, r2
 8056cd6:	e9dd 3200 	ldrd	r3, r2, [sp]
 8056cda:	1a9b      	subs	r3, r3, r2
 8056cdc:	eb03 134c 	add.w	r3, r3, ip, lsl #5
 8056ce0:	ec51 0b10 	vmov	r0, r1, d0
 8056ce4:	2b00      	cmp	r3, #0
 8056ce6:	bfd6      	itet	le
 8056ce8:	460a      	movle	r2, r1
 8056cea:	462a      	movgt	r2, r5
 8056cec:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
 8056cf0:	468b      	mov	fp, r1
 8056cf2:	462f      	mov	r7, r5
 8056cf4:	bfd4      	ite	le
 8056cf6:	eb02 5b03 	addle.w	fp, r2, r3, lsl #20
 8056cfa:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
 8056cfe:	4620      	mov	r0, r4
 8056d00:	ee10 2a10 	vmov	r2, s0
 8056d04:	465b      	mov	r3, fp
 8056d06:	4639      	mov	r1, r7
 8056d08:	f7e9 fdb0 	bl	804086c <__aeabi_ddiv>
 8056d0c:	ec41 0b10 	vmov	d0, r0, r1
 8056d10:	b003      	add	sp, #12
 8056d12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08056d16 <__copybits>:
 8056d16:	3901      	subs	r1, #1
 8056d18:	b570      	push	{r4, r5, r6, lr}
 8056d1a:	1149      	asrs	r1, r1, #5
 8056d1c:	6914      	ldr	r4, [r2, #16]
 8056d1e:	3101      	adds	r1, #1
 8056d20:	f102 0314 	add.w	r3, r2, #20
 8056d24:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 8056d28:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8056d2c:	1f05      	subs	r5, r0, #4
 8056d2e:	42a3      	cmp	r3, r4
 8056d30:	d30c      	bcc.n	8056d4c <__copybits+0x36>
 8056d32:	1aa3      	subs	r3, r4, r2
 8056d34:	3b11      	subs	r3, #17
 8056d36:	f023 0303 	bic.w	r3, r3, #3
 8056d3a:	3211      	adds	r2, #17
 8056d3c:	42a2      	cmp	r2, r4
 8056d3e:	bf88      	it	hi
 8056d40:	2300      	movhi	r3, #0
 8056d42:	4418      	add	r0, r3
 8056d44:	2300      	movs	r3, #0
 8056d46:	4288      	cmp	r0, r1
 8056d48:	d305      	bcc.n	8056d56 <__copybits+0x40>
 8056d4a:	bd70      	pop	{r4, r5, r6, pc}
 8056d4c:	f853 6b04 	ldr.w	r6, [r3], #4
 8056d50:	f845 6f04 	str.w	r6, [r5, #4]!
 8056d54:	e7eb      	b.n	8056d2e <__copybits+0x18>
 8056d56:	f840 3b04 	str.w	r3, [r0], #4
 8056d5a:	e7f4      	b.n	8056d46 <__copybits+0x30>

08056d5c <__any_on>:
 8056d5c:	f100 0214 	add.w	r2, r0, #20
 8056d60:	6900      	ldr	r0, [r0, #16]
 8056d62:	114b      	asrs	r3, r1, #5
 8056d64:	4298      	cmp	r0, r3
 8056d66:	b510      	push	{r4, lr}
 8056d68:	db11      	blt.n	8056d8e <__any_on+0x32>
 8056d6a:	dd0a      	ble.n	8056d82 <__any_on+0x26>
 8056d6c:	f011 011f 	ands.w	r1, r1, #31
 8056d70:	d007      	beq.n	8056d82 <__any_on+0x26>
 8056d72:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 8056d76:	fa24 f001 	lsr.w	r0, r4, r1
 8056d7a:	fa00 f101 	lsl.w	r1, r0, r1
 8056d7e:	428c      	cmp	r4, r1
 8056d80:	d10b      	bne.n	8056d9a <__any_on+0x3e>
 8056d82:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8056d86:	4293      	cmp	r3, r2
 8056d88:	d803      	bhi.n	8056d92 <__any_on+0x36>
 8056d8a:	2000      	movs	r0, #0
 8056d8c:	bd10      	pop	{r4, pc}
 8056d8e:	4603      	mov	r3, r0
 8056d90:	e7f7      	b.n	8056d82 <__any_on+0x26>
 8056d92:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8056d96:	2900      	cmp	r1, #0
 8056d98:	d0f5      	beq.n	8056d86 <__any_on+0x2a>
 8056d9a:	2001      	movs	r0, #1
 8056d9c:	e7f6      	b.n	8056d8c <__any_on+0x30>
	...

08056da0 <frexp>:
 8056da0:	b570      	push	{r4, r5, r6, lr}
 8056da2:	2100      	movs	r1, #0
 8056da4:	ec55 4b10 	vmov	r4, r5, d0
 8056da8:	6001      	str	r1, [r0, #0]
 8056daa:	4916      	ldr	r1, [pc, #88]	; (8056e04 <frexp+0x64>)
 8056dac:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
 8056db0:	428a      	cmp	r2, r1
 8056db2:	4606      	mov	r6, r0
 8056db4:	462b      	mov	r3, r5
 8056db6:	dc22      	bgt.n	8056dfe <frexp+0x5e>
 8056db8:	ee10 1a10 	vmov	r1, s0
 8056dbc:	4311      	orrs	r1, r2
 8056dbe:	d01e      	beq.n	8056dfe <frexp+0x5e>
 8056dc0:	4911      	ldr	r1, [pc, #68]	; (8056e08 <frexp+0x68>)
 8056dc2:	4029      	ands	r1, r5
 8056dc4:	b969      	cbnz	r1, 8056de2 <frexp+0x42>
 8056dc6:	4b11      	ldr	r3, [pc, #68]	; (8056e0c <frexp+0x6c>)
 8056dc8:	2200      	movs	r2, #0
 8056dca:	ee10 0a10 	vmov	r0, s0
 8056dce:	4629      	mov	r1, r5
 8056dd0:	f7e9 fc22 	bl	8040618 <__aeabi_dmul>
 8056dd4:	460b      	mov	r3, r1
 8056dd6:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 8056dda:	f06f 0135 	mvn.w	r1, #53	; 0x35
 8056dde:	4604      	mov	r4, r0
 8056de0:	6031      	str	r1, [r6, #0]
 8056de2:	6831      	ldr	r1, [r6, #0]
 8056de4:	1512      	asrs	r2, r2, #20
 8056de6:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 8056dea:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
 8056dee:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8056df2:	440a      	add	r2, r1
 8056df4:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
 8056df8:	6032      	str	r2, [r6, #0]
 8056dfa:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
 8056dfe:	ec45 4b10 	vmov	d0, r4, r5
 8056e02:	bd70      	pop	{r4, r5, r6, pc}
 8056e04:	7fefffff 	.word	0x7fefffff
 8056e08:	7ff00000 	.word	0x7ff00000
 8056e0c:	43500000 	.word	0x43500000

08056e10 <nan>:
 8056e10:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8056e18 <nan+0x8>
 8056e14:	4770      	bx	lr
 8056e16:	bf00      	nop
 8056e18:	00000000 	.word	0x00000000
 8056e1c:	7ff80000 	.word	0x7ff80000

08056e20 <__sread>:
 8056e20:	b510      	push	{r4, lr}
 8056e22:	460c      	mov	r4, r1
 8056e24:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8056e28:	f001 f8dc 	bl	8057fe4 <_read_r>
 8056e2c:	2800      	cmp	r0, #0
 8056e2e:	bfab      	itete	ge
 8056e30:	6d23      	ldrge	r3, [r4, #80]	; 0x50
 8056e32:	89a3      	ldrhlt	r3, [r4, #12]
 8056e34:	181b      	addge	r3, r3, r0
 8056e36:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8056e3a:	bfac      	ite	ge
 8056e3c:	6523      	strge	r3, [r4, #80]	; 0x50
 8056e3e:	81a3      	strhlt	r3, [r4, #12]
 8056e40:	bd10      	pop	{r4, pc}

08056e42 <__swrite>:
 8056e42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8056e46:	461f      	mov	r7, r3
 8056e48:	898b      	ldrh	r3, [r1, #12]
 8056e4a:	05db      	lsls	r3, r3, #23
 8056e4c:	4605      	mov	r5, r0
 8056e4e:	460c      	mov	r4, r1
 8056e50:	4616      	mov	r6, r2
 8056e52:	d505      	bpl.n	8056e60 <__swrite+0x1e>
 8056e54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8056e58:	2302      	movs	r3, #2
 8056e5a:	2200      	movs	r2, #0
 8056e5c:	f001 f896 	bl	8057f8c <_lseek_r>
 8056e60:	89a3      	ldrh	r3, [r4, #12]
 8056e62:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8056e66:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8056e6a:	81a3      	strh	r3, [r4, #12]
 8056e6c:	4632      	mov	r2, r6
 8056e6e:	463b      	mov	r3, r7
 8056e70:	4628      	mov	r0, r5
 8056e72:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8056e76:	f000 bd99 	b.w	80579ac <_write_r>

08056e7a <__sseek>:
 8056e7a:	b510      	push	{r4, lr}
 8056e7c:	460c      	mov	r4, r1
 8056e7e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8056e82:	f001 f883 	bl	8057f8c <_lseek_r>
 8056e86:	1c43      	adds	r3, r0, #1
 8056e88:	89a3      	ldrh	r3, [r4, #12]
 8056e8a:	bf15      	itete	ne
 8056e8c:	6520      	strne	r0, [r4, #80]	; 0x50
 8056e8e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8056e92:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8056e96:	81a3      	strheq	r3, [r4, #12]
 8056e98:	bf18      	it	ne
 8056e9a:	81a3      	strhne	r3, [r4, #12]
 8056e9c:	bd10      	pop	{r4, pc}

08056e9e <__sclose>:
 8056e9e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8056ea2:	f000 be21 	b.w	8057ae8 <_close_r>

08056ea6 <__ssprint_r>:
 8056ea6:	6893      	ldr	r3, [r2, #8]
 8056ea8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056eac:	4680      	mov	r8, r0
 8056eae:	460c      	mov	r4, r1
 8056eb0:	4617      	mov	r7, r2
 8056eb2:	2b00      	cmp	r3, #0
 8056eb4:	d061      	beq.n	8056f7a <__ssprint_r+0xd4>
 8056eb6:	2300      	movs	r3, #0
 8056eb8:	f8d2 a000 	ldr.w	sl, [r2]
 8056ebc:	9301      	str	r3, [sp, #4]
 8056ebe:	469b      	mov	fp, r3
 8056ec0:	f1bb 0f00 	cmp.w	fp, #0
 8056ec4:	d02b      	beq.n	8056f1e <__ssprint_r+0x78>
 8056ec6:	68a6      	ldr	r6, [r4, #8]
 8056ec8:	45b3      	cmp	fp, r6
 8056eca:	d342      	bcc.n	8056f52 <__ssprint_r+0xac>
 8056ecc:	89a2      	ldrh	r2, [r4, #12]
 8056ece:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8056ed2:	d03e      	beq.n	8056f52 <__ssprint_r+0xac>
 8056ed4:	6825      	ldr	r5, [r4, #0]
 8056ed6:	6921      	ldr	r1, [r4, #16]
 8056ed8:	eba5 0901 	sub.w	r9, r5, r1
 8056edc:	6965      	ldr	r5, [r4, #20]
 8056ede:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8056ee2:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8056ee6:	f109 0001 	add.w	r0, r9, #1
 8056eea:	106d      	asrs	r5, r5, #1
 8056eec:	4458      	add	r0, fp
 8056eee:	4285      	cmp	r5, r0
 8056ef0:	bf38      	it	cc
 8056ef2:	4605      	movcc	r5, r0
 8056ef4:	0553      	lsls	r3, r2, #21
 8056ef6:	d545      	bpl.n	8056f84 <__ssprint_r+0xde>
 8056ef8:	4629      	mov	r1, r5
 8056efa:	4640      	mov	r0, r8
 8056efc:	f7f9 ff04 	bl	8050d08 <_malloc_r>
 8056f00:	4606      	mov	r6, r0
 8056f02:	b9a0      	cbnz	r0, 8056f2e <__ssprint_r+0x88>
 8056f04:	230c      	movs	r3, #12
 8056f06:	f8c8 3000 	str.w	r3, [r8]
 8056f0a:	89a3      	ldrh	r3, [r4, #12]
 8056f0c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8056f10:	81a3      	strh	r3, [r4, #12]
 8056f12:	2300      	movs	r3, #0
 8056f14:	e9c7 3301 	strd	r3, r3, [r7, #4]
 8056f18:	f04f 30ff 	mov.w	r0, #4294967295
 8056f1c:	e02f      	b.n	8056f7e <__ssprint_r+0xd8>
 8056f1e:	f8da 3000 	ldr.w	r3, [sl]
 8056f22:	f8da b004 	ldr.w	fp, [sl, #4]
 8056f26:	9301      	str	r3, [sp, #4]
 8056f28:	f10a 0a08 	add.w	sl, sl, #8
 8056f2c:	e7c8      	b.n	8056ec0 <__ssprint_r+0x1a>
 8056f2e:	464a      	mov	r2, r9
 8056f30:	6921      	ldr	r1, [r4, #16]
 8056f32:	f7fa f939 	bl	80511a8 <memcpy>
 8056f36:	89a2      	ldrh	r2, [r4, #12]
 8056f38:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8056f3c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8056f40:	81a2      	strh	r2, [r4, #12]
 8056f42:	6126      	str	r6, [r4, #16]
 8056f44:	6165      	str	r5, [r4, #20]
 8056f46:	444e      	add	r6, r9
 8056f48:	eba5 0509 	sub.w	r5, r5, r9
 8056f4c:	6026      	str	r6, [r4, #0]
 8056f4e:	60a5      	str	r5, [r4, #8]
 8056f50:	465e      	mov	r6, fp
 8056f52:	455e      	cmp	r6, fp
 8056f54:	bf28      	it	cs
 8056f56:	465e      	movcs	r6, fp
 8056f58:	4632      	mov	r2, r6
 8056f5a:	9901      	ldr	r1, [sp, #4]
 8056f5c:	6820      	ldr	r0, [r4, #0]
 8056f5e:	f001 f827 	bl	8057fb0 <memmove>
 8056f62:	68a2      	ldr	r2, [r4, #8]
 8056f64:	1b92      	subs	r2, r2, r6
 8056f66:	60a2      	str	r2, [r4, #8]
 8056f68:	6822      	ldr	r2, [r4, #0]
 8056f6a:	4432      	add	r2, r6
 8056f6c:	6022      	str	r2, [r4, #0]
 8056f6e:	68ba      	ldr	r2, [r7, #8]
 8056f70:	eba2 030b 	sub.w	r3, r2, fp
 8056f74:	60bb      	str	r3, [r7, #8]
 8056f76:	2b00      	cmp	r3, #0
 8056f78:	d1d1      	bne.n	8056f1e <__ssprint_r+0x78>
 8056f7a:	2000      	movs	r0, #0
 8056f7c:	6078      	str	r0, [r7, #4]
 8056f7e:	b003      	add	sp, #12
 8056f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8056f84:	462a      	mov	r2, r5
 8056f86:	4640      	mov	r0, r8
 8056f88:	f001 f83e 	bl	8058008 <_realloc_r>
 8056f8c:	4606      	mov	r6, r0
 8056f8e:	2800      	cmp	r0, #0
 8056f90:	d1d7      	bne.n	8056f42 <__ssprint_r+0x9c>
 8056f92:	6921      	ldr	r1, [r4, #16]
 8056f94:	4640      	mov	r0, r8
 8056f96:	f7fe fdbb 	bl	8055b10 <_free_r>
 8056f9a:	e7b3      	b.n	8056f04 <__ssprint_r+0x5e>

08056f9c <__sprint_r>:
 8056f9c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8056fa0:	6893      	ldr	r3, [r2, #8]
 8056fa2:	4680      	mov	r8, r0
 8056fa4:	460f      	mov	r7, r1
 8056fa6:	4614      	mov	r4, r2
 8056fa8:	b91b      	cbnz	r3, 8056fb2 <__sprint_r+0x16>
 8056faa:	6053      	str	r3, [r2, #4]
 8056fac:	4618      	mov	r0, r3
 8056fae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8056fb2:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8056fb4:	049d      	lsls	r5, r3, #18
 8056fb6:	d520      	bpl.n	8056ffa <__sprint_r+0x5e>
 8056fb8:	6815      	ldr	r5, [r2, #0]
 8056fba:	3508      	adds	r5, #8
 8056fbc:	e955 b602 	ldrd	fp, r6, [r5, #-8]
 8056fc0:	f04f 0900 	mov.w	r9, #0
 8056fc4:	ea4f 0a96 	mov.w	sl, r6, lsr #2
 8056fc8:	45ca      	cmp	sl, r9
 8056fca:	dc0b      	bgt.n	8056fe4 <__sprint_r+0x48>
 8056fcc:	68a3      	ldr	r3, [r4, #8]
 8056fce:	f026 0003 	bic.w	r0, r6, #3
 8056fd2:	1a18      	subs	r0, r3, r0
 8056fd4:	60a0      	str	r0, [r4, #8]
 8056fd6:	3508      	adds	r5, #8
 8056fd8:	2800      	cmp	r0, #0
 8056fda:	d1ef      	bne.n	8056fbc <__sprint_r+0x20>
 8056fdc:	2300      	movs	r3, #0
 8056fde:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8056fe2:	e7e4      	b.n	8056fae <__sprint_r+0x12>
 8056fe4:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
 8056fe8:	463a      	mov	r2, r7
 8056fea:	4640      	mov	r0, r8
 8056fec:	f000 fe37 	bl	8057c5e <_fputwc_r>
 8056ff0:	1c43      	adds	r3, r0, #1
 8056ff2:	d0f3      	beq.n	8056fdc <__sprint_r+0x40>
 8056ff4:	f109 0901 	add.w	r9, r9, #1
 8056ff8:	e7e6      	b.n	8056fc8 <__sprint_r+0x2c>
 8056ffa:	f000 fe6d 	bl	8057cd8 <__sfvwrite_r>
 8056ffe:	e7ed      	b.n	8056fdc <__sprint_r+0x40>

08057000 <_vfiprintf_r>:
 8057000:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057004:	ed2d 8b02 	vpush	{d8}
 8057008:	b0b9      	sub	sp, #228	; 0xe4
 805700a:	460f      	mov	r7, r1
 805700c:	9201      	str	r2, [sp, #4]
 805700e:	461d      	mov	r5, r3
 8057010:	461c      	mov	r4, r3
 8057012:	4681      	mov	r9, r0
 8057014:	b118      	cbz	r0, 805701e <_vfiprintf_r+0x1e>
 8057016:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8057018:	b90b      	cbnz	r3, 805701e <_vfiprintf_r+0x1e>
 805701a:	f7fe fce9 	bl	80559f0 <__sinit>
 805701e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8057020:	07d8      	lsls	r0, r3, #31
 8057022:	d405      	bmi.n	8057030 <_vfiprintf_r+0x30>
 8057024:	89bb      	ldrh	r3, [r7, #12]
 8057026:	0599      	lsls	r1, r3, #22
 8057028:	d402      	bmi.n	8057030 <_vfiprintf_r+0x30>
 805702a:	6db8      	ldr	r0, [r7, #88]	; 0x58
 805702c:	f7ff f9ca 	bl	80563c4 <__retarget_lock_acquire_recursive>
 8057030:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8057034:	049a      	lsls	r2, r3, #18
 8057036:	d406      	bmi.n	8057046 <_vfiprintf_r+0x46>
 8057038:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 805703c:	81bb      	strh	r3, [r7, #12]
 805703e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8057040:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8057044:	667b      	str	r3, [r7, #100]	; 0x64
 8057046:	89bb      	ldrh	r3, [r7, #12]
 8057048:	071e      	lsls	r6, r3, #28
 805704a:	d501      	bpl.n	8057050 <_vfiprintf_r+0x50>
 805704c:	693b      	ldr	r3, [r7, #16]
 805704e:	b9bb      	cbnz	r3, 8057080 <_vfiprintf_r+0x80>
 8057050:	4639      	mov	r1, r7
 8057052:	4648      	mov	r0, r9
 8057054:	f7fd fd02 	bl	8054a5c <__swsetup_r>
 8057058:	b190      	cbz	r0, 8057080 <_vfiprintf_r+0x80>
 805705a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 805705c:	07d8      	lsls	r0, r3, #31
 805705e:	d508      	bpl.n	8057072 <_vfiprintf_r+0x72>
 8057060:	f04f 33ff 	mov.w	r3, #4294967295
 8057064:	9302      	str	r3, [sp, #8]
 8057066:	9802      	ldr	r0, [sp, #8]
 8057068:	b039      	add	sp, #228	; 0xe4
 805706a:	ecbd 8b02 	vpop	{d8}
 805706e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8057072:	89bb      	ldrh	r3, [r7, #12]
 8057074:	0599      	lsls	r1, r3, #22
 8057076:	d4f3      	bmi.n	8057060 <_vfiprintf_r+0x60>
 8057078:	6db8      	ldr	r0, [r7, #88]	; 0x58
 805707a:	f7ff f9a4 	bl	80563c6 <__retarget_lock_release_recursive>
 805707e:	e7ef      	b.n	8057060 <_vfiprintf_r+0x60>
 8057080:	89bb      	ldrh	r3, [r7, #12]
 8057082:	f003 021a 	and.w	r2, r3, #26
 8057086:	2a0a      	cmp	r2, #10
 8057088:	d113      	bne.n	80570b2 <_vfiprintf_r+0xb2>
 805708a:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 805708e:	2a00      	cmp	r2, #0
 8057090:	db0f      	blt.n	80570b2 <_vfiprintf_r+0xb2>
 8057092:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8057094:	07d2      	lsls	r2, r2, #31
 8057096:	d404      	bmi.n	80570a2 <_vfiprintf_r+0xa2>
 8057098:	059e      	lsls	r6, r3, #22
 805709a:	d402      	bmi.n	80570a2 <_vfiprintf_r+0xa2>
 805709c:	6db8      	ldr	r0, [r7, #88]	; 0x58
 805709e:	f7ff f992 	bl	80563c6 <__retarget_lock_release_recursive>
 80570a2:	9a01      	ldr	r2, [sp, #4]
 80570a4:	462b      	mov	r3, r5
 80570a6:	4639      	mov	r1, r7
 80570a8:	4648      	mov	r0, r9
 80570aa:	f000 fc31 	bl	8057910 <__sbprintf>
 80570ae:	9002      	str	r0, [sp, #8]
 80570b0:	e7d9      	b.n	8057066 <_vfiprintf_r+0x66>
 80570b2:	2300      	movs	r3, #0
 80570b4:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 80570b8:	e9cd 3305 	strd	r3, r3, [sp, #20]
 80570bc:	ae0f      	add	r6, sp, #60	; 0x3c
 80570be:	ee08 3a10 	vmov	s16, r3
 80570c2:	960c      	str	r6, [sp, #48]	; 0x30
 80570c4:	9307      	str	r3, [sp, #28]
 80570c6:	9302      	str	r3, [sp, #8]
 80570c8:	9b01      	ldr	r3, [sp, #4]
 80570ca:	461d      	mov	r5, r3
 80570cc:	f813 2b01 	ldrb.w	r2, [r3], #1
 80570d0:	b10a      	cbz	r2, 80570d6 <_vfiprintf_r+0xd6>
 80570d2:	2a25      	cmp	r2, #37	; 0x25
 80570d4:	d1f9      	bne.n	80570ca <_vfiprintf_r+0xca>
 80570d6:	9b01      	ldr	r3, [sp, #4]
 80570d8:	ebb5 0803 	subs.w	r8, r5, r3
 80570dc:	d00d      	beq.n	80570fa <_vfiprintf_r+0xfa>
 80570de:	e9c6 3800 	strd	r3, r8, [r6]
 80570e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80570e4:	4443      	add	r3, r8
 80570e6:	930e      	str	r3, [sp, #56]	; 0x38
 80570e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80570ea:	3301      	adds	r3, #1
 80570ec:	2b07      	cmp	r3, #7
 80570ee:	930d      	str	r3, [sp, #52]	; 0x34
 80570f0:	dc75      	bgt.n	80571de <_vfiprintf_r+0x1de>
 80570f2:	3608      	adds	r6, #8
 80570f4:	9b02      	ldr	r3, [sp, #8]
 80570f6:	4443      	add	r3, r8
 80570f8:	9302      	str	r3, [sp, #8]
 80570fa:	782b      	ldrb	r3, [r5, #0]
 80570fc:	2b00      	cmp	r3, #0
 80570fe:	f000 83c8 	beq.w	8057892 <_vfiprintf_r+0x892>
 8057102:	2300      	movs	r3, #0
 8057104:	f04f 31ff 	mov.w	r1, #4294967295
 8057108:	1c6a      	adds	r2, r5, #1
 805710a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 805710e:	9100      	str	r1, [sp, #0]
 8057110:	9303      	str	r3, [sp, #12]
 8057112:	469a      	mov	sl, r3
 8057114:	f812 3b01 	ldrb.w	r3, [r2], #1
 8057118:	9201      	str	r2, [sp, #4]
 805711a:	f1a3 0220 	sub.w	r2, r3, #32
 805711e:	2a5a      	cmp	r2, #90	; 0x5a
 8057120:	f200 8310 	bhi.w	8057744 <_vfiprintf_r+0x744>
 8057124:	e8df f012 	tbh	[pc, r2, lsl #1]
 8057128:	030e0099 	.word	0x030e0099
 805712c:	00a1030e 	.word	0x00a1030e
 8057130:	030e030e 	.word	0x030e030e
 8057134:	0080030e 	.word	0x0080030e
 8057138:	030e030e 	.word	0x030e030e
 805713c:	00ae00a4 	.word	0x00ae00a4
 8057140:	00ab030e 	.word	0x00ab030e
 8057144:	030e00b0 	.word	0x030e00b0
 8057148:	00ce00cb 	.word	0x00ce00cb
 805714c:	00ce00ce 	.word	0x00ce00ce
 8057150:	00ce00ce 	.word	0x00ce00ce
 8057154:	00ce00ce 	.word	0x00ce00ce
 8057158:	00ce00ce 	.word	0x00ce00ce
 805715c:	030e030e 	.word	0x030e030e
 8057160:	030e030e 	.word	0x030e030e
 8057164:	030e030e 	.word	0x030e030e
 8057168:	030e030e 	.word	0x030e030e
 805716c:	00f8030e 	.word	0x00f8030e
 8057170:	030e0106 	.word	0x030e0106
 8057174:	030e030e 	.word	0x030e030e
 8057178:	030e030e 	.word	0x030e030e
 805717c:	030e030e 	.word	0x030e030e
 8057180:	030e030e 	.word	0x030e030e
 8057184:	014d030e 	.word	0x014d030e
 8057188:	030e030e 	.word	0x030e030e
 805718c:	0192030e 	.word	0x0192030e
 8057190:	0270030e 	.word	0x0270030e
 8057194:	030e030e 	.word	0x030e030e
 8057198:	030e028e 	.word	0x030e028e
 805719c:	030e030e 	.word	0x030e030e
 80571a0:	030e030e 	.word	0x030e030e
 80571a4:	030e030e 	.word	0x030e030e
 80571a8:	030e030e 	.word	0x030e030e
 80571ac:	00f8030e 	.word	0x00f8030e
 80571b0:	030e0108 	.word	0x030e0108
 80571b4:	030e030e 	.word	0x030e030e
 80571b8:	010800de 	.word	0x010800de
 80571bc:	030e00f2 	.word	0x030e00f2
 80571c0:	030e00eb 	.word	0x030e00eb
 80571c4:	014f0130 	.word	0x014f0130
 80571c8:	00f20182 	.word	0x00f20182
 80571cc:	0192030e 	.word	0x0192030e
 80571d0:	02720097 	.word	0x02720097
 80571d4:	030e030e 	.word	0x030e030e
 80571d8:	030e0065 	.word	0x030e0065
 80571dc:	0097      	.short	0x0097
 80571de:	aa0c      	add	r2, sp, #48	; 0x30
 80571e0:	4639      	mov	r1, r7
 80571e2:	4648      	mov	r0, r9
 80571e4:	f7ff feda 	bl	8056f9c <__sprint_r>
 80571e8:	2800      	cmp	r0, #0
 80571ea:	f040 8331 	bne.w	8057850 <_vfiprintf_r+0x850>
 80571ee:	ae0f      	add	r6, sp, #60	; 0x3c
 80571f0:	e780      	b.n	80570f4 <_vfiprintf_r+0xf4>
 80571f2:	4a95      	ldr	r2, [pc, #596]	; (8057448 <_vfiprintf_r+0x448>)
 80571f4:	9205      	str	r2, [sp, #20]
 80571f6:	f01a 0f20 	tst.w	sl, #32
 80571fa:	f000 8225 	beq.w	8057648 <_vfiprintf_r+0x648>
 80571fe:	3407      	adds	r4, #7
 8057200:	f024 0b07 	bic.w	fp, r4, #7
 8057204:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057208:	f01a 0f01 	tst.w	sl, #1
 805720c:	d009      	beq.n	8057222 <_vfiprintf_r+0x222>
 805720e:	ea54 0205 	orrs.w	r2, r4, r5
 8057212:	bf1f      	itttt	ne
 8057214:	2230      	movne	r2, #48	; 0x30
 8057216:	f88d 202c 	strbne.w	r2, [sp, #44]	; 0x2c
 805721a:	f88d 302d 	strbne.w	r3, [sp, #45]	; 0x2d
 805721e:	f04a 0a02 	orrne.w	sl, sl, #2
 8057222:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 8057226:	e10d      	b.n	8057444 <_vfiprintf_r+0x444>
 8057228:	4648      	mov	r0, r9
 805722a:	f7ff f8c5 	bl	80563b8 <_localeconv_r>
 805722e:	6843      	ldr	r3, [r0, #4]
 8057230:	4618      	mov	r0, r3
 8057232:	ee08 3a10 	vmov	s16, r3
 8057236:	f7e8 ffdb 	bl	80401f0 <strlen>
 805723a:	9007      	str	r0, [sp, #28]
 805723c:	4648      	mov	r0, r9
 805723e:	f7ff f8bb 	bl	80563b8 <_localeconv_r>
 8057242:	6883      	ldr	r3, [r0, #8]
 8057244:	9306      	str	r3, [sp, #24]
 8057246:	9b07      	ldr	r3, [sp, #28]
 8057248:	b12b      	cbz	r3, 8057256 <_vfiprintf_r+0x256>
 805724a:	9b06      	ldr	r3, [sp, #24]
 805724c:	b11b      	cbz	r3, 8057256 <_vfiprintf_r+0x256>
 805724e:	781b      	ldrb	r3, [r3, #0]
 8057250:	b10b      	cbz	r3, 8057256 <_vfiprintf_r+0x256>
 8057252:	f44a 6a80 	orr.w	sl, sl, #1024	; 0x400
 8057256:	9a01      	ldr	r2, [sp, #4]
 8057258:	e75c      	b.n	8057114 <_vfiprintf_r+0x114>
 805725a:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 805725e:	2b00      	cmp	r3, #0
 8057260:	d1f9      	bne.n	8057256 <_vfiprintf_r+0x256>
 8057262:	2320      	movs	r3, #32
 8057264:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 8057268:	e7f5      	b.n	8057256 <_vfiprintf_r+0x256>
 805726a:	f04a 0a01 	orr.w	sl, sl, #1
 805726e:	e7f2      	b.n	8057256 <_vfiprintf_r+0x256>
 8057270:	f854 3b04 	ldr.w	r3, [r4], #4
 8057274:	9303      	str	r3, [sp, #12]
 8057276:	2b00      	cmp	r3, #0
 8057278:	daed      	bge.n	8057256 <_vfiprintf_r+0x256>
 805727a:	425b      	negs	r3, r3
 805727c:	9303      	str	r3, [sp, #12]
 805727e:	f04a 0a04 	orr.w	sl, sl, #4
 8057282:	e7e8      	b.n	8057256 <_vfiprintf_r+0x256>
 8057284:	232b      	movs	r3, #43	; 0x2b
 8057286:	e7ed      	b.n	8057264 <_vfiprintf_r+0x264>
 8057288:	9a01      	ldr	r2, [sp, #4]
 805728a:	f812 3b01 	ldrb.w	r3, [r2], #1
 805728e:	2b2a      	cmp	r3, #42	; 0x2a
 8057290:	d112      	bne.n	80572b8 <_vfiprintf_r+0x2b8>
 8057292:	f854 0b04 	ldr.w	r0, [r4], #4
 8057296:	ea40 73e0 	orr.w	r3, r0, r0, asr #31
 805729a:	e9cd 3200 	strd	r3, r2, [sp]
 805729e:	e7da      	b.n	8057256 <_vfiprintf_r+0x256>
 80572a0:	9b00      	ldr	r3, [sp, #0]
 80572a2:	200a      	movs	r0, #10
 80572a4:	fb00 1303 	mla	r3, r0, r3, r1
 80572a8:	9300      	str	r3, [sp, #0]
 80572aa:	f812 3b01 	ldrb.w	r3, [r2], #1
 80572ae:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 80572b2:	2909      	cmp	r1, #9
 80572b4:	d9f4      	bls.n	80572a0 <_vfiprintf_r+0x2a0>
 80572b6:	e72f      	b.n	8057118 <_vfiprintf_r+0x118>
 80572b8:	2100      	movs	r1, #0
 80572ba:	9100      	str	r1, [sp, #0]
 80572bc:	e7f7      	b.n	80572ae <_vfiprintf_r+0x2ae>
 80572be:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 80572c2:	e7c8      	b.n	8057256 <_vfiprintf_r+0x256>
 80572c4:	2100      	movs	r1, #0
 80572c6:	9a01      	ldr	r2, [sp, #4]
 80572c8:	9103      	str	r1, [sp, #12]
 80572ca:	9903      	ldr	r1, [sp, #12]
 80572cc:	3b30      	subs	r3, #48	; 0x30
 80572ce:	200a      	movs	r0, #10
 80572d0:	fb00 3301 	mla	r3, r0, r1, r3
 80572d4:	9303      	str	r3, [sp, #12]
 80572d6:	f812 3b01 	ldrb.w	r3, [r2], #1
 80572da:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 80572de:	2909      	cmp	r1, #9
 80572e0:	d9f3      	bls.n	80572ca <_vfiprintf_r+0x2ca>
 80572e2:	e719      	b.n	8057118 <_vfiprintf_r+0x118>
 80572e4:	9b01      	ldr	r3, [sp, #4]
 80572e6:	781b      	ldrb	r3, [r3, #0]
 80572e8:	2b68      	cmp	r3, #104	; 0x68
 80572ea:	bf01      	itttt	eq
 80572ec:	9b01      	ldreq	r3, [sp, #4]
 80572ee:	3301      	addeq	r3, #1
 80572f0:	9301      	streq	r3, [sp, #4]
 80572f2:	f44a 7a00 	orreq.w	sl, sl, #512	; 0x200
 80572f6:	bf18      	it	ne
 80572f8:	f04a 0a40 	orrne.w	sl, sl, #64	; 0x40
 80572fc:	e7ab      	b.n	8057256 <_vfiprintf_r+0x256>
 80572fe:	9b01      	ldr	r3, [sp, #4]
 8057300:	781b      	ldrb	r3, [r3, #0]
 8057302:	2b6c      	cmp	r3, #108	; 0x6c
 8057304:	d105      	bne.n	8057312 <_vfiprintf_r+0x312>
 8057306:	9b01      	ldr	r3, [sp, #4]
 8057308:	3301      	adds	r3, #1
 805730a:	9301      	str	r3, [sp, #4]
 805730c:	f04a 0a20 	orr.w	sl, sl, #32
 8057310:	e7a1      	b.n	8057256 <_vfiprintf_r+0x256>
 8057312:	f04a 0a10 	orr.w	sl, sl, #16
 8057316:	e79e      	b.n	8057256 <_vfiprintf_r+0x256>
 8057318:	46a3      	mov	fp, r4
 805731a:	2100      	movs	r1, #0
 805731c:	f85b 3b04 	ldr.w	r3, [fp], #4
 8057320:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
 8057324:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
 8057328:	2301      	movs	r3, #1
 805732a:	9300      	str	r3, [sp, #0]
 805732c:	460d      	mov	r5, r1
 805732e:	f10d 087c 	add.w	r8, sp, #124	; 0x7c
 8057332:	e0a0      	b.n	8057476 <_vfiprintf_r+0x476>
 8057334:	f04a 0a10 	orr.w	sl, sl, #16
 8057338:	f01a 0f20 	tst.w	sl, #32
 805733c:	d011      	beq.n	8057362 <_vfiprintf_r+0x362>
 805733e:	3407      	adds	r4, #7
 8057340:	f024 0b07 	bic.w	fp, r4, #7
 8057344:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 8057348:	2c00      	cmp	r4, #0
 805734a:	f175 0300 	sbcs.w	r3, r5, #0
 805734e:	da06      	bge.n	805735e <_vfiprintf_r+0x35e>
 8057350:	4264      	negs	r4, r4
 8057352:	f04f 032d 	mov.w	r3, #45	; 0x2d
 8057356:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 805735a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
 805735e:	2301      	movs	r3, #1
 8057360:	e03f      	b.n	80573e2 <_vfiprintf_r+0x3e2>
 8057362:	f01a 0f10 	tst.w	sl, #16
 8057366:	f104 0b04 	add.w	fp, r4, #4
 805736a:	d002      	beq.n	8057372 <_vfiprintf_r+0x372>
 805736c:	6824      	ldr	r4, [r4, #0]
 805736e:	17e5      	asrs	r5, r4, #31
 8057370:	e7ea      	b.n	8057348 <_vfiprintf_r+0x348>
 8057372:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057376:	6824      	ldr	r4, [r4, #0]
 8057378:	d001      	beq.n	805737e <_vfiprintf_r+0x37e>
 805737a:	b224      	sxth	r4, r4
 805737c:	e7f7      	b.n	805736e <_vfiprintf_r+0x36e>
 805737e:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057382:	bf18      	it	ne
 8057384:	b264      	sxtbne	r4, r4
 8057386:	e7f2      	b.n	805736e <_vfiprintf_r+0x36e>
 8057388:	f01a 0f20 	tst.w	sl, #32
 805738c:	f854 3b04 	ldr.w	r3, [r4], #4
 8057390:	d005      	beq.n	805739e <_vfiprintf_r+0x39e>
 8057392:	9a02      	ldr	r2, [sp, #8]
 8057394:	4610      	mov	r0, r2
 8057396:	17d1      	asrs	r1, r2, #31
 8057398:	e9c3 0100 	strd	r0, r1, [r3]
 805739c:	e694      	b.n	80570c8 <_vfiprintf_r+0xc8>
 805739e:	f01a 0f10 	tst.w	sl, #16
 80573a2:	d002      	beq.n	80573aa <_vfiprintf_r+0x3aa>
 80573a4:	9a02      	ldr	r2, [sp, #8]
 80573a6:	601a      	str	r2, [r3, #0]
 80573a8:	e68e      	b.n	80570c8 <_vfiprintf_r+0xc8>
 80573aa:	f01a 0f40 	tst.w	sl, #64	; 0x40
 80573ae:	d002      	beq.n	80573b6 <_vfiprintf_r+0x3b6>
 80573b0:	9a02      	ldr	r2, [sp, #8]
 80573b2:	801a      	strh	r2, [r3, #0]
 80573b4:	e688      	b.n	80570c8 <_vfiprintf_r+0xc8>
 80573b6:	f41a 7f00 	tst.w	sl, #512	; 0x200
 80573ba:	d0f3      	beq.n	80573a4 <_vfiprintf_r+0x3a4>
 80573bc:	9a02      	ldr	r2, [sp, #8]
 80573be:	701a      	strb	r2, [r3, #0]
 80573c0:	e682      	b.n	80570c8 <_vfiprintf_r+0xc8>
 80573c2:	f04a 0a10 	orr.w	sl, sl, #16
 80573c6:	f01a 0f20 	tst.w	sl, #32
 80573ca:	d01d      	beq.n	8057408 <_vfiprintf_r+0x408>
 80573cc:	3407      	adds	r4, #7
 80573ce:	f024 0b07 	bic.w	fp, r4, #7
 80573d2:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 80573d6:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 80573da:	2300      	movs	r3, #0
 80573dc:	2200      	movs	r2, #0
 80573de:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
 80573e2:	9a00      	ldr	r2, [sp, #0]
 80573e4:	3201      	adds	r2, #1
 80573e6:	f000 8261 	beq.w	80578ac <_vfiprintf_r+0x8ac>
 80573ea:	f02a 0280 	bic.w	r2, sl, #128	; 0x80
 80573ee:	9204      	str	r2, [sp, #16]
 80573f0:	ea54 0205 	orrs.w	r2, r4, r5
 80573f4:	f040 8260 	bne.w	80578b8 <_vfiprintf_r+0x8b8>
 80573f8:	9a00      	ldr	r2, [sp, #0]
 80573fa:	2a00      	cmp	r2, #0
 80573fc:	f000 8197 	beq.w	805772e <_vfiprintf_r+0x72e>
 8057400:	2b01      	cmp	r3, #1
 8057402:	f040 825c 	bne.w	80578be <_vfiprintf_r+0x8be>
 8057406:	e135      	b.n	8057674 <_vfiprintf_r+0x674>
 8057408:	f01a 0f10 	tst.w	sl, #16
 805740c:	f104 0b04 	add.w	fp, r4, #4
 8057410:	d001      	beq.n	8057416 <_vfiprintf_r+0x416>
 8057412:	6824      	ldr	r4, [r4, #0]
 8057414:	e003      	b.n	805741e <_vfiprintf_r+0x41e>
 8057416:	f01a 0f40 	tst.w	sl, #64	; 0x40
 805741a:	d002      	beq.n	8057422 <_vfiprintf_r+0x422>
 805741c:	8824      	ldrh	r4, [r4, #0]
 805741e:	2500      	movs	r5, #0
 8057420:	e7d9      	b.n	80573d6 <_vfiprintf_r+0x3d6>
 8057422:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057426:	d0f4      	beq.n	8057412 <_vfiprintf_r+0x412>
 8057428:	7824      	ldrb	r4, [r4, #0]
 805742a:	e7f8      	b.n	805741e <_vfiprintf_r+0x41e>
 805742c:	46a3      	mov	fp, r4
 805742e:	f647 0330 	movw	r3, #30768	; 0x7830
 8057432:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
 8057436:	f85b 4b04 	ldr.w	r4, [fp], #4
 805743a:	4b03      	ldr	r3, [pc, #12]	; (8057448 <_vfiprintf_r+0x448>)
 805743c:	9305      	str	r3, [sp, #20]
 805743e:	2500      	movs	r5, #0
 8057440:	f04a 0a02 	orr.w	sl, sl, #2
 8057444:	2302      	movs	r3, #2
 8057446:	e7c9      	b.n	80573dc <_vfiprintf_r+0x3dc>
 8057448:	0805a360 	.word	0x0805a360
 805744c:	9b00      	ldr	r3, [sp, #0]
 805744e:	46a3      	mov	fp, r4
 8057450:	2500      	movs	r5, #0
 8057452:	1c5c      	adds	r4, r3, #1
 8057454:	f85b 8b04 	ldr.w	r8, [fp], #4
 8057458:	f88d 502b 	strb.w	r5, [sp, #43]	; 0x2b
 805745c:	f000 80cf 	beq.w	80575fe <_vfiprintf_r+0x5fe>
 8057460:	461a      	mov	r2, r3
 8057462:	4629      	mov	r1, r5
 8057464:	4640      	mov	r0, r8
 8057466:	f7e8 fecb 	bl	8040200 <memchr>
 805746a:	2800      	cmp	r0, #0
 805746c:	f000 8174 	beq.w	8057758 <_vfiprintf_r+0x758>
 8057470:	eba0 0308 	sub.w	r3, r0, r8
 8057474:	9300      	str	r3, [sp, #0]
 8057476:	9b00      	ldr	r3, [sp, #0]
 8057478:	42ab      	cmp	r3, r5
 805747a:	bfb8      	it	lt
 805747c:	462b      	movlt	r3, r5
 805747e:	9304      	str	r3, [sp, #16]
 8057480:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 8057484:	b113      	cbz	r3, 805748c <_vfiprintf_r+0x48c>
 8057486:	9b04      	ldr	r3, [sp, #16]
 8057488:	3301      	adds	r3, #1
 805748a:	9304      	str	r3, [sp, #16]
 805748c:	f01a 0302 	ands.w	r3, sl, #2
 8057490:	9308      	str	r3, [sp, #32]
 8057492:	bf1e      	ittt	ne
 8057494:	9b04      	ldrne	r3, [sp, #16]
 8057496:	3302      	addne	r3, #2
 8057498:	9304      	strne	r3, [sp, #16]
 805749a:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
 805749e:	9309      	str	r3, [sp, #36]	; 0x24
 80574a0:	d11f      	bne.n	80574e2 <_vfiprintf_r+0x4e2>
 80574a2:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 80574a6:	1a9c      	subs	r4, r3, r2
 80574a8:	2c00      	cmp	r4, #0
 80574aa:	dd1a      	ble.n	80574e2 <_vfiprintf_r+0x4e2>
 80574ac:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
 80574b0:	48b9      	ldr	r0, [pc, #740]	; (8057798 <_vfiprintf_r+0x798>)
 80574b2:	6030      	str	r0, [r6, #0]
 80574b4:	2c10      	cmp	r4, #16
 80574b6:	f103 0301 	add.w	r3, r3, #1
 80574ba:	f106 0108 	add.w	r1, r6, #8
 80574be:	f300 814d 	bgt.w	805775c <_vfiprintf_r+0x75c>
 80574c2:	6074      	str	r4, [r6, #4]
 80574c4:	2b07      	cmp	r3, #7
 80574c6:	4414      	add	r4, r2
 80574c8:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 80574cc:	f340 8158 	ble.w	8057780 <_vfiprintf_r+0x780>
 80574d0:	aa0c      	add	r2, sp, #48	; 0x30
 80574d2:	4639      	mov	r1, r7
 80574d4:	4648      	mov	r0, r9
 80574d6:	f7ff fd61 	bl	8056f9c <__sprint_r>
 80574da:	2800      	cmp	r0, #0
 80574dc:	f040 81b8 	bne.w	8057850 <_vfiprintf_r+0x850>
 80574e0:	ae0f      	add	r6, sp, #60	; 0x3c
 80574e2:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
 80574e6:	b173      	cbz	r3, 8057506 <_vfiprintf_r+0x506>
 80574e8:	f10d 022b 	add.w	r2, sp, #43	; 0x2b
 80574ec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80574ee:	6032      	str	r2, [r6, #0]
 80574f0:	2201      	movs	r2, #1
 80574f2:	6072      	str	r2, [r6, #4]
 80574f4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80574f6:	3301      	adds	r3, #1
 80574f8:	3201      	adds	r2, #1
 80574fa:	2b07      	cmp	r3, #7
 80574fc:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057500:	f300 8140 	bgt.w	8057784 <_vfiprintf_r+0x784>
 8057504:	3608      	adds	r6, #8
 8057506:	9b08      	ldr	r3, [sp, #32]
 8057508:	b16b      	cbz	r3, 8057526 <_vfiprintf_r+0x526>
 805750a:	aa0b      	add	r2, sp, #44	; 0x2c
 805750c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 805750e:	6032      	str	r2, [r6, #0]
 8057510:	2202      	movs	r2, #2
 8057512:	6072      	str	r2, [r6, #4]
 8057514:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8057516:	3301      	adds	r3, #1
 8057518:	3202      	adds	r2, #2
 805751a:	2b07      	cmp	r3, #7
 805751c:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057520:	f300 8140 	bgt.w	80577a4 <_vfiprintf_r+0x7a4>
 8057524:	3608      	adds	r6, #8
 8057526:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8057528:	2b80      	cmp	r3, #128	; 0x80
 805752a:	d11f      	bne.n	805756c <_vfiprintf_r+0x56c>
 805752c:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8057530:	1a9c      	subs	r4, r3, r2
 8057532:	2c00      	cmp	r4, #0
 8057534:	dd1a      	ble.n	805756c <_vfiprintf_r+0x56c>
 8057536:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
 805753a:	4898      	ldr	r0, [pc, #608]	; (805779c <_vfiprintf_r+0x79c>)
 805753c:	6030      	str	r0, [r6, #0]
 805753e:	2c10      	cmp	r4, #16
 8057540:	f103 0301 	add.w	r3, r3, #1
 8057544:	f106 0108 	add.w	r1, r6, #8
 8057548:	f300 8135 	bgt.w	80577b6 <_vfiprintf_r+0x7b6>
 805754c:	6074      	str	r4, [r6, #4]
 805754e:	2b07      	cmp	r3, #7
 8057550:	4414      	add	r4, r2
 8057552:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 8057556:	f340 8140 	ble.w	80577da <_vfiprintf_r+0x7da>
 805755a:	aa0c      	add	r2, sp, #48	; 0x30
 805755c:	4639      	mov	r1, r7
 805755e:	4648      	mov	r0, r9
 8057560:	f7ff fd1c 	bl	8056f9c <__sprint_r>
 8057564:	2800      	cmp	r0, #0
 8057566:	f040 8173 	bne.w	8057850 <_vfiprintf_r+0x850>
 805756a:	ae0f      	add	r6, sp, #60	; 0x3c
 805756c:	9b00      	ldr	r3, [sp, #0]
 805756e:	1aec      	subs	r4, r5, r3
 8057570:	2c00      	cmp	r4, #0
 8057572:	dd1a      	ble.n	80575aa <_vfiprintf_r+0x5aa>
 8057574:	4d89      	ldr	r5, [pc, #548]	; (805779c <_vfiprintf_r+0x79c>)
 8057576:	6035      	str	r5, [r6, #0]
 8057578:	e9dd 310d 	ldrd	r3, r1, [sp, #52]	; 0x34
 805757c:	2c10      	cmp	r4, #16
 805757e:	f103 0301 	add.w	r3, r3, #1
 8057582:	f106 0208 	add.w	r2, r6, #8
 8057586:	f300 812a 	bgt.w	80577de <_vfiprintf_r+0x7de>
 805758a:	6074      	str	r4, [r6, #4]
 805758c:	2b07      	cmp	r3, #7
 805758e:	440c      	add	r4, r1
 8057590:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
 8057594:	f340 8134 	ble.w	8057800 <_vfiprintf_r+0x800>
 8057598:	aa0c      	add	r2, sp, #48	; 0x30
 805759a:	4639      	mov	r1, r7
 805759c:	4648      	mov	r0, r9
 805759e:	f7ff fcfd 	bl	8056f9c <__sprint_r>
 80575a2:	2800      	cmp	r0, #0
 80575a4:	f040 8154 	bne.w	8057850 <_vfiprintf_r+0x850>
 80575a8:	ae0f      	add	r6, sp, #60	; 0x3c
 80575aa:	9b00      	ldr	r3, [sp, #0]
 80575ac:	980e      	ldr	r0, [sp, #56]	; 0x38
 80575ae:	6073      	str	r3, [r6, #4]
 80575b0:	4418      	add	r0, r3
 80575b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80575b4:	f8c6 8000 	str.w	r8, [r6]
 80575b8:	3301      	adds	r3, #1
 80575ba:	2b07      	cmp	r3, #7
 80575bc:	900e      	str	r0, [sp, #56]	; 0x38
 80575be:	930d      	str	r3, [sp, #52]	; 0x34
 80575c0:	f300 8120 	bgt.w	8057804 <_vfiprintf_r+0x804>
 80575c4:	f106 0308 	add.w	r3, r6, #8
 80575c8:	f01a 0f04 	tst.w	sl, #4
 80575cc:	f040 8122 	bne.w	8057814 <_vfiprintf_r+0x814>
 80575d0:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 80575d4:	9904      	ldr	r1, [sp, #16]
 80575d6:	428a      	cmp	r2, r1
 80575d8:	bfac      	ite	ge
 80575da:	189b      	addge	r3, r3, r2
 80575dc:	185b      	addlt	r3, r3, r1
 80575de:	9302      	str	r3, [sp, #8]
 80575e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80575e2:	b13b      	cbz	r3, 80575f4 <_vfiprintf_r+0x5f4>
 80575e4:	aa0c      	add	r2, sp, #48	; 0x30
 80575e6:	4639      	mov	r1, r7
 80575e8:	4648      	mov	r0, r9
 80575ea:	f7ff fcd7 	bl	8056f9c <__sprint_r>
 80575ee:	2800      	cmp	r0, #0
 80575f0:	f040 812e 	bne.w	8057850 <_vfiprintf_r+0x850>
 80575f4:	2300      	movs	r3, #0
 80575f6:	930d      	str	r3, [sp, #52]	; 0x34
 80575f8:	465c      	mov	r4, fp
 80575fa:	ae0f      	add	r6, sp, #60	; 0x3c
 80575fc:	e564      	b.n	80570c8 <_vfiprintf_r+0xc8>
 80575fe:	4640      	mov	r0, r8
 8057600:	f7e8 fdf6 	bl	80401f0 <strlen>
 8057604:	9000      	str	r0, [sp, #0]
 8057606:	e736      	b.n	8057476 <_vfiprintf_r+0x476>
 8057608:	f04a 0a10 	orr.w	sl, sl, #16
 805760c:	f01a 0f20 	tst.w	sl, #32
 8057610:	d006      	beq.n	8057620 <_vfiprintf_r+0x620>
 8057612:	3407      	adds	r4, #7
 8057614:	f024 0b07 	bic.w	fp, r4, #7
 8057618:	e8fb 4502 	ldrd	r4, r5, [fp], #8
 805761c:	2301      	movs	r3, #1
 805761e:	e6dd      	b.n	80573dc <_vfiprintf_r+0x3dc>
 8057620:	f01a 0f10 	tst.w	sl, #16
 8057624:	f104 0b04 	add.w	fp, r4, #4
 8057628:	d001      	beq.n	805762e <_vfiprintf_r+0x62e>
 805762a:	6824      	ldr	r4, [r4, #0]
 805762c:	e003      	b.n	8057636 <_vfiprintf_r+0x636>
 805762e:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8057632:	d002      	beq.n	805763a <_vfiprintf_r+0x63a>
 8057634:	8824      	ldrh	r4, [r4, #0]
 8057636:	2500      	movs	r5, #0
 8057638:	e7f0      	b.n	805761c <_vfiprintf_r+0x61c>
 805763a:	f41a 7f00 	tst.w	sl, #512	; 0x200
 805763e:	d0f4      	beq.n	805762a <_vfiprintf_r+0x62a>
 8057640:	7824      	ldrb	r4, [r4, #0]
 8057642:	e7f8      	b.n	8057636 <_vfiprintf_r+0x636>
 8057644:	4a56      	ldr	r2, [pc, #344]	; (80577a0 <_vfiprintf_r+0x7a0>)
 8057646:	e5d5      	b.n	80571f4 <_vfiprintf_r+0x1f4>
 8057648:	f01a 0f10 	tst.w	sl, #16
 805764c:	f104 0b04 	add.w	fp, r4, #4
 8057650:	d001      	beq.n	8057656 <_vfiprintf_r+0x656>
 8057652:	6824      	ldr	r4, [r4, #0]
 8057654:	e003      	b.n	805765e <_vfiprintf_r+0x65e>
 8057656:	f01a 0f40 	tst.w	sl, #64	; 0x40
 805765a:	d002      	beq.n	8057662 <_vfiprintf_r+0x662>
 805765c:	8824      	ldrh	r4, [r4, #0]
 805765e:	2500      	movs	r5, #0
 8057660:	e5d2      	b.n	8057208 <_vfiprintf_r+0x208>
 8057662:	f41a 7f00 	tst.w	sl, #512	; 0x200
 8057666:	d0f4      	beq.n	8057652 <_vfiprintf_r+0x652>
 8057668:	7824      	ldrb	r4, [r4, #0]
 805766a:	e7f8      	b.n	805765e <_vfiprintf_r+0x65e>
 805766c:	2d00      	cmp	r5, #0
 805766e:	bf08      	it	eq
 8057670:	2c0a      	cmpeq	r4, #10
 8057672:	d205      	bcs.n	8057680 <_vfiprintf_r+0x680>
 8057674:	3430      	adds	r4, #48	; 0x30
 8057676:	f88d 40df 	strb.w	r4, [sp, #223]	; 0xdf
 805767a:	f10d 08df 	add.w	r8, sp, #223	; 0xdf
 805767e:	e13c      	b.n	80578fa <_vfiprintf_r+0x8fa>
 8057680:	ab38      	add	r3, sp, #224	; 0xe0
 8057682:	9308      	str	r3, [sp, #32]
 8057684:	9b04      	ldr	r3, [sp, #16]
 8057686:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 805768a:	f04f 0a00 	mov.w	sl, #0
 805768e:	9309      	str	r3, [sp, #36]	; 0x24
 8057690:	9b08      	ldr	r3, [sp, #32]
 8057692:	220a      	movs	r2, #10
 8057694:	f103 38ff 	add.w	r8, r3, #4294967295
 8057698:	4620      	mov	r0, r4
 805769a:	2300      	movs	r3, #0
 805769c:	4629      	mov	r1, r5
 805769e:	f7e9 fb03 	bl	8040ca8 <__aeabi_uldivmod>
 80576a2:	9b08      	ldr	r3, [sp, #32]
 80576a4:	3230      	adds	r2, #48	; 0x30
 80576a6:	f803 2c01 	strb.w	r2, [r3, #-1]
 80576aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80576ac:	f10a 0a01 	add.w	sl, sl, #1
 80576b0:	b1db      	cbz	r3, 80576ea <_vfiprintf_r+0x6ea>
 80576b2:	9b06      	ldr	r3, [sp, #24]
 80576b4:	781b      	ldrb	r3, [r3, #0]
 80576b6:	4553      	cmp	r3, sl
 80576b8:	d117      	bne.n	80576ea <_vfiprintf_r+0x6ea>
 80576ba:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 80576be:	d014      	beq.n	80576ea <_vfiprintf_r+0x6ea>
 80576c0:	2d00      	cmp	r5, #0
 80576c2:	bf08      	it	eq
 80576c4:	2c0a      	cmpeq	r4, #10
 80576c6:	d310      	bcc.n	80576ea <_vfiprintf_r+0x6ea>
 80576c8:	9b07      	ldr	r3, [sp, #28]
 80576ca:	eba8 0803 	sub.w	r8, r8, r3
 80576ce:	461a      	mov	r2, r3
 80576d0:	ee18 1a10 	vmov	r1, s16
 80576d4:	4640      	mov	r0, r8
 80576d6:	f7f9 fe01 	bl	80512dc <strncpy>
 80576da:	9b06      	ldr	r3, [sp, #24]
 80576dc:	785b      	ldrb	r3, [r3, #1]
 80576de:	b1a3      	cbz	r3, 805770a <_vfiprintf_r+0x70a>
 80576e0:	9b06      	ldr	r3, [sp, #24]
 80576e2:	3301      	adds	r3, #1
 80576e4:	9306      	str	r3, [sp, #24]
 80576e6:	f04f 0a00 	mov.w	sl, #0
 80576ea:	220a      	movs	r2, #10
 80576ec:	2300      	movs	r3, #0
 80576ee:	4620      	mov	r0, r4
 80576f0:	4629      	mov	r1, r5
 80576f2:	f7e9 fad9 	bl	8040ca8 <__aeabi_uldivmod>
 80576f6:	2d00      	cmp	r5, #0
 80576f8:	bf08      	it	eq
 80576fa:	2c0a      	cmpeq	r4, #10
 80576fc:	f0c0 80fd 	bcc.w	80578fa <_vfiprintf_r+0x8fa>
 8057700:	4604      	mov	r4, r0
 8057702:	460d      	mov	r5, r1
 8057704:	f8cd 8020 	str.w	r8, [sp, #32]
 8057708:	e7c2      	b.n	8057690 <_vfiprintf_r+0x690>
 805770a:	469a      	mov	sl, r3
 805770c:	e7ed      	b.n	80576ea <_vfiprintf_r+0x6ea>
 805770e:	9a05      	ldr	r2, [sp, #20]
 8057710:	f004 030f 	and.w	r3, r4, #15
 8057714:	5cd3      	ldrb	r3, [r2, r3]
 8057716:	f808 3d01 	strb.w	r3, [r8, #-1]!
 805771a:	0923      	lsrs	r3, r4, #4
 805771c:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
 8057720:	092a      	lsrs	r2, r5, #4
 8057722:	461c      	mov	r4, r3
 8057724:	4615      	mov	r5, r2
 8057726:	ea54 0305 	orrs.w	r3, r4, r5
 805772a:	d1f0      	bne.n	805770e <_vfiprintf_r+0x70e>
 805772c:	e0e5      	b.n	80578fa <_vfiprintf_r+0x8fa>
 805772e:	b933      	cbnz	r3, 805773e <_vfiprintf_r+0x73e>
 8057730:	f01a 0f01 	tst.w	sl, #1
 8057734:	d003      	beq.n	805773e <_vfiprintf_r+0x73e>
 8057736:	2330      	movs	r3, #48	; 0x30
 8057738:	f88d 30df 	strb.w	r3, [sp, #223]	; 0xdf
 805773c:	e79d      	b.n	805767a <_vfiprintf_r+0x67a>
 805773e:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
 8057742:	e0da      	b.n	80578fa <_vfiprintf_r+0x8fa>
 8057744:	2b00      	cmp	r3, #0
 8057746:	f000 80a4 	beq.w	8057892 <_vfiprintf_r+0x892>
 805774a:	2100      	movs	r1, #0
 805774c:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
 8057750:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
 8057754:	46a3      	mov	fp, r4
 8057756:	e5e7      	b.n	8057328 <_vfiprintf_r+0x328>
 8057758:	4605      	mov	r5, r0
 805775a:	e68c      	b.n	8057476 <_vfiprintf_r+0x476>
 805775c:	2010      	movs	r0, #16
 805775e:	4402      	add	r2, r0
 8057760:	2b07      	cmp	r3, #7
 8057762:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 8057766:	6070      	str	r0, [r6, #4]
 8057768:	dd07      	ble.n	805777a <_vfiprintf_r+0x77a>
 805776a:	aa0c      	add	r2, sp, #48	; 0x30
 805776c:	4639      	mov	r1, r7
 805776e:	4648      	mov	r0, r9
 8057770:	f7ff fc14 	bl	8056f9c <__sprint_r>
 8057774:	2800      	cmp	r0, #0
 8057776:	d16b      	bne.n	8057850 <_vfiprintf_r+0x850>
 8057778:	a90f      	add	r1, sp, #60	; 0x3c
 805777a:	3c10      	subs	r4, #16
 805777c:	460e      	mov	r6, r1
 805777e:	e695      	b.n	80574ac <_vfiprintf_r+0x4ac>
 8057780:	460e      	mov	r6, r1
 8057782:	e6ae      	b.n	80574e2 <_vfiprintf_r+0x4e2>
 8057784:	aa0c      	add	r2, sp, #48	; 0x30
 8057786:	4639      	mov	r1, r7
 8057788:	4648      	mov	r0, r9
 805778a:	f7ff fc07 	bl	8056f9c <__sprint_r>
 805778e:	2800      	cmp	r0, #0
 8057790:	d15e      	bne.n	8057850 <_vfiprintf_r+0x850>
 8057792:	ae0f      	add	r6, sp, #60	; 0x3c
 8057794:	e6b7      	b.n	8057506 <_vfiprintf_r+0x506>
 8057796:	bf00      	nop
 8057798:	0805a744 	.word	0x0805a744
 805779c:	0805a754 	.word	0x0805a754
 80577a0:	0805a371 	.word	0x0805a371
 80577a4:	aa0c      	add	r2, sp, #48	; 0x30
 80577a6:	4639      	mov	r1, r7
 80577a8:	4648      	mov	r0, r9
 80577aa:	f7ff fbf7 	bl	8056f9c <__sprint_r>
 80577ae:	2800      	cmp	r0, #0
 80577b0:	d14e      	bne.n	8057850 <_vfiprintf_r+0x850>
 80577b2:	ae0f      	add	r6, sp, #60	; 0x3c
 80577b4:	e6b7      	b.n	8057526 <_vfiprintf_r+0x526>
 80577b6:	2010      	movs	r0, #16
 80577b8:	4402      	add	r2, r0
 80577ba:	2b07      	cmp	r3, #7
 80577bc:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
 80577c0:	6070      	str	r0, [r6, #4]
 80577c2:	dd07      	ble.n	80577d4 <_vfiprintf_r+0x7d4>
 80577c4:	aa0c      	add	r2, sp, #48	; 0x30
 80577c6:	4639      	mov	r1, r7
 80577c8:	4648      	mov	r0, r9
 80577ca:	f7ff fbe7 	bl	8056f9c <__sprint_r>
 80577ce:	2800      	cmp	r0, #0
 80577d0:	d13e      	bne.n	8057850 <_vfiprintf_r+0x850>
 80577d2:	a90f      	add	r1, sp, #60	; 0x3c
 80577d4:	3c10      	subs	r4, #16
 80577d6:	460e      	mov	r6, r1
 80577d8:	e6ad      	b.n	8057536 <_vfiprintf_r+0x536>
 80577da:	460e      	mov	r6, r1
 80577dc:	e6c6      	b.n	805756c <_vfiprintf_r+0x56c>
 80577de:	2010      	movs	r0, #16
 80577e0:	4401      	add	r1, r0
 80577e2:	2b07      	cmp	r3, #7
 80577e4:	e9cd 310d 	strd	r3, r1, [sp, #52]	; 0x34
 80577e8:	6070      	str	r0, [r6, #4]
 80577ea:	dd06      	ble.n	80577fa <_vfiprintf_r+0x7fa>
 80577ec:	aa0c      	add	r2, sp, #48	; 0x30
 80577ee:	4639      	mov	r1, r7
 80577f0:	4648      	mov	r0, r9
 80577f2:	f7ff fbd3 	bl	8056f9c <__sprint_r>
 80577f6:	bb58      	cbnz	r0, 8057850 <_vfiprintf_r+0x850>
 80577f8:	aa0f      	add	r2, sp, #60	; 0x3c
 80577fa:	3c10      	subs	r4, #16
 80577fc:	4616      	mov	r6, r2
 80577fe:	e6ba      	b.n	8057576 <_vfiprintf_r+0x576>
 8057800:	4616      	mov	r6, r2
 8057802:	e6d2      	b.n	80575aa <_vfiprintf_r+0x5aa>
 8057804:	aa0c      	add	r2, sp, #48	; 0x30
 8057806:	4639      	mov	r1, r7
 8057808:	4648      	mov	r0, r9
 805780a:	f7ff fbc7 	bl	8056f9c <__sprint_r>
 805780e:	b9f8      	cbnz	r0, 8057850 <_vfiprintf_r+0x850>
 8057810:	ab0f      	add	r3, sp, #60	; 0x3c
 8057812:	e6d9      	b.n	80575c8 <_vfiprintf_r+0x5c8>
 8057814:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 8057818:	1a54      	subs	r4, r2, r1
 805781a:	2c00      	cmp	r4, #0
 805781c:	f77f aed8 	ble.w	80575d0 <_vfiprintf_r+0x5d0>
 8057820:	4d3a      	ldr	r5, [pc, #232]	; (805790c <_vfiprintf_r+0x90c>)
 8057822:	2610      	movs	r6, #16
 8057824:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 8057828:	2c10      	cmp	r4, #16
 805782a:	f102 0201 	add.w	r2, r2, #1
 805782e:	601d      	str	r5, [r3, #0]
 8057830:	dc1d      	bgt.n	805786e <_vfiprintf_r+0x86e>
 8057832:	605c      	str	r4, [r3, #4]
 8057834:	2a07      	cmp	r2, #7
 8057836:	440c      	add	r4, r1
 8057838:	e9cd 240d 	strd	r2, r4, [sp, #52]	; 0x34
 805783c:	f77f aec8 	ble.w	80575d0 <_vfiprintf_r+0x5d0>
 8057840:	aa0c      	add	r2, sp, #48	; 0x30
 8057842:	4639      	mov	r1, r7
 8057844:	4648      	mov	r0, r9
 8057846:	f7ff fba9 	bl	8056f9c <__sprint_r>
 805784a:	2800      	cmp	r0, #0
 805784c:	f43f aec0 	beq.w	80575d0 <_vfiprintf_r+0x5d0>
 8057850:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8057852:	07d9      	lsls	r1, r3, #31
 8057854:	d405      	bmi.n	8057862 <_vfiprintf_r+0x862>
 8057856:	89bb      	ldrh	r3, [r7, #12]
 8057858:	059a      	lsls	r2, r3, #22
 805785a:	d402      	bmi.n	8057862 <_vfiprintf_r+0x862>
 805785c:	6db8      	ldr	r0, [r7, #88]	; 0x58
 805785e:	f7fe fdb2 	bl	80563c6 <__retarget_lock_release_recursive>
 8057862:	89bb      	ldrh	r3, [r7, #12]
 8057864:	065b      	lsls	r3, r3, #25
 8057866:	f57f abfe 	bpl.w	8057066 <_vfiprintf_r+0x66>
 805786a:	f7ff bbf9 	b.w	8057060 <_vfiprintf_r+0x60>
 805786e:	3110      	adds	r1, #16
 8057870:	2a07      	cmp	r2, #7
 8057872:	e9cd 210d 	strd	r2, r1, [sp, #52]	; 0x34
 8057876:	605e      	str	r6, [r3, #4]
 8057878:	dc02      	bgt.n	8057880 <_vfiprintf_r+0x880>
 805787a:	3308      	adds	r3, #8
 805787c:	3c10      	subs	r4, #16
 805787e:	e7d1      	b.n	8057824 <_vfiprintf_r+0x824>
 8057880:	aa0c      	add	r2, sp, #48	; 0x30
 8057882:	4639      	mov	r1, r7
 8057884:	4648      	mov	r0, r9
 8057886:	f7ff fb89 	bl	8056f9c <__sprint_r>
 805788a:	2800      	cmp	r0, #0
 805788c:	d1e0      	bne.n	8057850 <_vfiprintf_r+0x850>
 805788e:	ab0f      	add	r3, sp, #60	; 0x3c
 8057890:	e7f4      	b.n	805787c <_vfiprintf_r+0x87c>
 8057892:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8057894:	b913      	cbnz	r3, 805789c <_vfiprintf_r+0x89c>
 8057896:	2300      	movs	r3, #0
 8057898:	930d      	str	r3, [sp, #52]	; 0x34
 805789a:	e7d9      	b.n	8057850 <_vfiprintf_r+0x850>
 805789c:	aa0c      	add	r2, sp, #48	; 0x30
 805789e:	4639      	mov	r1, r7
 80578a0:	4648      	mov	r0, r9
 80578a2:	f7ff fb7b 	bl	8056f9c <__sprint_r>
 80578a6:	2800      	cmp	r0, #0
 80578a8:	d0f5      	beq.n	8057896 <_vfiprintf_r+0x896>
 80578aa:	e7d1      	b.n	8057850 <_vfiprintf_r+0x850>
 80578ac:	ea54 0205 	orrs.w	r2, r4, r5
 80578b0:	f8cd a010 	str.w	sl, [sp, #16]
 80578b4:	f43f ada4 	beq.w	8057400 <_vfiprintf_r+0x400>
 80578b8:	2b01      	cmp	r3, #1
 80578ba:	f43f aed7 	beq.w	805766c <_vfiprintf_r+0x66c>
 80578be:	2b02      	cmp	r3, #2
 80578c0:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
 80578c4:	f43f af23 	beq.w	805770e <_vfiprintf_r+0x70e>
 80578c8:	08e2      	lsrs	r2, r4, #3
 80578ca:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
 80578ce:	08e8      	lsrs	r0, r5, #3
 80578d0:	f004 0307 	and.w	r3, r4, #7
 80578d4:	4605      	mov	r5, r0
 80578d6:	4614      	mov	r4, r2
 80578d8:	3330      	adds	r3, #48	; 0x30
 80578da:	ea54 0205 	orrs.w	r2, r4, r5
 80578de:	4641      	mov	r1, r8
 80578e0:	f808 3d01 	strb.w	r3, [r8, #-1]!
 80578e4:	d1f0      	bne.n	80578c8 <_vfiprintf_r+0x8c8>
 80578e6:	9a04      	ldr	r2, [sp, #16]
 80578e8:	07d0      	lsls	r0, r2, #31
 80578ea:	d506      	bpl.n	80578fa <_vfiprintf_r+0x8fa>
 80578ec:	2b30      	cmp	r3, #48	; 0x30
 80578ee:	d004      	beq.n	80578fa <_vfiprintf_r+0x8fa>
 80578f0:	2330      	movs	r3, #48	; 0x30
 80578f2:	f808 3c01 	strb.w	r3, [r8, #-1]
 80578f6:	f1a1 0802 	sub.w	r8, r1, #2
 80578fa:	ab38      	add	r3, sp, #224	; 0xe0
 80578fc:	eba3 0308 	sub.w	r3, r3, r8
 8057900:	9d00      	ldr	r5, [sp, #0]
 8057902:	f8dd a010 	ldr.w	sl, [sp, #16]
 8057906:	9300      	str	r3, [sp, #0]
 8057908:	e5b5      	b.n	8057476 <_vfiprintf_r+0x476>
 805790a:	bf00      	nop
 805790c:	0805a744 	.word	0x0805a744

08057910 <__sbprintf>:
 8057910:	b570      	push	{r4, r5, r6, lr}
 8057912:	460c      	mov	r4, r1
 8057914:	8989      	ldrh	r1, [r1, #12]
 8057916:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 805791a:	f021 0102 	bic.w	r1, r1, #2
 805791e:	f8ad 1014 	strh.w	r1, [sp, #20]
 8057922:	6e61      	ldr	r1, [r4, #100]	; 0x64
 8057924:	911b      	str	r1, [sp, #108]	; 0x6c
 8057926:	89e1      	ldrh	r1, [r4, #14]
 8057928:	f8ad 1016 	strh.w	r1, [sp, #22]
 805792c:	69e1      	ldr	r1, [r4, #28]
 805792e:	9109      	str	r1, [sp, #36]	; 0x24
 8057930:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8057932:	910b      	str	r1, [sp, #44]	; 0x2c
 8057934:	a91c      	add	r1, sp, #112	; 0x70
 8057936:	9102      	str	r1, [sp, #8]
 8057938:	9106      	str	r1, [sp, #24]
 805793a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 805793e:	4606      	mov	r6, r0
 8057940:	9104      	str	r1, [sp, #16]
 8057942:	9107      	str	r1, [sp, #28]
 8057944:	a818      	add	r0, sp, #96	; 0x60
 8057946:	2100      	movs	r1, #0
 8057948:	e9cd 3200 	strd	r3, r2, [sp]
 805794c:	9108      	str	r1, [sp, #32]
 805794e:	f7fe fd37 	bl	80563c0 <__retarget_lock_init_recursive>
 8057952:	e9dd 3200 	ldrd	r3, r2, [sp]
 8057956:	a902      	add	r1, sp, #8
 8057958:	4630      	mov	r0, r6
 805795a:	f7ff fb51 	bl	8057000 <_vfiprintf_r>
 805795e:	1e05      	subs	r5, r0, #0
 8057960:	db07      	blt.n	8057972 <__sbprintf+0x62>
 8057962:	a902      	add	r1, sp, #8
 8057964:	4630      	mov	r0, r6
 8057966:	f7fd ffd7 	bl	8055918 <_fflush_r>
 805796a:	2800      	cmp	r0, #0
 805796c:	bf18      	it	ne
 805796e:	f04f 35ff 	movne.w	r5, #4294967295
 8057972:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8057976:	9818      	ldr	r0, [sp, #96]	; 0x60
 8057978:	065b      	lsls	r3, r3, #25
 805797a:	bf42      	ittt	mi
 805797c:	89a3      	ldrhmi	r3, [r4, #12]
 805797e:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 8057982:	81a3      	strhmi	r3, [r4, #12]
 8057984:	f7fe fd1d 	bl	80563c2 <__retarget_lock_close_recursive>
 8057988:	4628      	mov	r0, r5
 805798a:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 805798e:	bd70      	pop	{r4, r5, r6, pc}

08057990 <__ascii_wctomb>:
 8057990:	b149      	cbz	r1, 80579a6 <__ascii_wctomb+0x16>
 8057992:	2aff      	cmp	r2, #255	; 0xff
 8057994:	bf85      	ittet	hi
 8057996:	238a      	movhi	r3, #138	; 0x8a
 8057998:	6003      	strhi	r3, [r0, #0]
 805799a:	700a      	strbls	r2, [r1, #0]
 805799c:	f04f 30ff 	movhi.w	r0, #4294967295
 80579a0:	bf98      	it	ls
 80579a2:	2001      	movls	r0, #1
 80579a4:	4770      	bx	lr
 80579a6:	4608      	mov	r0, r1
 80579a8:	4770      	bx	lr
	...

080579ac <_write_r>:
 80579ac:	b538      	push	{r3, r4, r5, lr}
 80579ae:	4d07      	ldr	r5, [pc, #28]	; (80579cc <_write_r+0x20>)
 80579b0:	4604      	mov	r4, r0
 80579b2:	4608      	mov	r0, r1
 80579b4:	4611      	mov	r1, r2
 80579b6:	2200      	movs	r2, #0
 80579b8:	602a      	str	r2, [r5, #0]
 80579ba:	461a      	mov	r2, r3
 80579bc:	f7f8 f9f0 	bl	804fda0 <_write>
 80579c0:	1c43      	adds	r3, r0, #1
 80579c2:	d102      	bne.n	80579ca <_write_r+0x1e>
 80579c4:	682b      	ldr	r3, [r5, #0]
 80579c6:	b103      	cbz	r3, 80579ca <_write_r+0x1e>
 80579c8:	6023      	str	r3, [r4, #0]
 80579ca:	bd38      	pop	{r3, r4, r5, pc}
 80579cc:	20010330 	.word	0x20010330

080579d0 <__register_exitproc>:
 80579d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80579d4:	4d1c      	ldr	r5, [pc, #112]	; (8057a48 <__register_exitproc+0x78>)
 80579d6:	4606      	mov	r6, r0
 80579d8:	6828      	ldr	r0, [r5, #0]
 80579da:	4698      	mov	r8, r3
 80579dc:	460f      	mov	r7, r1
 80579de:	4691      	mov	r9, r2
 80579e0:	f7fe fcf0 	bl	80563c4 <__retarget_lock_acquire_recursive>
 80579e4:	4b19      	ldr	r3, [pc, #100]	; (8057a4c <__register_exitproc+0x7c>)
 80579e6:	681b      	ldr	r3, [r3, #0]
 80579e8:	f8d3 4148 	ldr.w	r4, [r3, #328]	; 0x148
 80579ec:	4628      	mov	r0, r5
 80579ee:	b91c      	cbnz	r4, 80579f8 <__register_exitproc+0x28>
 80579f0:	f503 74a6 	add.w	r4, r3, #332	; 0x14c
 80579f4:	f8c3 4148 	str.w	r4, [r3, #328]	; 0x148
 80579f8:	6865      	ldr	r5, [r4, #4]
 80579fa:	6800      	ldr	r0, [r0, #0]
 80579fc:	2d1f      	cmp	r5, #31
 80579fe:	dd05      	ble.n	8057a0c <__register_exitproc+0x3c>
 8057a00:	f7fe fce1 	bl	80563c6 <__retarget_lock_release_recursive>
 8057a04:	f04f 30ff 	mov.w	r0, #4294967295
 8057a08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8057a0c:	b19e      	cbz	r6, 8057a36 <__register_exitproc+0x66>
 8057a0e:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 8057a12:	2201      	movs	r2, #1
 8057a14:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
 8057a18:	f8d4 3188 	ldr.w	r3, [r4, #392]	; 0x188
 8057a1c:	40aa      	lsls	r2, r5
 8057a1e:	4313      	orrs	r3, r2
 8057a20:	2e02      	cmp	r6, #2
 8057a22:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
 8057a26:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
 8057a2a:	bf02      	ittt	eq
 8057a2c:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 8057a30:	431a      	orreq	r2, r3
 8057a32:	f8c4 218c 	streq.w	r2, [r4, #396]	; 0x18c
 8057a36:	1c6b      	adds	r3, r5, #1
 8057a38:	3502      	adds	r5, #2
 8057a3a:	6063      	str	r3, [r4, #4]
 8057a3c:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 8057a40:	f7fe fcc1 	bl	80563c6 <__retarget_lock_release_recursive>
 8057a44:	2000      	movs	r0, #0
 8057a46:	e7df      	b.n	8057a08 <__register_exitproc+0x38>
 8057a48:	20004108 	.word	0x20004108
 8057a4c:	0805a2fc 	.word	0x0805a2fc

08057a50 <__assert_func>:
 8057a50:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8057a52:	4614      	mov	r4, r2
 8057a54:	461a      	mov	r2, r3
 8057a56:	4b09      	ldr	r3, [pc, #36]	; (8057a7c <__assert_func+0x2c>)
 8057a58:	681b      	ldr	r3, [r3, #0]
 8057a5a:	4605      	mov	r5, r0
 8057a5c:	68d8      	ldr	r0, [r3, #12]
 8057a5e:	b14c      	cbz	r4, 8057a74 <__assert_func+0x24>
 8057a60:	4b07      	ldr	r3, [pc, #28]	; (8057a80 <__assert_func+0x30>)
 8057a62:	9100      	str	r1, [sp, #0]
 8057a64:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8057a68:	4906      	ldr	r1, [pc, #24]	; (8057a84 <__assert_func+0x34>)
 8057a6a:	462b      	mov	r3, r5
 8057a6c:	f000 f8a4 	bl	8057bb8 <fiprintf>
 8057a70:	f000 fcd0 	bl	8058414 <abort>
 8057a74:	4b04      	ldr	r3, [pc, #16]	; (8057a88 <__assert_func+0x38>)
 8057a76:	461c      	mov	r4, r3
 8057a78:	e7f3      	b.n	8057a62 <__assert_func+0x12>
 8057a7a:	bf00      	nop
 8057a7c:	200038cc 	.word	0x200038cc
 8057a80:	0805a764 	.word	0x0805a764
 8057a84:	0805a771 	.word	0x0805a771
 8057a88:	0805a79f 	.word	0x0805a79f

08057a8c <_calloc_r>:
 8057a8c:	b510      	push	{r4, lr}
 8057a8e:	4351      	muls	r1, r2
 8057a90:	f7f9 f93a 	bl	8050d08 <_malloc_r>
 8057a94:	4604      	mov	r4, r0
 8057a96:	b198      	cbz	r0, 8057ac0 <_calloc_r+0x34>
 8057a98:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8057a9c:	f022 0203 	bic.w	r2, r2, #3
 8057aa0:	3a04      	subs	r2, #4
 8057aa2:	2a24      	cmp	r2, #36	; 0x24
 8057aa4:	d81b      	bhi.n	8057ade <_calloc_r+0x52>
 8057aa6:	2a13      	cmp	r2, #19
 8057aa8:	d917      	bls.n	8057ada <_calloc_r+0x4e>
 8057aaa:	2100      	movs	r1, #0
 8057aac:	2a1b      	cmp	r2, #27
 8057aae:	e9c0 1100 	strd	r1, r1, [r0]
 8057ab2:	d807      	bhi.n	8057ac4 <_calloc_r+0x38>
 8057ab4:	f100 0308 	add.w	r3, r0, #8
 8057ab8:	2200      	movs	r2, #0
 8057aba:	e9c3 2200 	strd	r2, r2, [r3]
 8057abe:	609a      	str	r2, [r3, #8]
 8057ac0:	4620      	mov	r0, r4
 8057ac2:	bd10      	pop	{r4, pc}
 8057ac4:	2a24      	cmp	r2, #36	; 0x24
 8057ac6:	e9c0 1102 	strd	r1, r1, [r0, #8]
 8057aca:	bf11      	iteee	ne
 8057acc:	f100 0310 	addne.w	r3, r0, #16
 8057ad0:	6101      	streq	r1, [r0, #16]
 8057ad2:	f100 0318 	addeq.w	r3, r0, #24
 8057ad6:	6141      	streq	r1, [r0, #20]
 8057ad8:	e7ee      	b.n	8057ab8 <_calloc_r+0x2c>
 8057ada:	4603      	mov	r3, r0
 8057adc:	e7ec      	b.n	8057ab8 <_calloc_r+0x2c>
 8057ade:	2100      	movs	r1, #0
 8057ae0:	f7f9 fb70 	bl	80511c4 <memset>
 8057ae4:	e7ec      	b.n	8057ac0 <_calloc_r+0x34>
	...

08057ae8 <_close_r>:
 8057ae8:	b538      	push	{r3, r4, r5, lr}
 8057aea:	4d06      	ldr	r5, [pc, #24]	; (8057b04 <_close_r+0x1c>)
 8057aec:	2300      	movs	r3, #0
 8057aee:	4604      	mov	r4, r0
 8057af0:	4608      	mov	r0, r1
 8057af2:	602b      	str	r3, [r5, #0]
 8057af4:	f7f8 f980 	bl	804fdf8 <_close>
 8057af8:	1c43      	adds	r3, r0, #1
 8057afa:	d102      	bne.n	8057b02 <_close_r+0x1a>
 8057afc:	682b      	ldr	r3, [r5, #0]
 8057afe:	b103      	cbz	r3, 8057b02 <_close_r+0x1a>
 8057b00:	6023      	str	r3, [r4, #0]
 8057b02:	bd38      	pop	{r3, r4, r5, pc}
 8057b04:	20010330 	.word	0x20010330

08057b08 <_fclose_r>:
 8057b08:	b570      	push	{r4, r5, r6, lr}
 8057b0a:	4606      	mov	r6, r0
 8057b0c:	460c      	mov	r4, r1
 8057b0e:	b911      	cbnz	r1, 8057b16 <_fclose_r+0xe>
 8057b10:	2500      	movs	r5, #0
 8057b12:	4628      	mov	r0, r5
 8057b14:	bd70      	pop	{r4, r5, r6, pc}
 8057b16:	b118      	cbz	r0, 8057b20 <_fclose_r+0x18>
 8057b18:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8057b1a:	b90b      	cbnz	r3, 8057b20 <_fclose_r+0x18>
 8057b1c:	f7fd ff68 	bl	80559f0 <__sinit>
 8057b20:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8057b22:	07d8      	lsls	r0, r3, #31
 8057b24:	d405      	bmi.n	8057b32 <_fclose_r+0x2a>
 8057b26:	89a3      	ldrh	r3, [r4, #12]
 8057b28:	0599      	lsls	r1, r3, #22
 8057b2a:	d402      	bmi.n	8057b32 <_fclose_r+0x2a>
 8057b2c:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057b2e:	f7fe fc49 	bl	80563c4 <__retarget_lock_acquire_recursive>
 8057b32:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8057b36:	b93b      	cbnz	r3, 8057b48 <_fclose_r+0x40>
 8057b38:	6e65      	ldr	r5, [r4, #100]	; 0x64
 8057b3a:	f015 0501 	ands.w	r5, r5, #1
 8057b3e:	d1e7      	bne.n	8057b10 <_fclose_r+0x8>
 8057b40:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057b42:	f7fe fc40 	bl	80563c6 <__retarget_lock_release_recursive>
 8057b46:	e7e4      	b.n	8057b12 <_fclose_r+0xa>
 8057b48:	4621      	mov	r1, r4
 8057b4a:	4630      	mov	r0, r6
 8057b4c:	f7fd fe56 	bl	80557fc <__sflush_r>
 8057b50:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8057b52:	4605      	mov	r5, r0
 8057b54:	b133      	cbz	r3, 8057b64 <_fclose_r+0x5c>
 8057b56:	69e1      	ldr	r1, [r4, #28]
 8057b58:	4630      	mov	r0, r6
 8057b5a:	4798      	blx	r3
 8057b5c:	2800      	cmp	r0, #0
 8057b5e:	bfb8      	it	lt
 8057b60:	f04f 35ff 	movlt.w	r5, #4294967295
 8057b64:	89a3      	ldrh	r3, [r4, #12]
 8057b66:	061a      	lsls	r2, r3, #24
 8057b68:	d503      	bpl.n	8057b72 <_fclose_r+0x6a>
 8057b6a:	6921      	ldr	r1, [r4, #16]
 8057b6c:	4630      	mov	r0, r6
 8057b6e:	f7fd ffcf 	bl	8055b10 <_free_r>
 8057b72:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8057b74:	b141      	cbz	r1, 8057b88 <_fclose_r+0x80>
 8057b76:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8057b7a:	4299      	cmp	r1, r3
 8057b7c:	d002      	beq.n	8057b84 <_fclose_r+0x7c>
 8057b7e:	4630      	mov	r0, r6
 8057b80:	f7fd ffc6 	bl	8055b10 <_free_r>
 8057b84:	2300      	movs	r3, #0
 8057b86:	6323      	str	r3, [r4, #48]	; 0x30
 8057b88:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8057b8a:	b121      	cbz	r1, 8057b96 <_fclose_r+0x8e>
 8057b8c:	4630      	mov	r0, r6
 8057b8e:	f7fd ffbf 	bl	8055b10 <_free_r>
 8057b92:	2300      	movs	r3, #0
 8057b94:	6463      	str	r3, [r4, #68]	; 0x44
 8057b96:	f7fd ff13 	bl	80559c0 <__sfp_lock_acquire>
 8057b9a:	2300      	movs	r3, #0
 8057b9c:	81a3      	strh	r3, [r4, #12]
 8057b9e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8057ba0:	07db      	lsls	r3, r3, #31
 8057ba2:	d402      	bmi.n	8057baa <_fclose_r+0xa2>
 8057ba4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057ba6:	f7fe fc0e 	bl	80563c6 <__retarget_lock_release_recursive>
 8057baa:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057bac:	f7fe fc09 	bl	80563c2 <__retarget_lock_close_recursive>
 8057bb0:	f7fd ff0c 	bl	80559cc <__sfp_lock_release>
 8057bb4:	e7ad      	b.n	8057b12 <_fclose_r+0xa>
	...

08057bb8 <fiprintf>:
 8057bb8:	b40e      	push	{r1, r2, r3}
 8057bba:	b503      	push	{r0, r1, lr}
 8057bbc:	4601      	mov	r1, r0
 8057bbe:	ab03      	add	r3, sp, #12
 8057bc0:	4805      	ldr	r0, [pc, #20]	; (8057bd8 <fiprintf+0x20>)
 8057bc2:	f853 2b04 	ldr.w	r2, [r3], #4
 8057bc6:	6800      	ldr	r0, [r0, #0]
 8057bc8:	9301      	str	r3, [sp, #4]
 8057bca:	f7ff fa19 	bl	8057000 <_vfiprintf_r>
 8057bce:	b002      	add	sp, #8
 8057bd0:	f85d eb04 	ldr.w	lr, [sp], #4
 8057bd4:	b003      	add	sp, #12
 8057bd6:	4770      	bx	lr
 8057bd8:	200038cc 	.word	0x200038cc

08057bdc <__fputwc>:
 8057bdc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8057be0:	4680      	mov	r8, r0
 8057be2:	460e      	mov	r6, r1
 8057be4:	4615      	mov	r5, r2
 8057be6:	f7fe fbe1 	bl	80563ac <__locale_mb_cur_max>
 8057bea:	2801      	cmp	r0, #1
 8057bec:	d11c      	bne.n	8057c28 <__fputwc+0x4c>
 8057bee:	1e73      	subs	r3, r6, #1
 8057bf0:	2bfe      	cmp	r3, #254	; 0xfe
 8057bf2:	d819      	bhi.n	8057c28 <__fputwc+0x4c>
 8057bf4:	f88d 6004 	strb.w	r6, [sp, #4]
 8057bf8:	4604      	mov	r4, r0
 8057bfa:	2700      	movs	r7, #0
 8057bfc:	f10d 0904 	add.w	r9, sp, #4
 8057c00:	42a7      	cmp	r7, r4
 8057c02:	d020      	beq.n	8057c46 <__fputwc+0x6a>
 8057c04:	68ab      	ldr	r3, [r5, #8]
 8057c06:	f817 1009 	ldrb.w	r1, [r7, r9]
 8057c0a:	3b01      	subs	r3, #1
 8057c0c:	2b00      	cmp	r3, #0
 8057c0e:	60ab      	str	r3, [r5, #8]
 8057c10:	da04      	bge.n	8057c1c <__fputwc+0x40>
 8057c12:	69aa      	ldr	r2, [r5, #24]
 8057c14:	4293      	cmp	r3, r2
 8057c16:	db1a      	blt.n	8057c4e <__fputwc+0x72>
 8057c18:	290a      	cmp	r1, #10
 8057c1a:	d018      	beq.n	8057c4e <__fputwc+0x72>
 8057c1c:	682b      	ldr	r3, [r5, #0]
 8057c1e:	1c5a      	adds	r2, r3, #1
 8057c20:	602a      	str	r2, [r5, #0]
 8057c22:	7019      	strb	r1, [r3, #0]
 8057c24:	3701      	adds	r7, #1
 8057c26:	e7eb      	b.n	8057c00 <__fputwc+0x24>
 8057c28:	4632      	mov	r2, r6
 8057c2a:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 8057c2e:	a901      	add	r1, sp, #4
 8057c30:	4640      	mov	r0, r8
 8057c32:	f000 fbd9 	bl	80583e8 <_wcrtomb_r>
 8057c36:	1c42      	adds	r2, r0, #1
 8057c38:	4604      	mov	r4, r0
 8057c3a:	d1de      	bne.n	8057bfa <__fputwc+0x1e>
 8057c3c:	89ab      	ldrh	r3, [r5, #12]
 8057c3e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8057c42:	81ab      	strh	r3, [r5, #12]
 8057c44:	4606      	mov	r6, r0
 8057c46:	4630      	mov	r0, r6
 8057c48:	b003      	add	sp, #12
 8057c4a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8057c4e:	462a      	mov	r2, r5
 8057c50:	4640      	mov	r0, r8
 8057c52:	f000 fb7f 	bl	8058354 <__swbuf_r>
 8057c56:	1c43      	adds	r3, r0, #1
 8057c58:	d1e4      	bne.n	8057c24 <__fputwc+0x48>
 8057c5a:	4606      	mov	r6, r0
 8057c5c:	e7f3      	b.n	8057c46 <__fputwc+0x6a>

08057c5e <_fputwc_r>:
 8057c5e:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8057c60:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8057c62:	4614      	mov	r4, r2
 8057c64:	07da      	lsls	r2, r3, #31
 8057c66:	4605      	mov	r5, r0
 8057c68:	d407      	bmi.n	8057c7a <_fputwc_r+0x1c>
 8057c6a:	89a3      	ldrh	r3, [r4, #12]
 8057c6c:	059b      	lsls	r3, r3, #22
 8057c6e:	d404      	bmi.n	8057c7a <_fputwc_r+0x1c>
 8057c70:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057c72:	9101      	str	r1, [sp, #4]
 8057c74:	f7fe fba6 	bl	80563c4 <__retarget_lock_acquire_recursive>
 8057c78:	9901      	ldr	r1, [sp, #4]
 8057c7a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8057c7e:	0498      	lsls	r0, r3, #18
 8057c80:	d406      	bmi.n	8057c90 <_fputwc_r+0x32>
 8057c82:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8057c86:	81a3      	strh	r3, [r4, #12]
 8057c88:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8057c8a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8057c8e:	6663      	str	r3, [r4, #100]	; 0x64
 8057c90:	4622      	mov	r2, r4
 8057c92:	4628      	mov	r0, r5
 8057c94:	f7ff ffa2 	bl	8057bdc <__fputwc>
 8057c98:	6e63      	ldr	r3, [r4, #100]	; 0x64
 8057c9a:	07da      	lsls	r2, r3, #31
 8057c9c:	4605      	mov	r5, r0
 8057c9e:	d405      	bmi.n	8057cac <_fputwc_r+0x4e>
 8057ca0:	89a3      	ldrh	r3, [r4, #12]
 8057ca2:	059b      	lsls	r3, r3, #22
 8057ca4:	d402      	bmi.n	8057cac <_fputwc_r+0x4e>
 8057ca6:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8057ca8:	f7fe fb8d 	bl	80563c6 <__retarget_lock_release_recursive>
 8057cac:	4628      	mov	r0, r5
 8057cae:	b003      	add	sp, #12
 8057cb0:	bd30      	pop	{r4, r5, pc}
	...

08057cb4 <_fstat_r>:
 8057cb4:	b538      	push	{r3, r4, r5, lr}
 8057cb6:	4d07      	ldr	r5, [pc, #28]	; (8057cd4 <_fstat_r+0x20>)
 8057cb8:	2300      	movs	r3, #0
 8057cba:	4604      	mov	r4, r0
 8057cbc:	4608      	mov	r0, r1
 8057cbe:	4611      	mov	r1, r2
 8057cc0:	602b      	str	r3, [r5, #0]
 8057cc2:	f7f8 f89c 	bl	804fdfe <_fstat>
 8057cc6:	1c43      	adds	r3, r0, #1
 8057cc8:	d102      	bne.n	8057cd0 <_fstat_r+0x1c>
 8057cca:	682b      	ldr	r3, [r5, #0]
 8057ccc:	b103      	cbz	r3, 8057cd0 <_fstat_r+0x1c>
 8057cce:	6023      	str	r3, [r4, #0]
 8057cd0:	bd38      	pop	{r3, r4, r5, pc}
 8057cd2:	bf00      	nop
 8057cd4:	20010330 	.word	0x20010330

08057cd8 <__sfvwrite_r>:
 8057cd8:	6893      	ldr	r3, [r2, #8]
 8057cda:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8057cde:	4606      	mov	r6, r0
 8057ce0:	460c      	mov	r4, r1
 8057ce2:	4690      	mov	r8, r2
 8057ce4:	b91b      	cbnz	r3, 8057cee <__sfvwrite_r+0x16>
 8057ce6:	2000      	movs	r0, #0
 8057ce8:	b003      	add	sp, #12
 8057cea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8057cee:	898b      	ldrh	r3, [r1, #12]
 8057cf0:	0718      	lsls	r0, r3, #28
 8057cf2:	d550      	bpl.n	8057d96 <__sfvwrite_r+0xbe>
 8057cf4:	690b      	ldr	r3, [r1, #16]
 8057cf6:	2b00      	cmp	r3, #0
 8057cf8:	d04d      	beq.n	8057d96 <__sfvwrite_r+0xbe>
 8057cfa:	89a3      	ldrh	r3, [r4, #12]
 8057cfc:	f8d8 7000 	ldr.w	r7, [r8]
 8057d00:	f013 0902 	ands.w	r9, r3, #2
 8057d04:	d16c      	bne.n	8057de0 <__sfvwrite_r+0x108>
 8057d06:	f013 0301 	ands.w	r3, r3, #1
 8057d0a:	f000 809c 	beq.w	8057e46 <__sfvwrite_r+0x16e>
 8057d0e:	4648      	mov	r0, r9
 8057d10:	46ca      	mov	sl, r9
 8057d12:	46cb      	mov	fp, r9
 8057d14:	f1bb 0f00 	cmp.w	fp, #0
 8057d18:	f000 8103 	beq.w	8057f22 <__sfvwrite_r+0x24a>
 8057d1c:	b950      	cbnz	r0, 8057d34 <__sfvwrite_r+0x5c>
 8057d1e:	465a      	mov	r2, fp
 8057d20:	210a      	movs	r1, #10
 8057d22:	4650      	mov	r0, sl
 8057d24:	f7e8 fa6c 	bl	8040200 <memchr>
 8057d28:	2800      	cmp	r0, #0
 8057d2a:	f000 80ff 	beq.w	8057f2c <__sfvwrite_r+0x254>
 8057d2e:	3001      	adds	r0, #1
 8057d30:	eba0 090a 	sub.w	r9, r0, sl
 8057d34:	6820      	ldr	r0, [r4, #0]
 8057d36:	6921      	ldr	r1, [r4, #16]
 8057d38:	6963      	ldr	r3, [r4, #20]
 8057d3a:	45d9      	cmp	r9, fp
 8057d3c:	464a      	mov	r2, r9
 8057d3e:	bf28      	it	cs
 8057d40:	465a      	movcs	r2, fp
 8057d42:	4288      	cmp	r0, r1
 8057d44:	f240 80f5 	bls.w	8057f32 <__sfvwrite_r+0x25a>
 8057d48:	68a5      	ldr	r5, [r4, #8]
 8057d4a:	441d      	add	r5, r3
 8057d4c:	42aa      	cmp	r2, r5
 8057d4e:	f340 80f0 	ble.w	8057f32 <__sfvwrite_r+0x25a>
 8057d52:	4651      	mov	r1, sl
 8057d54:	462a      	mov	r2, r5
 8057d56:	f000 f92b 	bl	8057fb0 <memmove>
 8057d5a:	6823      	ldr	r3, [r4, #0]
 8057d5c:	442b      	add	r3, r5
 8057d5e:	6023      	str	r3, [r4, #0]
 8057d60:	4621      	mov	r1, r4
 8057d62:	4630      	mov	r0, r6
 8057d64:	f7fd fdd8 	bl	8055918 <_fflush_r>
 8057d68:	2800      	cmp	r0, #0
 8057d6a:	d167      	bne.n	8057e3c <__sfvwrite_r+0x164>
 8057d6c:	ebb9 0905 	subs.w	r9, r9, r5
 8057d70:	f040 80f7 	bne.w	8057f62 <__sfvwrite_r+0x28a>
 8057d74:	4621      	mov	r1, r4
 8057d76:	4630      	mov	r0, r6
 8057d78:	f7fd fdce 	bl	8055918 <_fflush_r>
 8057d7c:	2800      	cmp	r0, #0
 8057d7e:	d15d      	bne.n	8057e3c <__sfvwrite_r+0x164>
 8057d80:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8057d84:	44aa      	add	sl, r5
 8057d86:	ebab 0b05 	sub.w	fp, fp, r5
 8057d8a:	1b55      	subs	r5, r2, r5
 8057d8c:	f8c8 5008 	str.w	r5, [r8, #8]
 8057d90:	2d00      	cmp	r5, #0
 8057d92:	d1bf      	bne.n	8057d14 <__sfvwrite_r+0x3c>
 8057d94:	e7a7      	b.n	8057ce6 <__sfvwrite_r+0xe>
 8057d96:	4621      	mov	r1, r4
 8057d98:	4630      	mov	r0, r6
 8057d9a:	f7fc fe5f 	bl	8054a5c <__swsetup_r>
 8057d9e:	2800      	cmp	r0, #0
 8057da0:	d0ab      	beq.n	8057cfa <__sfvwrite_r+0x22>
 8057da2:	f04f 30ff 	mov.w	r0, #4294967295
 8057da6:	e79f      	b.n	8057ce8 <__sfvwrite_r+0x10>
 8057da8:	e9d7 b900 	ldrd	fp, r9, [r7]
 8057dac:	3708      	adds	r7, #8
 8057dae:	f1b9 0f00 	cmp.w	r9, #0
 8057db2:	d0f9      	beq.n	8057da8 <__sfvwrite_r+0xd0>
 8057db4:	45d1      	cmp	r9, sl
 8057db6:	464b      	mov	r3, r9
 8057db8:	69e1      	ldr	r1, [r4, #28]
 8057dba:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8057dbc:	bf28      	it	cs
 8057dbe:	4653      	movcs	r3, sl
 8057dc0:	465a      	mov	r2, fp
 8057dc2:	4630      	mov	r0, r6
 8057dc4:	47a8      	blx	r5
 8057dc6:	2800      	cmp	r0, #0
 8057dc8:	dd38      	ble.n	8057e3c <__sfvwrite_r+0x164>
 8057dca:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8057dce:	4483      	add	fp, r0
 8057dd0:	eba9 0900 	sub.w	r9, r9, r0
 8057dd4:	1a18      	subs	r0, r3, r0
 8057dd6:	f8c8 0008 	str.w	r0, [r8, #8]
 8057dda:	2800      	cmp	r0, #0
 8057ddc:	d1e7      	bne.n	8057dae <__sfvwrite_r+0xd6>
 8057dde:	e782      	b.n	8057ce6 <__sfvwrite_r+0xe>
 8057de0:	f04f 0b00 	mov.w	fp, #0
 8057de4:	f8df a180 	ldr.w	sl, [pc, #384]	; 8057f68 <__sfvwrite_r+0x290>
 8057de8:	46d9      	mov	r9, fp
 8057dea:	e7e0      	b.n	8057dae <__sfvwrite_r+0xd6>
 8057dec:	e9d7 9a00 	ldrd	r9, sl, [r7]
 8057df0:	3708      	adds	r7, #8
 8057df2:	f1ba 0f00 	cmp.w	sl, #0
 8057df6:	d0f9      	beq.n	8057dec <__sfvwrite_r+0x114>
 8057df8:	89a3      	ldrh	r3, [r4, #12]
 8057dfa:	68a2      	ldr	r2, [r4, #8]
 8057dfc:	6820      	ldr	r0, [r4, #0]
 8057dfe:	0599      	lsls	r1, r3, #22
 8057e00:	d563      	bpl.n	8057eca <__sfvwrite_r+0x1f2>
 8057e02:	4552      	cmp	r2, sl
 8057e04:	d836      	bhi.n	8057e74 <__sfvwrite_r+0x19c>
 8057e06:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8057e0a:	d033      	beq.n	8057e74 <__sfvwrite_r+0x19c>
 8057e0c:	6921      	ldr	r1, [r4, #16]
 8057e0e:	6965      	ldr	r5, [r4, #20]
 8057e10:	eba0 0b01 	sub.w	fp, r0, r1
 8057e14:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8057e18:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8057e1c:	f10b 0201 	add.w	r2, fp, #1
 8057e20:	106d      	asrs	r5, r5, #1
 8057e22:	4452      	add	r2, sl
 8057e24:	4295      	cmp	r5, r2
 8057e26:	bf38      	it	cc
 8057e28:	4615      	movcc	r5, r2
 8057e2a:	055b      	lsls	r3, r3, #21
 8057e2c:	d53d      	bpl.n	8057eaa <__sfvwrite_r+0x1d2>
 8057e2e:	4629      	mov	r1, r5
 8057e30:	4630      	mov	r0, r6
 8057e32:	f7f8 ff69 	bl	8050d08 <_malloc_r>
 8057e36:	b948      	cbnz	r0, 8057e4c <__sfvwrite_r+0x174>
 8057e38:	230c      	movs	r3, #12
 8057e3a:	6033      	str	r3, [r6, #0]
 8057e3c:	89a3      	ldrh	r3, [r4, #12]
 8057e3e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8057e42:	81a3      	strh	r3, [r4, #12]
 8057e44:	e7ad      	b.n	8057da2 <__sfvwrite_r+0xca>
 8057e46:	4699      	mov	r9, r3
 8057e48:	469a      	mov	sl, r3
 8057e4a:	e7d2      	b.n	8057df2 <__sfvwrite_r+0x11a>
 8057e4c:	465a      	mov	r2, fp
 8057e4e:	6921      	ldr	r1, [r4, #16]
 8057e50:	9001      	str	r0, [sp, #4]
 8057e52:	f7f9 f9a9 	bl	80511a8 <memcpy>
 8057e56:	89a2      	ldrh	r2, [r4, #12]
 8057e58:	9b01      	ldr	r3, [sp, #4]
 8057e5a:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8057e5e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8057e62:	81a2      	strh	r2, [r4, #12]
 8057e64:	6123      	str	r3, [r4, #16]
 8057e66:	6165      	str	r5, [r4, #20]
 8057e68:	445b      	add	r3, fp
 8057e6a:	eba5 050b 	sub.w	r5, r5, fp
 8057e6e:	6023      	str	r3, [r4, #0]
 8057e70:	4652      	mov	r2, sl
 8057e72:	60a5      	str	r5, [r4, #8]
 8057e74:	4552      	cmp	r2, sl
 8057e76:	bf28      	it	cs
 8057e78:	4652      	movcs	r2, sl
 8057e7a:	6820      	ldr	r0, [r4, #0]
 8057e7c:	9201      	str	r2, [sp, #4]
 8057e7e:	4649      	mov	r1, r9
 8057e80:	f000 f896 	bl	8057fb0 <memmove>
 8057e84:	68a3      	ldr	r3, [r4, #8]
 8057e86:	9a01      	ldr	r2, [sp, #4]
 8057e88:	1a9b      	subs	r3, r3, r2
 8057e8a:	60a3      	str	r3, [r4, #8]
 8057e8c:	6823      	ldr	r3, [r4, #0]
 8057e8e:	441a      	add	r2, r3
 8057e90:	4655      	mov	r5, sl
 8057e92:	6022      	str	r2, [r4, #0]
 8057e94:	f8d8 0008 	ldr.w	r0, [r8, #8]
 8057e98:	44a9      	add	r9, r5
 8057e9a:	ebaa 0a05 	sub.w	sl, sl, r5
 8057e9e:	1b45      	subs	r5, r0, r5
 8057ea0:	f8c8 5008 	str.w	r5, [r8, #8]
 8057ea4:	2d00      	cmp	r5, #0
 8057ea6:	d1a4      	bne.n	8057df2 <__sfvwrite_r+0x11a>
 8057ea8:	e71d      	b.n	8057ce6 <__sfvwrite_r+0xe>
 8057eaa:	462a      	mov	r2, r5
 8057eac:	4630      	mov	r0, r6
 8057eae:	f000 f8ab 	bl	8058008 <_realloc_r>
 8057eb2:	4603      	mov	r3, r0
 8057eb4:	2800      	cmp	r0, #0
 8057eb6:	d1d5      	bne.n	8057e64 <__sfvwrite_r+0x18c>
 8057eb8:	6921      	ldr	r1, [r4, #16]
 8057eba:	4630      	mov	r0, r6
 8057ebc:	f7fd fe28 	bl	8055b10 <_free_r>
 8057ec0:	89a3      	ldrh	r3, [r4, #12]
 8057ec2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8057ec6:	81a3      	strh	r3, [r4, #12]
 8057ec8:	e7b6      	b.n	8057e38 <__sfvwrite_r+0x160>
 8057eca:	6923      	ldr	r3, [r4, #16]
 8057ecc:	4283      	cmp	r3, r0
 8057ece:	d302      	bcc.n	8057ed6 <__sfvwrite_r+0x1fe>
 8057ed0:	6961      	ldr	r1, [r4, #20]
 8057ed2:	4551      	cmp	r1, sl
 8057ed4:	d915      	bls.n	8057f02 <__sfvwrite_r+0x22a>
 8057ed6:	4552      	cmp	r2, sl
 8057ed8:	bf28      	it	cs
 8057eda:	4652      	movcs	r2, sl
 8057edc:	4649      	mov	r1, r9
 8057ede:	4615      	mov	r5, r2
 8057ee0:	f000 f866 	bl	8057fb0 <memmove>
 8057ee4:	68a3      	ldr	r3, [r4, #8]
 8057ee6:	6822      	ldr	r2, [r4, #0]
 8057ee8:	1b5b      	subs	r3, r3, r5
 8057eea:	442a      	add	r2, r5
 8057eec:	60a3      	str	r3, [r4, #8]
 8057eee:	6022      	str	r2, [r4, #0]
 8057ef0:	2b00      	cmp	r3, #0
 8057ef2:	d1cf      	bne.n	8057e94 <__sfvwrite_r+0x1bc>
 8057ef4:	4621      	mov	r1, r4
 8057ef6:	4630      	mov	r0, r6
 8057ef8:	f7fd fd0e 	bl	8055918 <_fflush_r>
 8057efc:	2800      	cmp	r0, #0
 8057efe:	d0c9      	beq.n	8057e94 <__sfvwrite_r+0x1bc>
 8057f00:	e79c      	b.n	8057e3c <__sfvwrite_r+0x164>
 8057f02:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 8057f06:	459a      	cmp	sl, r3
 8057f08:	bf38      	it	cc
 8057f0a:	4653      	movcc	r3, sl
 8057f0c:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8057f0e:	fb93 f3f1 	sdiv	r3, r3, r1
 8057f12:	464a      	mov	r2, r9
 8057f14:	434b      	muls	r3, r1
 8057f16:	4630      	mov	r0, r6
 8057f18:	69e1      	ldr	r1, [r4, #28]
 8057f1a:	47a8      	blx	r5
 8057f1c:	1e05      	subs	r5, r0, #0
 8057f1e:	dcb9      	bgt.n	8057e94 <__sfvwrite_r+0x1bc>
 8057f20:	e78c      	b.n	8057e3c <__sfvwrite_r+0x164>
 8057f22:	e9d7 ab00 	ldrd	sl, fp, [r7]
 8057f26:	2000      	movs	r0, #0
 8057f28:	3708      	adds	r7, #8
 8057f2a:	e6f3      	b.n	8057d14 <__sfvwrite_r+0x3c>
 8057f2c:	f10b 0901 	add.w	r9, fp, #1
 8057f30:	e700      	b.n	8057d34 <__sfvwrite_r+0x5c>
 8057f32:	4293      	cmp	r3, r2
 8057f34:	dc08      	bgt.n	8057f48 <__sfvwrite_r+0x270>
 8057f36:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8057f38:	69e1      	ldr	r1, [r4, #28]
 8057f3a:	4652      	mov	r2, sl
 8057f3c:	4630      	mov	r0, r6
 8057f3e:	47a8      	blx	r5
 8057f40:	1e05      	subs	r5, r0, #0
 8057f42:	f73f af13 	bgt.w	8057d6c <__sfvwrite_r+0x94>
 8057f46:	e779      	b.n	8057e3c <__sfvwrite_r+0x164>
 8057f48:	4651      	mov	r1, sl
 8057f4a:	9201      	str	r2, [sp, #4]
 8057f4c:	f000 f830 	bl	8057fb0 <memmove>
 8057f50:	9a01      	ldr	r2, [sp, #4]
 8057f52:	68a3      	ldr	r3, [r4, #8]
 8057f54:	1a9b      	subs	r3, r3, r2
 8057f56:	60a3      	str	r3, [r4, #8]
 8057f58:	6823      	ldr	r3, [r4, #0]
 8057f5a:	4413      	add	r3, r2
 8057f5c:	6023      	str	r3, [r4, #0]
 8057f5e:	4615      	mov	r5, r2
 8057f60:	e704      	b.n	8057d6c <__sfvwrite_r+0x94>
 8057f62:	2001      	movs	r0, #1
 8057f64:	e70c      	b.n	8057d80 <__sfvwrite_r+0xa8>
 8057f66:	bf00      	nop
 8057f68:	7ffffc00 	.word	0x7ffffc00

08057f6c <_isatty_r>:
 8057f6c:	b538      	push	{r3, r4, r5, lr}
 8057f6e:	4d06      	ldr	r5, [pc, #24]	; (8057f88 <_isatty_r+0x1c>)
 8057f70:	2300      	movs	r3, #0
 8057f72:	4604      	mov	r4, r0
 8057f74:	4608      	mov	r0, r1
 8057f76:	602b      	str	r3, [r5, #0]
 8057f78:	f7f7 ff46 	bl	804fe08 <_isatty>
 8057f7c:	1c43      	adds	r3, r0, #1
 8057f7e:	d102      	bne.n	8057f86 <_isatty_r+0x1a>
 8057f80:	682b      	ldr	r3, [r5, #0]
 8057f82:	b103      	cbz	r3, 8057f86 <_isatty_r+0x1a>
 8057f84:	6023      	str	r3, [r4, #0]
 8057f86:	bd38      	pop	{r3, r4, r5, pc}
 8057f88:	20010330 	.word	0x20010330

08057f8c <_lseek_r>:
 8057f8c:	b538      	push	{r3, r4, r5, lr}
 8057f8e:	4d07      	ldr	r5, [pc, #28]	; (8057fac <_lseek_r+0x20>)
 8057f90:	4604      	mov	r4, r0
 8057f92:	4608      	mov	r0, r1
 8057f94:	4611      	mov	r1, r2
 8057f96:	2200      	movs	r2, #0
 8057f98:	602a      	str	r2, [r5, #0]
 8057f9a:	461a      	mov	r2, r3
 8057f9c:	f7f7 ff36 	bl	804fe0c <_lseek>
 8057fa0:	1c43      	adds	r3, r0, #1
 8057fa2:	d102      	bne.n	8057faa <_lseek_r+0x1e>
 8057fa4:	682b      	ldr	r3, [r5, #0]
 8057fa6:	b103      	cbz	r3, 8057faa <_lseek_r+0x1e>
 8057fa8:	6023      	str	r3, [r4, #0]
 8057faa:	bd38      	pop	{r3, r4, r5, pc}
 8057fac:	20010330 	.word	0x20010330

08057fb0 <memmove>:
 8057fb0:	4288      	cmp	r0, r1
 8057fb2:	b510      	push	{r4, lr}
 8057fb4:	eb01 0402 	add.w	r4, r1, r2
 8057fb8:	d902      	bls.n	8057fc0 <memmove+0x10>
 8057fba:	4284      	cmp	r4, r0
 8057fbc:	4623      	mov	r3, r4
 8057fbe:	d807      	bhi.n	8057fd0 <memmove+0x20>
 8057fc0:	1e43      	subs	r3, r0, #1
 8057fc2:	42a1      	cmp	r1, r4
 8057fc4:	d008      	beq.n	8057fd8 <memmove+0x28>
 8057fc6:	f811 2b01 	ldrb.w	r2, [r1], #1
 8057fca:	f803 2f01 	strb.w	r2, [r3, #1]!
 8057fce:	e7f8      	b.n	8057fc2 <memmove+0x12>
 8057fd0:	4402      	add	r2, r0
 8057fd2:	4601      	mov	r1, r0
 8057fd4:	428a      	cmp	r2, r1
 8057fd6:	d100      	bne.n	8057fda <memmove+0x2a>
 8057fd8:	bd10      	pop	{r4, pc}
 8057fda:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8057fde:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8057fe2:	e7f7      	b.n	8057fd4 <memmove+0x24>

08057fe4 <_read_r>:
 8057fe4:	b538      	push	{r3, r4, r5, lr}
 8057fe6:	4d07      	ldr	r5, [pc, #28]	; (8058004 <_read_r+0x20>)
 8057fe8:	4604      	mov	r4, r0
 8057fea:	4608      	mov	r0, r1
 8057fec:	4611      	mov	r1, r2
 8057fee:	2200      	movs	r2, #0
 8057ff0:	602a      	str	r2, [r5, #0]
 8057ff2:	461a      	mov	r2, r3
 8057ff4:	f7f7 fec4 	bl	804fd80 <_read>
 8057ff8:	1c43      	adds	r3, r0, #1
 8057ffa:	d102      	bne.n	8058002 <_read_r+0x1e>
 8057ffc:	682b      	ldr	r3, [r5, #0]
 8057ffe:	b103      	cbz	r3, 8058002 <_read_r+0x1e>
 8058000:	6023      	str	r3, [r4, #0]
 8058002:	bd38      	pop	{r3, r4, r5, pc}
 8058004:	20010330 	.word	0x20010330

08058008 <_realloc_r>:
 8058008:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 805800c:	4681      	mov	r9, r0
 805800e:	460c      	mov	r4, r1
 8058010:	b929      	cbnz	r1, 805801e <_realloc_r+0x16>
 8058012:	4611      	mov	r1, r2
 8058014:	b003      	add	sp, #12
 8058016:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 805801a:	f7f8 be75 	b.w	8050d08 <_malloc_r>
 805801e:	9201      	str	r2, [sp, #4]
 8058020:	f7f9 f8d8 	bl	80511d4 <__malloc_lock>
 8058024:	9a01      	ldr	r2, [sp, #4]
 8058026:	f102 080b 	add.w	r8, r2, #11
 805802a:	f1b8 0f16 	cmp.w	r8, #22
 805802e:	d90b      	bls.n	8058048 <_realloc_r+0x40>
 8058030:	f038 0807 	bics.w	r8, r8, #7
 8058034:	d50a      	bpl.n	805804c <_realloc_r+0x44>
 8058036:	230c      	movs	r3, #12
 8058038:	f8c9 3000 	str.w	r3, [r9]
 805803c:	f04f 0b00 	mov.w	fp, #0
 8058040:	4658      	mov	r0, fp
 8058042:	b003      	add	sp, #12
 8058044:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8058048:	f04f 0810 	mov.w	r8, #16
 805804c:	4590      	cmp	r8, r2
 805804e:	d3f2      	bcc.n	8058036 <_realloc_r+0x2e>
 8058050:	f854 5c04 	ldr.w	r5, [r4, #-4]
 8058054:	f025 0603 	bic.w	r6, r5, #3
 8058058:	45b0      	cmp	r8, r6
 805805a:	f1a4 0a08 	sub.w	sl, r4, #8
 805805e:	f340 8170 	ble.w	8058342 <_realloc_r+0x33a>
 8058062:	48a9      	ldr	r0, [pc, #676]	; (8058308 <_realloc_r+0x300>)
 8058064:	9001      	str	r0, [sp, #4]
 8058066:	f8d0 c008 	ldr.w	ip, [r0, #8]
 805806a:	eb0a 0306 	add.w	r3, sl, r6
 805806e:	459c      	cmp	ip, r3
 8058070:	6859      	ldr	r1, [r3, #4]
 8058072:	d005      	beq.n	8058080 <_realloc_r+0x78>
 8058074:	f021 0001 	bic.w	r0, r1, #1
 8058078:	4418      	add	r0, r3
 805807a:	6840      	ldr	r0, [r0, #4]
 805807c:	07c7      	lsls	r7, r0, #31
 805807e:	d427      	bmi.n	80580d0 <_realloc_r+0xc8>
 8058080:	f021 0103 	bic.w	r1, r1, #3
 8058084:	459c      	cmp	ip, r3
 8058086:	eb06 0701 	add.w	r7, r6, r1
 805808a:	d119      	bne.n	80580c0 <_realloc_r+0xb8>
 805808c:	f108 0010 	add.w	r0, r8, #16
 8058090:	42b8      	cmp	r0, r7
 8058092:	dc1f      	bgt.n	80580d4 <_realloc_r+0xcc>
 8058094:	eb0a 0308 	add.w	r3, sl, r8
 8058098:	9a01      	ldr	r2, [sp, #4]
 805809a:	eba7 0708 	sub.w	r7, r7, r8
 805809e:	f047 0701 	orr.w	r7, r7, #1
 80580a2:	6093      	str	r3, [r2, #8]
 80580a4:	605f      	str	r7, [r3, #4]
 80580a6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80580aa:	f003 0301 	and.w	r3, r3, #1
 80580ae:	ea43 0308 	orr.w	r3, r3, r8
 80580b2:	f844 3c04 	str.w	r3, [r4, #-4]
 80580b6:	4648      	mov	r0, r9
 80580b8:	f7f9 f892 	bl	80511e0 <__malloc_unlock>
 80580bc:	46a3      	mov	fp, r4
 80580be:	e7bf      	b.n	8058040 <_realloc_r+0x38>
 80580c0:	45b8      	cmp	r8, r7
 80580c2:	dc07      	bgt.n	80580d4 <_realloc_r+0xcc>
 80580c4:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 80580c8:	60da      	str	r2, [r3, #12]
 80580ca:	6093      	str	r3, [r2, #8]
 80580cc:	4655      	mov	r5, sl
 80580ce:	e07f      	b.n	80581d0 <_realloc_r+0x1c8>
 80580d0:	2100      	movs	r1, #0
 80580d2:	460b      	mov	r3, r1
 80580d4:	07e8      	lsls	r0, r5, #31
 80580d6:	f100 80e5 	bmi.w	80582a4 <_realloc_r+0x29c>
 80580da:	f854 5c08 	ldr.w	r5, [r4, #-8]
 80580de:	ebaa 0505 	sub.w	r5, sl, r5
 80580e2:	6868      	ldr	r0, [r5, #4]
 80580e4:	f020 0003 	bic.w	r0, r0, #3
 80580e8:	eb00 0b06 	add.w	fp, r0, r6
 80580ec:	2b00      	cmp	r3, #0
 80580ee:	f000 80a5 	beq.w	805823c <_realloc_r+0x234>
 80580f2:	459c      	cmp	ip, r3
 80580f4:	eb01 070b 	add.w	r7, r1, fp
 80580f8:	d14a      	bne.n	8058190 <_realloc_r+0x188>
 80580fa:	f108 0310 	add.w	r3, r8, #16
 80580fe:	42bb      	cmp	r3, r7
 8058100:	f300 809c 	bgt.w	805823c <_realloc_r+0x234>
 8058104:	46ab      	mov	fp, r5
 8058106:	68eb      	ldr	r3, [r5, #12]
 8058108:	f85b 2f08 	ldr.w	r2, [fp, #8]!
 805810c:	60d3      	str	r3, [r2, #12]
 805810e:	609a      	str	r2, [r3, #8]
 8058110:	1f32      	subs	r2, r6, #4
 8058112:	2a24      	cmp	r2, #36	; 0x24
 8058114:	d837      	bhi.n	8058186 <_realloc_r+0x17e>
 8058116:	2a13      	cmp	r2, #19
 8058118:	d933      	bls.n	8058182 <_realloc_r+0x17a>
 805811a:	6823      	ldr	r3, [r4, #0]
 805811c:	60ab      	str	r3, [r5, #8]
 805811e:	6863      	ldr	r3, [r4, #4]
 8058120:	60eb      	str	r3, [r5, #12]
 8058122:	2a1b      	cmp	r2, #27
 8058124:	d81b      	bhi.n	805815e <_realloc_r+0x156>
 8058126:	3408      	adds	r4, #8
 8058128:	f105 0310 	add.w	r3, r5, #16
 805812c:	6822      	ldr	r2, [r4, #0]
 805812e:	601a      	str	r2, [r3, #0]
 8058130:	6862      	ldr	r2, [r4, #4]
 8058132:	605a      	str	r2, [r3, #4]
 8058134:	68a2      	ldr	r2, [r4, #8]
 8058136:	609a      	str	r2, [r3, #8]
 8058138:	eb05 0308 	add.w	r3, r5, r8
 805813c:	9a01      	ldr	r2, [sp, #4]
 805813e:	eba7 0708 	sub.w	r7, r7, r8
 8058142:	f047 0701 	orr.w	r7, r7, #1
 8058146:	6093      	str	r3, [r2, #8]
 8058148:	605f      	str	r7, [r3, #4]
 805814a:	686b      	ldr	r3, [r5, #4]
 805814c:	f003 0301 	and.w	r3, r3, #1
 8058150:	ea43 0308 	orr.w	r3, r3, r8
 8058154:	606b      	str	r3, [r5, #4]
 8058156:	4648      	mov	r0, r9
 8058158:	f7f9 f842 	bl	80511e0 <__malloc_unlock>
 805815c:	e770      	b.n	8058040 <_realloc_r+0x38>
 805815e:	68a3      	ldr	r3, [r4, #8]
 8058160:	612b      	str	r3, [r5, #16]
 8058162:	68e3      	ldr	r3, [r4, #12]
 8058164:	616b      	str	r3, [r5, #20]
 8058166:	2a24      	cmp	r2, #36	; 0x24
 8058168:	bf01      	itttt	eq
 805816a:	6923      	ldreq	r3, [r4, #16]
 805816c:	61ab      	streq	r3, [r5, #24]
 805816e:	6962      	ldreq	r2, [r4, #20]
 8058170:	61ea      	streq	r2, [r5, #28]
 8058172:	bf19      	ittee	ne
 8058174:	3410      	addne	r4, #16
 8058176:	f105 0318 	addne.w	r3, r5, #24
 805817a:	f105 0320 	addeq.w	r3, r5, #32
 805817e:	3418      	addeq	r4, #24
 8058180:	e7d4      	b.n	805812c <_realloc_r+0x124>
 8058182:	465b      	mov	r3, fp
 8058184:	e7d2      	b.n	805812c <_realloc_r+0x124>
 8058186:	4621      	mov	r1, r4
 8058188:	4658      	mov	r0, fp
 805818a:	f7ff ff11 	bl	8057fb0 <memmove>
 805818e:	e7d3      	b.n	8058138 <_realloc_r+0x130>
 8058190:	45b8      	cmp	r8, r7
 8058192:	dc53      	bgt.n	805823c <_realloc_r+0x234>
 8058194:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8058198:	4628      	mov	r0, r5
 805819a:	60da      	str	r2, [r3, #12]
 805819c:	6093      	str	r3, [r2, #8]
 805819e:	f850 2f08 	ldr.w	r2, [r0, #8]!
 80581a2:	68eb      	ldr	r3, [r5, #12]
 80581a4:	60d3      	str	r3, [r2, #12]
 80581a6:	609a      	str	r2, [r3, #8]
 80581a8:	1f32      	subs	r2, r6, #4
 80581aa:	2a24      	cmp	r2, #36	; 0x24
 80581ac:	d842      	bhi.n	8058234 <_realloc_r+0x22c>
 80581ae:	2a13      	cmp	r2, #19
 80581b0:	d908      	bls.n	80581c4 <_realloc_r+0x1bc>
 80581b2:	6823      	ldr	r3, [r4, #0]
 80581b4:	60ab      	str	r3, [r5, #8]
 80581b6:	6863      	ldr	r3, [r4, #4]
 80581b8:	60eb      	str	r3, [r5, #12]
 80581ba:	2a1b      	cmp	r2, #27
 80581bc:	d828      	bhi.n	8058210 <_realloc_r+0x208>
 80581be:	3408      	adds	r4, #8
 80581c0:	f105 0010 	add.w	r0, r5, #16
 80581c4:	6823      	ldr	r3, [r4, #0]
 80581c6:	6003      	str	r3, [r0, #0]
 80581c8:	6863      	ldr	r3, [r4, #4]
 80581ca:	6043      	str	r3, [r0, #4]
 80581cc:	68a3      	ldr	r3, [r4, #8]
 80581ce:	6083      	str	r3, [r0, #8]
 80581d0:	686a      	ldr	r2, [r5, #4]
 80581d2:	eba7 0008 	sub.w	r0, r7, r8
 80581d6:	280f      	cmp	r0, #15
 80581d8:	f002 0201 	and.w	r2, r2, #1
 80581dc:	eb05 0307 	add.w	r3, r5, r7
 80581e0:	f240 80b1 	bls.w	8058346 <_realloc_r+0x33e>
 80581e4:	eb05 0108 	add.w	r1, r5, r8
 80581e8:	ea48 0202 	orr.w	r2, r8, r2
 80581ec:	f040 0001 	orr.w	r0, r0, #1
 80581f0:	606a      	str	r2, [r5, #4]
 80581f2:	6048      	str	r0, [r1, #4]
 80581f4:	685a      	ldr	r2, [r3, #4]
 80581f6:	f042 0201 	orr.w	r2, r2, #1
 80581fa:	605a      	str	r2, [r3, #4]
 80581fc:	3108      	adds	r1, #8
 80581fe:	4648      	mov	r0, r9
 8058200:	f7fd fc86 	bl	8055b10 <_free_r>
 8058204:	4648      	mov	r0, r9
 8058206:	f7f8 ffeb 	bl	80511e0 <__malloc_unlock>
 805820a:	f105 0b08 	add.w	fp, r5, #8
 805820e:	e717      	b.n	8058040 <_realloc_r+0x38>
 8058210:	68a3      	ldr	r3, [r4, #8]
 8058212:	612b      	str	r3, [r5, #16]
 8058214:	68e3      	ldr	r3, [r4, #12]
 8058216:	616b      	str	r3, [r5, #20]
 8058218:	2a24      	cmp	r2, #36	; 0x24
 805821a:	bf01      	itttt	eq
 805821c:	6923      	ldreq	r3, [r4, #16]
 805821e:	61ab      	streq	r3, [r5, #24]
 8058220:	6963      	ldreq	r3, [r4, #20]
 8058222:	61eb      	streq	r3, [r5, #28]
 8058224:	bf19      	ittee	ne
 8058226:	3410      	addne	r4, #16
 8058228:	f105 0018 	addne.w	r0, r5, #24
 805822c:	f105 0020 	addeq.w	r0, r5, #32
 8058230:	3418      	addeq	r4, #24
 8058232:	e7c7      	b.n	80581c4 <_realloc_r+0x1bc>
 8058234:	4621      	mov	r1, r4
 8058236:	f7ff febb 	bl	8057fb0 <memmove>
 805823a:	e7c9      	b.n	80581d0 <_realloc_r+0x1c8>
 805823c:	45d8      	cmp	r8, fp
 805823e:	dc31      	bgt.n	80582a4 <_realloc_r+0x29c>
 8058240:	4628      	mov	r0, r5
 8058242:	68eb      	ldr	r3, [r5, #12]
 8058244:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8058248:	60d3      	str	r3, [r2, #12]
 805824a:	609a      	str	r2, [r3, #8]
 805824c:	1f32      	subs	r2, r6, #4
 805824e:	2a24      	cmp	r2, #36	; 0x24
 8058250:	d824      	bhi.n	805829c <_realloc_r+0x294>
 8058252:	2a13      	cmp	r2, #19
 8058254:	d908      	bls.n	8058268 <_realloc_r+0x260>
 8058256:	6823      	ldr	r3, [r4, #0]
 8058258:	60ab      	str	r3, [r5, #8]
 805825a:	6863      	ldr	r3, [r4, #4]
 805825c:	60eb      	str	r3, [r5, #12]
 805825e:	2a1b      	cmp	r2, #27
 8058260:	d80a      	bhi.n	8058278 <_realloc_r+0x270>
 8058262:	3408      	adds	r4, #8
 8058264:	f105 0010 	add.w	r0, r5, #16
 8058268:	6823      	ldr	r3, [r4, #0]
 805826a:	6003      	str	r3, [r0, #0]
 805826c:	6863      	ldr	r3, [r4, #4]
 805826e:	6043      	str	r3, [r0, #4]
 8058270:	68a3      	ldr	r3, [r4, #8]
 8058272:	6083      	str	r3, [r0, #8]
 8058274:	465f      	mov	r7, fp
 8058276:	e7ab      	b.n	80581d0 <_realloc_r+0x1c8>
 8058278:	68a3      	ldr	r3, [r4, #8]
 805827a:	612b      	str	r3, [r5, #16]
 805827c:	68e3      	ldr	r3, [r4, #12]
 805827e:	616b      	str	r3, [r5, #20]
 8058280:	2a24      	cmp	r2, #36	; 0x24
 8058282:	bf01      	itttt	eq
 8058284:	6923      	ldreq	r3, [r4, #16]
 8058286:	61ab      	streq	r3, [r5, #24]
 8058288:	6963      	ldreq	r3, [r4, #20]
 805828a:	61eb      	streq	r3, [r5, #28]
 805828c:	bf19      	ittee	ne
 805828e:	3410      	addne	r4, #16
 8058290:	f105 0018 	addne.w	r0, r5, #24
 8058294:	f105 0020 	addeq.w	r0, r5, #32
 8058298:	3418      	addeq	r4, #24
 805829a:	e7e5      	b.n	8058268 <_realloc_r+0x260>
 805829c:	4621      	mov	r1, r4
 805829e:	f7ff fe87 	bl	8057fb0 <memmove>
 80582a2:	e7e7      	b.n	8058274 <_realloc_r+0x26c>
 80582a4:	4611      	mov	r1, r2
 80582a6:	4648      	mov	r0, r9
 80582a8:	f7f8 fd2e 	bl	8050d08 <_malloc_r>
 80582ac:	4683      	mov	fp, r0
 80582ae:	2800      	cmp	r0, #0
 80582b0:	f43f af51 	beq.w	8058156 <_realloc_r+0x14e>
 80582b4:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80582b8:	f023 0301 	bic.w	r3, r3, #1
 80582bc:	4453      	add	r3, sl
 80582be:	f1a0 0208 	sub.w	r2, r0, #8
 80582c2:	4293      	cmp	r3, r2
 80582c4:	d105      	bne.n	80582d2 <_realloc_r+0x2ca>
 80582c6:	f850 7c04 	ldr.w	r7, [r0, #-4]
 80582ca:	f027 0703 	bic.w	r7, r7, #3
 80582ce:	4437      	add	r7, r6
 80582d0:	e6fc      	b.n	80580cc <_realloc_r+0xc4>
 80582d2:	1f32      	subs	r2, r6, #4
 80582d4:	2a24      	cmp	r2, #36	; 0x24
 80582d6:	d830      	bhi.n	805833a <_realloc_r+0x332>
 80582d8:	2a13      	cmp	r2, #19
 80582da:	d92b      	bls.n	8058334 <_realloc_r+0x32c>
 80582dc:	6823      	ldr	r3, [r4, #0]
 80582de:	6003      	str	r3, [r0, #0]
 80582e0:	6863      	ldr	r3, [r4, #4]
 80582e2:	6043      	str	r3, [r0, #4]
 80582e4:	2a1b      	cmp	r2, #27
 80582e6:	d811      	bhi.n	805830c <_realloc_r+0x304>
 80582e8:	f104 0208 	add.w	r2, r4, #8
 80582ec:	f100 0308 	add.w	r3, r0, #8
 80582f0:	6811      	ldr	r1, [r2, #0]
 80582f2:	6019      	str	r1, [r3, #0]
 80582f4:	6851      	ldr	r1, [r2, #4]
 80582f6:	6059      	str	r1, [r3, #4]
 80582f8:	6892      	ldr	r2, [r2, #8]
 80582fa:	609a      	str	r2, [r3, #8]
 80582fc:	4621      	mov	r1, r4
 80582fe:	4648      	mov	r0, r9
 8058300:	f7fd fc06 	bl	8055b10 <_free_r>
 8058304:	e727      	b.n	8058156 <_realloc_r+0x14e>
 8058306:	bf00      	nop
 8058308:	20003cf8 	.word	0x20003cf8
 805830c:	68a3      	ldr	r3, [r4, #8]
 805830e:	6083      	str	r3, [r0, #8]
 8058310:	68e3      	ldr	r3, [r4, #12]
 8058312:	60c3      	str	r3, [r0, #12]
 8058314:	2a24      	cmp	r2, #36	; 0x24
 8058316:	bf01      	itttt	eq
 8058318:	6923      	ldreq	r3, [r4, #16]
 805831a:	6103      	streq	r3, [r0, #16]
 805831c:	6961      	ldreq	r1, [r4, #20]
 805831e:	6141      	streq	r1, [r0, #20]
 8058320:	bf19      	ittee	ne
 8058322:	f104 0210 	addne.w	r2, r4, #16
 8058326:	f100 0310 	addne.w	r3, r0, #16
 805832a:	f104 0218 	addeq.w	r2, r4, #24
 805832e:	f100 0318 	addeq.w	r3, r0, #24
 8058332:	e7dd      	b.n	80582f0 <_realloc_r+0x2e8>
 8058334:	4603      	mov	r3, r0
 8058336:	4622      	mov	r2, r4
 8058338:	e7da      	b.n	80582f0 <_realloc_r+0x2e8>
 805833a:	4621      	mov	r1, r4
 805833c:	f7ff fe38 	bl	8057fb0 <memmove>
 8058340:	e7dc      	b.n	80582fc <_realloc_r+0x2f4>
 8058342:	4637      	mov	r7, r6
 8058344:	e6c2      	b.n	80580cc <_realloc_r+0xc4>
 8058346:	4317      	orrs	r7, r2
 8058348:	606f      	str	r7, [r5, #4]
 805834a:	685a      	ldr	r2, [r3, #4]
 805834c:	f042 0201 	orr.w	r2, r2, #1
 8058350:	605a      	str	r2, [r3, #4]
 8058352:	e757      	b.n	8058204 <_realloc_r+0x1fc>

08058354 <__swbuf_r>:
 8058354:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8058356:	460e      	mov	r6, r1
 8058358:	4614      	mov	r4, r2
 805835a:	4605      	mov	r5, r0
 805835c:	b118      	cbz	r0, 8058366 <__swbuf_r+0x12>
 805835e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8058360:	b90b      	cbnz	r3, 8058366 <__swbuf_r+0x12>
 8058362:	f7fd fb45 	bl	80559f0 <__sinit>
 8058366:	69a3      	ldr	r3, [r4, #24]
 8058368:	60a3      	str	r3, [r4, #8]
 805836a:	89a3      	ldrh	r3, [r4, #12]
 805836c:	0719      	lsls	r1, r3, #28
 805836e:	d529      	bpl.n	80583c4 <__swbuf_r+0x70>
 8058370:	6923      	ldr	r3, [r4, #16]
 8058372:	b33b      	cbz	r3, 80583c4 <__swbuf_r+0x70>
 8058374:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8058378:	b2f6      	uxtb	r6, r6
 805837a:	049a      	lsls	r2, r3, #18
 805837c:	4637      	mov	r7, r6
 805837e:	d52a      	bpl.n	80583d6 <__swbuf_r+0x82>
 8058380:	6823      	ldr	r3, [r4, #0]
 8058382:	6920      	ldr	r0, [r4, #16]
 8058384:	1a18      	subs	r0, r3, r0
 8058386:	6963      	ldr	r3, [r4, #20]
 8058388:	4283      	cmp	r3, r0
 805838a:	dc04      	bgt.n	8058396 <__swbuf_r+0x42>
 805838c:	4621      	mov	r1, r4
 805838e:	4628      	mov	r0, r5
 8058390:	f7fd fac2 	bl	8055918 <_fflush_r>
 8058394:	b9e0      	cbnz	r0, 80583d0 <__swbuf_r+0x7c>
 8058396:	68a3      	ldr	r3, [r4, #8]
 8058398:	3b01      	subs	r3, #1
 805839a:	60a3      	str	r3, [r4, #8]
 805839c:	6823      	ldr	r3, [r4, #0]
 805839e:	1c5a      	adds	r2, r3, #1
 80583a0:	6022      	str	r2, [r4, #0]
 80583a2:	701e      	strb	r6, [r3, #0]
 80583a4:	6962      	ldr	r2, [r4, #20]
 80583a6:	1c43      	adds	r3, r0, #1
 80583a8:	429a      	cmp	r2, r3
 80583aa:	d004      	beq.n	80583b6 <__swbuf_r+0x62>
 80583ac:	89a3      	ldrh	r3, [r4, #12]
 80583ae:	07db      	lsls	r3, r3, #31
 80583b0:	d506      	bpl.n	80583c0 <__swbuf_r+0x6c>
 80583b2:	2e0a      	cmp	r6, #10
 80583b4:	d104      	bne.n	80583c0 <__swbuf_r+0x6c>
 80583b6:	4621      	mov	r1, r4
 80583b8:	4628      	mov	r0, r5
 80583ba:	f7fd faad 	bl	8055918 <_fflush_r>
 80583be:	b938      	cbnz	r0, 80583d0 <__swbuf_r+0x7c>
 80583c0:	4638      	mov	r0, r7
 80583c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80583c4:	4621      	mov	r1, r4
 80583c6:	4628      	mov	r0, r5
 80583c8:	f7fc fb48 	bl	8054a5c <__swsetup_r>
 80583cc:	2800      	cmp	r0, #0
 80583ce:	d0d1      	beq.n	8058374 <__swbuf_r+0x20>
 80583d0:	f04f 37ff 	mov.w	r7, #4294967295
 80583d4:	e7f4      	b.n	80583c0 <__swbuf_r+0x6c>
 80583d6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80583da:	81a3      	strh	r3, [r4, #12]
 80583dc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80583de:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80583e2:	6663      	str	r3, [r4, #100]	; 0x64
 80583e4:	e7cc      	b.n	8058380 <__swbuf_r+0x2c>
	...

080583e8 <_wcrtomb_r>:
 80583e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80583ea:	4c09      	ldr	r4, [pc, #36]	; (8058410 <_wcrtomb_r+0x28>)
 80583ec:	b085      	sub	sp, #20
 80583ee:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
 80583f2:	4605      	mov	r5, r0
 80583f4:	461e      	mov	r6, r3
 80583f6:	b909      	cbnz	r1, 80583fc <_wcrtomb_r+0x14>
 80583f8:	460a      	mov	r2, r1
 80583fa:	a901      	add	r1, sp, #4
 80583fc:	47b8      	blx	r7
 80583fe:	1c43      	adds	r3, r0, #1
 8058400:	bf01      	itttt	eq
 8058402:	2300      	moveq	r3, #0
 8058404:	6033      	streq	r3, [r6, #0]
 8058406:	238a      	moveq	r3, #138	; 0x8a
 8058408:	602b      	streq	r3, [r5, #0]
 805840a:	b005      	add	sp, #20
 805840c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 805840e:	bf00      	nop
 8058410:	20004110 	.word	0x20004110

08058414 <abort>:
 8058414:	b508      	push	{r3, lr}
 8058416:	2006      	movs	r0, #6
 8058418:	f000 f82c 	bl	8058474 <raise>
 805841c:	2001      	movs	r0, #1
 805841e:	f7f7 fca9 	bl	804fd74 <_exit>

08058422 <_raise_r>:
 8058422:	291f      	cmp	r1, #31
 8058424:	b538      	push	{r3, r4, r5, lr}
 8058426:	4604      	mov	r4, r0
 8058428:	460d      	mov	r5, r1
 805842a:	d904      	bls.n	8058436 <_raise_r+0x14>
 805842c:	2316      	movs	r3, #22
 805842e:	6003      	str	r3, [r0, #0]
 8058430:	f04f 30ff 	mov.w	r0, #4294967295
 8058434:	bd38      	pop	{r3, r4, r5, pc}
 8058436:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
 805843a:	b112      	cbz	r2, 8058442 <_raise_r+0x20>
 805843c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8058440:	b94b      	cbnz	r3, 8058456 <_raise_r+0x34>
 8058442:	4620      	mov	r0, r4
 8058444:	f000 f830 	bl	80584a8 <_getpid_r>
 8058448:	462a      	mov	r2, r5
 805844a:	4601      	mov	r1, r0
 805844c:	4620      	mov	r0, r4
 805844e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8058452:	f000 b817 	b.w	8058484 <_kill_r>
 8058456:	2b01      	cmp	r3, #1
 8058458:	d00a      	beq.n	8058470 <_raise_r+0x4e>
 805845a:	1c59      	adds	r1, r3, #1
 805845c:	d103      	bne.n	8058466 <_raise_r+0x44>
 805845e:	2316      	movs	r3, #22
 8058460:	6003      	str	r3, [r0, #0]
 8058462:	2001      	movs	r0, #1
 8058464:	e7e6      	b.n	8058434 <_raise_r+0x12>
 8058466:	2400      	movs	r4, #0
 8058468:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 805846c:	4628      	mov	r0, r5
 805846e:	4798      	blx	r3
 8058470:	2000      	movs	r0, #0
 8058472:	e7df      	b.n	8058434 <_raise_r+0x12>

08058474 <raise>:
 8058474:	4b02      	ldr	r3, [pc, #8]	; (8058480 <raise+0xc>)
 8058476:	4601      	mov	r1, r0
 8058478:	6818      	ldr	r0, [r3, #0]
 805847a:	f7ff bfd2 	b.w	8058422 <_raise_r>
 805847e:	bf00      	nop
 8058480:	200038cc 	.word	0x200038cc

08058484 <_kill_r>:
 8058484:	b538      	push	{r3, r4, r5, lr}
 8058486:	4d07      	ldr	r5, [pc, #28]	; (80584a4 <_kill_r+0x20>)
 8058488:	2300      	movs	r3, #0
 805848a:	4604      	mov	r4, r0
 805848c:	4608      	mov	r0, r1
 805848e:	4611      	mov	r1, r2
 8058490:	602b      	str	r3, [r5, #0]
 8058492:	f7f7 fc67 	bl	804fd64 <_kill>
 8058496:	1c43      	adds	r3, r0, #1
 8058498:	d102      	bne.n	80584a0 <_kill_r+0x1c>
 805849a:	682b      	ldr	r3, [r5, #0]
 805849c:	b103      	cbz	r3, 80584a0 <_kill_r+0x1c>
 805849e:	6023      	str	r3, [r4, #0]
 80584a0:	bd38      	pop	{r3, r4, r5, pc}
 80584a2:	bf00      	nop
 80584a4:	20010330 	.word	0x20010330

080584a8 <_getpid_r>:
 80584a8:	f7f7 bc5a 	b.w	804fd60 <_getpid>

080584ac <_init>:
 80584ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80584ae:	bf00      	nop
 80584b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80584b2:	bc08      	pop	{r3}
 80584b4:	469e      	mov	lr, r3
 80584b6:	4770      	bx	lr

080584b8 <_fini>:
 80584b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80584ba:	bf00      	nop
 80584bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80584be:	bc08      	pop	{r3}
 80584c0:	469e      	mov	lr, r3
 80584c2:	4770      	bx	lr
